{"ast":null,"code":"/*!\n * pbkdf2.js - pbkdf2 for bcrypto\n * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/PBKDF2\n *   https://tools.ietf.org/html/rfc2898\n *   https://tools.ietf.org/html/rfc2898#section-5.2\n *   https://tools.ietf.org/html/rfc6070\n *   https://www.emc.com/collateral/white-papers/h11302-pkcs5v2-1-password-based-cryptography-standard-wp.pdf\n *   http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst crypto = global.crypto || global.msCrypto || {};\nconst subtle = crypto.subtle || {};\n/**\n * Perform key derivation using PBKDF2.\n * @param {Function} hash\n * @param {Buffer} pass\n * @param {Buffer} salt\n * @param {Number} iter\n * @param {Number} len\n * @returns {Buffer}\n */\n\nfunction derive(hash, pass, salt, iter, len) {\n  if (typeof pass === 'string') pass = Buffer.from(pass, 'utf8');\n  if (typeof salt === 'string') salt = Buffer.from(salt, 'utf8');\n  if (salt == null) salt = Buffer.alloc(0);\n  assert(hash && typeof hash.id === 'string');\n  assert(Buffer.isBuffer(pass));\n  assert(Buffer.isBuffer(salt));\n  assert(iter >>> 0 === iter);\n  assert(len >>> 0 === len);\n  const size = hash.size;\n  const blocks = Math.ceil(len / size);\n  const out = Buffer.allocUnsafe(blocks * size);\n  const state = Buffer.allocUnsafe(salt.length + 4);\n  salt.copy(state, 0); // Preemptively shorten key.\n\n  if (pass.length > hash.blockSize) {\n    pass = hash.digest(pass);\n    assert(pass.length <= hash.blockSize);\n  }\n\n  for (let i = 0; i < blocks; i++) {\n    const round = i + 1;\n    state[salt.length + 0] = round >>> 24;\n    state[salt.length + 1] = round >>> 16;\n    state[salt.length + 2] = round >>> 8;\n    state[salt.length + 3] = round;\n    const block = hash.mac(state, pass);\n    let mac = block;\n\n    for (let j = 1; j < iter; j++) {\n      mac = hash.mac(mac, pass);\n\n      for (let k = 0; k < size; k++) block[k] ^= mac[k];\n    }\n\n    block.copy(out, i * size);\n  }\n\n  return out.slice(0, len);\n}\n/**\n * Execute pbkdf2 asynchronously.\n * @param {Function} hash\n * @param {Buffer} pass\n * @param {Buffer} salt\n * @param {Number} iter\n * @param {Number} len\n * @returns {Promise}\n */\n\n\nasync function deriveAsync(hash, pass, salt, iter, len) {\n  if (typeof pass === 'string') pass = Buffer.from(pass, 'utf8');\n  if (typeof salt === 'string') salt = Buffer.from(salt, 'utf8');\n  if (salt == null) salt = Buffer.alloc(0);\n  assert(hash && typeof hash.id === 'string');\n  assert(Buffer.isBuffer(pass));\n  assert(Buffer.isBuffer(salt));\n  assert(iter >>> 0 === iter);\n  assert(len >>> 0 === len);\n  const name = getHash(hash);\n  if (!subtle.importKey || !subtle.deriveBits || !name) return derive(hash, pass, salt, iter, len);\n  const algo = {\n    name: 'PBKDF2'\n  };\n  const use = ['deriveBits'];\n  const options = {\n    name: 'PBKDF2',\n    salt: salt,\n    iterations: iter,\n    hash: name\n  };\n  const key = await subtle.importKey('raw', pass, algo, false, use);\n  const out = await subtle.deriveBits(options, key, len * 8);\n  return Buffer.from(out);\n}\n/*\n * Helpers\n */\n\n\nfunction getHash(hash) {\n  switch (hash.id) {\n    case 'SHA1':\n      return 'SHA-1';\n\n    case 'SHA256':\n      return 'SHA-256';\n\n    case 'SHA384':\n      return 'SHA-384';\n\n    case 'SHA512':\n      return 'SHA-512';\n\n    default:\n      return null;\n  }\n}\n/*\n * Expose\n */\n\n\nexports.native = 0;\nexports.derive = derive;\nexports.deriveAsync = deriveAsync;","map":null,"metadata":{},"sourceType":"script"}