{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ResultPoint_1 = require(\"../../ResultPoint\");\n\nvar DetectorResult_1 = require(\"../../common/DetectorResult\");\n\nvar GridSamplerInstance_1 = require(\"../../common/GridSamplerInstance\");\n\nvar MathUtils_1 = require(\"../../common/detector/MathUtils\");\n\nvar WhiteRectangleDetector_1 = require(\"../../common/detector/WhiteRectangleDetector\");\n\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n/*\r\n * Copyright 2008 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * <p>Encapsulates logic that can detect a Data Matrix Code in an image, even if the Data Matrix Code\r\n * is rotated or skewed, or partially obscured.</p>\r\n *\r\n * @author Sean Owen\r\n */\n\n\nvar Detector =\n/** @class */\nfunction () {\n  function Detector(image) {\n    this.image = image;\n    this.rectangleDetector = new WhiteRectangleDetector_1.default(image);\n  }\n  /**\r\n   * <p>Detects a Data Matrix Code in an image.</p>\r\n   *\r\n   * @return {@link DetectorResult} encapsulating results of detecting a Data Matrix Code\r\n   * @throws NotFoundException if no Data Matrix Code can be found\r\n   */\n\n\n  Detector.prototype.detect = function () {\n    var cornerPoints = this.rectangleDetector.detect();\n    var pointA = cornerPoints[0];\n    var pointB = cornerPoints[1];\n    var pointC = cornerPoints[2];\n    var pointD = cornerPoints[3]; // Point A and D are across the diagonal from one another,\n    // as are B and C. Figure out which are the solid black lines\n    // by counting transitions\n\n    var transitions = [];\n    transitions.push(this.transitionsBetween(pointA, pointB));\n    transitions.push(this.transitionsBetween(pointA, pointC));\n    transitions.push(this.transitionsBetween(pointB, pointD));\n    transitions.push(this.transitionsBetween(pointC, pointD));\n    transitions.sort(ResultPointsAndTransitions.resultPointsAndTransitionsComparator); // Sort by number of transitions. First two will be the two solid sides; last two\n    // will be the two alternating black/white sides\n\n    var lSideOne = transitions[0];\n    var lSideTwo = transitions[1]; // Figure out which point is their intersection by tallying up the number of times we see the\n    // endpoints in the four endpoints. One will show up twice.\n\n    var pointCount = new Map();\n    Detector.increment(pointCount, lSideOne.getFrom());\n    Detector.increment(pointCount, lSideOne.getTo());\n    Detector.increment(pointCount, lSideTwo.getFrom());\n    Detector.increment(pointCount, lSideTwo.getTo());\n    var maybeTopLeft = null;\n    var bottomLeft = null;\n    var maybeBottomRight = null;\n\n    for (var _i = 0, _a = Array.from(pointCount.entries()); _i < _a.length; _i++) {\n      var _b = _a[_i],\n          point = _b[0],\n          value = _b[1];\n\n      if (value === 2) {\n        bottomLeft = point; // this is definitely the bottom left, then -- end of two L sides\n      } else {\n        // Otherwise it's either top left or bottom right -- just assign the two arbitrarily now\n        if (maybeTopLeft == null) {\n          maybeTopLeft = point;\n        } else {\n          maybeBottomRight = point;\n        }\n      }\n    }\n\n    if (maybeTopLeft == null || bottomLeft == null || maybeBottomRight == null) {\n      throw new NotFoundException_1.default();\n    } // Bottom left is correct but top left and bottom right might be switched\n\n\n    var corners = [maybeTopLeft, bottomLeft, maybeBottomRight]; // Use the dot product trick to sort them out\n\n    ResultPoint_1.default.orderBestPatterns(corners); // Now we know which is which:\n\n    var bottomRight = corners[0];\n    bottomLeft = corners[1];\n    var topLeft = corners[2]; // Which point didn't we find in relation to the \"L\" sides? that's the top right corner\n\n    var topRight;\n\n    if (!pointCount.has(pointA)) {\n      topRight = pointA;\n    } else if (!pointCount.has(pointB)) {\n      topRight = pointB;\n    } else if (!pointCount.has(pointC)) {\n      topRight = pointC;\n    } else {\n      topRight = pointD;\n    } // Next determine the dimension by tracing along the top or right side and counting black/white\n    // transitions. Since we start inside a black module, we should see a number of transitions\n    // equal to 1 less than the code dimension. Well, actually 2 less, because we are going to\n    // end on a black module:\n    // The top right point is actually the corner of a module, which is one of the two black modules\n    // adjacent to the white module at the top right. Tracing to that corner from either the top left\n    // or bottom right should work here.\n\n\n    var dimensionTop = this.transitionsBetween(topLeft, topRight).getTransitions();\n    var dimensionRight = this.transitionsBetween(bottomRight, topRight).getTransitions();\n\n    if ((dimensionTop & 0x01) === 1) {\n      // it can't be odd, so, round... up?\n      dimensionTop++;\n    }\n\n    dimensionTop += 2;\n\n    if ((dimensionRight & 0x01) === 1) {\n      // it can't be odd, so, round... up?\n      dimensionRight++;\n    }\n\n    dimensionRight += 2;\n    var bits;\n    var correctedTopRight; // Rectangular symbols are 6x16, 6x28, 10x24, 10x32, 14x32, or 14x44. If one dimension is more\n    // than twice the other, it's certainly rectangular, but to cut a bit more slack we accept it as\n    // rectangular if the bigger side is at least 7/4 times the other:\n\n    if (4 * dimensionTop >= 7 * dimensionRight || 4 * dimensionRight >= 7 * dimensionTop) {\n      // The matrix is rectangular\n      correctedTopRight = this.correctTopRightRectangular(bottomLeft, bottomRight, topLeft, topRight, dimensionTop, dimensionRight);\n\n      if (correctedTopRight == null) {\n        correctedTopRight = topRight;\n      }\n\n      dimensionTop = this.transitionsBetween(topLeft, correctedTopRight).getTransitions();\n      dimensionRight = this.transitionsBetween(bottomRight, correctedTopRight).getTransitions();\n\n      if ((dimensionTop & 0x01) === 1) {\n        // it can't be odd, so, round... up?\n        dimensionTop++;\n      }\n\n      if ((dimensionRight & 0x01) === 1) {\n        // it can't be odd, so, round... up?\n        dimensionRight++;\n      }\n\n      bits = Detector.sampleGrid(this.image, topLeft, bottomLeft, bottomRight, correctedTopRight, dimensionTop, dimensionRight);\n    } else {\n      // The matrix is square\n      var dimension = Math.min(dimensionRight, dimensionTop); // correct top right point to match the white module\n\n      correctedTopRight = this.correctTopRight(bottomLeft, bottomRight, topLeft, topRight, dimension);\n\n      if (correctedTopRight == null) {\n        correctedTopRight = topRight;\n      } // Redetermine the dimension using the corrected top right point\n\n\n      var dimensionCorrected = Math.max(this.transitionsBetween(topLeft, correctedTopRight).getTransitions(), this.transitionsBetween(bottomRight, correctedTopRight).getTransitions());\n      dimensionCorrected++;\n\n      if ((dimensionCorrected & 0x01) === 1) {\n        dimensionCorrected++;\n      }\n\n      bits = Detector.sampleGrid(this.image, topLeft, bottomLeft, bottomRight, correctedTopRight, dimensionCorrected, dimensionCorrected);\n    }\n\n    return new DetectorResult_1.default(bits, [topLeft, bottomLeft, bottomRight, correctedTopRight]);\n  };\n  /**\r\n   * Calculates the position of the white top right module using the output of the rectangle detector\r\n   * for a rectangular matrix\r\n   */\n\n\n  Detector.prototype.correctTopRightRectangular = function (bottomLeft, bottomRight, topLeft, topRight, dimensionTop, dimensionRight) {\n    var corr = Detector.distance(bottomLeft, bottomRight) / dimensionTop;\n    var norm = Detector.distance(topLeft, topRight);\n    var cos = (topRight.getX() - topLeft.getX()) / norm;\n    var sin = (topRight.getY() - topLeft.getY()) / norm;\n    var c1 = new ResultPoint_1.default(topRight.getX() + corr * cos, topRight.getY() + corr * sin);\n    corr = Detector.distance(bottomLeft, topLeft) / dimensionRight;\n    norm = Detector.distance(bottomRight, topRight);\n    cos = (topRight.getX() - bottomRight.getX()) / norm;\n    sin = (topRight.getY() - bottomRight.getY()) / norm;\n    var c2 = new ResultPoint_1.default(topRight.getX() + corr * cos, topRight.getY() + corr * sin);\n\n    if (!this.isValid(c1)) {\n      if (this.isValid(c2)) {\n        return c2;\n      }\n\n      return null;\n    }\n\n    if (!this.isValid(c2)) {\n      return c1;\n    }\n\n    var l1 = Math.abs(dimensionTop - this.transitionsBetween(topLeft, c1).getTransitions()) + Math.abs(dimensionRight - this.transitionsBetween(bottomRight, c1).getTransitions());\n    var l2 = Math.abs(dimensionTop - this.transitionsBetween(topLeft, c2).getTransitions()) + Math.abs(dimensionRight - this.transitionsBetween(bottomRight, c2).getTransitions());\n\n    if (l1 <= l2) {\n      return c1;\n    }\n\n    return c2;\n  };\n  /**\r\n   * Calculates the position of the white top right module using the output of the rectangle detector\r\n   * for a square matrix\r\n   */\n\n\n  Detector.prototype.correctTopRight = function (bottomLeft, bottomRight, topLeft, topRight, dimension) {\n    var corr = Detector.distance(bottomLeft, bottomRight) / dimension;\n    var norm = Detector.distance(topLeft, topRight);\n    var cos = (topRight.getX() - topLeft.getX()) / norm;\n    var sin = (topRight.getY() - topLeft.getY()) / norm;\n    var c1 = new ResultPoint_1.default(topRight.getX() + corr * cos, topRight.getY() + corr * sin);\n    corr = Detector.distance(bottomLeft, topLeft) / dimension;\n    norm = Detector.distance(bottomRight, topRight);\n    cos = (topRight.getX() - bottomRight.getX()) / norm;\n    sin = (topRight.getY() - bottomRight.getY()) / norm;\n    var c2 = new ResultPoint_1.default(topRight.getX() + corr * cos, topRight.getY() + corr * sin);\n\n    if (!this.isValid(c1)) {\n      if (this.isValid(c2)) {\n        return c2;\n      }\n\n      return null;\n    }\n\n    if (!this.isValid(c2)) {\n      return c1;\n    }\n\n    var l1 = Math.abs(this.transitionsBetween(topLeft, c1).getTransitions() - this.transitionsBetween(bottomRight, c1).getTransitions());\n    var l2 = Math.abs(this.transitionsBetween(topLeft, c2).getTransitions() - this.transitionsBetween(bottomRight, c2).getTransitions());\n    return l1 <= l2 ? c1 : c2;\n  };\n\n  Detector.prototype.isValid = function (p) {\n    return p.getX() >= 0 && p.getX() < this.image.getWidth() && p.getY() > 0 && p.getY() < this.image.getHeight();\n  };\n\n  Detector.distance = function (a, b) {\n    return MathUtils_1.default.round(ResultPoint_1.default.distance(a, b));\n  };\n  /**\r\n   * Increments the Integer associated with a key by one.\r\n   */\n\n\n  Detector.increment = function (table, key) {\n    var value = table.get(key);\n    table.set(key, value == null ? 1 : value + 1);\n  };\n\n  Detector.sampleGrid = function (image, topLeft, bottomLeft, bottomRight, topRight, dimensionX, dimensionY) {\n    var sampler = GridSamplerInstance_1.default.getInstance();\n    return sampler.sampleGrid(image, dimensionX, dimensionY, 0.5, 0.5, dimensionX - 0.5, 0.5, dimensionX - 0.5, dimensionY - 0.5, 0.5, dimensionY - 0.5, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());\n  };\n  /**\r\n   * Counts the number of black/white transitions between two points, using something like Bresenham's algorithm.\r\n   */\n\n\n  Detector.prototype.transitionsBetween = function (from, to) {\n    // See QR Code Detector, sizeOfBlackWhiteBlackRun()\n    var fromX = from.getX() | 0;\n    var fromY = from.getY() | 0;\n    var toX = to.getX() | 0;\n    var toY = to.getY() | 0;\n    var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\n\n    if (steep) {\n      var temp = fromX;\n      fromX = fromY;\n      fromY = temp;\n      temp = toX;\n      toX = toY;\n      toY = temp;\n    }\n\n    var dx = Math.abs(toX - fromX);\n    var dy = Math.abs(toY - fromY);\n    var error = -dx / 2;\n    var ystep = fromY < toY ? 1 : -1;\n    var xstep = fromX < toX ? 1 : -1;\n    var transitions = 0;\n    var inBlack = this.image.get(steep ? fromY : fromX, steep ? fromX : fromY);\n\n    for (var x = fromX, y = fromY; x !== toX; x += xstep) {\n      var isBlack = this.image.get(steep ? y : x, steep ? x : y);\n\n      if (isBlack !== inBlack) {\n        transitions++;\n        inBlack = isBlack;\n      }\n\n      error += dy;\n\n      if (error > 0) {\n        if (y === toY) {\n          break;\n        }\n\n        y += ystep;\n        error -= dx;\n      }\n    }\n\n    return new ResultPointsAndTransitions(from, to, transitions);\n  };\n\n  return Detector;\n}();\n\nexports.default = Detector;\n\nvar ResultPointsAndTransitions =\n/** @class */\nfunction () {\n  function ResultPointsAndTransitions(from, to, transitions) {\n    this.from = from;\n    this.to = to;\n    this.transitions = transitions;\n  }\n\n  ResultPointsAndTransitions.prototype.getFrom = function () {\n    return this.from;\n  };\n\n  ResultPointsAndTransitions.prototype.getTo = function () {\n    return this.to;\n  };\n\n  ResultPointsAndTransitions.prototype.getTransitions = function () {\n    return this.transitions;\n  }; // @Override\n\n\n  ResultPointsAndTransitions.prototype.toString = function () {\n    return this.from + '/' + this.to + '/' + this.transitions;\n  };\n\n  ResultPointsAndTransitions.resultPointsAndTransitionsComparator = function (o1, o2) {\n    return o1.getTransitions() - o2.getTransitions();\n  };\n\n  return ResultPointsAndTransitions;\n}();","map":null,"metadata":{},"sourceType":"script"}