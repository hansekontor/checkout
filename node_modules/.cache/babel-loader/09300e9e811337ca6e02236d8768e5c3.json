{"ast":null,"code":"/*!\n * ctr-drbg.js - ctr-drbg implementation for bcrypto\n * Copyright (c) 2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on google/boringssl:\n *   https://github.com/google/boringssl\n *\n * Resources:\n *   https://csrc.nist.gov/publications/detail/sp/800-90a/archive/2012-01-23\n *   https://github.com/google/boringssl/blob/master/crypto/fipsmodule/rand/ctrdrbg.c\n *   https://github.com/google/boringssl/blob/master/crypto/fipsmodule/rand/internal.h\n *   https://github.com/openssl/openssl/blob/master/crypto/rand/drbg_lib.c\n *   https://github.com/cryptocoinjs/drbg.js/blob/master/ctr.js\n *   https://github.com/netroby/jdk9-dev/blob/master/jdk/src/java.base/share/classes/sun/security/provider/CtrDrbg.java\n */\n'use strict';\n\nconst assert = require('./internal/assert');\n\nconst cipher = require('./cipher');\n\nconst {\n  Cipher\n} = cipher;\n/*\n * Constants\n */\n\nconst MAX_GENERATE_LENGTH = 65536;\nconst RESEED_INTERVAL = 0x1000000000000;\n/**\n * CtrDRBG\n */\n\nclass CtrDRBG {\n  constructor(name, entropy, nonce, pers) {\n    let derivation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    assert(derivation == null || typeof derivation === 'boolean');\n    const [id, keySize, blkSize] = get(name);\n    this.id = id;\n    this.ctr = new CTR(id);\n    this.keySize = keySize;\n    this.blkSize = blkSize;\n    this.entSize = keySize + blkSize;\n    this.slab = Buffer.alloc(this.entSize);\n    this.K = this.slab.slice(0, this.keySize);\n    this.V = this.slab.slice(this.keySize);\n    this.derivation = Boolean(derivation);\n    this.rounds = 0;\n    if (entropy) this.init(entropy, nonce, pers);\n  }\n\n  init(entropy) {\n    let nonce = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let pers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (nonce == null) nonce = Buffer.alloc(0);\n    if (pers == null) pers = Buffer.alloc(0);\n    assert(Buffer.isBuffer(entropy));\n    assert(Buffer.isBuffer(nonce));\n    assert(Buffer.isBuffer(pers));\n    let seed;\n\n    if (this.derivation) {\n      seed = this.derive(entropy, nonce, pers);\n    } else {\n      if (entropy.length + nonce.length > this.entSize) throw new Error('Entropy is too long.');\n      if (pers.length > this.entSize) throw new Error('Personalization string is too long.');\n      seed = Buffer.alloc(this.entSize, 0x00);\n      entropy.copy(seed, 0);\n      nonce.copy(seed, entropy.length);\n\n      for (let i = 0; i < pers.length; i++) seed[i] ^= pers[i];\n    }\n\n    this.slab.fill(0x00);\n    this.ctr.init(this.K, this.V);\n    this.update(seed);\n    this.rounds = 1;\n    return this;\n  }\n\n  reseed(entropy) {\n    let add = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (add == null) add = Buffer.alloc(0);\n    assert(Buffer.isBuffer(entropy));\n    assert(Buffer.isBuffer(add));\n    if (this.rounds === 0) throw new Error('DRBG not initialized.');\n    let seed;\n\n    if (this.derivation) {\n      seed = this.derive(entropy, add);\n    } else {\n      if (add.length > this.entSize) throw new Error('Additional data is too long.');\n      seed = Buffer.alloc(this.entSize, 0x00);\n      entropy.copy(seed, 0);\n\n      for (let i = 0; i < add.length; i++) seed[i] ^= add[i];\n    }\n\n    this.update(seed);\n    this.rounds = 1;\n    return this;\n  }\n\n  generate(len) {\n    let add = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    assert(len >>> 0 === len);\n    assert(!add || Buffer.isBuffer(add));\n    if (this.rounds === 0) throw new Error('DRBG not initialized.');\n    if (this.rounds > RESEED_INTERVAL) throw new Error('Reseed is required.');\n    if (len > MAX_GENERATE_LENGTH) throw new Error('Requested length is too long.');\n\n    if (add && add.length !== 0) {\n      if (this.derivation) add = this.derive(add);\n      this.update(add);\n    }\n\n    const blocks = Math.ceil(len / this.blkSize);\n    const out = Buffer.allocUnsafe(blocks * this.blkSize);\n\n    for (let i = 0; i < blocks; i++) this.ctr.encrypt(out, i * this.blkSize);\n\n    this.update(add);\n    this.rounds += 1;\n    return out.slice(0, len);\n  }\n\n  randomBytes(size) {\n    return this.generate(size);\n  }\n  /*\n   * Helpers\n   */\n\n\n  update() {\n    let seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    if (seed == null) seed = Buffer.alloc(0);\n    assert(Buffer.isBuffer(seed));\n    if (seed.length > this.entSize) throw new Error('Seed is too long.');\n    this.slab.fill(0x00);\n\n    for (let i = 0; i < this.entSize; i += this.blkSize) this.ctr.encrypt(this.slab, i);\n\n    for (let i = 0; i < seed.length; i++) this.slab[i] ^= seed[i];\n\n    this.ctr.init(this.K, this.V);\n    return this;\n  }\n\n  serialize() {\n    const N = this.entSize;\n    let L = 0;\n\n    for (var _len = arguments.length, input = new Array(_len), _key = 0; _key < _len; _key++) {\n      input[_key] = arguments[_key];\n    }\n\n    for (const item of input) L += item.length;\n\n    let size = this.blkSize + 4 + 4 + L + 1;\n    if (size % this.blkSize) size += this.blkSize - size % this.blkSize;\n    assert(size % this.blkSize === 0); // S = IV || (L || N || input || 0x80 || 0x00...)\n\n    const S = Buffer.alloc(size, 0x00);\n    let pos = this.blkSize;\n    S[pos++] = L >>> 24;\n    S[pos++] = L >>> 16;\n    S[pos++] = L >>> 8;\n    S[pos++] = L;\n    S[pos++] = N >>> 24;\n    S[pos++] = N >>> 16;\n    S[pos++] = N >>> 8;\n    S[pos++] = N;\n\n    for (const item of input) pos += item.copy(S, pos);\n\n    S[pos++] = 0x80;\n    assert(pos === this.blkSize + 4 + 4 + L + 1);\n    return S;\n  }\n\n  derive() {\n    const S = this.serialize(...arguments);\n    const N = S.length / this.blkSize;\n    const K = Buffer.alloc(this.keySize);\n    const blocks = Math.ceil(this.entSize / this.blkSize);\n    const slab = Buffer.alloc(blocks * this.blkSize);\n\n    for (let i = 0; i < K.length; i++) K[i] = i;\n\n    const ctx = new Cipher(this.id).init(K);\n\n    for (let i = 0; i < blocks; i++) {\n      let chain = Buffer.alloc(this.blkSize, 0x00);\n      S[0] = i >>> 24;\n      S[1] = i >>> 16;\n      S[2] = i >>> 8;\n      S[3] = i; // chain = BCC(K, IV || S)\n\n      for (let j = 0; j < N; j++) {\n        for (let k = 0; k < chain.length; k++) chain[k] ^= S[j * this.blkSize + k];\n\n        chain = ctx.update(chain);\n      }\n\n      chain.copy(slab, i * this.blkSize);\n    }\n\n    const k = slab.slice(0, this.keySize);\n    ctx.init(k);\n    let x = slab.slice(this.keySize, this.entSize);\n\n    for (let i = 0; i < blocks; i++) {\n      x = ctx.update(x);\n      x.copy(slab, i * this.blkSize);\n    }\n\n    return slab.slice(0, this.entSize);\n  }\n\n}\n/*\n * Static\n */\n\n\nCtrDRBG.native = 0;\n/*\n * CTR\n */\n\nclass CTR {\n  constructor(name) {\n    this.ctx = new Cipher(name);\n    this.ctr = null;\n  }\n\n  init(key, iv) {\n    this.ctx.init(key);\n    this.ctr = Buffer.from(iv);\n    return this;\n  }\n\n  increment() {\n    for (let i = this.ctr.length - 1; i >= 0; i--) {\n      this.ctr[i] += 1;\n      if (this.ctr[i] !== 0x00) break;\n    }\n  }\n\n  encrypt(output, opos) {\n    this.increment();\n    this.ctx.update(this.ctr).copy(output, opos);\n    return this;\n  }\n\n}\n/*\n * Helpers\n */\n\n\nfunction get(name) {\n  assert(typeof name === 'string');\n\n  switch (name) {\n    case 'AES-128':\n      return ['AES-128-ECB', 16, 16];\n\n    case 'AES-192':\n      return ['AES-192-ECB', 24, 16];\n\n    case 'AES-256':\n      return ['AES-256-ECB', 32, 16];\n\n    default:\n      throw new Error(`Unsupported cipher: ${name}.`);\n  }\n}\n/*\n * Expose\n */\n\n\nmodule.exports = CtrDRBG;","map":null,"metadata":{},"sourceType":"script"}