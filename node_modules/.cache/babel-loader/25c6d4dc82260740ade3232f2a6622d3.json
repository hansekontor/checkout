{"ast":null,"code":"/*!\n * asn1.js - ASN1 encoding for javascript\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on indutny/asn1.js:\n *   Copyright Fedor Indutny, 2013.\n *   https://github.com/indutny/asn1.js\n *\n * Parts of this software are based on golang/go:\n *   Copyright (c) 2009 The Go Authors. All rights reserved.\n *   https://github.com/golang/go\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One\n *   https://en.wikipedia.org/wiki/X.690#BER_encoding\n *   https://en.wikipedia.org/wiki/X.690#DER_encoding\n *   http://luca.ntop.org/Teaching/Appunti/asn1.html\n *   ftp://ftp.rsasecurity.com/pub/pkcs/ascii/layman.asc\n *   https://tools.ietf.org/html/rfc2560\n *   https://tools.ietf.org/html/rfc5280\n *   https://github.com/indutny/asn1.js/blob/master/rfc/2560/index.js\n *   https://github.com/indutny/asn1.js/blob/master/rfc/5280/index.js\n *   https://github.com/indutny/asn1.js/blob/master/lib/asn1/base/node.js\n *   https://github.com/indutny/asn1.js/blob/master/lib/asn1/encoders/der.js\n *   https://github.com/indutny/asn1.js/blob/master/lib/asn1/decoders/der.js\n *   https://github.com/openssl/openssl/blob/master/include/openssl/asn1.h\n *   https://github.com/golang/go/blob/master/src/encoding/asn1/asn1.go\n *   https://github.com/golang/go/blob/master/src/encoding/asn1/marshal.go\n */\n\n/* eslint no-prototype-builtins: \"off\" */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst bio = require('bufio');\n\nconst objects = require('../internal/objects');\n/*\n * Constants\n */\n\n\nconst EMPTY = Buffer.alloc(0);\nconst ZERO = Buffer.alloc(1, 0x00);\nconst EMPTY_OID = new Uint32Array(2);\nconst MIN_TIME = -62167219200; // 0000-01-01T00:00:00.000Z\n\nconst MAX_TIME = 253402300799; // 9999-12-31T23:59:59.000Z\n\nconst MIN_OFFSET = -43200; // UTC-12:00\n\nconst MAX_OFFSET = 50400; // UTC+14:00\n// Missing types:\n//   EOC: 0\n//   OBJDESC: 7\n//   EXTERNAL: 8\n//   REAL: 9\n//   EMBED: 11\n//   ROID: 13\n//   VIDEOSTRING: 21\n//   GRAPHSTRING: 25\n//   ISO64STRING: 26\n//   UNISTRING: 28\n//   CHARSTRING: 29\n//   BMPSTRING: 30\n\nconst types = {\n  BOOLEAN: 1,\n  INTEGER: 2,\n  BITSTRING: 3,\n  OCTSTRING: 4,\n  NULL: 5,\n  OID: 6,\n  ENUM: 10,\n  UTF8STRING: 12,\n  SEQUENCE: 16,\n  SET: 17,\n  NUMSTRING: 18,\n  PRINTSTRING: 19,\n  T61STRING: 20,\n  IA5STRING: 22,\n  UTCTIME: 23,\n  GENTIME: 24,\n  GENSTRING: 27\n};\nconst typesByVal = {\n  1: 'BOOLEAN',\n  2: 'INTEGER',\n  3: 'BITSTRING',\n  4: 'OCTSTRING',\n  5: 'NULL',\n  6: 'OID',\n  10: 'ENUM',\n  12: 'UTF8STRING',\n  16: 'SEQUENCE',\n  17: 'SET',\n  18: 'NUMSTRING',\n  19: 'PRINTSTRING',\n  20: 'T61STRING',\n  22: 'IA5STRING',\n  23: 'UTCTIME',\n  24: 'GENTIME',\n  27: 'GENSTRING'\n};\nconst classes = {\n  UNIVERSAL: 0,\n  APPLICATION: 1,\n  CONTEXT: 2,\n  PRIVATE: 3\n};\nconst classesByVal = {\n  0: 'UNIVERSAL',\n  1: 'APPLICATION',\n  2: 'CONTEXT',\n  3: 'PRIVATE'\n};\nconst TARGET = 0xff;\nconst OPTIONAL = 1 << 8;\nconst MODE = 0xff << 9;\nconst NORMAL = 0 << 9;\nconst EXPLICIT = 1 << 9;\nconst IMPLICIT = 2 << 9;\n/**\n * Node\n */\n\nclass Node extends bio.Struct {\n  constructor() {\n    super();\n    this.flags = 0;\n  }\n\n  get mode() {\n    return this.flags & MODE;\n  }\n\n  set mode(value) {\n    this.flags &= ~MODE;\n    this.flags |= value;\n  }\n\n  get opt() {\n    return (this.flags & OPTIONAL) !== 0;\n  }\n\n  set opt(value) {\n    if (value) this.flags |= OPTIONAL;else this.flags &= ~OPTIONAL;\n  }\n\n  get target() {\n    return this.flags & TARGET;\n  }\n\n  set target(value) {\n    this.flags &= ~TARGET;\n    this.flags |= value;\n  }\n\n  get isRaw() {\n    return false;\n  }\n\n  explicit(target) {\n    assert(target >>> 0 === target);\n    this.mode = EXPLICIT;\n    this.target = target;\n    return this;\n  }\n\n  implicit(target) {\n    assert(target >>> 0 === target);\n    this.mode = IMPLICIT;\n    this.target = target;\n    return this;\n  }\n\n  optional() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    assert(typeof value === 'boolean');\n    this.opt = value;\n    return this;\n  }\n\n  clean() {\n    return false;\n  }\n\n  getBodySize(extra) {\n    return 0;\n  }\n\n  writeBody(bw, extra) {\n    return bw;\n  }\n\n  readBody(br, extra) {\n    return this;\n  }\n\n  encodeBody(extra) {\n    const size = this.getBodySize();\n    const bw = bio.write(size);\n    this.writeBody(bw, extra);\n    return bw.render();\n  }\n\n  decodeBody(data, extra) {\n    const br = bio.read(data);\n    return this.readBody(br, extra);\n  }\n\n  set() {\n    return this;\n  }\n\n  from(options) {\n    if (options == null) return this;\n\n    for (var _len = arguments.length, extra = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      extra[_key - 1] = arguments[_key];\n    }\n\n    return this.set(options, ...extra);\n  }\n\n  error(str) {\n    if (this.opt) return this;\n    const err = new Error(str);\n    if (Error.captureStackTrace) Error.captureStackTrace(err, this.error);\n    throw err;\n  }\n\n  getSize(extra) {\n    if (this.opt && this.clean()) return 0;\n    const body = this.getBodySize(extra);\n    let size = 0;\n    size += sizeHeader(body);\n    size += body;\n    if (this.mode === EXPLICIT) size += sizeHeader(size);\n    return size;\n  }\n\n  write(bw, extra) {\n    if (this.opt && this.clean()) return bw;\n    const body = this.getBodySize();\n\n    switch (this.mode) {\n      case EXPLICIT:\n        {\n          const size = sizeHeader(body) + body;\n          writeHeader(bw, this.target, classes.CONTEXT, false, size); // fall through\n        }\n\n      case NORMAL:\n        {\n          const primitive = this.type !== types.SEQUENCE && this.type !== types.SET;\n          writeHeader(bw, this.type, classes.UNIVERSAL, primitive, body);\n          break;\n        }\n\n      case IMPLICIT:\n        {\n          const primitive = this.type !== types.SEQUENCE && this.type !== types.SET;\n          writeHeader(bw, this.target, classes.CONTEXT, primitive, body);\n          break;\n        }\n\n      default:\n        {\n          throw new assert.AssertionError('Invalid mode.');\n        }\n    }\n\n    return this.writeBody(bw, extra);\n  }\n\n  read(br, extra) {\n    switch (this.mode) {\n      case EXPLICIT:\n        {\n          const hdr = peekHeader(br, this.opt);\n          if (!hdr) return this;\n          if (hdr.cls !== classes.CONTEXT) return this.error(`Unexpected class: ${hdr.cls}.`);\n          if (hdr.primitive) return this.error('Unexpected primitive flag.');\n          if (hdr.type !== this.target) return this.error(`Unexpected type: ${hdr.type}.`);\n          br.seek(hdr.len);\n          br = br.readChild(hdr.size); // Fall through.\n        }\n\n      case NORMAL:\n        {\n          const hdr = peekHeader(br, this.opt);\n          if (!hdr) return this;\n          if (hdr.cls !== classes.UNIVERSAL) return this.error(`Unexpected class: ${hdr.cls}.`);\n          const primitive = this.type !== types.SEQUENCE && this.type !== types.SET;\n          if (hdr.primitive !== primitive) return this.error('Unexpected primitive flag.');\n          if (hdr.type !== this.type) return this.error(`Unexpected type: ${hdr.type}.`);\n\n          if (this.isRaw) {\n            const size = hdr.len + hdr.size;\n            this.raw = br.readBytes(size);\n            br.seek(-size);\n          }\n\n          br.seek(hdr.len);\n          const child = br.readChild(hdr.size);\n          return this.readBody(child, extra);\n        }\n\n      case IMPLICIT:\n        {\n          const hdr = peekHeader(br, this.opt);\n          if (!hdr) return this;\n          if (hdr.cls !== classes.CONTEXT) return this.error(`Unexpected class: ${hdr.cls}.`);\n          const primitive = this.type !== types.SEQUENCE && this.type !== types.SET;\n          if (hdr.primitive !== primitive) return this.error('Unexpected primitive flag.');\n          if (hdr.type !== this.target) return this.error(`Unexpected type: ${hdr.type}.`);\n          br.seek(hdr.len);\n          const child = br.readChild(hdr.size);\n          return this.readBody(child, extra);\n        }\n\n      default:\n        {\n          throw new assert.AssertionError('Invalid mode.');\n        }\n    }\n  }\n\n  fromArray(value) {\n    return this;\n  }\n\n  fromNumber(num) {\n    return this;\n  }\n\n  fromPEM(num) {\n    return this;\n  }\n\n  static decodeBody(value) {\n    return new this().decodeBody(value);\n  }\n\n  static fromArray(value) {\n    return new this().fromArray(value);\n  }\n\n  static fromNumber(num) {\n    return new this().fromNumber(num);\n  }\n\n  static fromPEM(str) {\n    return new this().fromPEM(str);\n  }\n\n}\n/**\n * Sequence\n */\n\n\nclass Sequence extends Node {\n  constructor() {\n    super();\n    this.raw = null;\n    this.from(...arguments);\n  }\n\n  get type() {\n    return types.SEQUENCE;\n  }\n\n}\n\n;\n/**\n * Set\n */\n\nclass Set extends Node {\n  constructor() {\n    super();\n    this.raw = null;\n    this.from(...arguments);\n  }\n\n  get type() {\n    return types.SET;\n  }\n\n}\n\n;\n/**\n * Any\n */\n\nclass Any extends Node {\n  constructor() {\n    super();\n    this.node = new Null();\n    this.raw = null;\n    this.from(...arguments);\n  }\n\n  get isRaw() {\n    return true;\n  }\n\n  explicit(target) {\n    throw new Error('Cannot set explicit on any.');\n  }\n\n  implicit(target) {\n    throw new Error('Cannot set implicit on any.');\n  }\n\n  get type() {\n    return this.node.type;\n  }\n\n  getSize(extra) {\n    this.node.flags = this.flags;\n    return this.node.getSize(extra);\n  }\n\n  write(bw, extra) {\n    assert(bw);\n    assert(this.mode === NORMAL);\n    this.node.flags = this.flags;\n    this.node.write(bw, extra);\n    return bw;\n  }\n\n  read(br, extra) {\n    assert(br);\n    assert(this.mode === NORMAL);\n    const hdr = peekHeader(br, this.opt);\n\n    if (!hdr) {\n      this.node.flags = this.flags;\n      return this;\n    }\n\n    const Node = typeToClass(hdr.type);\n    this.node = new Node();\n    this.node.flags = this.flags;\n    this.node.read(br, extra);\n    return this;\n  }\n\n  getBodySize(extra) {\n    this.node.flags = this.flags;\n    return this.node.getBodySize(extra);\n  }\n\n  writeBody(bw, extra) {\n    this.node.flags = this.flags;\n    this.node.writeBody(bw, extra);\n    return bw;\n  }\n\n  readBody(br, extra) {\n    this.node.flags = this.flags;\n    this.node.readBody(br, extra);\n    return this;\n  }\n\n  set(node) {\n    if (node == null) node = new Null();\n    assert(node instanceof Node);\n    this.node = node;\n    this.node.flags = this.flags;\n    return this;\n  }\n\n  clean() {\n    return this.node.type === types.NULL;\n  }\n\n  format() {\n    return {\n      type: this.constructor.name,\n      node: this.node\n    };\n  }\n\n}\n/**\n * Choice\n */\n\n\nclass Choice extends Node {\n  constructor(node) {\n    super();\n    assert(node instanceof Node);\n    this.node = node;\n\n    for (var _len2 = arguments.length, options = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      options[_key2 - 1] = arguments[_key2];\n    }\n\n    this.from(...options);\n  }\n\n  get type() {\n    return this.node.type;\n  }\n\n  choices() {\n    throw new Error('Unimplemented.');\n  }\n\n  getSize(extra) {\n    return this.node.getSize(extra);\n  }\n\n  write(bw, extra) {\n    assert(bw);\n    this.node.flags = this.flags;\n    this.node.write(bw, extra);\n    return bw;\n  }\n\n  read(br, extra) {\n    assert(br);\n    const choices = this.choices();\n    assert(Array.isArray(choices));\n    assert(choices.length >= 1);\n    const hdr = peekHeader(br, this.opt);\n    if (!hdr) return this;\n    if (choices.indexOf(hdr.type) === -1) throw new Error(`Could not satisfy choice for: ${hdr.type}.`);\n    const Node = typeToClass(hdr.type);\n    const el = new Node();\n    el.flags = this.flags;\n    this.node = el.read(br, extra);\n    return this;\n  }\n\n  getBodySize(extra) {\n    return this.node.getBodySize(extra);\n  }\n\n  writeBody(bw, extra) {\n    this.node.writeBody(bw, extra);\n    return bw;\n  }\n\n  readBody(br, extra) {\n    this.node.readBody(br, extra);\n    return this;\n  }\n\n  set() {\n    return this.node.set(...arguments);\n  }\n\n  clean() {\n    return this.node.clean();\n  }\n\n  format() {\n    return {\n      type: this.constructor.name,\n      node: this.node\n    };\n  }\n\n}\n/**\n * String\n */\n\n\nconst Str = class String extends Node {\n  constructor() {\n    super();\n    this.value = '';\n    this.from(...arguments);\n  }\n\n  get encoding() {\n    return 'binary';\n  }\n\n  getBodySize() {\n    return Buffer.byteLength(this.value, this.encoding);\n  }\n\n  writeBody(bw) {\n    bw.writeString(this.value, this.encoding);\n    return bw;\n  }\n\n  readBody(br) {\n    const str = br.readString(br.left(), this.encoding);\n\n    switch (this.type) {\n      case types.NUMSTRING:\n        {\n          if (!isNumString(str)) throw new Error('Invalid num string.');\n          break;\n        }\n\n      case types.PRINTSTRING:\n        {\n          if (!isPrintString(str)) throw new Error('Invalid print string.');\n          break;\n        }\n\n      case types.IA5STRING:\n        {\n          if (!isIA5String(str)) throw new Error('Invalid print string.');\n          break;\n        }\n    }\n\n    this.value = str;\n    return this;\n  }\n\n  set(value) {\n    if (value == null) value = '';\n    assert(typeof value === 'string');\n    this.value = value;\n    return this;\n  }\n\n  clean() {\n    return this.value.length === 0;\n  }\n\n  format() {\n    return `<${this.constructor.name}: ${this.value}>`;\n  }\n\n};\n/**\n * Boolean\n */\n\nconst Bool = class Boolean extends Node {\n  constructor() {\n    super();\n    this.value = false;\n    this.from(...arguments);\n  }\n\n  get type() {\n    return types.BOOLEAN;\n  }\n\n  getBodySize() {\n    return 1;\n  }\n\n  writeBody(bw) {\n    bw.writeU8(this.value ? 0xff : 0x00);\n    return bw;\n  }\n\n  readBody(br) {\n    if (br.left() !== 1) throw new Error('Non-minimal boolean.');\n    const value = br.readU8();\n    if (value !== 0x00 && value !== 0xff) throw new Error('Invalid boolean.');\n    this.value = value === 0xff;\n    return this;\n  }\n\n  set(value) {\n    if (value == null) value = false;\n    assert(typeof value === 'boolean');\n    this.value = value;\n    return this;\n  }\n\n  clean() {\n    return this.value === false;\n  }\n\n  format() {\n    return `<${this.constructor.name}: ${this.value}>`;\n  }\n\n};\n/**\n * Integer\n */\n\nclass Integer extends Node {\n  constructor() {\n    super();\n    this.value = ZERO;\n    this.negative = false;\n    this.from(...arguments);\n  }\n\n  get type() {\n    return types.INTEGER;\n  }\n\n  getBodySize() {\n    const b = this.value;\n    if (b.length === 0) return 1;\n    let pad = 0;\n    let size = 0;\n\n    if (!this.negative && b[0] > 127) {\n      pad = 1;\n    } else if (this.negative) {\n      if (b[0] > 128) {\n        pad = 1;\n      } else if (b[0] === 128) {\n        pad = 0;\n\n        for (let i = 1; i < b.length; i++) pad |= b[i];\n\n        pad = pad ? 1 : 0;\n      }\n    }\n\n    size += pad;\n    size += b.length;\n    return size;\n  }\n\n  writeBody(bw) {\n    const b = this.value;\n\n    if (b.length === 0) {\n      bw.writeU8(0x00);\n      return bw;\n    }\n\n    let pad = 0;\n    let pb = 0;\n\n    if (!this.negative && b[0] > 127) {\n      pad = 1;\n      pb = 0;\n    } else if (this.negative) {\n      pb = 0xff;\n\n      if (b[0] > 128) {\n        pad = 1;\n      } else if (b[0] === 128) {\n        pad = 0;\n\n        for (let i = 1; i < b.length; i++) pad |= b[i];\n\n        pb = pad !== 0 ? 0xff : 0;\n        pad = pb & 1;\n      }\n    }\n\n    if (pad) bw.writeU8(pb);\n    const start = bw.offset;\n    bw.writeBytes(b);\n    if (pb) twosComplement(bw.data, start, bw.offset);\n    return this;\n  }\n\n  readBody(br) {\n    let p = br.readBytes(br.left());\n    if (p.length === 0) throw new Error('Zero length integer.');\n    const neg = p[0] & 0x80;\n\n    if (p.length === 1) {\n      if (neg) p[0] = (p[0] ^ 0xff) + 1;\n      this.negative = neg !== 0;\n      this.value = p;\n      return this;\n    }\n\n    if (p[0] === 0x00 && (p[1] & 0x80) === 0) throw new Error('Non-minimal integer.');\n    if (p[0] === 0xff && (p[1] & 0x80) === 0x80) throw new Error('Non-minimal integer.');\n    let pad = 0;\n\n    if (p[0] === 0x00) {\n      pad = 1;\n    } else if (p[0] === 0xff) {\n      for (let i = 1; i < p.length; i++) pad |= p[i];\n\n      pad = pad !== 0 ? 1 : 0;\n    }\n\n    if (pad && neg === (p[1] & 0x80)) throw new Error('Invalid integer padding.');\n    if (pad) p = p.slice(1);\n    if (neg) twosComplement(p, 0, p.length);\n    this.negative = neg !== 0;\n    this.value = trimLeft(p);\n    return this;\n  }\n\n  set(value, negative) {\n    if (typeof value === 'number') return this.fromNumber(value);\n    if (value == null) value = ZERO;\n    assert(Buffer.isBuffer(value));\n    this.value = trimLeft(value);\n    this.negative = false;\n\n    if (negative != null) {\n      assert(typeof negative === 'boolean');\n      this.negative = negative;\n    }\n\n    return this;\n  }\n\n  clean() {\n    return !this.negative && this.value.equals(ZERO);\n  }\n\n  formatValue() {\n    return this.value.toString('hex');\n  }\n\n  toNumber() {\n    let num = bio.readUBE(this.value, 0, this.value.length);\n    if (this.negative) num = -num;\n    return num;\n  }\n\n  fromNumber(num) {\n    assert(Number.isSafeInteger(num));\n    const buf = Buffer.allocUnsafe(8);\n    let neg = false;\n\n    if (num < 0) {\n      neg = true;\n      num = -num;\n    }\n\n    bio.writeU64BE(buf, num, 0);\n    this.value = trimLeft(buf);\n    this.negative = neg;\n    return this;\n  }\n\n  format() {\n    const name = this.constructor.name;\n    if (this.value.length <= 6) return `<${name}: ${this.toNumber()}>`;\n    const sign = this.negative ? '-' : '';\n    const hex = this.value.toString('hex');\n    return `<${name}: ${sign}0x${hex}>`;\n  }\n\n}\n/**\n * Unsigned\n */\n\n\nclass Unsigned extends Integer {\n  constructor() {\n    super(...arguments);\n  }\n\n  getBodySize() {\n    assert(!this.negative);\n    return super.getBodySize();\n  }\n\n  writeBody(bw) {\n    assert(!this.negative);\n    return super.writeBody(bw);\n  }\n\n  readBody(br) {\n    super.readBody(br);\n    assert(!this.negative);\n    return this;\n  }\n\n  set(value) {\n    return super.set(value);\n  }\n\n  toNumber() {\n    assert(!this.negative);\n    return super.toNumber();\n  }\n\n  fromNumber(num) {\n    super.fromNumber(num);\n    assert(!this.negative);\n    return this;\n  }\n\n}\n/**\n * BitString\n */\n\n\nclass BitString extends Node {\n  constructor() {\n    super();\n    this.bits = 0;\n    this.value = EMPTY;\n    this.from(...arguments);\n  }\n\n  get type() {\n    return types.BITSTRING;\n  }\n\n  getBodySize() {\n    return 1 + this.value.length;\n  }\n\n  writeBody(bw) {\n    const prefix = 8 - (this.bits & 7) & 7;\n    bw.writeU8(prefix);\n    bw.writeBytes(this.value);\n    return bw;\n  }\n\n  readBody(br) {\n    const data = br.readBytes(br.left());\n    if (data.length === 0) throw new Error('Zero length bit string.');\n    const padding = data[0];\n\n    if (padding > 7 || data.length === 1 && padding > 0 || (data[data.length - 1] & (1 << padding) - 1) !== 0) {\n      throw new Error('Invalid padding bits.');\n    }\n\n    this.bits = (data.length - 1) * 8 - padding;\n    this.value = data.slice(1);\n    return this;\n  }\n\n  rightAlign() {\n    const data = this.value;\n    const shift = 8 - (this.bits & 7);\n    if (shift === 8 || data.length === 0) return data;\n    const out = Buffer.allocUnsafe(data.length);\n    out[0] = data[0] >>> shift;\n\n    for (let i = 1; i < data.length; i++) {\n      out[i] = data[i - 1] << 8 - shift;\n      out[i] |= data[i] >>> shift;\n    }\n\n    return out;\n  }\n\n  getBit(i) {\n    assert(i >>> 0 === i);\n    if (i < 0 || i > this.bits) return 0;\n    const x = i >>> 3;\n    const y = 7 - (i & 7);\n    return this.value[x] >>> y & 1;\n  }\n\n  setBit(i, val) {\n    assert(i >>> 0 === i);\n    if (i < 0 || i > this.bits) return this;\n    const x = i >>> 3;\n    const y = 7 - (i & 7);\n    if (val) this.value[x] |= 1 << y;else this.value[x] &= ~(1 << y);\n    return this;\n  }\n\n  set(value) {\n    if (value == null) value = EMPTY;\n\n    if (typeof value === 'number') {\n      assert(value >>> 0 === value);\n      this.bits = value;\n      this.value = Buffer.alloc(value + 7 >>> 3);\n    } else {\n      assert(Buffer.isBuffer(value));\n      this.bits = value.length * 8;\n      this.value = value;\n    }\n\n    return this;\n  }\n\n  clean() {\n    return this.bits === 0 && this.value.length === 0;\n  }\n\n  format() {\n    let value = this.rightAlign();\n    if (value.length > 32) value = value.slice(0, 32);\n    return `<${this.constructor.name}: ${this.bits}:${value.toString('hex')}>`;\n  }\n\n}\n/**\n * OctString\n */\n\n\nclass OctString extends Node {\n  constructor() {\n    super();\n    this.value = EMPTY;\n    this.from(...arguments);\n  }\n\n  get type() {\n    return types.OCTSTRING;\n  }\n\n  getBodySize() {\n    return this.value.length;\n  }\n\n  writeBody(bw) {\n    bw.writeBytes(this.value);\n    return bw;\n  }\n\n  readBody(br) {\n    this.value = br.readBytes(br.left());\n    return this;\n  }\n\n  set(value) {\n    if (value == null) value = EMPTY;\n    assert(Buffer.isBuffer(value));\n    this.value = value;\n    return this;\n  }\n\n  clean() {\n    return this.value.length === 0;\n  }\n\n  format() {\n    let value = this.value;\n    if (value.length > 32) value = value.slice(0, 32);\n    return `<${this.constructor.name}: ${value.toString('hex')}>`;\n  }\n\n}\n/**\n * Null\n */\n\n\nclass Null extends Node {\n  constructor() {\n    super();\n    this.from(...arguments);\n  }\n\n  get type() {\n    return types.NULL;\n  }\n\n  getBodySize() {\n    return 0;\n  }\n\n  writeBody(bw) {\n    return bw;\n  }\n\n  readBody(br) {\n    if (br.left() !== 0) throw new Error('Non-minimal NULL.');\n    return this;\n  }\n\n  clean() {\n    return true;\n  }\n\n  format() {\n    return `<${this.constructor.name}>`;\n  }\n\n}\n/**\n * OID\n */\n\n\nclass OID extends Node {\n  constructor() {\n    super();\n    this.value = EMPTY_OID;\n    this.from(...arguments);\n  }\n\n  get type() {\n    return types.OID;\n  }\n\n  getBodySize() {\n    const oid = this.value;\n    if (oid.length < 2 || oid[0] > 2 || oid[0] < 2 && oid[1] >= 40) throw new Error('Invalid OID.');\n    let size = sizeBase128(oid[0] * 40 + oid[1]);\n\n    for (let i = 2; i < oid.length; i++) size += sizeBase128(oid[i]);\n\n    return size;\n  }\n\n  writeBody(bw) {\n    const oid = this.value;\n    const data = bw.data;\n    if (oid.length < 2 || oid[0] > 2 || oid[0] < 2 && oid[1] >= 40) throw new Error('Invalid OID.');\n    let off = bw.offset;\n    off = writeBase128(data, oid[0] * 40 + oid[1], off);\n\n    for (let i = 2; i < oid.length; i++) off = writeBase128(data, oid[i], off);\n\n    bw.offset = off;\n    return bw;\n  }\n\n  readBody(br) {\n    const data = br.readBytes(br.left(), true);\n    if (data.length === 0) throw new Error('Zero length OID.');\n    const s = new Uint32Array(data.length + 1);\n    let [v, off] = readBase128(data, 0);\n\n    if (v < 80) {\n      s[0] = v / 40 >>> 0;\n      s[1] = v % 40;\n    } else {\n      s[0] = 2;\n      s[1] = v - 80;\n    }\n\n    let i = 2;\n\n    for (; off < data.length; i++) {\n      [v, off] = readBase128(data, off);\n      s[i] = v;\n    }\n\n    this.value = s.subarray(0, i);\n    return this;\n  }\n\n  equals(oid) {\n    assert(oid instanceof OID);\n    return isEqual(this.value, oid.value);\n  }\n\n  set(value) {\n    if (value == null) value = EMPTY_OID;\n    if (typeof value === 'string') return this.fromString(value);\n    if (Array.isArray(value)) return this.fromArray(value);\n    assert(value instanceof Uint32Array);\n    this.value = value;\n    return this;\n  }\n\n  clean() {\n    return isEqual(this.value, EMPTY_OID);\n  }\n\n  toArray() {\n    const arr = [];\n\n    for (let i = 0; i < this.value.length; i++) arr.push(this.value[i]);\n\n    return arr;\n  }\n\n  fromArray(arr) {\n    assert(Array.isArray(arr));\n    const out = new Uint32Array(arr.length);\n\n    for (let i = 0; i < arr.length; i++) {\n      const val = arr[i];\n      assert(val >>> 0 === val);\n      out[i] = val;\n    }\n\n    this.value = out;\n    return this;\n  }\n\n  toString() {\n    let str = '';\n\n    for (let i = 0; i < this.value.length; i++) {\n      if (i > 0) str += '.';\n      str += this.value[i].toString(10);\n    }\n\n    return str;\n  }\n\n  fromString(str) {\n    assert(typeof str === 'string');\n    if (objects.attrs.hasOwnProperty(str)) str = objects.attrs[str];else if (objects.keyAlgs.hasOwnProperty(str)) str = objects.keyAlgs[str];else if (objects.hashes.hasOwnProperty(str)) str = objects.hashes[str];else if (objects.curves.hasOwnProperty(str)) str = objects.curves[str];\n    const parts = str.split('.');\n    const out = new Uint32Array(parts.length);\n\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n      out[i] = parseU32(part);\n    }\n\n    this.value = out;\n    return this;\n  }\n\n  getAttributeName() {\n    return objects.attrsByVal[this.toString()] || null;\n  }\n\n  getSignatureAlgorithmName() {\n    return objects.sigAlgsByVal[this.toString()] || null;\n  }\n\n  getSignatureHash() {\n    return objects.sigToHash[this.toString()] || null;\n  }\n\n  getSignatureHashName() {\n    const oid = this.getSignatureHash();\n    if (!oid) return null;\n    return objects.hashesByVal[oid] || null;\n  }\n\n  getKeyAlgorithmName() {\n    return objects.keyAlgsByVal[this.toString()] || null;\n  }\n\n  getHashName() {\n    return objects.hashesByVal[this.toString()] || null;\n  }\n\n  getCurveName() {\n    return objects.curvesByVal[this.toString()] || null;\n  }\n\n  format() {\n    const oid = this.toString();\n    const name = objects.attrsByVal[oid] || objects.sigAlgsByVal[oid] || objects.keyAlgsByVal[oid] || objects.hashesByVal[oid] || objects.curvesByVal[oid] || 'UNKNOWN';\n    const str = `${oid} (${name})`;\n    return `<${this.constructor.name}: ${str}>`;\n  }\n\n}\n/**\n * Enum\n */\n\n\nclass Enum extends Integer {\n  constructor() {\n    super(...arguments);\n  }\n\n  get type() {\n    return types.ENUM;\n  }\n\n}\n/**\n * Utf8String\n */\n\n\nclass Utf8String extends Str {\n  constructor() {\n    super(...arguments);\n  }\n\n  get type() {\n    return types.UTF8STRING;\n  }\n\n  get encoding() {\n    return 'utf8';\n  }\n\n}\n/**\n * RawSequence\n */\n\n\nclass RawSequence extends Node {\n  constructor() {\n    super();\n    this.value = EMPTY;\n    this.from(...arguments);\n  }\n\n  get type() {\n    return types.SEQUENCE;\n  }\n\n  getBodySize() {\n    return this.value.length;\n  }\n\n  writeBody(bw) {\n    bw.writeBytes(this.value);\n    return bw;\n  }\n\n  readBody(br) {\n    this.value = br.readBytes(br.left());\n    return this;\n  }\n\n  set(value) {\n    if (value == null) value = EMPTY;\n    if (Array.isArray(value)) return this.fromArray(value);\n    assert(Buffer.isBuffer(value));\n    this.value = value;\n    return this;\n  }\n\n  clean() {\n    return this.value.length === 0;\n  }\n\n  *children() {\n    const br = bio.read(this.value);\n\n    while (br.left()) yield Any.read(br).node;\n  }\n\n  toArray() {\n    const out = [];\n\n    for (const el of this.children()) out.push(el);\n\n    return out;\n  }\n\n  fromArray(value) {\n    assert(Array.isArray(value));\n    let size = 0;\n\n    for (const el of value) {\n      assert(el instanceof Node);\n      size += el.getSize();\n    }\n\n    const bw = bio.write(size);\n\n    for (const el of value) el.write(bw);\n\n    this.value = bw.render();\n    return this;\n  }\n\n  format() {\n    return this.toArray();\n  }\n\n}\n/**\n * RawSet\n */\n\n\nclass RawSet extends RawSequence {\n  constructor() {\n    super(...arguments);\n  }\n\n  get type() {\n    return types.SET;\n  }\n\n}\n/**\n * NumString\n */\n\n\nclass NumString extends Str {\n  constructor() {\n    super(...arguments);\n  }\n\n  get type() {\n    return types.NUMSTRING;\n  }\n\n}\n/**\n * PrintString\n */\n\n\nclass PrintString extends Str {\n  constructor() {\n    super(...arguments);\n  }\n\n  get type() {\n    return types.PRINTSTRING;\n  }\n\n}\n/**\n * T61String\n */\n\n\nclass T61String extends Str {\n  constructor() {\n    super(...arguments);\n  }\n\n  get type() {\n    return types.T61STRING;\n  }\n\n}\n/**\n * IA5String\n */\n\n\nclass IA5String extends Str {\n  constructor() {\n    super(...arguments);\n  }\n\n  get type() {\n    return types.IA5STRING;\n  }\n\n}\n/**\n * Time\n */\n\n\nclass Time extends Node {\n  constructor() {\n    super();\n    this.value = 0;\n    this.offset = 0;\n    this.from(...arguments);\n  }\n\n  set(value, offset) {\n    if (value == null) value = 0;\n    if (offset == null) offset = 0;\n    if (typeof value === 'string') return this.fromString(value);\n    assert(isTime(value));\n    assert(isOffset(offset));\n    this.value = value;\n    this.offset = offset;\n    return this;\n  }\n\n  clean() {\n    return this.value === 0 && this.offset === 0;\n  }\n\n  unix() {\n    return this.value - this.offset;\n  }\n\n  toString() {\n    const date = new Date(this.value * 1000);\n    const str = date.toISOString().slice(0, -5);\n    return str + serializeOffset(this.offset);\n  }\n\n  fromString(str) {\n    assert(typeof str === 'string');\n    const ms = Date.parse(str);\n    if (ms !== ms) throw new Error('Invalid date string.');\n    const time = Math.floor(ms / 1000);\n    if (!isTime(time)) throw new Error('Invalid time.');\n    this.value = time;\n    this.offset = 0;\n    return this;\n  }\n\n  format() {\n    const name = this.constructor.name;\n    const value = this.value;\n    let off = this.offset.toString(10);\n    if (this.offset >= 0) off = '+' + off;\n    return `<${name}: ${value}${off} (${this.toString()})>`;\n  }\n\n}\n/**\n * UTCTime\n */\n\n\nclass UTCTime extends Time {\n  constructor() {\n    super(...arguments);\n  }\n\n  get type() {\n    return types.UTCTIME;\n  }\n\n  getBodySize() {\n    return this.offset === 0 ? 13 : 17;\n  }\n\n  writeBody(bw) {\n    assert(isTime(this.value));\n    const date = new Date(this.value * 1000);\n    let str = '';\n    str += two(date.getUTCFullYear() % 100);\n    str += two(date.getUTCMonth() + 1);\n    str += two(date.getUTCDate());\n    str += two(date.getUTCHours());\n    str += two(date.getUTCMinutes());\n    str += two(date.getUTCSeconds());\n    str += serializeOffset(this.offset);\n    bw.writeString(str, 'binary');\n    return bw;\n  }\n\n  readBody(br) {\n    const size = br.left();\n    if (size !== 13 && size !== 17) throw new Error('Invalid UTCTIME.');\n    const str = br.readString(size, 'binary');\n    const year = parseU32(str.substring(0, 2));\n    const mon = parseU32(str.substring(2, 4));\n    const day = parseU32(str.substring(4, 6));\n    const hour = parseU32(str.substring(6, 8));\n    const min = parseU32(str.substring(8, 10));\n    const sec = parseU32(str.substring(10, 12));\n    this.value = toSeconds(year, mon, day, hour, min, sec, true);\n    this.offset = parseOffset(str.substring(12));\n    return this;\n  }\n\n}\n/**\n * GenTime\n */\n\n\nclass GenTime extends Time {\n  constructor() {\n    super(...arguments);\n  }\n\n  get type() {\n    return types.GENTIME;\n  }\n\n  getBodySize() {\n    return this.offset === 0 ? 15 : 19;\n  }\n\n  writeBody(bw) {\n    assert(isTime(this.value));\n    const date = new Date(this.value * 1000);\n    let str = '';\n    str += date.getUTCFullYear().toString(10);\n    str += two(date.getUTCMonth() + 1);\n    str += two(date.getUTCDate());\n    str += two(date.getUTCHours());\n    str += two(date.getUTCMinutes());\n    str += two(date.getUTCSeconds());\n    str += serializeOffset(this.offset);\n    bw.writeString(str, 'binary');\n    return bw;\n  }\n\n  readBody(br) {\n    const size = br.left();\n    if (size !== 15 && size !== 19) throw new Error('Invalid GENTIME.');\n    const str = br.readString(size, 'binary');\n    const year = parseU32(str.substring(0, 4));\n    const mon = parseU32(str.substring(4, 6));\n    const day = parseU32(str.substring(6, 8));\n    const hour = parseU32(str.substring(8, 10));\n    const min = parseU32(str.substring(10, 12));\n    const sec = parseU32(str.substring(12, 14));\n    this.value = toSeconds(year, mon, day, hour, min, sec, false);\n    this.offset = parseOffset(str.substring(14));\n    return this;\n  }\n\n}\n/**\n * GenString\n */\n\n\nclass GenString extends Str {\n  constructor() {\n    super(...arguments);\n  }\n\n  get type() {\n    return types.GENSTRING;\n  }\n\n}\n/**\n * API\n */\n\n\nfunction typeToClass(type) {\n  assert(type >>> 0 === type);\n\n  switch (type) {\n    case types.BOOLEAN:\n      return Bool;\n\n    case types.INTEGER:\n      return Integer;\n\n    case types.BITSTRING:\n      return BitString;\n\n    case types.OCTSTRING:\n      return OctString;\n\n    case types.NULL:\n      return Null;\n\n    case types.OID:\n      return OID;\n\n    case types.ENUM:\n      return Enum;\n\n    case types.UTF8STRING:\n      return Utf8String;\n\n    case types.SEQUENCE:\n      return RawSequence;\n\n    case types.SET:\n      return RawSet;\n\n    case types.NUMSTRING:\n      return NumString;\n\n    case types.PRINTSTRING:\n      return PrintString;\n\n    case types.T61STRING:\n      return T61String;\n\n    case types.IA5STRING:\n      return IA5String;\n\n    case types.UTCTIME:\n      return UTCTime;\n\n    case types.GENTIME:\n      return GenTime;\n\n    case types.GENSTRING:\n      return GenString;\n\n    default:\n      throw new Error(`Unknown type: ${type}.`);\n  }\n}\n/*\n * Helpers\n */\n\n\nfunction sizeHeader(size) {\n  assert(size >>> 0 === size);\n  if (size <= 0x7f) return 1 + 1;\n  if (size <= 0xff) return 1 + 1 + 1;\n  if (size <= 0xffff) return 1 + 1 + 2;\n  assert(size <= 0xffffff);\n  return 1 + 1 + 3;\n}\n\nfunction writeHeader(bw, type, cls, primitive, size) {\n  assert(bw);\n  assert(type >>> 0 === type);\n  assert(cls >>> 0 === cls);\n  assert(typeof primitive === 'boolean');\n  assert(size >>> 0 === size);\n  if (!primitive) type |= 0x20;\n  type |= cls << 6; // Short form.\n\n  if (size <= 0x7f) {\n    bw.writeU8(type);\n    bw.writeU8(size);\n    return bw;\n  } // Long form (1 byte).\n\n\n  if (size <= 0xff) {\n    bw.writeU8(type);\n    bw.writeU8(0x80 | 1);\n    bw.writeU8(size);\n    return bw;\n  } // Long form (2 bytes).\n\n\n  if (size <= 0xffff) {\n    bw.writeU8(type);\n    bw.writeU8(0x80 | 2);\n    bw.writeU16BE(size);\n    return bw;\n  }\n\n  assert(size <= 0xffffff); // Long form (3 bytes).\n\n  bw.writeU8(type);\n  bw.writeU8(0x80 | 3);\n  bw.writeU24BE(size);\n  return bw;\n}\n\nfunction readHeader(br) {\n  const start = br.offset;\n  const field = br.readU8();\n  const cls = field >>> 6;\n  const primitive = (field & 0x20) === 0;\n  let type = field & 0x1f;\n\n  if (type === 0x1f) {\n    [type, br.offset] = readBase128(br.data, br.offset);\n    if (type < 0x1f) throw new Error('Non-minimal type.');\n  }\n\n  switch (cls) {\n    case classes.UNIVERSAL:\n    case classes.CONTEXT:\n      break;\n\n    default:\n      throw new Error('Unknown class.');\n  }\n\n  const size = readSize(br);\n  const len = br.offset - start;\n  return {\n    type,\n    cls,\n    primitive,\n    size,\n    len\n  };\n}\n\nfunction peekHeader(br, optional) {\n  const offset = br.offset;\n  let hdr = null;\n  let err = null;\n\n  try {\n    hdr = readHeader(br);\n  } catch (e) {\n    err = e;\n  }\n\n  br.offset = offset;\n  if (!optional && !hdr) throw err;\n  return hdr;\n}\n\nfunction readSize(br) {\n  const field = br.readU8();\n  const bytes = field & 0x7f; // Definite form\n\n  if ((field & 0x80) === 0) {\n    // Short form\n    return bytes;\n  } // Indefinite form.\n\n\n  if (bytes === 0) throw new Error('Indefinite length.');\n  let len = 0;\n\n  for (let i = 0; i < bytes; i++) {\n    const ch = br.readU8();\n    if (len >= 1 << 24) throw new Error('Length too large.');\n    len *= 0x100;\n    len += ch;\n    if (len === 0) throw new Error('Unexpected leading zeroes.');\n  }\n\n  if (len < 0x80) throw new Error('Non-minimal length.');\n  return len;\n}\n\nfunction sizeBase128(n) {\n  assert(n >>> 0 === n);\n  if (n === 0) return 1;\n  let len = 0;\n\n  while (n > 0) {\n    len += 1;\n    n >>>= 7;\n  }\n\n  return len;\n}\n\nfunction writeBase128(data, n, off) {\n  assert(Buffer.isBuffer(data));\n  assert(n >>> 0 === n);\n  assert(off >>> 0 === off);\n  const l = sizeBase128(n);\n\n  for (let i = l - 1; i >= 0; i--) {\n    let o = n >>> i * 7;\n    o &= 0x7f;\n    if (i !== 0) o |= 0x80;\n    if (off >= data.length) throw new bio.EncodingError(off, 'Out of bounds write');\n    data[off] = o;\n    off += 1;\n  }\n\n  return off;\n}\n\nfunction readBase128(data, off) {\n  assert(Buffer.isBuffer(data));\n  assert(off >>> 0 === off);\n  let shifted = 0;\n  let num = 0;\n\n  for (; off < data.length; shifted++) {\n    if (shifted === 5) throw new Error('Base128 integer too large.');\n    const b = data[off];\n    num *= 128;\n    num += b & 0x7f;\n    off += 1;\n\n    if ((b & 0x80) === 0) {\n      if (num > 0xffffffff) throw new Error('Base128 integer too large.');\n      return [num, off];\n    }\n  }\n\n  throw new Error('Base128 integer too short.');\n}\n\nfunction two(num) {\n  if (num < 10) return '0' + num.toString(10);\n  return num.toString(10);\n}\n\nfunction isNumString(str) {\n  assert(typeof str === 'string');\n\n  for (let i = 0; i < str.length; i++) {\n    const ch = str.charCodeAt(i);\n    if (ch >= 0x30 && ch <= 0x39) continue;\n    if (ch === 0x20) continue;\n    return false;\n  }\n\n  return true;\n}\n\nfunction isPrintString(str) {\n  assert(typeof str === 'string');\n\n  for (let i = 0; i < str.length; i++) {\n    const ch = str.charCodeAt(i); // 0 - 9\n\n    if (ch >= 0x30 && ch <= 0x39) continue; // A - Z\n\n    if (ch >= 0x41 && ch <= 0x5a) continue; // a - z\n\n    if (ch >= 0x61 && ch <= 0x7a) continue;\n\n    switch (ch) {\n      case 0x20: // ' '\n\n      case 0x26: // & - nonstandard\n\n      case 0x27: // '\n\n      case 0x28: // (\n\n      case 0x29: // )\n\n      case 0x2a: // * - nonstandard\n\n      case 0x2b: // +\n\n      case 0x2c: // ,\n\n      case 0x2d: // -\n\n      case 0x2e: // .\n\n      case 0x2f: // /\n\n      case 0x3a: // :\n\n      case 0x3d: // =\n\n      case 0x3f:\n        // ?\n        continue;\n    }\n\n    return false;\n  }\n\n  return true;\n}\n\nfunction isIA5String(str) {\n  assert(typeof str === 'string');\n\n  for (let i = 0; i < str.length; i++) {\n    const ch = str.charCodeAt(i);\n    if (ch >= 0x80) return false;\n  }\n\n  return true;\n}\n\nfunction parseU32(str) {\n  assert(typeof str === 'string');\n  let word = 0;\n  if (str.length === 0 || str.length > 10) throw new Error('Invalid integer.');\n\n  for (let i = 0; i < str.length; i++) {\n    const ch = str.charCodeAt(i) - 0x30;\n    if (ch < 0 || ch > 9) throw new Error('Invalid integer.');\n    word *= 10;\n    word += ch;\n    if (word > 0xffffffff) throw new Error('Invalid integer.');\n  }\n\n  return word;\n}\n\nfunction isEqual(a, b) {\n  assert(a instanceof Uint32Array);\n  assert(b instanceof Uint32Array);\n  if (a.length !== b.length) return false;\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n\n  return true;\n}\n\nfunction trimLeft(buf) {\n  assert(Buffer.isBuffer(buf));\n  if (buf.length === 0) return Buffer.from([0x00]);\n  if (buf[0] !== 0x00) return buf;\n\n  for (let i = 1; i < buf.length; i++) {\n    if (buf[i] !== 0x00) return buf.slice(i);\n  }\n\n  return buf.slice(-1);\n}\n\nfunction twosComplement(num, start, end) {\n  assert(Buffer.isBuffer(num));\n  assert(start >>> 0 === start);\n  assert(end >>> 0 === end);\n  assert(start <= end);\n  let carry = 1;\n\n  for (let i = end - 1; i >= start; i--) {\n    carry += num[i] ^ 0xff;\n    num[i] = carry & 0xff;\n    carry >>>= 8;\n  }\n\n  return num;\n}\n\nfunction isTime(time) {\n  if (!Number.isSafeInteger(time)) return false; // ASN.1 time ranges from;\n  //   0000-01-01T00:00:00.000Z\n  // to:\n  //   9999-12-31T00:59:59.000Z\n\n  if (time < MIN_TIME || time > MAX_TIME) return false;\n  return true;\n}\n\nfunction toSeconds(year, mon, day, hour, min, sec, utc) {\n  assert(year >>> 0 === year);\n  assert(mon >>> 0 === mon);\n  assert(day >>> 0 === day);\n  assert(hour >>> 0 === hour);\n  assert(min >>> 0 === min);\n  assert(sec >>> 0 === sec);\n  assert(typeof utc === 'boolean');\n\n  if (utc) {\n    if (year < 70) year = 2000 + year;else year = 1900 + year;\n  } // Highest valid date:\n  //   new Date(8640000000000000)\n\n\n  if (year > 275760) throw new Error('Invalid year.');\n  if (mon < 1 || mon > 12 || day < 1 || day > 32) throw new Error('Invalid month or day.');\n  if (hour > 23 || min > 59 || sec > 59) throw new Error('Invalid hours, minutes, or seconds.');\n  const ms = Date.UTC(year, mon - 1, day, hour, min, sec, 0);\n  assert(ms === ms);\n  const time = ms / 1000;\n  assert(isTime(time));\n  return time;\n}\n\nfunction isOffset(offset) {\n  if (!Number.isSafeInteger(offset)) return false; // UTC timezones range from -12:00 to +14:00.\n\n  if (offset < MIN_OFFSET || offset > MAX_OFFSET) return false;\n  return true;\n}\n\nfunction serializeOffset(offset) {\n  assert(isOffset(offset));\n  if (offset === 0) return 'Z';\n  let str = '';\n\n  if (offset < 0) {\n    str += '-';\n    offset = -offset;\n  } else {\n    str += '+';\n  }\n\n  const minutes = offset / 60 >>> 0;\n  const hour = minutes / 60 >>> 0;\n  const min = minutes % 60;\n  str += two(hour);\n  str += two(min);\n  return str;\n}\n\nfunction parseOffset(str) {\n  assert(typeof str === 'string');\n  if (str.length === 0) throw new Error('Invalid time offset.');\n  const zone = str[0];\n\n  switch (zone) {\n    case 'Z':\n      {\n        if (str.length !== 1) throw new Error('Non-minimal time offset.');\n        return 0;\n      }\n\n    case '+':\n    case '-':\n      {\n        if (str.length !== 5) throw new Error('Non-minimal time offset.');\n        const hour = parseU32(str.substring(1, 3));\n        const min = parseU32(str.substring(3, 5));\n        const minutes = hour * 60 + min;\n        let offset = minutes * 60;\n        if (zone === '-') offset = -offset;\n        if (!isOffset(offset)) throw new Error('Not a time zone.');\n        return offset;\n      }\n  }\n\n  throw new Error('Invalid time offset.');\n}\n/*\n * Expose\n */\n\n\nexports.EMPTY = EMPTY;\nexports.ZERO = ZERO;\nexports.EMPTY_OID = EMPTY_OID;\nexports.types = types;\nexports.typesByVal = typesByVal;\nexports.classes = classes;\nexports.classesByVal = classesByVal;\nexports.objects = objects;\nexports.TARGET = TARGET;\nexports.OPTIONAL = OPTIONAL;\nexports.MODE = MODE;\nexports.NORMAL = NORMAL;\nexports.EXPLICIT = EXPLICIT;\nexports.IMPLICIT = IMPLICIT;\nexports.Node = Node;\nexports.Sequence = Sequence;\nexports.Set = Set;\nexports.Any = Any;\nexports.Choice = Choice;\nexports.Str = Str;\nexports.String = Str;\nexports.Bool = Bool;\nexports.Boolean = Bool;\nexports.Integer = Integer;\nexports.Unsigned = Unsigned;\nexports.BitString = BitString;\nexports.OctString = OctString;\nexports.Null = Null;\nexports.OID = OID;\nexports.Enum = Enum;\nexports.Utf8String = Utf8String;\nexports.RawSequence = RawSequence;\nexports.RawSet = RawSet;\nexports.NumString = NumString;\nexports.PrintString = PrintString;\nexports.T61String = T61String;\nexports.IA5String = IA5String;\nexports.Time = Time;\nexports.UTCTime = UTCTime;\nexports.GenTime = GenTime;\nexports.GenString = GenString;\nexports.typeToClass = typeToClass;","map":null,"metadata":{},"sourceType":"script"}