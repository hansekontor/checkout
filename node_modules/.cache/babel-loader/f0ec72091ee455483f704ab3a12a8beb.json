{"ast":null,"code":"/*!\n * gost94.js - GOST94 implementation for bcrypto\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on RustCrypto/hashes:\n *   Copyright (c) 2016-2018, The RustCrypto Authors (MIT License).\n *   https://github.com/RustCrypto/hashes\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/GOST_(hash_function)\n *   https://tools.ietf.org/html/rfc4357\n *   https://tools.ietf.org/html/rfc5831\n *   https://github.com/RustCrypto/hashes/blob/master/gost94/src/gost94.rs\n */\n'use strict';\n\nconst assert = require('./internal/assert');\n\nconst HMAC = require('./internal/hmac');\n/*\n * Constants\n */\n\n\nconst FINALIZED = -1;\nconst PADDING = Buffer.alloc(32, 0x00);\nconst DESC = Buffer.alloc(32, 0x00);\nconst C = Buffer.from([0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff]);\nconst S_CRYPTOPRO = [Buffer.from([10, 4, 5, 6, 8, 1, 3, 7, 13, 12, 14, 0, 9, 2, 11, 15]), Buffer.from([5, 15, 4, 0, 2, 13, 11, 9, 1, 7, 6, 3, 12, 14, 10, 8]), Buffer.from([7, 15, 12, 14, 9, 4, 1, 0, 3, 11, 5, 2, 6, 10, 8, 13]), Buffer.from([4, 10, 7, 12, 0, 15, 2, 8, 14, 1, 6, 5, 13, 11, 9, 3]), Buffer.from([7, 6, 4, 11, 9, 12, 2, 10, 1, 8, 0, 14, 15, 13, 3, 5]), Buffer.from([7, 6, 2, 4, 13, 9, 15, 0, 10, 1, 5, 11, 8, 14, 12, 3]), Buffer.from([13, 14, 4, 1, 7, 0, 5, 10, 3, 12, 8, 15, 6, 2, 9, 11]), Buffer.from([1, 3, 10, 9, 5, 11, 4, 15, 8, 6, 7, 14, 13, 0, 2, 12])];\nconst S_TEST = [Buffer.from([4, 10, 9, 2, 13, 8, 0, 14, 6, 11, 1, 12, 7, 15, 5, 3]), Buffer.from([14, 11, 4, 12, 6, 13, 15, 10, 2, 3, 8, 1, 0, 7, 5, 9]), Buffer.from([5, 8, 1, 13, 10, 3, 4, 2, 14, 15, 12, 7, 6, 0, 9, 11]), Buffer.from([7, 13, 10, 1, 0, 8, 9, 15, 14, 4, 6, 12, 11, 2, 5, 3]), Buffer.from([6, 12, 7, 1, 5, 15, 13, 8, 4, 10, 9, 14, 0, 3, 11, 2]), Buffer.from([4, 11, 10, 0, 7, 2, 1, 13, 3, 6, 8, 5, 9, 12, 15, 14]), Buffer.from([13, 11, 4, 1, 3, 15, 5, 9, 0, 10, 14, 7, 6, 8, 2, 12]), Buffer.from([1, 15, 13, 0, 5, 7, 10, 4, 9, 2, 3, 14, 6, 11, 8, 12])];\nconst S_S2015 = [Buffer.from([12, 4, 6, 2, 10, 5, 11, 9, 14, 8, 13, 7, 0, 3, 15, 1]), Buffer.from([6, 8, 2, 3, 9, 10, 5, 12, 1, 14, 4, 7, 11, 13, 0, 15]), Buffer.from([11, 3, 5, 8, 2, 15, 10, 13, 14, 1, 7, 4, 12, 9, 6, 0]), Buffer.from([12, 8, 2, 1, 13, 4, 15, 6, 7, 0, 10, 5, 3, 14, 9, 11]), Buffer.from([7, 15, 5, 10, 8, 1, 6, 13, 0, 9, 3, 14, 11, 4, 2, 12]), Buffer.from([5, 13, 15, 6, 9, 2, 12, 10, 11, 7, 8, 1, 4, 3, 14, 0]), Buffer.from([8, 14, 2, 5, 6, 9, 1, 12, 15, 4, 11, 0, 13, 10, 3, 7]), Buffer.from([1, 7, 14, 13, 0, 5, 8, 3, 4, 15, 10, 6, 9, 12, 11, 2])];\n/**\n * GOST94\n */\n\nclass GOST94 {\n  constructor() {\n    this.S = S_CRYPTOPRO;\n    this.state = Buffer.allocUnsafe(32);\n    this.sigma = Buffer.allocUnsafe(32);\n    this.block = Buffer.allocUnsafe(32);\n    this.size = FINALIZED;\n  }\n\n  init(box) {\n    if (box == null) box = S_CRYPTOPRO;\n    assert(Array.isArray(box) && box.length === 8);\n    this.S = box;\n    this.state.fill(0x00);\n    this.sigma.fill(0x00);\n    this.size = 0;\n    return this;\n  }\n\n  update(data) {\n    assert(Buffer.isBuffer(data));\n\n    this._update(data, data.length);\n\n    return this;\n  }\n\n  final() {\n    return this._final(Buffer.allocUnsafe(32));\n  }\n\n  _update(data, len) {\n    assert(this.size !== FINALIZED, 'Context is not initialized.');\n    let pos = this.size & 31;\n    let off = 0;\n    this.size += len;\n\n    if (pos > 0) {\n      let want = 32 - pos;\n      if (want > len) want = len;\n      data.copy(this.block, pos, off, off + want);\n      pos += want;\n      len -= want;\n      off += want;\n      if (pos < 32) return;\n\n      this._transform(this.block, 0);\n    }\n\n    while (len >= 32) {\n      this._transform(data, off);\n\n      off += 32;\n      len -= 32;\n    }\n\n    if (len > 0) data.copy(this.block, 0, off, off + len);\n  }\n\n  _final(out) {\n    assert(this.size !== FINALIZED, 'Context is not initialized.');\n    const bits = this.size * 8;\n    const pos = this.size & 31;\n    if (pos !== 0) this._update(PADDING, 32 - pos);\n    const hi = bits * (1 / 0x100000000) >>> 0;\n    const lo = bits >>> 0;\n    writeU32(DESC, lo, 0);\n    writeU32(DESC, hi, 4);\n\n    this._f(DESC);\n\n    this._f(this.sigma);\n\n    this.state.copy(out, 0);\n    this.state.fill(0x00);\n    this.sigma.fill(0x00);\n    this.block.fill(0x00);\n    DESC.fill(0x00, 0, 8);\n    this.size = FINALIZED;\n    return out;\n  }\n\n  _transform(chunk, pos) {\n    const m = chunk.slice(pos, pos + 32);\n\n    this._f(m);\n\n    this._sum(m);\n  }\n\n  _shuffle(m, s) {\n    const res = Buffer.allocUnsafe(32);\n    s.copy(res, 0);\n\n    for (let i = 0; i < 12; i++) psi(res);\n\n    XM(res, m);\n    psi(res);\n    XM(this.state, res);\n\n    for (let i = 0; i < 61; i++) psi(this.state);\n  }\n\n  _f(m) {\n    const s = Buffer.allocUnsafe(32);\n    this.state.copy(s, 0);\n    let k, u, v;\n    k = P(X(this.state, m));\n    encrypt(s, 0, k, this.S);\n    u = A(this.state);\n    v = A(A(m));\n    k = P(X(u, v));\n    encrypt(s, 8, k, this.S);\n    u = A(u);\n    XM(u, C);\n    v = A(A(v));\n    k = P(X(u, v));\n    encrypt(s, 16, k, this.S);\n    u = A(u);\n    v = A(A(v));\n    k = P(X(u, v));\n    encrypt(s, 24, k, this.S);\n\n    this._shuffle(m, s);\n  }\n\n  _sum(m) {\n    let c = 0;\n\n    for (let i = 0; i < 32; i++) {\n      c += this.sigma[i] + m[i];\n      this.sigma[i] = c;\n      c >>>= 8;\n    }\n  }\n\n  static hash() {\n    return new GOST94();\n  }\n\n  static hmac(box) {\n    return new HMAC(GOST94, 32, [box]);\n  }\n\n  static digest(data, box) {\n    return GOST94.ctx.init(box).update(data).final();\n  }\n\n  static root(left, right, box) {\n    assert(Buffer.isBuffer(left) && left.length === 32);\n    assert(Buffer.isBuffer(right) && right.length === 32);\n    return GOST94.ctx.init(box).update(left).update(right).final();\n  }\n\n  static multi(x, y, z, box) {\n    const {\n      ctx\n    } = GOST94;\n    ctx.init(box);\n    ctx.update(x);\n    ctx.update(y);\n    if (z) ctx.update(z);\n    return ctx.final();\n  }\n\n  static mac(data, key, box) {\n    return GOST94.hmac(box).init(key).update(data).final();\n  }\n\n}\n/*\n * Static\n */\n\n\nGOST94.native = 0;\nGOST94.id = 'GOST94';\nGOST94.size = 32;\nGOST94.bits = 256;\nGOST94.blockSize = 32;\nGOST94.zero = Buffer.alloc(32, 0x00);\nGOST94.ctx = new GOST94();\nGOST94.CRYPTOPRO = S_CRYPTOPRO;\nGOST94.TEST = S_TEST;\nGOST94.S2015 = S_S2015;\n/*\n * Helpers\n */\n\nfunction sbox(a, S) {\n  let v = 0;\n\n  for (let i = 0; i < 8; i++) {\n    const shft = 4 * i;\n    const k = (a & 15 << shft) >>> shft;\n    v += S[i][k] << shft;\n  }\n\n  return v >>> 0;\n}\n\nfunction G(a, k, S) {\n  return rotl32(sbox(a + k >>> 0, S), 11);\n}\n\nfunction encrypt(msg, pos, key, sbox) {\n  const k = new Uint32Array(8);\n  let a = readU32(msg, pos + 0);\n  let b = readU32(msg, pos + 4);\n\n  for (let i = 0; i < 8; i++) k[i] = readU32(key, i * 4);\n\n  for (let x = 0; x < 3; x++) {\n    for (let i = 0; i < 8; i++) {\n      const t = b ^ G(a, k[i], sbox);\n      b = a;\n      a = t;\n    }\n  }\n\n  for (let i = 7; i >= 0; i--) {\n    const t = b ^ G(a, k[i], sbox);\n    b = a;\n    a = t;\n  }\n\n  writeU32(msg, b, pos + 0);\n  writeU32(msg, a, pos + 4);\n}\n\nfunction X(a, b) {\n  const out = Buffer.allocUnsafe(32);\n\n  for (let i = 0; i < 32; i++) out[i] = a[i] ^ b[i];\n\n  return out;\n}\n\nfunction XM(a, b) {\n  for (let i = 0; i < 32; i++) a[i] ^= b[i];\n}\n\nfunction A(x) {\n  const out = Buffer.allocUnsafe(32);\n  x.copy(out, 0, 8, 32);\n\n  for (let i = 0; i < 8; i++) out[24 + i] = x[i] ^ x[i + 8];\n\n  return out;\n}\n\nfunction P(y) {\n  const out = Buffer.allocUnsafe(32);\n\n  for (let i = 0; i < 4; i++) {\n    for (let k = 0; k < 8; k++) out[i + 4 * k] = y[8 * i + k];\n  }\n\n  return out;\n}\n\nfunction psi(block) {\n  const out = Buffer.allocUnsafe(32);\n  block.copy(out, 0, 2, 32);\n  block.copy(out, 30, 0, 2);\n  out[30] ^= block[2];\n  out[31] ^= block[3];\n  out[30] ^= block[4];\n  out[31] ^= block[5];\n  out[30] ^= block[6];\n  out[31] ^= block[7];\n  out[30] ^= block[24];\n  out[31] ^= block[25];\n  out[30] ^= block[30];\n  out[31] ^= block[31];\n  out.copy(block, 0);\n}\n\nfunction rotl32(w, b) {\n  return w << b | w >>> 32 - b;\n}\n\nfunction readU32(data, off) {\n  return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;\n}\n\nfunction writeU32(dst, num, off) {\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  return off;\n}\n/*\n * Expose\n */\n\n\nmodule.exports = GOST94;","map":null,"metadata":{},"sourceType":"script"}