{"ast":null,"code":"/*!\n * keyring.js - keyring object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst {\n  base58\n} = require('bstring');\n\nconst bio = require('bufio');\n\nconst hash160 = require('bcrypto/lib/hash160');\n\nconst hash256 = require('bcrypto/lib/hash256');\n\nconst Network = require('../protocol/network');\n\nconst Script = require('../script/script');\n\nconst Address = require('./address');\n\nconst Output = require('./output');\n\nconst secp256k1 = require('bcrypto/lib/secp256k1');\n\nconst {\n  encoding\n} = bio;\n\nconst {\n  inspectSymbol\n} = require('../utils');\n/*\n * Constants\n */\n\n\nconst ZERO_KEY = Buffer.alloc(33, 0x00);\n/**\n * Key Ring\n * Represents a key ring which amounts to an address.\n * @alias module:primitives.KeyRing\n */\n\nclass KeyRing {\n  /**\n   * Create a key ring.\n   * @constructor\n   * @param {Object} options\n   */\n  constructor(options) {\n    this.nested = false;\n    this.publicKey = ZERO_KEY;\n    this.privateKey = null;\n    this.script = null;\n    this._keyHash = null;\n    this._keyAddress = null;\n    this._scriptHash160 = null;\n    this._scriptAddress = null; // if (options)\n    //   this.fromOptions(options);\n  } //   /**\n  //    * Inject properties from options object.\n  //    * @private\n  //    * @param {Object} options\n  //    */\n  //   fromOptions(options) {\n  //     let key = toKey(options);\n  //     if (Buffer.isBuffer(key))\n  //       return this.fromKey(key);\n  //     key = toKey(options.key);\n  //     if (options.publicKey)\n  //       key = toKey(options.publicKey);\n  //     if (options.privateKey)\n  //       key = toKey(options.privateKey);\n  //     const script = options.script;\n  //     const compress = options.compressed;\n  //     if (script)\n  //       return this.fromScript(key, script, compress);\n  //     return this.fromKey(key, compress);\n  //   }\n  //   /**\n  //    * Instantiate key ring from options.\n  //    * @param {Object} options\n  //    * @returns {KeyRing}\n  //    */\n  //   static fromOptions(options) {\n  //     return new this().fromOptions(options);\n  //   }\n  //   /**\n  //    * Clear cached key/script hashes.\n  //    */\n  //   refresh() {\n  //     this._keyHash = null;\n  //     this._keyAddress = null;\n  //     this._scriptHash160 = null;\n  //     this._scriptAddress = null;\n  //   }\n  //   /**\n  //    * Inject data from private key.\n  //    * @private\n  //    * @param {Buffer} key\n  //    * @param {Boolean?} compress\n  //    */\n\n\n  fromPrivate(key, compress) {\n    assert(Buffer.isBuffer(key), 'Private key must be a buffer.');\n    assert(secp256k1.privateKeyVerify(key), 'Not a valid private key.');\n    this.privateKey = key;\n    this.publicKey = secp256k1.publicKeyCreate(key, compress !== false);\n    return this;\n  } //   /**\n  //    * Instantiate keyring from a private key.\n  //    * @param {Buffer} key\n  //    * @param {Boolean?} compress\n  //    * @returns {KeyRing}\n  //    */\n  //   static fromPrivate(key, compress) {\n  //     return new this().fromPrivate(key, compress);\n  //   }\n  //   /**\n  //    * Inject data from public key.\n  //    * @private\n  //    * @param {Buffer} key\n  //    */\n  //   fromPublic(key) {\n  //     assert(Buffer.isBuffer(key), 'Public key must be a buffer.');\n  //     assert(secp256k1.publicKeyVerify(key), 'Not a valid public key.');\n  //     this.publicKey = key;\n  //     return this;\n  //   }\n  //   /**\n  //    * Generate a keyring.\n  //    * @private\n  //    * @param {Boolean?} compress\n  //    * @returns {KeyRing}\n  //    */\n  //   generate(compress) {\n  //     const key = secp256k1.privateKeyGenerate();\n  //     return this.fromKey(key, compress);\n  //   }\n  //   /**\n  //    * Generate a keyring.\n  //    * @param {Boolean?} compress\n  //    * @returns {KeyRing}\n  //    */\n  //   static generate(compress) {\n  //     return new this().generate(compress);\n  //   }\n  //   /**\n  //    * Instantiate keyring from a public key.\n  //    * @param {Buffer} publicKey\n  //    * @returns {KeyRing}\n  //    */\n  //   static fromPublic(key) {\n  //     return new this().fromPublic(key);\n  //   }\n  //   /**\n  //    * Inject data from public key.\n  //    * @private\n  //    * @param {Buffer} privateKey\n  //    * @param {Boolean?} compress\n  //    */\n  //   fromKey(key, compress) {\n  //     assert(Buffer.isBuffer(key), 'Key must be a buffer.');\n  //     if (key.length === 32)\n  //       return this.fromPrivate(key, compress !== false);\n  //     return this.fromPublic(key);\n  //   }\n  //   /**\n  //    * Instantiate keyring from a public key.\n  //    * @param {Buffer} publicKey\n  //    * @param {Boolean?} compress\n  //    * @returns {KeyRing}\n  //    */\n  //   static fromKey(key, compress) {\n  //     return new this().fromKey(key, compress);\n  //   }\n  //   /**\n  //    * Inject data from script.\n  //    * @private\n  //    * @param {Buffer} key\n  //    * @param {Script} script\n  //    * @param {Boolean?} compress\n  //    */\n  //   fromScript(key, script, compress) {\n  //     assert(script instanceof Script, 'Non-script passed into KeyRing.');\n  //     this.fromKey(key, compress);\n  //     this.script = script;\n  //     return this;\n  //   }\n  //   /**\n  //    * Instantiate keyring from script.\n  //    * @param {Buffer} key\n  //    * @param {Script} script\n  //    * @param {Boolean?} compress\n  //    * @returns {KeyRing}\n  //    */\n  //   static fromScript(key, script, compress) {\n  //     return new this().fromScript(key, script, compress);\n  //   }\n  //   /**\n  //    * Get ith public key from multisig script.\n  //    * @private\n  //    * @param {Script} script\n  //    * @param {Number} i\n  //    * @returns {KeyRing}\n  //    */\n  //   fromMultisigScript(script, i) {\n  //     assert(script instanceof Script, 'Non-script passed.');\n  //     assert(script.isMultisig(), 'Script must be multisig');\n  //     const n = script.getSmall(-2);\n  //     assert(i >= 1 && i <= n, 'Requested `i`th key, `n` available');\n  //     this.fromKey(script.code[i].toData());\n  //     return this;\n  //   }\n  //   /**\n  //    * Instantiate keyring from ith key in multisig script.\n  //    * @param {Script} script\n  //    * @param {Number} i\n  //    * @returns {KeyRing}\n  //    */\n  //   static fromMultisigScript(script, i) {\n  //     return new this().fromMultisigScript(script, i);\n  //   }\n  //   /**\n  //    * Calculate WIF serialization size.\n  //    * @returns {Number}\n  //    */\n  //   getSecretSize() {\n  //     let size = 0;\n  //     size += 1;\n  //     size += this.privateKey.length;\n  //     if (this.publicKey.length === 33)\n  //       size += 1;\n  //     size += 4;\n  //     return size;\n  //   }\n  //   /**\n  //    * Convert key to a CBitcoinSecret.\n  //    * @param {(Network|NetworkType)?} network\n  //    * @returns {Base58String}\n  //    */\n  //   toSecret(network) {\n  //     const size = this.getSecretSize();\n  //     const bw = bio.write(size);\n  //     assert(this.privateKey, 'Cannot serialize without private key.');\n  //     network = Network.get(network);\n  //     bw.writeU8(network.keyPrefix.privkey);\n  //     bw.writeBytes(this.privateKey);\n  //     if (this.publicKey.length === 33)\n  //       bw.writeU8(1);\n  //     bw.writeChecksum(hash256.digest);\n  //     return base58.encode(bw.render());\n  //   }\n  //   /**\n  //    * Inject properties from serialized CBitcoinSecret.\n  //    * @private\n  //    * @param {Base58String} secret\n  //    * @param {(Network|NetworkType)?} network\n  //    */\n\n\n  fromSecret(data, network) {\n    const br = bio.read(base58.decode(data), true);\n    const version = br.readU8();\n    Network.fromWIF(version, network);\n    const key = br.readBytes(32);\n    let compress = false;\n\n    if (br.left() > 4) {\n      assert(br.readU8() === 1, 'Bad compression flag.');\n      compress = true;\n    }\n\n    br.verifyChecksum(hash256.digest);\n    return this.fromPrivate(key, compress);\n  } //   /**\n  //    * Instantiate a keyring from a serialized CBitcoinSecret.\n  //    * @param {Base58String} secret\n  //    * @param {(Network|NetworkType)?} network\n  //    * @returns {KeyRing}\n  //    */\n  //   static fromSecret(data, network) {\n  //     return new this().fromSecret(data, network);\n  //   }\n  //   /**\n  //    * Get private key.\n  //    * @param {String?} enc - Can be `\"hex\"`, `\"base58\"`, or `null`.\n  //    * @returns {Buffer} Private key.\n  //    */\n  //   getPrivateKey(enc, network) {\n  //     if (!this.privateKey)\n  //       return null;\n  //     if (enc === 'base58')\n  //       return this.toSecret(network);\n  //     if (enc === 'hex')\n  //       return this.privateKey.toString('hex');\n  //     return this.privateKey;\n  //   }\n  //   /**\n  //    * Get public key.\n  //    * @param {String?} enc - `\"hex\"` or `null`.\n  //    * @returns {Buffer}\n  //    */\n  //   getPublicKey(enc) {\n  //     if (enc === 'base58')\n  //       return base58.encode(this.publicKey);\n  //     if (enc === 'hex')\n  //       return this.publicKey.toString('hex');\n  //     return this.publicKey;\n  //   }\n  //   /**\n  //    * Get redeem script.\n  //    * @returns {Script}\n  //    */\n  //   getScript() {\n  //     return this.script;\n  //   }\n\n  /**\n   * Get scripthash.\n   * @param {String?} enc - `\"hex\"` or `null`.\n   * @returns {Buffer}\n   */\n\n\n  getScriptHash(enc) {\n    return this.getScriptHash160(enc);\n  }\n  /**\n   * Get ripemd160 scripthash.\n   * @param {String?} enc - `\"hex\"` or `null`.\n   * @returns {Buffer}\n   */\n\n\n  getScriptHash160(enc) {\n    if (!this.script) return null;\n    if (!this._scriptHash160) this._scriptHash160 = this.script.hash160();\n    return enc === 'hex' ? this._scriptHash160.toString('hex') : this._scriptHash160;\n  } //   /**\n  //    * Get scripthash address.\n  //    * @param {String?} enc - `\"base58\"` or `null`.\n  //    * @returns {Address|AddressString}\n  //    */\n  //   getScriptAddress(enc, network) {\n  //     if (!this.script)\n  //       return null;\n  //     if (!this._scriptAddress) {\n  //       const hash = this.getScriptHash160();\n  //       const addr = Address.fromScripthash(hash);\n  //       this._scriptAddress = addr;\n  //     }\n  //     if (enc === 'base58')\n  //       return this._scriptAddress.toBase58(network);\n  //     if (enc === 'string')\n  //       return this._scriptAddress.toString(network);\n  //     return this._scriptAddress;\n  //   }\n\n  /**\n   * Get public key hash.\n   * @param {String?} enc - `\"hex\"` or `null`.\n   * @returns {Buffer}\n   */\n\n\n  getKeyHash(enc) {\n    if (!this._keyHash) this._keyHash = hash160.digest(this.publicKey);\n    return enc === 'hex' ? this._keyHash.toString('hex') : this._keyHash;\n  } //   /**\n  //    * Get pubkeyhash address.\n  //    * @param {String?} enc - `\"base58\"` or `null`.\n  //    * @returns {Address|AddressString}\n  //    */\n  //   getKeyAddress(enc, network) {\n  //     if (!this._keyAddress) {\n  //       const hash = this.getKeyHash();\n  //       const addr = Address.fromPubkeyhash(hash);\n  //       this._keyAddress = addr;\n  //     }\n  //     if (enc === 'base58')\n  //       return this._keyAddress.toBase58(network);\n  //     if (enc === 'string')\n  //       return this._keyAddress.toString(network);\n  //     return this._keyAddress;\n  //   }\n  //   /**\n  //    * Get hash.\n  //    * @param {String?} enc - `\"hex\"` or `null`.\n  //    * @returns {Buffer}\n  //    */\n  //   getHash(enc) {\n  //     if (this.script)\n  //       return this.getScriptHash(enc);\n  //     return this.getKeyHash(enc);\n  //   }\n  //   /**\n  //    * Get base58 address.\n  //    * @param {String?} enc - `\"base58\"` or `null`.\n  //    * @returns {Address|AddressString}\n  //    */\n  //   getAddress(enc, network) {\n  //     if (this.script)\n  //       return this.getScriptAddress(enc, network);\n  //     return this.getKeyAddress(enc, network);\n  //   }\n\n  /**\n   * Test an address hash against hash.\n   * @param {Buffer} hash\n   * @returns {Boolean}\n   */\n\n\n  ownHash(hash) {\n    if (!hash) return false;\n    if (hash.equals(this.getKeyHash())) return true;\n\n    if (this.script) {\n      if (hash.equals(this.getScriptHash())) return true;\n    }\n\n    return false;\n  }\n  /**\n   * Check whether transaction output belongs to this address.\n   * @param {TX|Output} tx - Transaction or Output.\n   * @param {Number?} index - Output index.\n   * @returns {Boolean}\n   */\n\n\n  ownOutput(tx, index) {\n    let output;\n\n    if (tx instanceof Output) {\n      output = tx;\n    } else {\n      output = tx.outputs[index];\n      assert(output, 'Output does not exist.');\n    }\n\n    return this.ownHash(output.getHash());\n  } //   /**\n  //    * Test a hash against script hashes to\n  //    * find the correct redeem script, if any.\n  //    * @param {Buffer} hash\n  //    * @returns {Script|null}\n  //    */\n  //   getRedeem(hash) {\n  //     if (this.script) {\n  //       if (hash.equals(this.getScriptHash160()))\n  //         return this.script;\n  //     }\n  //     return null;\n  //   }\n  //   /**\n  //    * Sign a message.\n  //    * @param {Buffer} msg\n  //    * @returns {Buffer} Signature in DER format.\n  //    */\n  //   sign(msg) {\n  //     assert(this.privateKey, 'Cannot sign without private key.');\n  //     return secp256k1.signDER(msg, this.privateKey);\n  //   }\n  //   /**\n  //    * Sign a message.\n  //    * @param {Buffer} msg\n  //    * @returns {Buffer} Signature in Schnorr format.\n  //    */\n  //   signSchnorr(msg) {\n  //     assert(this.privateKey, 'Cannot sign without private key.');\n  //     return secp256k1.schnorrSign(msg, this.privateKey);\n  //   }\n  //   /**\n  //    * Verify a message.\n  //    * @param {Buffer} msg\n  //    * @param {Buffer} sig - Signature in DER format.\n  //    * @returns {Boolean}\n  //    */\n  //   verify(msg, sig) {\n  //     return secp256k1.verifyDER(msg, sig, this.publicKey);\n  //   }\n  //   /**\n  //    * Verify a message.\n  //    * @param {Buffer} msg\n  //    * @param {Buffer} sig - Signature in Schnorr format.\n  //    * @returns {Boolean}\n  //    */\n  //   verifySchnorr(msg, sig) {\n  //     return secp256k1.schnorrVerify(msg, sig, this.publicKey);\n  //   }\n  //   /**\n  //    * Get witness program version.\n  //    * @returns {Number}\n  //    */\n  //   getVersion() {\n  //     return -1;\n  //   }\n  //   /**\n  //    * Get address type.\n  //    * @returns {ScriptType}\n  //    */\n  //   getType() {\n  //     if (this.script)\n  //       return Address.types.SCRIPTHASH;\n  //     return Address.types.PUBKEYHASH;\n  //   }\n  //   /**\n  //    * Inspect keyring.\n  //    * @returns {Object}\n  //    */\n  //   [inspectSymbol]() {\n  //     return this.toJSON();\n  //   }\n  //   /**\n  //    * Convert an KeyRing to a more json-friendly object.\n  //    * @returns {Object}\n  //    */\n  //   toJSON(network) {\n  //     return {\n  //       publicKey: this.publicKey.toString('hex'),\n  //       script: this.script ? this.script.toRaw().toString('hex') : null,\n  //       type: Address.typesByVal[this.getType()].toLowerCase(),\n  //       address: this.getAddress('string', network)\n  //     };\n  //   }\n  //   /**\n  //    * Inject properties from json object.\n  //    * @private\n  //    * @param {Object} json\n  //    */\n  //   fromJSON(json) {\n  //     assert(json);\n  //     assert(typeof json.publicKey === 'string');\n  //     assert(!json.script || typeof json.script === 'string');\n  //     this.publicKey = Buffer.from(json.publicKey, 'hex');\n  //     if (json.script)\n  //       this.script = Buffer.from(json.script, 'hex');\n  //     return this;\n  //   }\n  //   /**\n  //    * Instantiate an KeyRing from a jsonified transaction object.\n  //    * @param {Object} json - The jsonified transaction object.\n  //    * @returns {KeyRing}\n  //    */\n  //   static fromJSON(json) {\n  //     return new this().fromJSON(json);\n  //   }\n  //   /**\n  //    * Calculate serialization size.\n  //    * @returns {Number}\n  //    */\n  //   getSize() {\n  //     let size = 0;\n  //     size += 1;\n  //     if (this.privateKey) {\n  //       size += encoding.sizeVarBytes(this.privateKey);\n  //       size += 1;\n  //     } else {\n  //       size += encoding.sizeVarBytes(this.publicKey);\n  //     }\n  //     size += this.script ? this.script.getVarSize() : 1;\n  //     return size;\n  //   }\n  //   /**\n  //    * Write the keyring to a buffer writer.\n  //    * @param {BufferWriter} bw\n  //    */\n  //   toWriter(bw) {\n  //     const field = 0;\n  //     // we don't use field for now,\n  //     // we can use this for flags different\n  //     // flags in the future.\n  //     bw.writeU8(field);\n  //     if (this.privateKey) {\n  //       bw.writeVarBytes(this.privateKey);\n  //       bw.writeU8(this.publicKey.length === 33 ? 1 : 0);\n  //     } else {\n  //       bw.writeVarBytes(this.publicKey);\n  //     }\n  //     if (this.script)\n  //       bw.writeVarBytes(this.script.toRaw());\n  //     else\n  //       bw.writeVarint(0);\n  //     return bw;\n  //   }\n  //   /**\n  //    * Serialize the keyring.\n  //    * @returns {Buffer}\n  //    */\n  //   toRaw() {\n  //     const size = this.getSize();\n  //     return this.toWriter(bio.write(size)).render();\n  //   }\n  //   /**\n  //    * Inject properties from buffer reader.\n  //    * @private\n  //    * @param {BufferReader} br\n  //    */\n  //   fromReader(br) {\n  //     // we are not interested in flags.\n  //     br.readU8();\n  //     const key = br.readVarBytes();\n  //     if (key.length === 32) {\n  //       const compress = br.readU8() === 1;\n  //       this.privateKey = key;\n  //       this.publicKey = secp256k1.publicKeyCreate(key, compress);\n  //     } else {\n  //       this.publicKey = key;\n  //       assert(secp256k1.publicKeyVerify(key), 'Invalid public key.');\n  //     }\n  //     const script = br.readVarBytes();\n  //     if (script.length > 0)\n  //       this.script = Script.fromRaw(script);\n  //     return this;\n  //   }\n  //   /**\n  //    * Inject properties from serialized data.\n  //    * @private\n  //    * @param {Buffer} data\n  //    */\n  //   fromRaw(data) {\n  //     return this.fromReader(bio.read(data));\n  //   }\n  //   /**\n  //    * Instantiate a keyring from buffer reader.\n  //    * @param {BufferReader} br\n  //    * @returns {KeyRing}\n  //    */\n  //   static fromReader(br) {\n  //     return new this().fromReader(br);\n  //   }\n  //   /**\n  //    * Instantiate a keyring from serialized data.\n  //    * @param {Buffer} data\n  //    * @returns {KeyRing}\n  //    */\n  //   static fromRaw(data) {\n  //     return new this().fromRaw(data);\n  //   }\n  //   /**\n  //    * Test whether an object is a KeyRing.\n  //    * @param {Object} obj\n  //    * @returns {Boolean}\n  //    */\n  //   static isKeyRing(obj) {\n  //     return obj instanceof KeyRing;\n  //   }\n\n\n} // /*\n//  * Helpers\n//  */\n// function toKey(opt) {\n//   if (!opt)\n//     return opt;\n//   if (opt.privateKey)\n//     return opt.privateKey;\n//   if (opt.publicKey)\n//     return opt.publicKey;\n//   return opt;\n// }\n\n/*\n * Expose\n */\n\n\nmodule.exports = KeyRing;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/primitives/keyring.js"],"names":["assert","require","base58","bio","hash160","hash256","Network","Script","Address","Output","secp256k1","encoding","inspectSymbol","ZERO_KEY","Buffer","alloc","KeyRing","constructor","options","nested","publicKey","privateKey","script","_keyHash","_keyAddress","_scriptHash160","_scriptAddress","fromPrivate","key","compress","isBuffer","privateKeyVerify","publicKeyCreate","fromSecret","data","network","br","read","decode","version","readU8","fromWIF","readBytes","left","verifyChecksum","digest","getScriptHash","enc","getScriptHash160","toString","getKeyHash","ownHash","hash","equals","ownOutput","tx","index","output","outputs","getHash","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,OAAD,CAAtB;;AACA,MAAM;AAACC,EAAAA;AAAD,IAAWD,OAAO,CAAC,SAAD,CAAxB;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMI,OAAO,GAAGJ,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMK,OAAO,GAAGL,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMM,MAAM,GAAGN,OAAO,CAAC,kBAAD,CAAtB;;AACA,MAAMO,OAAO,GAAGP,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAMQ,MAAM,GAAGR,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMS,SAAS,GAAGT,OAAO,CAAC,uBAAD,CAAzB;;AACA,MAAM;AAACU,EAAAA;AAAD,IAAaR,GAAnB;;AACA,MAAM;AAACS,EAAAA;AAAD,IAAkBX,OAAO,CAAC,UAAD,CAA/B;AAEA;AACA;AACA;;;AAEA,MAAMY,QAAQ,GAAGC,MAAM,CAACC,KAAP,CAAa,EAAb,EAAiB,IAAjB,CAAjB;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,OAAN,CAAc;AACZ;AACF;AACA;AACA;AACA;AAEEC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB,SAAKC,MAAL,GAAc,KAAd;AACA,SAAKC,SAAL,GAAiBP,QAAjB;AACA,SAAKQ,UAAL,GAAkB,IAAlB;AACA,SAAKC,MAAL,GAAc,IAAd;AAEA,SAAKC,QAAL,GAAgB,IAAhB;AACA,SAAKC,WAAL,GAAmB,IAAnB;AACA,SAAKC,cAAL,GAAsB,IAAtB;AACA,SAAKC,cAAL,GAAsB,IAAtB,CATmB,CAWnB;AACA;AACD,GApBW,CAsBd;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAEEC,EAAAA,WAAW,CAACC,GAAD,EAAMC,QAAN,EAAgB;AACzB7B,IAAAA,MAAM,CAACc,MAAM,CAACgB,QAAP,CAAgBF,GAAhB,CAAD,EAAuB,+BAAvB,CAAN;AACA5B,IAAAA,MAAM,CAACU,SAAS,CAACqB,gBAAV,CAA2BH,GAA3B,CAAD,EAAkC,0BAAlC,CAAN;AAEA,SAAKP,UAAL,GAAkBO,GAAlB;AACA,SAAKR,SAAL,GAAiBV,SAAS,CAACsB,eAAV,CAA0BJ,GAA1B,EAA+BC,QAAQ,KAAK,KAA5C,CAAjB;AAEA,WAAO,IAAP;AACD,GAvFW,CAyFd;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAEEI,EAAAA,UAAU,CAACC,IAAD,EAAOC,OAAP,EAAgB;AACxB,UAAMC,EAAE,GAAG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CA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAtwBc,C,CAywBd;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;;AAEAC,MAAM,CAACC,OAAP,GAAiB7C,OAAjB","sourcesContent":["/*!\n * keyring.js - keyring object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst {base58} = require('bstring');\nconst bio = require('bufio');\nconst hash160 = require('bcrypto/lib/hash160');\nconst hash256 = require('bcrypto/lib/hash256');\nconst Network = require('../protocol/network');\nconst Script = require('../script/script');\nconst Address = require('./address');\nconst Output = require('./output');\nconst secp256k1 = require('bcrypto/lib/secp256k1');\nconst {encoding} = bio;\nconst {inspectSymbol} = require('../utils');\n\n/*\n * Constants\n */\n\nconst ZERO_KEY = Buffer.alloc(33, 0x00);\n\n/**\n * Key Ring\n * Represents a key ring which amounts to an address.\n * @alias module:primitives.KeyRing\n */\n\nclass KeyRing {\n  /**\n   * Create a key ring.\n   * @constructor\n   * @param {Object} options\n   */\n\n  constructor(options) {\n    this.nested = false;\n    this.publicKey = ZERO_KEY;\n    this.privateKey = null;\n    this.script = null;\n\n    this._keyHash = null;\n    this._keyAddress = null;\n    this._scriptHash160 = null;\n    this._scriptAddress = null;\n\n    // if (options)\n    //   this.fromOptions(options);\n  }\n\n//   /**\n//    * Inject properties from options object.\n//    * @private\n//    * @param {Object} options\n//    */\n\n//   fromOptions(options) {\n//     let key = toKey(options);\n\n//     if (Buffer.isBuffer(key))\n//       return this.fromKey(key);\n\n//     key = toKey(options.key);\n\n//     if (options.publicKey)\n//       key = toKey(options.publicKey);\n\n//     if (options.privateKey)\n//       key = toKey(options.privateKey);\n\n//     const script = options.script;\n//     const compress = options.compressed;\n\n//     if (script)\n//       return this.fromScript(key, script, compress);\n\n//     return this.fromKey(key, compress);\n//   }\n\n//   /**\n//    * Instantiate key ring from options.\n//    * @param {Object} options\n//    * @returns {KeyRing}\n//    */\n\n//   static fromOptions(options) {\n//     return new this().fromOptions(options);\n//   }\n\n//   /**\n//    * Clear cached key/script hashes.\n//    */\n\n//   refresh() {\n//     this._keyHash = null;\n//     this._keyAddress = null;\n//     this._scriptHash160 = null;\n//     this._scriptAddress = null;\n//   }\n\n//   /**\n//    * Inject data from private key.\n//    * @private\n//    * @param {Buffer} key\n//    * @param {Boolean?} compress\n//    */\n\n  fromPrivate(key, compress) {\n    assert(Buffer.isBuffer(key), 'Private key must be a buffer.');\n    assert(secp256k1.privateKeyVerify(key), 'Not a valid private key.');\n\n    this.privateKey = key;\n    this.publicKey = secp256k1.publicKeyCreate(key, compress !== false);\n\n    return this;\n  }\n\n//   /**\n//    * Instantiate keyring from a private key.\n//    * @param {Buffer} key\n//    * @param {Boolean?} compress\n//    * @returns {KeyRing}\n//    */\n\n//   static fromPrivate(key, compress) {\n//     return new this().fromPrivate(key, compress);\n//   }\n\n//   /**\n//    * Inject data from public key.\n//    * @private\n//    * @param {Buffer} key\n//    */\n\n//   fromPublic(key) {\n//     assert(Buffer.isBuffer(key), 'Public key must be a buffer.');\n//     assert(secp256k1.publicKeyVerify(key), 'Not a valid public key.');\n//     this.publicKey = key;\n//     return this;\n//   }\n\n//   /**\n//    * Generate a keyring.\n//    * @private\n//    * @param {Boolean?} compress\n//    * @returns {KeyRing}\n//    */\n\n//   generate(compress) {\n//     const key = secp256k1.privateKeyGenerate();\n//     return this.fromKey(key, compress);\n//   }\n\n//   /**\n//    * Generate a keyring.\n//    * @param {Boolean?} compress\n//    * @returns {KeyRing}\n//    */\n\n//   static generate(compress) {\n//     return new this().generate(compress);\n//   }\n\n//   /**\n//    * Instantiate keyring from a public key.\n//    * @param {Buffer} publicKey\n//    * @returns {KeyRing}\n//    */\n\n//   static fromPublic(key) {\n//     return new this().fromPublic(key);\n//   }\n\n//   /**\n//    * Inject data from public key.\n//    * @private\n//    * @param {Buffer} privateKey\n//    * @param {Boolean?} compress\n//    */\n\n//   fromKey(key, compress) {\n//     assert(Buffer.isBuffer(key), 'Key must be a buffer.');\n\n//     if (key.length === 32)\n//       return this.fromPrivate(key, compress !== false);\n\n//     return this.fromPublic(key);\n//   }\n\n//   /**\n//    * Instantiate keyring from a public key.\n//    * @param {Buffer} publicKey\n//    * @param {Boolean?} compress\n//    * @returns {KeyRing}\n//    */\n\n//   static fromKey(key, compress) {\n//     return new this().fromKey(key, compress);\n//   }\n\n//   /**\n//    * Inject data from script.\n//    * @private\n//    * @param {Buffer} key\n//    * @param {Script} script\n//    * @param {Boolean?} compress\n//    */\n\n//   fromScript(key, script, compress) {\n//     assert(script instanceof Script, 'Non-script passed into KeyRing.');\n\n//     this.fromKey(key, compress);\n//     this.script = script;\n\n//     return this;\n//   }\n\n//   /**\n//    * Instantiate keyring from script.\n//    * @param {Buffer} key\n//    * @param {Script} script\n//    * @param {Boolean?} compress\n//    * @returns {KeyRing}\n//    */\n\n//   static fromScript(key, script, compress) {\n//     return new this().fromScript(key, script, compress);\n//   }\n\n//   /**\n//    * Get ith public key from multisig script.\n//    * @private\n//    * @param {Script} script\n//    * @param {Number} i\n//    * @returns {KeyRing}\n//    */\n\n//   fromMultisigScript(script, i) {\n//     assert(script instanceof Script, 'Non-script passed.');\n//     assert(script.isMultisig(), 'Script must be multisig');\n\n//     const n = script.getSmall(-2);\n//     assert(i >= 1 && i <= n, 'Requested `i`th key, `n` available');\n\n//     this.fromKey(script.code[i].toData());\n\n//     return this;\n//   }\n\n//   /**\n//    * Instantiate keyring from ith key in multisig script.\n//    * @param {Script} script\n//    * @param {Number} i\n//    * @returns {KeyRing}\n//    */\n\n//   static fromMultisigScript(script, i) {\n//     return new this().fromMultisigScript(script, i);\n//   }\n\n//   /**\n//    * Calculate WIF serialization size.\n//    * @returns {Number}\n//    */\n\n//   getSecretSize() {\n//     let size = 0;\n\n//     size += 1;\n//     size += this.privateKey.length;\n\n//     if (this.publicKey.length === 33)\n//       size += 1;\n\n//     size += 4;\n\n//     return size;\n//   }\n\n//   /**\n//    * Convert key to a CBitcoinSecret.\n//    * @param {(Network|NetworkType)?} network\n//    * @returns {Base58String}\n//    */\n\n//   toSecret(network) {\n//     const size = this.getSecretSize();\n//     const bw = bio.write(size);\n\n//     assert(this.privateKey, 'Cannot serialize without private key.');\n\n//     network = Network.get(network);\n\n//     bw.writeU8(network.keyPrefix.privkey);\n//     bw.writeBytes(this.privateKey);\n\n//     if (this.publicKey.length === 33)\n//       bw.writeU8(1);\n\n//     bw.writeChecksum(hash256.digest);\n\n//     return base58.encode(bw.render());\n//   }\n\n//   /**\n//    * Inject properties from serialized CBitcoinSecret.\n//    * @private\n//    * @param {Base58String} secret\n//    * @param {(Network|NetworkType)?} network\n//    */\n\n  fromSecret(data, network) {\n    const br = bio.read(base58.decode(data), true);\n\n    const version = br.readU8();\n\n    Network.fromWIF(version, network);\n\n    const key = br.readBytes(32);\n\n    let compress = false;\n\n    if (br.left() > 4) {\n      assert(br.readU8() === 1, 'Bad compression flag.');\n      compress = true;\n    }\n\n    br.verifyChecksum(hash256.digest);\n\n    return this.fromPrivate(key, compress);\n  }\n\n//   /**\n//    * Instantiate a keyring from a serialized CBitcoinSecret.\n//    * @param {Base58String} secret\n//    * @param {(Network|NetworkType)?} network\n//    * @returns {KeyRing}\n//    */\n\n//   static fromSecret(data, network) {\n//     return new this().fromSecret(data, network);\n//   }\n\n//   /**\n//    * Get private key.\n//    * @param {String?} enc - Can be `\"hex\"`, `\"base58\"`, or `null`.\n//    * @returns {Buffer} Private key.\n//    */\n\n//   getPrivateKey(enc, network) {\n//     if (!this.privateKey)\n//       return null;\n\n//     if (enc === 'base58')\n//       return this.toSecret(network);\n\n//     if (enc === 'hex')\n//       return this.privateKey.toString('hex');\n\n//     return this.privateKey;\n//   }\n\n//   /**\n//    * Get public key.\n//    * @param {String?} enc - `\"hex\"` or `null`.\n//    * @returns {Buffer}\n//    */\n\n//   getPublicKey(enc) {\n//     if (enc === 'base58')\n//       return base58.encode(this.publicKey);\n\n//     if (enc === 'hex')\n//       return this.publicKey.toString('hex');\n\n//     return this.publicKey;\n//   }\n\n//   /**\n//    * Get redeem script.\n//    * @returns {Script}\n//    */\n\n//   getScript() {\n//     return this.script;\n//   }\n\n  /**\n   * Get scripthash.\n   * @param {String?} enc - `\"hex\"` or `null`.\n   * @returns {Buffer}\n   */\n\n  getScriptHash(enc) {\n    return this.getScriptHash160(enc);\n  }\n\n  /**\n   * Get ripemd160 scripthash.\n   * @param {String?} enc - `\"hex\"` or `null`.\n   * @returns {Buffer}\n   */\n\n  getScriptHash160(enc) {\n    if (!this.script)\n      return null;\n\n    if (!this._scriptHash160)\n      this._scriptHash160 = this.script.hash160();\n\n    return enc === 'hex'\n      ? this._scriptHash160.toString('hex')\n      : this._scriptHash160;\n  }\n\n//   /**\n//    * Get scripthash address.\n//    * @param {String?} enc - `\"base58\"` or `null`.\n//    * @returns {Address|AddressString}\n//    */\n\n//   getScriptAddress(enc, network) {\n//     if (!this.script)\n//       return null;\n\n//     if (!this._scriptAddress) {\n//       const hash = this.getScriptHash160();\n//       const addr = Address.fromScripthash(hash);\n\n//       this._scriptAddress = addr;\n//     }\n\n//     if (enc === 'base58')\n//       return this._scriptAddress.toBase58(network);\n\n//     if (enc === 'string')\n//       return this._scriptAddress.toString(network);\n\n//     return this._scriptAddress;\n//   }\n\n  /**\n   * Get public key hash.\n   * @param {String?} enc - `\"hex\"` or `null`.\n   * @returns {Buffer}\n   */\n\n  getKeyHash(enc) {\n    if (!this._keyHash)\n      this._keyHash = hash160.digest(this.publicKey);\n\n    return enc === 'hex'\n      ? this._keyHash.toString('hex')\n      : this._keyHash;\n  }\n\n//   /**\n//    * Get pubkeyhash address.\n//    * @param {String?} enc - `\"base58\"` or `null`.\n//    * @returns {Address|AddressString}\n//    */\n\n//   getKeyAddress(enc, network) {\n//     if (!this._keyAddress) {\n//       const hash = this.getKeyHash();\n//       const addr = Address.fromPubkeyhash(hash);\n\n//       this._keyAddress = addr;\n//     }\n\n//     if (enc === 'base58')\n//       return this._keyAddress.toBase58(network);\n\n//     if (enc === 'string')\n//       return this._keyAddress.toString(network);\n\n//     return this._keyAddress;\n//   }\n\n//   /**\n//    * Get hash.\n//    * @param {String?} enc - `\"hex\"` or `null`.\n//    * @returns {Buffer}\n//    */\n\n//   getHash(enc) {\n//     if (this.script)\n//       return this.getScriptHash(enc);\n\n//     return this.getKeyHash(enc);\n//   }\n\n//   /**\n//    * Get base58 address.\n//    * @param {String?} enc - `\"base58\"` or `null`.\n//    * @returns {Address|AddressString}\n//    */\n\n//   getAddress(enc, network) {\n//     if (this.script)\n//       return this.getScriptAddress(enc, network);\n\n//     return this.getKeyAddress(enc, network);\n//   }\n\n  /**\n   * Test an address hash against hash.\n   * @param {Buffer} hash\n   * @returns {Boolean}\n   */\n\n  ownHash(hash) {\n    if (!hash)\n      return false;\n\n    if (hash.equals(this.getKeyHash()))\n      return true;\n\n    if (this.script) {\n      if (hash.equals(this.getScriptHash()))\n        return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Check whether transaction output belongs to this address.\n   * @param {TX|Output} tx - Transaction or Output.\n   * @param {Number?} index - Output index.\n   * @returns {Boolean}\n   */\n\n  ownOutput(tx, index) {\n    let output;\n\n    if (tx instanceof Output) {\n      output = tx;\n    } else {\n      output = tx.outputs[index];\n      assert(output, 'Output does not exist.');\n    }\n\n    return this.ownHash(output.getHash());\n  }\n\n//   /**\n//    * Test a hash against script hashes to\n//    * find the correct redeem script, if any.\n//    * @param {Buffer} hash\n//    * @returns {Script|null}\n//    */\n\n//   getRedeem(hash) {\n//     if (this.script) {\n//       if (hash.equals(this.getScriptHash160()))\n//         return this.script;\n//     }\n\n//     return null;\n//   }\n\n//   /**\n//    * Sign a message.\n//    * @param {Buffer} msg\n//    * @returns {Buffer} Signature in DER format.\n//    */\n\n//   sign(msg) {\n//     assert(this.privateKey, 'Cannot sign without private key.');\n//     return secp256k1.signDER(msg, this.privateKey);\n//   }\n\n//   /**\n//    * Sign a message.\n//    * @param {Buffer} msg\n//    * @returns {Buffer} Signature in Schnorr format.\n//    */\n\n//   signSchnorr(msg) {\n//     assert(this.privateKey, 'Cannot sign without private key.');\n//     return secp256k1.schnorrSign(msg, this.privateKey);\n//   }\n\n//   /**\n//    * Verify a message.\n//    * @param {Buffer} msg\n//    * @param {Buffer} sig - Signature in DER format.\n//    * @returns {Boolean}\n//    */\n\n//   verify(msg, sig) {\n//     return secp256k1.verifyDER(msg, sig, this.publicKey);\n//   }\n\n//   /**\n//    * Verify a message.\n//    * @param {Buffer} msg\n//    * @param {Buffer} sig - Signature in Schnorr format.\n//    * @returns {Boolean}\n//    */\n\n//   verifySchnorr(msg, sig) {\n//     return secp256k1.schnorrVerify(msg, sig, this.publicKey);\n//   }\n\n//   /**\n//    * Get witness program version.\n//    * @returns {Number}\n//    */\n\n//   getVersion() {\n//     return -1;\n//   }\n\n//   /**\n//    * Get address type.\n//    * @returns {ScriptType}\n//    */\n\n//   getType() {\n//     if (this.script)\n//       return Address.types.SCRIPTHASH;\n\n//     return Address.types.PUBKEYHASH;\n//   }\n\n//   /**\n//    * Inspect keyring.\n//    * @returns {Object}\n//    */\n\n//   [inspectSymbol]() {\n//     return this.toJSON();\n//   }\n\n//   /**\n//    * Convert an KeyRing to a more json-friendly object.\n//    * @returns {Object}\n//    */\n\n//   toJSON(network) {\n//     return {\n//       publicKey: this.publicKey.toString('hex'),\n//       script: this.script ? this.script.toRaw().toString('hex') : null,\n//       type: Address.typesByVal[this.getType()].toLowerCase(),\n//       address: this.getAddress('string', network)\n//     };\n//   }\n\n//   /**\n//    * Inject properties from json object.\n//    * @private\n//    * @param {Object} json\n//    */\n\n//   fromJSON(json) {\n//     assert(json);\n//     assert(typeof json.publicKey === 'string');\n//     assert(!json.script || typeof json.script === 'string');\n\n//     this.publicKey = Buffer.from(json.publicKey, 'hex');\n\n//     if (json.script)\n//       this.script = Buffer.from(json.script, 'hex');\n\n//     return this;\n//   }\n\n//   /**\n//    * Instantiate an KeyRing from a jsonified transaction object.\n//    * @param {Object} json - The jsonified transaction object.\n//    * @returns {KeyRing}\n//    */\n\n//   static fromJSON(json) {\n//     return new this().fromJSON(json);\n//   }\n\n//   /**\n//    * Calculate serialization size.\n//    * @returns {Number}\n//    */\n\n//   getSize() {\n//     let size = 0;\n//     size += 1;\n//     if (this.privateKey) {\n//       size += encoding.sizeVarBytes(this.privateKey);\n//       size += 1;\n//     } else {\n//       size += encoding.sizeVarBytes(this.publicKey);\n//     }\n//     size += this.script ? this.script.getVarSize() : 1;\n//     return size;\n//   }\n\n//   /**\n//    * Write the keyring to a buffer writer.\n//    * @param {BufferWriter} bw\n//    */\n\n//   toWriter(bw) {\n//     const field = 0;\n\n//     // we don't use field for now,\n//     // we can use this for flags different\n//     // flags in the future.\n//     bw.writeU8(field);\n\n//     if (this.privateKey) {\n//       bw.writeVarBytes(this.privateKey);\n//       bw.writeU8(this.publicKey.length === 33 ? 1 : 0);\n//     } else {\n//       bw.writeVarBytes(this.publicKey);\n//     }\n\n//     if (this.script)\n//       bw.writeVarBytes(this.script.toRaw());\n//     else\n//       bw.writeVarint(0);\n\n//     return bw;\n//   }\n\n//   /**\n//    * Serialize the keyring.\n//    * @returns {Buffer}\n//    */\n\n//   toRaw() {\n//     const size = this.getSize();\n//     return this.toWriter(bio.write(size)).render();\n//   }\n\n//   /**\n//    * Inject properties from buffer reader.\n//    * @private\n//    * @param {BufferReader} br\n//    */\n\n//   fromReader(br) {\n//     // we are not interested in flags.\n//     br.readU8();\n\n//     const key = br.readVarBytes();\n\n//     if (key.length === 32) {\n//       const compress = br.readU8() === 1;\n//       this.privateKey = key;\n//       this.publicKey = secp256k1.publicKeyCreate(key, compress);\n//     } else {\n//       this.publicKey = key;\n//       assert(secp256k1.publicKeyVerify(key), 'Invalid public key.');\n//     }\n\n//     const script = br.readVarBytes();\n\n//     if (script.length > 0)\n//       this.script = Script.fromRaw(script);\n\n//     return this;\n//   }\n\n//   /**\n//    * Inject properties from serialized data.\n//    * @private\n//    * @param {Buffer} data\n//    */\n\n//   fromRaw(data) {\n//     return this.fromReader(bio.read(data));\n//   }\n\n//   /**\n//    * Instantiate a keyring from buffer reader.\n//    * @param {BufferReader} br\n//    * @returns {KeyRing}\n//    */\n\n//   static fromReader(br) {\n//     return new this().fromReader(br);\n//   }\n\n//   /**\n//    * Instantiate a keyring from serialized data.\n//    * @param {Buffer} data\n//    * @returns {KeyRing}\n//    */\n\n//   static fromRaw(data) {\n//     return new this().fromRaw(data);\n//   }\n\n//   /**\n//    * Test whether an object is a KeyRing.\n//    * @param {Object} obj\n//    * @returns {Boolean}\n//    */\n\n//   static isKeyRing(obj) {\n//     return obj instanceof KeyRing;\n//   }\n}\n\n// /*\n//  * Helpers\n//  */\n\n// function toKey(opt) {\n//   if (!opt)\n//     return opt;\n\n//   if (opt.privateKey)\n//     return opt.privateKey;\n\n//   if (opt.publicKey)\n//     return opt.publicKey;\n\n//   return opt;\n// }\n\n/*\n * Expose\n */\n\nmodule.exports = KeyRing;\n"]},"metadata":{},"sourceType":"module"}