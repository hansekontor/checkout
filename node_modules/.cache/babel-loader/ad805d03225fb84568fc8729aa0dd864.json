{"ast":null,"code":"/*!\n * sha1.js - SHA1 implementation for bcrypto\n * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on indutny/hash.js:\n *   Copyright (c) 2014, Fedor Indutny (MIT License).\n *   https://github.com/indutny/hash.js\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/SHA-1\n *   https://tools.ietf.org/html/rfc3174\n *   http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/1.js\n */\n\n/* eslint camelcase: \"off\" */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst HMAC = require('../internal/hmac');\n/*\n * Constants\n */\n\n\nconst FINALIZED = -1;\nconst DESC = Buffer.alloc(8, 0x00);\nconst PADDING = Buffer.alloc(64, 0x00);\nPADDING[0] = 0x80;\nconst K = new Uint32Array([0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6]);\n/**\n * SHA1\n */\n\nclass SHA1 {\n  constructor() {\n    this.state = new Uint32Array(5);\n    this.msg = new Uint32Array(80);\n    this.block = Buffer.allocUnsafe(64);\n    this.size = FINALIZED;\n  }\n\n  init() {\n    this.state[0] = 0x67452301;\n    this.state[1] = 0xefcdab89;\n    this.state[2] = 0x98badcfe;\n    this.state[3] = 0x10325476;\n    this.state[4] = 0xc3d2e1f0;\n    this.size = 0;\n    return this;\n  }\n\n  update(data) {\n    assert(Buffer.isBuffer(data));\n\n    this._update(data, data.length);\n\n    return this;\n  }\n\n  final() {\n    return this._final(Buffer.allocUnsafe(20));\n  }\n\n  _update(data, len) {\n    assert(this.size !== FINALIZED, 'Context is not initialized.');\n    let pos = this.size & 63;\n    let off = 0;\n    this.size += len;\n\n    if (pos > 0) {\n      let want = 64 - pos;\n      if (want > len) want = len;\n      data.copy(this.block, pos, off, off + want);\n      pos += want;\n      len -= want;\n      off += want;\n      if (pos < 64) return;\n\n      this._transform(this.block, 0);\n    }\n\n    while (len >= 64) {\n      this._transform(data, off);\n\n      off += 64;\n      len -= 64;\n    }\n\n    if (len > 0) data.copy(this.block, 0, off, off + len);\n  }\n\n  _final(out) {\n    assert(this.size !== FINALIZED, 'Context is not initialized.');\n    const pos = this.size & 63;\n    const len = this.size * 8;\n    writeU32(DESC, len * (1 / 0x100000000) >>> 0, 0);\n    writeU32(DESC, len >>> 0, 4);\n\n    this._update(PADDING, 1 + (119 - pos & 63));\n\n    this._update(DESC, 8);\n\n    for (let i = 0; i < 5; i++) {\n      writeU32(out, this.state[i], i * 4);\n      this.state[i] = 0;\n    }\n\n    for (let i = 0; i < 80; i++) this.msg[i] = 0;\n\n    for (let i = 0; i < 64; i++) this.block[i] = 0;\n\n    this.size = FINALIZED;\n    return out;\n  }\n\n  _transform(chunk, pos) {\n    const W = this.msg;\n    let a = this.state[0];\n    let b = this.state[1];\n    let c = this.state[2];\n    let d = this.state[3];\n    let e = this.state[4];\n    let i = 0;\n\n    for (; i < 16; i++) W[i] = readU32(chunk, pos + i * 4);\n\n    for (; i < 80; i++) W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);\n\n    for (i = 0; i < 80; i++) {\n      const s = i / 20 | 0;\n      const t = rotl32(a, 5) + ft_1(s, b, c, d) + e + W[i] + K[s];\n      e = d;\n      d = c;\n      c = rotl32(b, 30);\n      b = a;\n      a = t >>> 0;\n    }\n\n    this.state[0] += a;\n    this.state[1] += b;\n    this.state[2] += c;\n    this.state[3] += d;\n    this.state[4] += e;\n  }\n\n  static hash() {\n    return new SHA1();\n  }\n\n  static hmac() {\n    return new HMAC(SHA1, 64);\n  }\n\n  static digest(data) {\n    return SHA1.ctx.init().update(data).final();\n  }\n\n  static root(left, right) {\n    assert(Buffer.isBuffer(left) && left.length === 20);\n    assert(Buffer.isBuffer(right) && right.length === 20);\n    return SHA1.ctx.init().update(left).update(right).final();\n  }\n\n  static multi(x, y, z) {\n    const {\n      ctx\n    } = SHA1;\n    ctx.init();\n    ctx.update(x);\n    ctx.update(y);\n    if (z) ctx.update(z);\n    return ctx.final();\n  }\n\n  static mac(data, key) {\n    return SHA1.hmac().init(key).update(data).final();\n  }\n\n}\n/*\n * Static\n */\n\n\nSHA1.native = 0;\nSHA1.id = 'SHA1';\nSHA1.size = 20;\nSHA1.bits = 160;\nSHA1.blockSize = 64;\nSHA1.zero = Buffer.alloc(20, 0x00);\nSHA1.ctx = new SHA1();\n/*\n * Helpers\n */\n\nfunction rotl32(w, b) {\n  return w << b | w >>> 32 - b;\n}\n\nfunction ft_1(s, x, y, z) {\n  if (s === 0) return ch32(x, y, z);\n  if (s === 1 || s === 3) return p32(x, y, z);\n  if (s === 2) return maj32(x, y, z);\n  return 0;\n}\n\nfunction ch32(x, y, z) {\n  return x & y ^ ~x & z;\n}\n\nfunction maj32(x, y, z) {\n  return x & y ^ x & z ^ y & z;\n}\n\nfunction p32(x, y, z) {\n  return x ^ y ^ z;\n}\n\nfunction readU32(data, off) {\n  return data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];\n}\n\nfunction writeU32(data, num, off) {\n  data[off++] = num >>> 24;\n  data[off++] = num >>> 16;\n  data[off++] = num >>> 8;\n  data[off++] = num;\n  return off;\n}\n/*\n * Expose\n */\n\n\nmodule.exports = SHA1;","map":null,"metadata":{},"sourceType":"script"}