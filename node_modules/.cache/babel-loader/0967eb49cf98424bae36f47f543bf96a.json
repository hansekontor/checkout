{"ast":null,"code":"/*!\n * scriptnum.js - script number object for bcoin.\n * Copyright (c) 2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst {\n  I64\n} = require('n64');\n\nconst ScriptError = require('./scripterror');\n/*\n * Constants\n */\n\n\nconst EMPTY_ARRAY = Buffer.alloc(0);\n/**\n * Script Number\n * @see https://github.com/chjj/n64\n * @alias module:script.ScriptNum\n * @property {Number} hi\n * @property {Number} lo\n * @property {Number} sign\n */\n\nclass ScriptNum extends I64 {\n  /**\n   * Create a script number.\n   * @constructor\n   * @param {(Number|String|Buffer|Object)?} num\n   * @param {(String|Number)?} base\n   */\n  constructor(num, base) {\n    super(num, base);\n  }\n  /**\n   * Cast to int32.\n   * @returns {Number}\n   */\n\n\n  getInt() {\n    if (this.lt(I64.INT32_MIN)) return I64.LONG_MIN;\n    if (this.gt(I64.INT32_MAX)) return I64.LONG_MAX;\n    return this.toInt();\n  }\n  /**\n   * Serialize script number.\n   * @returns {Buffer}\n   */\n\n\n  toRaw() {\n    let num = this; // Zeroes are always empty arrays.\n\n    if (num.isZero()) return EMPTY_ARRAY; // Need to append sign bit.\n\n    let neg = false;\n\n    if (num.isNeg()) {\n      num = num.neg();\n      neg = true;\n    } // Calculate size.\n\n\n    const size = num.byteLength();\n    let offset = 0;\n    if (num.testn(size * 8 - 1)) offset = 1; // Write number.\n\n    const data = Buffer.allocUnsafe(size + offset);\n\n    switch (size) {\n      case 8:\n        data[7] = num.hi >>> 24 & 0xff;\n\n      case 7:\n        data[6] = num.hi >> 16 & 0xff;\n\n      case 6:\n        data[5] = num.hi >> 8 & 0xff;\n\n      case 5:\n        data[4] = num.hi & 0xff;\n\n      case 4:\n        data[3] = num.lo >>> 24 & 0xff;\n\n      case 3:\n        data[2] = num.lo >> 16 & 0xff;\n\n      case 2:\n        data[1] = num.lo >> 8 & 0xff;\n\n      case 1:\n        data[0] = num.lo & 0xff;\n    } // Append sign bit.\n\n\n    if (data[size - 1] & 0x80) {\n      assert(offset === 1);\n      assert(data.length === size + offset);\n      data[size] = neg ? 0x80 : 0;\n    } else if (neg) {\n      assert(offset === 0);\n      assert(data.length === size);\n      data[size - 1] |= 0x80;\n    } else {\n      assert(offset === 0);\n      assert(data.length === size);\n    }\n\n    return data;\n  }\n  /**\n   * Instantiate script number from serialized data.\n   * @private\n   * @param {Buffer} data\n   * @returns {ScriptNum}\n   */\n\n\n  fromRaw(data) {\n    assert(Buffer.isBuffer(data)); // Empty arrays are always zero.\n\n    if (data.length === 0) return this; // Read number (9 bytes max).\n\n    switch (data.length) {\n      case 8:\n        this.hi |= data[7] << 24;\n\n      case 7:\n        this.hi |= data[6] << 16;\n\n      case 6:\n        this.hi |= data[5] << 8;\n\n      case 5:\n        this.hi |= data[4];\n\n      case 4:\n        this.lo |= data[3] << 24;\n\n      case 3:\n        this.lo |= data[2] << 16;\n\n      case 2:\n        this.lo |= data[1] << 8;\n\n      case 1:\n        this.lo |= data[0];\n        break;\n\n      default:\n        for (let i = 0; i < data.length; i++) this.orb(i, data[i]);\n\n        break;\n    } // Remove high bit and flip sign.\n\n\n    if (data[data.length - 1] & 0x80) {\n      this.setn(data.length * 8 - 1, 0);\n      this.ineg();\n    }\n\n    return this;\n  }\n  /**\n   * Serialize script number.\n   * @returns {Buffer}\n   */\n\n\n  encode() {\n    return this.toRaw();\n  }\n  /**\n   * Decode and verify script number.\n   * @private\n   * @param {Buffer} data\n   * @param {Boolean?} minimal - Require minimal encoding.\n   * @param {Number?} limit - Size limit.\n   * @returns {ScriptNum}\n   */\n\n\n  decode(data, minimal, limit) {\n    assert(Buffer.isBuffer(data));\n    if (limit != null && data.length > limit) throw new ScriptError('UNKNOWN_ERROR', 'Script number overflow.');\n    if (minimal && !ScriptNum.isMinimal(data)) throw new ScriptError('UNKNOWN_ERROR', 'Non-minimal script number.');\n    return this.fromRaw(data);\n  }\n  /**\n   * Inspect script number.\n   * @returns {String}\n   */\n\n\n  inspect() {\n    return `<ScriptNum: ${this.toString(10)}>`;\n  }\n  /**\n   * Test wether a serialized script\n   * number is in its most minimal form.\n   * @param {Buffer} data\n   * @returns {Boolean}\n   */\n\n\n  static isMinimal(data) {\n    assert(Buffer.isBuffer(data));\n    if (data.length === 0) return true;\n\n    if ((data[data.length - 1] & 0x7f) === 0) {\n      if (data.length === 1) return false;\n      if ((data[data.length - 2] & 0x80) === 0) return false;\n    }\n\n    return true;\n  }\n  /**\n   * Encode serialized script number in its most minimal form.\n   * @param {Buffer} data\n   * @returns {Buffer} minimal encoded data\n   */\n\n\n  static toMinimal(data) {\n    assert(Buffer.isBuffer(data));\n    if (this.isMinimal(data)) return data;\n    const last = data[data.length - 1]; // We are not minimally encoded, we need to figure out how much to trim.\n\n    for (let i = data.length - 1; i > 0; i--) {\n      // We found a non zero byte, time to encode.\n      if (data[i - 1] !== 0) {\n        if (data[i - 1] & 0x80) {\n          // We found a byte with it sign bit set so we need one more\n          // byte.\n          data[i++] = last;\n        } else {\n          // the sign bit is clear, we can use it.\n          data[i - 1] |= last;\n        }\n\n        data = data.slice(0, i);\n        return data;\n      }\n    } // If we the whole thing is zeros, then we have a zero.\n\n\n    data = Buffer.alloc(0);\n    return data;\n  }\n  /**\n   * Decode and verify script number.\n   * @param {Buffer} data\n   * @param {Boolean?} minimal - Require minimal encoding.\n   * @param {Number?} limit - Size limit.\n   * @returns {ScriptNum}\n   */\n\n\n  static decode(data, minimal, limit) {\n    return new this().decode(data, minimal, limit);\n  }\n  /**\n   * Test whether object is a script number.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n\n  static isScriptNum(obj) {\n    return obj instanceof ScriptNum;\n  }\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = ScriptNum;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/script/scriptnum.js"],"names":["assert","require","I64","ScriptError","EMPTY_ARRAY","Buffer","alloc","ScriptNum","constructor","num","base","getInt","lt","INT32_MIN","LONG_MIN","gt","INT32_MAX","LONG_MAX","toInt","toRaw","isZero","neg","isNeg","size","byteLength","offset","testn","data","allocUnsafe","hi","lo","length","fromRaw","isBuffer","i","orb","setn","ineg","encode","decode","minimal","limit","isMinimal","inspect","toString","toMinimal","last","slice","isScriptNum","obj","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,OAAD,CAAtB;;AACA,MAAM;AAACC,EAAAA;AAAD,IAAQD,OAAO,CAAC,KAAD,CAArB;;AACA,MAAME,WAAW,GAAGF,OAAO,CAAC,eAAD,CAA3B;AAEA;AACA;AACA;;;AAEA,MAAMG,WAAW,GAAGC,MAAM,CAACC,KAAP,CAAa,CAAb,CAApB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,SAAN,SAAwBL,GAAxB,CAA4B;AAC1B;AACF;AACA;AACA;AACA;AACA;AAEEM,EAAAA,WAAW,CAACC,GAAD,EAAMC,IAAN,EAAY;AACrB,UAAMD,GAAN,EAAWC,IAAX;AACD;AAED;AACF;AACA;AACA;;;AAEEC,EAAAA,MAAM,GAAG;AACP,QAAI,KAAKC,EAAL,CAAQV,GAAG,CAACW,SAAZ,CAAJ,EACE,OAAOX,GAAG,CAACY,QAAX;AAEF,QAAI,KAAKC,EAAL,CAAQb,GAAG,CAACc,SAAZ,CAAJ,EACE,OAAOd,GAAG,CAACe,QAAX;AAEF,WAAO,KAAKC,KAAL,EAAP;AACD;AAED;AACF;AACA;AACA;;;AAEEC,EAAAA,KAAK,GAAG;AACN,QAAIV,GAAG,GAAG,IAAV,CADM,CAGN;;AACA,QAAIA,GAAG,CAACW,MAAJ,EAAJ,EACE,OAAOhB,WAAP,CALI,CAON;;AACA,QAAIiB,GAAG,GAAG,KAAV;;AACA,QAAIZ,GAAG,CAACa,KAAJ,EAAJ,EAAiB;AACfb,MAAAA,GAAG,GAAGA,GAAG,CAACY,GAAJ,EAAN;AACAA,MAAAA,GAAG,GAAG,IAAN;AACD,KAZK,CAcN;;;AACA,UAAME,IAAI,GAAGd,GAAG,CAACe,UAAJ,EAAb;AAEA,QAAIC,MAAM,GAAG,CAAb;AAEA,QAAIhB,GAAG,CAACiB,KAAJ,CAAWH,IAAI,GAAG,CAAR,GAAa,CAAvB,CAAJ,EACEE,MAAM,GAAG,CAAT,CApBI,CAsBN;;AACA,UAAME,IAAI,GAAGtB,MAAM,CAACuB,WAAP,CAAmBL,IAAI,GAAGE,MAA1B,CAAb;;AAEA,YAAQF,IAAR;AACE,WAAK,CAAL;AACEI,QAAAA,IAAI,CAAC,CAAD,CAAJ,GAAWlB,GAAG,CAACoB,EAAJ,KAAW,EAAZ,GAAkB,IAA5B;;AACF,WAAK,CAAL;AACEF,QAAAA,IAAI,CAAC,CAAD,CAAJ,GAAWlB,GAAG,CAACoB,EAAJ,IAAU,EAAX,GAAiB,IAA3B;;AACF,WAAK,CAAL;AACEF,QAAAA,IAAI,CAAC,CAAD,CAAJ,GAAWlB,GAAG,CAACoB,EAAJ,IAAU,CAAX,GAAgB,IAA1B;;AACF,WAAK,CAAL;AACEF,QAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUlB,GAAG,CAACoB,EAAJ,GAAS,IAAnB;;AACF,WAAK,CAAL;AACEF,QAAAA,IAAI,CAAC,CAAD,CAAJ,GAAWlB,GAAG,CAACqB,EAAJ,KAAW,EAAZ,GAAkB,IAA5B;;AACF,WAAK,CAAL;AACEH,QAAAA,IAAI,CAAC,CAAD,CAAJ,GAAWlB,GAAG,CAACqB,EAAJ,IAAU,EAAX,GAAiB,IAA3B;;AACF,WAAK,CAAL;AACEH,QAAAA,IAAI,CAAC,CAAD,CAAJ,GAAWlB,GAAG,CAACqB,EAAJ,IAAU,CAAX,GAAgB,IAA1B;;AACF,WAAK,CAAL;AACEH,QAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUlB,GAAG,CAACqB,EAAJ,GAAS,IAAnB;AAhBJ,KAzBM,CA4CN;;;AACA,QAAIH,IAAI,CAACJ,IAAI,GAAG,CAAR,CAAJ,GAAiB,IAArB,EAA2B;AACzBvB,MAAAA,MAAM,CAACyB,MAAM,KAAK,CAAZ,CAAN;AACAzB,MAAAA,MAAM,CAAC2B,IAAI,CAACI,MAAL,KAAgBR,IAAI,GAAGE,MAAxB,CAAN;AACAE,MAAAA,IAAI,CAACJ,IAAD,CAAJ,GAAaF,GAAG,GAAG,IAAH,GAAU,CAA1B;AACD,KAJD,MAIO,IAAIA,GAAJ,EAAS;AACdrB,MAAAA,MAAM,CAACyB,MAAM,KAAK,CAAZ,CAAN;AACAzB,MAAAA,MAAM,CAAC2B,IAAI,CAACI,MAAL,KAAgBR,IAAjB,CAAN;AACAI,MAAAA,IAAI,CAACJ,IAAI,GAAG,CAAR,CAAJ,IAAkB,IAAlB;AACD,KAJM,MAIA;AACLvB,MAAAA,MAAM,CAACyB,MAAM,KAAK,CAAZ,CAAN;AACAzB,MAAAA,MAAM,CAAC2B,IAAI,CAACI,MAAL,KAAgBR,IAAjB,CAAN;AACD;;AAED,WAAOI,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AAEEK,EAAAA,OAAO,CAACL,IAAD,EAAO;AACZ3B,IAAAA,MAAM,CAACK,MAAM,CAAC4B,QAAP,CAAgBN,IAAhB,CAAD,CAAN,CADY,CAGZ;;AACA,QAAIA,IAAI,CAACI,MAAL,KAAgB,CAApB,EACE,OAAO,IAAP,CALU,CAOZ;;AACA,YAAQJ,IAAI,CAACI,MAAb;AACE,WAAK,CAAL;AACE,aAAKF,EAAL,IAAWF,IAAI,CAAC,CAAD,CAAJ,IAAW,EAAtB;;AACF,WAAK,CAAL;AACE,aAAKE,EAAL,IAAWF,IAAI,CAAC,CAAD,CAAJ,IAAW,EAAtB;;AACF,WAAK,CAAL;AACE,aAAKE,EAAL,IAAWF,IAAI,CAAC,CAAD,CAAJ,IAAW,CAAtB;;AACF,WAAK,CAAL;AACE,aAAKE,EAAL,IAAWF,IAAI,CAAC,CAAD,CAAf;;AACF,WAAK,CAAL;AACE,aAAKG,EAAL,IAAWH,IAAI,CAAC,CAAD,CAAJ,IAAW,EAAtB;;AACF,WAAK,CAAL;AACE,aAAKG,EAAL,IAAWH,IAAI,CAAC,CAAD,CAAJ,IAAW,EAAtB;;AACF,WAAK,CAAL;AACE,aAAKG,EAAL,IAAWH,IAAI,CAAC,CAAD,CAAJ,IAAW,CAAtB;;AACF,WAAK,CAAL;AACE,aAAKG,EAAL,IAAWH,IAAI,CAAC,CAAD,CAAf;AACA;;AACF;AACE,aAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,IAAI,CAACI,MAAzB,EAAiCG,CAAC,EAAlC,EACE,KAAKC,GAAL,CAASD,CAAT,EAAYP,IAAI,CAACO,CAAD,CAAhB;;AACF;AArBJ,KARY,CAgCZ;;;AACA,QAAIP,IAAI,CAACA,IAAI,CAACI,MAAL,GAAc,CAAf,CAAJ,GAAwB,IAA5B,EAAkC;AAChC,WAAKK,IAAL,CAAWT,IAAI,CAACI,MAAL,GAAc,CAAf,GAAoB,CAA9B,EAAiC,CAAjC;AACA,WAAKM,IAAL;AACD;;AAED,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;;;AAEEC,EAAAA,MAAM,GAAG;AACP,WAAO,KAAKnB,KAAL,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEEoB,EAAAA,MAAM,CAACZ,IAAD,EAAOa,OAAP,EAAgBC,KAAhB,EAAuB;AAC3BzC,IAAAA,MAAM,CAACK,MAAM,CAAC4B,QAAP,CAAgBN,IAAhB,CAAD,CAAN;AAEA,QAAIc,KAAK,IAAI,IAAT,IAAiBd,IAAI,CAACI,MAAL,GAAcU,KAAnC,EACE,MAAM,IAAItC,WAAJ,CAAgB,eAAhB,EAAiC,yBAAjC,CAAN;AAEF,QAAIqC,OAAO,IAAI,CAACjC,SAAS,CAACmC,SAAV,CAAoBf,IAApB,CAAhB,EACE,MAAM,IAAIxB,WAAJ,CAAgB,eAAhB,EAAiC,4BAAjC,CAAN;AAEF,WAAO,KAAK6B,OAAL,CAAaL,IAAb,CAAP;AACD;AAED;AACF;AACA;AACA;;;AAEEgB,EAAAA,OAAO,GAAG;AACR,WAAQ,eAAc,KAAKC,QAAL,CAAc,EAAd,CAAkB,GAAxC;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AAEkB,SAATF,SAAS,CAACf,IAAD,EAAO;AACrB3B,IAAAA,MAAM,CAACK,MAAM,CAAC4B,QAAP,CAAgBN,IAAhB,CAAD,CAAN;AAEA,QAAIA,IAAI,CAACI,MAAL,KAAgB,CAApB,EACE,OAAO,IAAP;;AAEF,QAAI,CAACJ,IAAI,CAACA,IAAI,CAACI,MAAL,GAAc,CAAf,CAAJ,GAAwB,IAAzB,MAAmC,CAAvC,EAA0C;AACxC,UAAIJ,IAAI,CAACI,MAAL,KAAgB,CAApB,EACE,OAAO,KAAP;AAEF,UAAI,CAACJ,IAAI,CAACA,IAAI,CAACI,MAAL,GAAc,CAAf,CAAJ,GAAwB,IAAzB,MAAmC,CAAvC,EACE,OAAO,KAAP;AACH;;AAED,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEkB,SAATc,SAAS,CAAClB,IAAD,EAAO;AACrB3B,IAAAA,MAAM,CAACK,MAAM,CAAC4B,QAAP,CAAgBN,IAAhB,CAAD,CAAN;AAEA,QAAI,KAAKe,SAAL,CAAef,IAAf,CAAJ,EACE,OAAOA,IAAP;AAEF,UAAMmB,IAAI,GAAGnB,IAAI,CAACA,IAAI,CAACI,MAAL,GAAc,CAAf,CAAjB,CANqB,CAQrB;;AACA,SAAK,IAAIG,CAAC,GAAGP,IAAI,CAACI,MAAL,GAAc,CAA3B,EAA8BG,CAAC,GAAG,CAAlC,EAAqCA,CAAC,EAAtC,EAA0C;AACxC;AACA,UAAIP,IAAI,CAACO,CAAC,GAAG,CAAL,CAAJ,KAAgB,CAApB,EAAuB;AACrB,YAAIP,IAAI,CAACO,CAAC,GAAG,CAAL,CAAJ,GAAc,IAAlB,EAAwB;AACtB;AACA;AACAP,UAAAA,IAAI,CAACO,CAAC,EAAF,CAAJ,GAAYY,IAAZ;AACD,SAJD,MAIO;AACL;AACAnB,UAAAA,IAAI,CAACO,CAAC,GAAG,CAAL,CAAJ,IAAeY,IAAf;AACD;;AAEDnB,QAAAA,IAAI,GAAGA,IAAI,CAACoB,KAAL,CAAW,CAAX,EAAcb,CAAd,CAAP;AACA,eAAOP,IAAP;AACD;AACF,KAxBoB,CA0BrB;;;AACAA,IAAAA,IAAI,GAAGtB,MAAM,CAACC,KAAP,CAAa,CAAb,CAAP;AACA,WAAOqB,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AAEe,SAANY,MAAM,CAACZ,IAAD,EAAOa,OAAP,EAAgBC,KAAhB,EAAuB;AAClC,WAAO,IAAI,IAAJ,GAAWF,MAAX,CAAkBZ,IAAlB,EAAwBa,OAAxB,EAAiCC,KAAjC,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEoB,SAAXO,WAAW,CAACC,GAAD,EAAM;AACtB,WAAOA,GAAG,YAAY1C,SAAtB;AACD;;AArQyB;AAwQ5B;AACA;AACA;;;AAEA2C,MAAM,CAACC,OAAP,GAAiB5C,SAAjB","sourcesContent":["/*!\n * scriptnum.js - script number object for bcoin.\n * Copyright (c) 2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst {I64} = require('n64');\nconst ScriptError = require('./scripterror');\n\n/*\n * Constants\n */\n\nconst EMPTY_ARRAY = Buffer.alloc(0);\n\n/**\n * Script Number\n * @see https://github.com/chjj/n64\n * @alias module:script.ScriptNum\n * @property {Number} hi\n * @property {Number} lo\n * @property {Number} sign\n */\n\nclass ScriptNum extends I64 {\n  /**\n   * Create a script number.\n   * @constructor\n   * @param {(Number|String|Buffer|Object)?} num\n   * @param {(String|Number)?} base\n   */\n\n  constructor(num, base) {\n    super(num, base);\n  }\n\n  /**\n   * Cast to int32.\n   * @returns {Number}\n   */\n\n  getInt() {\n    if (this.lt(I64.INT32_MIN))\n      return I64.LONG_MIN;\n\n    if (this.gt(I64.INT32_MAX))\n      return I64.LONG_MAX;\n\n    return this.toInt();\n  }\n\n  /**\n   * Serialize script number.\n   * @returns {Buffer}\n   */\n\n  toRaw() {\n    let num = this;\n\n    // Zeroes are always empty arrays.\n    if (num.isZero())\n      return EMPTY_ARRAY;\n\n    // Need to append sign bit.\n    let neg = false;\n    if (num.isNeg()) {\n      num = num.neg();\n      neg = true;\n    }\n\n    // Calculate size.\n    const size = num.byteLength();\n\n    let offset = 0;\n\n    if (num.testn((size * 8) - 1))\n      offset = 1;\n\n    // Write number.\n    const data = Buffer.allocUnsafe(size + offset);\n\n    switch (size) {\n      case 8:\n        data[7] = (num.hi >>> 24) & 0xff;\n      case 7:\n        data[6] = (num.hi >> 16) & 0xff;\n      case 6:\n        data[5] = (num.hi >> 8) & 0xff;\n      case 5:\n        data[4] = num.hi & 0xff;\n      case 4:\n        data[3] = (num.lo >>> 24) & 0xff;\n      case 3:\n        data[2] = (num.lo >> 16) & 0xff;\n      case 2:\n        data[1] = (num.lo >> 8) & 0xff;\n      case 1:\n        data[0] = num.lo & 0xff;\n    }\n\n    // Append sign bit.\n    if (data[size - 1] & 0x80) {\n      assert(offset === 1);\n      assert(data.length === size + offset);\n      data[size] = neg ? 0x80 : 0;\n    } else if (neg) {\n      assert(offset === 0);\n      assert(data.length === size);\n      data[size - 1] |= 0x80;\n    } else {\n      assert(offset === 0);\n      assert(data.length === size);\n    }\n\n    return data;\n  }\n\n  /**\n   * Instantiate script number from serialized data.\n   * @private\n   * @param {Buffer} data\n   * @returns {ScriptNum}\n   */\n\n  fromRaw(data) {\n    assert(Buffer.isBuffer(data));\n\n    // Empty arrays are always zero.\n    if (data.length === 0)\n      return this;\n\n    // Read number (9 bytes max).\n    switch (data.length) {\n      case 8:\n        this.hi |= data[7] << 24;\n      case 7:\n        this.hi |= data[6] << 16;\n      case 6:\n        this.hi |= data[5] << 8;\n      case 5:\n        this.hi |= data[4];\n      case 4:\n        this.lo |= data[3] << 24;\n      case 3:\n        this.lo |= data[2] << 16;\n      case 2:\n        this.lo |= data[1] << 8;\n      case 1:\n        this.lo |= data[0];\n        break;\n      default:\n        for (let i = 0; i < data.length; i++)\n          this.orb(i, data[i]);\n        break;\n    }\n\n    // Remove high bit and flip sign.\n    if (data[data.length - 1] & 0x80) {\n      this.setn((data.length * 8) - 1, 0);\n      this.ineg();\n    }\n\n    return this;\n  }\n\n  /**\n   * Serialize script number.\n   * @returns {Buffer}\n   */\n\n  encode() {\n    return this.toRaw();\n  }\n\n  /**\n   * Decode and verify script number.\n   * @private\n   * @param {Buffer} data\n   * @param {Boolean?} minimal - Require minimal encoding.\n   * @param {Number?} limit - Size limit.\n   * @returns {ScriptNum}\n   */\n\n  decode(data, minimal, limit) {\n    assert(Buffer.isBuffer(data));\n\n    if (limit != null && data.length > limit)\n      throw new ScriptError('UNKNOWN_ERROR', 'Script number overflow.');\n\n    if (minimal && !ScriptNum.isMinimal(data))\n      throw new ScriptError('UNKNOWN_ERROR', 'Non-minimal script number.');\n\n    return this.fromRaw(data);\n  }\n\n  /**\n   * Inspect script number.\n   * @returns {String}\n   */\n\n  inspect() {\n    return `<ScriptNum: ${this.toString(10)}>`;\n  }\n\n  /**\n   * Test wether a serialized script\n   * number is in its most minimal form.\n   * @param {Buffer} data\n   * @returns {Boolean}\n   */\n\n  static isMinimal(data) {\n    assert(Buffer.isBuffer(data));\n\n    if (data.length === 0)\n      return true;\n\n    if ((data[data.length - 1] & 0x7f) === 0) {\n      if (data.length === 1)\n        return false;\n\n      if ((data[data.length - 2] & 0x80) === 0)\n        return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Encode serialized script number in its most minimal form.\n   * @param {Buffer} data\n   * @returns {Buffer} minimal encoded data\n   */\n\n  static toMinimal(data) {\n    assert(Buffer.isBuffer(data));\n\n    if (this.isMinimal(data))\n      return data;\n\n    const last = data[data.length - 1];\n\n    // We are not minimally encoded, we need to figure out how much to trim.\n    for (let i = data.length - 1; i > 0; i--) {\n      // We found a non zero byte, time to encode.\n      if (data[i - 1] !== 0) {\n        if (data[i - 1] & 0x80) {\n          // We found a byte with it sign bit set so we need one more\n          // byte.\n          data[i++] = last;\n        } else {\n          // the sign bit is clear, we can use it.\n          data[i - 1] |= last;\n        }\n\n        data = data.slice(0, i);\n        return data;\n      }\n    }\n\n    // If we the whole thing is zeros, then we have a zero.\n    data = Buffer.alloc(0);\n    return data;\n  }\n\n  /**\n   * Decode and verify script number.\n   * @param {Buffer} data\n   * @param {Boolean?} minimal - Require minimal encoding.\n   * @param {Number?} limit - Size limit.\n   * @returns {ScriptNum}\n   */\n\n  static decode(data, minimal, limit) {\n    return new this().decode(data, minimal, limit);\n  }\n\n  /**\n   * Test whether object is a script number.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n  static isScriptNum(obj) {\n    return obj instanceof ScriptNum;\n  }\n}\n\n/*\n * Expose\n */\n\nmodule.exports = ScriptNum;\n"]},"metadata":{},"sourceType":"module"}