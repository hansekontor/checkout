{"ast":null,"code":"/*!\n * bn.js - big numbers for bcrypto\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on indutny/bn.js:\n *   Copyright (c) 2015, Fedor Indutny (MIT License).\n *   https://github.com/indutny/bn.js\n *\n * Parts of this software are based on golang/go:\n *   Copyright (c) 2009, The Go Authors. All rights reserved.\n *   https://github.com/golang/go\n *\n * Parts of this software are based on openssl/openssl:\n *   Copyright (c) 1998-2018, The OpenSSL Project (Apache License v2.0).\n *   Copyright (c) 1995-1998, Eric A. Young, Tim J. Hudson. All rights reserved.\n *   https://github.com/openssl/openssl\n *\n * Parts of this software are based on libgmp:\n *   Copyright (c) 1991-1997, 1999-2014, Free Software Foundation, Inc.\n *   https://gmplib.org/\n *\n * Parts of this software are based on v8/v8:\n *   Copyright (c) 2017, The V8 Project Authors (BSD-Style License).\n *   https://github.com/v8/v8\n *\n * Resources:\n *   https://github.com/indutny/bn.js/blob/master/lib/bn.js\n *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js\n *   https://github.com/golang/go/blob/master/src/math/big/int.go\n *   https://github.com/golang/go/blob/master/src/math/big/nat.go\n *   https://github.com/golang/go/blob/master/src/math/big/prime.go\n *   https://github.com/openssl/openssl/tree/master/crypto/bn\n *   https://github.com/openssl/openssl/blob/master/crypto/bn/bn_kron.c\n *   https://github.com/gnutls/nettle/blob/master/mini-gmp.c\n *   https://github.com/v8/v8/blob/master/src/objects/bigint.cc\n */\n\n/* eslint valid-typeof: \"off\" */\n'use strict';\n\nconst {\n  custom\n} = require('../internal/custom');\n/*\n * Constants\n */\n\n\nconst U8_MAX = (1n << 8n) - 1n;\nconst U16_MAX = (1n << 16n) - 1n;\nconst U32_MAX = (1n << 32n) - 1n;\nconst U64_MAX = (1n << 64n) - 1n;\nconst U128_MAX = (1n << 128n) - 1n;\nconst U256_MAX = (1n << 256n) - 1n;\nconst MAX_SAFE_INTEGER = 9007199254740991n;\nconst ENDIAN = new Int8Array(new Int16Array([1]).buffer)[0] === 0 ? 'be' : 'le';\nconst primes = {\n  p192: null,\n  p224: null,\n  p521: null,\n  k256: null,\n  p25519: null,\n  p448: null\n};\n/**\n * BN\n */\n\nclass BN {\n  constructor(num, base, endian) {\n    this.n = 0n;\n    this.red = null;\n    this.from(num, base, endian);\n  }\n  /*\n   * Compat\n   */\n\n\n  get negative() {\n    return this.n < 0n ? 1 : 0;\n  }\n\n  set negative(val) {\n    if ((val & 1) !== this.negative) this.n = -this.n;\n  }\n\n  get length() {\n    return countWords(this.n, 26);\n  }\n  /*\n   * Addition\n   */\n\n\n  iadd(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    this.n += num.n;\n    return this;\n  }\n\n  iaddn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    this.n += BigInt(num);\n    return this;\n  }\n\n  add(num) {\n    return this.clone().iadd(num);\n  }\n\n  addn(num) {\n    return this.clone().iaddn(num);\n  }\n  /*\n   * Subtraction\n   */\n\n\n  isub(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    this.n -= num.n;\n    return this;\n  }\n\n  isubn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    this.n -= BigInt(num);\n    return this;\n  }\n\n  sub(num) {\n    return this.clone().isub(num);\n  }\n\n  subn(num) {\n    return this.clone().isubn(num);\n  }\n  /*\n   * Multiplication\n   */\n\n\n  imul(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    this.n *= num.n;\n    return this;\n  }\n\n  imuln(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    this.n *= BigInt(num);\n    return this;\n  }\n\n  mul(num) {\n    return this.clone().imul(num);\n  }\n\n  muln(num) {\n    return this.clone().imuln(num);\n  }\n  /*\n   * Multiplication + Shift\n   */\n\n\n  mulShift(num, bits) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    enforce(bits - 1 >>> 0 === bits - 1, 'bits', 'uint32');\n    return new BN(mulShift(this.n, num.n, bits));\n  }\n  /*\n   * Truncation Division + Modulo\n   */\n\n\n  quorem(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    nonzero(num.n !== 0n);\n    const [q, r] = quorem(this.n, num.n);\n    return [new BN(q), new BN(r)];\n  }\n  /*\n   * Truncation Division\n   */\n\n\n  iquo(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    nonzero(num.n !== 0n);\n    this.n /= num.n;\n    return this;\n  }\n\n  iquon(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    nonzero(num !== 0);\n    this.n /= BigInt(num);\n    return this;\n  }\n\n  quo(num) {\n    return this.clone().iquo(num);\n  }\n\n  quon(num) {\n    return this.clone().iquon(num);\n  }\n  /*\n   * Truncation Modulo\n   */\n\n\n  irem(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    nonzero(num.n !== 0n);\n    this.n %= num.n;\n    return this;\n  }\n\n  iremn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    nonzero(num !== 0);\n    this.n %= BigInt(num);\n    return this;\n  }\n\n  rem(num) {\n    return this.clone().irem(num);\n  }\n\n  remn(num) {\n    return this.clone().iremn(num);\n  }\n\n  remrn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    nonzero(num !== 0);\n    return remrn(this.n, num);\n  }\n  /*\n   * Euclidean Division + Modulo\n   */\n\n\n  divmod(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    nonzero(num.n !== 0n);\n    const [q, r] = divmod(this.n, num.n);\n    return [new BN(q), new BN(r)];\n  }\n  /*\n   * Euclidean Division\n   */\n\n\n  idiv(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    nonzero(num.n !== 0n);\n    this.n = div(this.n, num.n);\n    return this;\n  }\n\n  idivn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    nonzero(num !== 0);\n    this.n = div(this.n, BigInt(num));\n    return this;\n  }\n\n  div(num) {\n    return this.clone().idiv(num);\n  }\n\n  divn(num) {\n    return this.clone().idivn(num);\n  }\n  /*\n   * Euclidean Modulo\n   */\n\n\n  imod(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    nonzero(num.n !== 0n);\n    this.n = mod(this.n, num.n);\n    return this;\n  }\n\n  imodn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    nonzero(num !== 0);\n    this.n = mod(this.n, BigInt(num));\n    return this;\n  }\n\n  mod(num) {\n    return this.clone().imod(num);\n  }\n\n  modn(num) {\n    return this.clone().imodn(num);\n  }\n\n  modrn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    nonzero(num !== 0);\n    return modrn(this.n, num);\n  }\n  /*\n   * Round Division\n   */\n\n\n  divRound(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    nonzero(num.n !== 0n);\n    return new BN(divRound(this.n, num.n));\n  }\n  /*\n   * Exponentiation\n   */\n\n\n  ipow(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    this.n **= abs(num.n);\n    return this;\n  }\n\n  ipown(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    this.n **= abs(BigInt(num));\n    return this;\n  }\n\n  pow(num) {\n    return this.clone().ipow(num);\n  }\n\n  pown(num) {\n    return this.clone().ipown(num);\n  }\n\n  isqr() {\n    this.n *= this.n;\n    return this;\n  }\n\n  sqr() {\n    return this.clone().isqr();\n  }\n  /*\n   * Roots\n   */\n\n\n  rootrem(pow) {\n    const [x, r] = rootrem(this.n, pow);\n    return [new BN(x), new BN(r)];\n  }\n\n  iroot(pow) {\n    this.n = root(this.n, pow);\n    return this;\n  }\n\n  root(pow) {\n    return this.clone().iroot(pow);\n  }\n\n  isPower(pow) {\n    return isPower(this.n, pow);\n  }\n\n  sqrtrem() {\n    const [x, r] = sqrtrem(this.n);\n    return [new BN(x), new BN(r)];\n  }\n\n  isqrt() {\n    this.n = sqrt(this.n);\n    return this;\n  }\n\n  sqrt() {\n    return this.clone().isqrt();\n  }\n\n  isSquare() {\n    return isSquare(this.n);\n  }\n  /*\n   * AND\n   */\n\n\n  iand(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    this.n &= num.n;\n    return this;\n  }\n\n  iandn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    this.n &= BigInt(num);\n    return this;\n  }\n\n  and(num) {\n    return this.clone().iand(num);\n  }\n\n  andn(num) {\n    return this.clone().iandn(num);\n  }\n\n  andrn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    const n = this.n & BigInt(num);\n    if (n < -0x3ffffffn || n > 0x3ffffffn) throw new RangeError('Number exceeds 26 bits.');\n    return Number(n);\n  }\n  /*\n   * Unsigned AND\n   */\n\n\n  iuand(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    this.n = uand(this.n, num.n);\n    return this;\n  }\n\n  iuandn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    this.n = uandn(this.n, num);\n    return this;\n  }\n\n  uand(num) {\n    return this.clone().iuand(num);\n  }\n\n  uandn(num) {\n    return this.clone().iuandn(num);\n  }\n\n  uandrn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    return Number(uandn(this.n, num));\n  }\n  /*\n   * OR\n   */\n\n\n  ior(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    this.n |= num.n;\n    return this;\n  }\n\n  iorn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    this.n |= BigInt(num);\n    return this;\n  }\n\n  or(num) {\n    return this.clone().ior(num);\n  }\n\n  orn(num) {\n    return this.clone().iorn(num);\n  }\n  /*\n   * Unsigned OR\n   */\n\n\n  iuor(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    this.n = uor(this.n, num.n);\n    return this;\n  }\n\n  iuorn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    this.n = uorn(this.n, num);\n    return this;\n  }\n\n  uor(num) {\n    return this.clone().iuor(num);\n  }\n\n  uorn(num) {\n    return this.clone().iuorn(num);\n  }\n  /*\n   * XOR\n   */\n\n\n  ixor(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    this.n ^= num.n;\n    return this;\n  }\n\n  ixorn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    this.n ^= BigInt(num);\n    return this;\n  }\n\n  xor(num) {\n    return this.clone().ixor(num);\n  }\n\n  xorn(num) {\n    return this.clone().ixorn(num);\n  }\n  /*\n   * Unsigned XOR\n   */\n\n\n  iuxor(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    this.n = uxor(this.n, num.n);\n    return this;\n  }\n\n  iuxorn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    this.n = uxorn(this.n, num);\n    return this;\n  }\n\n  uxor(num) {\n    return this.clone().ixor(num);\n  }\n\n  uxorn(num) {\n    return this.clone().iuxorn(num);\n  }\n  /*\n   * NOT\n   */\n\n\n  inot() {\n    this.n = ~this.n;\n    return this;\n  }\n\n  not() {\n    return this.clone().inot();\n  }\n\n  inotn(width) {\n    enforce(width >>> 0 === width, 'width', 'uint32');\n    this.n = notn(this.n, width);\n    return this;\n  }\n\n  notn(width) {\n    return this.clone().inotn(width);\n  }\n  /*\n   * Left Shift\n   */\n\n\n  ishl(num) {\n    enforce(BN.isBN(num), 'bits', 'bignum');\n    enforce(num.n >= 0n && num.n <= U32_MAX, 'bits', 'uint32');\n    this.n <<= num.n;\n    return this;\n  }\n\n  ishln(bits) {\n    enforce(bits >>> 0 === bits, 'bits', 'uint32');\n    this.n <<= BigInt(bits);\n    return this;\n  }\n\n  shl(num) {\n    return this.clone().ishl(num);\n  }\n\n  shln(bits) {\n    return this.clone().ishln(bits);\n  }\n  /*\n   * Unsigned Left Shift\n   */\n\n\n  iushl(num) {\n    enforce(BN.isBN(num), 'bits', 'bignum');\n    enforce(num.n >= 0n && num.n <= U32_MAX, 'bits', 'uint32');\n    this.n <<= num.n;\n    return this;\n  }\n\n  iushln(bits) {\n    enforce(bits >>> 0 === bits, 'bits', 'uint32');\n    this.n <<= BigInt(bits);\n    return this;\n  }\n\n  ushl(num) {\n    return this.clone().iushl(num);\n  }\n\n  ushln(bits) {\n    return this.clone().iushln(bits);\n  }\n  /*\n   * Right Shift\n   */\n\n\n  ishr(num) {\n    enforce(BN.isBN(num), 'bits', 'bignum');\n    enforce(num.n >= 0n && num.n <= U32_MAX, 'bits', 'uint32');\n    this.n >>= num.n;\n    return this;\n  }\n\n  ishrn(bits) {\n    enforce(bits >>> 0 === bits, 'bits', 'uint32');\n    this.n >>= BigInt(bits);\n    return this;\n  }\n\n  shr(num) {\n    return this.clone().ishr(num);\n  }\n\n  shrn(bits) {\n    return this.clone().ishrn(bits);\n  }\n  /*\n   * Unsigned Right Shift\n   */\n\n\n  iushr(num) {\n    enforce(BN.isBN(num), 'bits', 'bignum');\n    enforce(num.n >= 0n && num.n <= U32_MAX, 'bits', 'uint32');\n    this.n = ushr(this.n, num.n);\n    return this;\n  }\n\n  iushrn(bits) {\n    enforce(bits >>> 0 === bits, 'bits', 'uint32');\n    this.n = ushrn(this.n, bits);\n    return this;\n  }\n\n  ushr(num) {\n    return this.clone().iushr(num);\n  }\n\n  ushrn(bits) {\n    return this.clone().iushrn(bits);\n  }\n  /*\n   * Bit Manipulation\n   */\n\n\n  setn(bit, val) {\n    enforce(bit >>> 0 === bit, 'bit', 'uint32');\n    this.n = setn(this.n, bit, val);\n    return this;\n  }\n\n  usetn(bit, val) {\n    enforce(bit >>> 0 === bit, 'bit', 'uint32');\n    this.n = usetn(this.n, bit, val);\n    return this;\n  }\n\n  testn(bit) {\n    enforce(bit >>> 0 === bit, 'bit', 'uint32');\n    return testn(this.n, bit);\n  }\n\n  utestn(bit) {\n    enforce(bit >>> 0 === bit, 'bit', 'uint32');\n    return utestn(this.n, bit);\n  }\n\n  imaskn(bits) {\n    enforce(bits >>> 0 === bits, 'bits', 'uint32');\n    this.n = maskn(this.n, bits);\n    return this;\n  }\n\n  maskn(bits) {\n    return this.clone().imaskn(bits);\n  }\n\n  iumaskn(bits) {\n    enforce(bits >>> 0 === bits, 'bits', 'uint32');\n    this.n = umaskn(this.n, bits);\n    return this;\n  }\n\n  umaskn(bits) {\n    return this.clone().iumaskn(bits);\n  }\n\n  andln(num) {\n    return andln(this.n, num);\n  }\n  /*\n   * Negation\n   */\n\n\n  ineg() {\n    this.n = -this.n;\n    return this;\n  }\n\n  neg() {\n    return this.clone().ineg();\n  }\n\n  iabs() {\n    this.n = abs(this.n);\n    return this;\n  }\n\n  abs() {\n    return this.clone().iabs();\n  }\n  /*\n   * Comparison\n   */\n\n\n  cmp(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    return cmp(this.n, num.n);\n  }\n\n  cmpn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    return cmpn(this.n, num);\n  }\n\n  eq(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    return this.n === num.n;\n  }\n\n  eqn(num) {\n    enforce(isSMI(num), 'num', 'smi'); // v8 allows loose comparisons\n    // between bigints and doubles.\n    // eslint-disable-next-line\n\n    return this.n == num;\n  }\n\n  gt(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    return this.n > num.n;\n  }\n\n  gtn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    return this.n > num;\n  }\n\n  gte(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    return this.n >= num.n;\n  }\n\n  gten(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    return this.n >= num;\n  }\n\n  lt(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    return this.n < num.n;\n  }\n\n  ltn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    return this.n < num;\n  }\n\n  lte(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    return this.n <= num.n;\n  }\n\n  lten(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    return this.n <= num;\n  }\n\n  sign() {\n    return (this.n > 0n) - (this.n < 0n);\n  }\n\n  isZero() {\n    return this.n === 0n;\n  }\n\n  isNeg() {\n    return this.n < 0n;\n  }\n\n  isPos() {\n    return this.n >= 0n;\n  }\n\n  isOdd() {\n    return (this.n & 1n) === 1n;\n  }\n\n  isEven() {\n    return (this.n & 1n) === 0n;\n  }\n  /*\n   * Unsigned Comparison\n   */\n\n\n  ucmp(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    return ucmp(this.n, num.n);\n  }\n\n  ucmpn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    return ucmpn(this.n, num);\n  }\n  /*\n   * Number Theoretic Functions\n   */\n\n\n  legendre(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    nonred(!num.red, 'legendre');\n    return legendre(this.n, num.n);\n  }\n\n  jacobi(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    return jacobi(this.n, num.n);\n  }\n\n  kronecker(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    return kronecker(this.n, num.n);\n  }\n\n  igcd(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    this.n = gcd(this.n, num.n);\n    return this;\n  }\n\n  gcd(num) {\n    return this.clone().igcd(num);\n  }\n\n  ilcm(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    this.n = lcm(this.n, num.n);\n    return this;\n  }\n\n  lcm(num) {\n    return this.clone().ilcm(num);\n  }\n\n  egcd(p) {\n    enforce(BN.isBN(p), 'p', 'bignum');\n    const [a, b, gcd] = egcd(this.n, p.n);\n    return [new BN(a), new BN(b), new BN(gcd)];\n  }\n\n  iinvert(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    range(num.n >= 1n, 'iinvert');\n    this.n = invert(this.n, num.n);\n    return this;\n  }\n\n  invert(num) {\n    return this.clone().iinvert(num);\n  }\n\n  ifermat(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    range(num.n >= 1n, 'ifermat');\n    nonred(!num.red, 'ifermat');\n    this.n = fermat(this.n, num.n);\n    return this;\n  }\n\n  fermat(num) {\n    return this.clone().ifermat(num);\n  }\n\n  ipowm(y, m, mont, size) {\n    enforce(BN.isBN(y), 'y', 'bignum');\n    enforce(BN.isBN(m), 'm', 'bignum');\n    range(m.n >= 1n, 'ipowm');\n    nonred(!this.red && !y.red && !m.red, 'ipowm');\n    this.n = powm(this.n, y.n, m.n, size);\n    return this;\n  }\n\n  powm(y, m, mont, size) {\n    return this.clone().ipowm(y, m, mont, size);\n  }\n\n  ipowmn(y, m, mont) {\n    enforce(isSMI(y), 'y', 'smi');\n    enforce(BN.isBN(m), 'm', 'bignum');\n    range(m.n >= 1n, 'ipowmn');\n    nonred(!this.red && !m.red, 'ipowmn');\n    this.n = powm(this.n, BigInt(y), m.n);\n    return this;\n  }\n\n  powmn(y, m, mont) {\n    return this.clone().ipowmn(y, m, mont);\n  }\n\n  isqrtm(p) {\n    enforce(BN.isBN(p), 'p', 'bignum');\n    range(p.n >= 1n, 'isqrtm');\n    nonred(!this.red && !p.red, 'isqrtm');\n    this.n = sqrtm(this.n, p.n);\n    return this;\n  }\n\n  sqrtm(p) {\n    return this.clone().isqrtm(p);\n  }\n\n  isqrtpq(p, q) {\n    enforce(BN.isBN(p), 'p', 'bignum');\n    enforce(BN.isBN(q), 'q', 'bignum');\n    range(p.n >= 1n, 'isqrtpq');\n    range(q.n >= 1n, 'isqrtpq');\n    nonred(!this.red && !p.red && !q.red, 'isqrtpq');\n    this.n = sqrtpq(this.n, p.n, q.n);\n    return this;\n  }\n\n  sqrtpq(p, q) {\n    return this.clone().isqrtpq(p, q);\n  }\n  /*\n   * Primality Testing\n   */\n\n\n  isPrime(rng, reps, limit) {\n    enforce(reps >>> 0 === reps, 'reps', 'uint32');\n    if (!this.isPrimeMR(rng, reps + 1, true)) return false;\n    if (!this.isPrimeLucas(limit)) return false;\n    return true;\n  }\n\n  isPrimeMR(rng, reps, force2) {\n    return isPrimeMR(this.n, rng, reps, force2);\n  }\n\n  isPrimeLucas(limit) {\n    return isPrimeLucas(this.n, limit);\n  }\n  /*\n   * Twos Complement\n   */\n\n\n  toTwos(width) {\n    enforce(width >>> 0 === width, 'width', 'uint32');\n    return new BN(toTwos(this.n, width));\n  }\n\n  fromTwos(width) {\n    enforce(width >>> 0 === width, 'width', 'uint32');\n    range(width > 0, 'width');\n    return new BN(fromTwos(this.n, width));\n  }\n  /*\n   * Reduction Context\n   */\n\n\n  toRed(ctx) {\n    enforce(ctx instanceof Red, 'ctx', 'reduction context');\n    if (this.red) throw new Error('Already in reduction context.');\n    return ctx.convertTo(this);\n  }\n\n  fromRed() {\n    red(this.red, 'fromRed');\n    return this.red.convertFrom(this);\n  }\n\n  forceRed(ctx) {\n    enforce(ctx instanceof Red, 'ctx', 'reduction context');\n\n    if (this.red) {\n      if (ctx.n !== this.red.n || ctx.mont !== this.red.mont) throw new Error('Already in reduction context.');\n    } else {\n      range(this.n >= 0n, 'red');\n      range(this.n < ctx.n, 'red');\n    }\n\n    return this.clone()._forceRed(ctx);\n  }\n\n  redIAdd(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redIAdd');\n    return this.red.iadd(this, num);\n  }\n\n  redAdd(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redAdd');\n    return this.red.add(this, num);\n  }\n\n  redIAddn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redIAddn');\n    return this.red.iaddn(this, num);\n  }\n\n  redAddn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redAddn');\n    return this.red.addn(this, num);\n  }\n\n  redISub(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redISub');\n    return this.red.isub(this, num);\n  }\n\n  redSub(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redSub');\n    return this.red.sub(this, num);\n  }\n\n  redISubn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redISubn');\n    return this.red.isubn(this, num);\n  }\n\n  redSubn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redSubn');\n    return this.red.subn(this, num);\n  }\n\n  redIMul(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redIMul');\n    return this.red.imul(this, num);\n  }\n\n  redMul(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redMul');\n    return this.red.mul(this, num);\n  }\n\n  redIMuln(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redIMuln');\n    return this.red.imuln(this, num);\n  }\n\n  redMuln(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redMuln');\n    return this.red.muln(this, num);\n  }\n\n  redIDiv(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redIDiv');\n    return this.red.idiv(this, num);\n  }\n\n  redDiv(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redDiv');\n    return this.red.div(this, num);\n  }\n\n  redIDivn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redIDivn');\n    return this.red.idivn(this, num);\n  }\n\n  redDivn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redDivn');\n    return this.red.divn(this, num);\n  }\n\n  redIPow(num, size) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redIPow');\n    nonred(!num.red, 'redIPow');\n    return this.red.ipow(this, num, size);\n  }\n\n  redPow(num, size) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redPow');\n    nonred(!num.red, 'redPow');\n    return this.red.pow(this, num, size);\n  }\n\n  redIPown(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redIPown');\n    return this.red.ipown(this, num);\n  }\n\n  redPown(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redPown');\n    return this.red.pown(this, num);\n  }\n\n  redISqr() {\n    red(this.red, 'redISqr');\n    return this.red.isqr(this);\n  }\n\n  redSqr() {\n    red(this.red, 'redSqr');\n    return this.red.sqr(this);\n  }\n\n  redISqrt() {\n    red(this.red, 'redISqrt');\n    return this.red.isqrt(this);\n  }\n\n  redSqrt() {\n    red(this.red, 'redSqrt');\n    return this.red.sqrt(this);\n  }\n\n  redIDivSqrt(v) {\n    red(this.red, 'redIDivSqrt');\n    return this.red.idivsqrt(this, v);\n  }\n\n  redDivSqrt(v) {\n    red(this.red, 'redDivSqrt');\n    return this.red.divsqrt(this, v);\n  }\n\n  redIsSquare() {\n    red(this.red, 'redIsSquare');\n    return this.red.isSquare(this);\n  }\n\n  redIShl(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redIShl');\n    nonred(!num.red, 'redIShl');\n    return this.red.ishl(this, num);\n  }\n\n  redShl(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    enforce(num.n >= 0n && num.n <= U32_MAX, 'num', 'uint32');\n    red(this.red, 'redShl');\n    nonred(!num.red, 'redShl');\n    return this.red.shl(this, num);\n  }\n\n  redIShln(num) {\n    enforce(num >>> 0 === num, 'num', 'uint32');\n    red(this.red, 'redIShln');\n    return this.red.ishln(this, num);\n  }\n\n  redShln(num) {\n    enforce(num >>> 0 === num, 'num', 'uint32');\n    red(this.red, 'redShln');\n    return this.red.shln(this, num);\n  }\n\n  redINeg() {\n    red(this.red, 'redINeg');\n    return this.red.ineg(this);\n  }\n\n  redNeg() {\n    red(this.red, 'redNeg');\n    return this.red.neg(this);\n  }\n\n  redEq(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redEq');\n    return this.red.eq(this, num);\n  }\n\n  redEqn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redEqn');\n    return this.red.eqn(this, num);\n  }\n\n  redIsHigh() {\n    red(this.red, 'redIsHigh');\n    return this.red.isHigh(this);\n  }\n\n  redIsLow() {\n    red(this.red, 'redIsLow');\n    return this.red.isLow(this);\n  }\n\n  redIsOdd() {\n    red(this.red, 'redIsOdd');\n    return this.red.isOdd(this);\n  }\n\n  redIsEven() {\n    red(this.red, 'redIsEven');\n    return this.red.isEven(this);\n  }\n\n  redLegendre() {\n    red(this.red, 'redLegendre');\n    return this.red.legendre(this);\n  }\n\n  redJacobi() {\n    red(this.red, 'redJacobi');\n    return this.red.jacobi(this);\n  }\n\n  redKronecker() {\n    red(this.red, 'redKronecker');\n    return this.red.kronecker(this);\n  }\n\n  redIInvert() {\n    red(this.red, 'redIInvert');\n    return this.red.iinvert(this);\n  }\n\n  redInvert() {\n    red(this.red, 'redInvert');\n    return this.red.invert(this);\n  }\n\n  redIFermat() {\n    red(this.red, 'redIFermat');\n    return this.red.ifermat(this);\n  }\n\n  redFermat() {\n    red(this.red, 'redFermat');\n    return this.red.fermat(this);\n  }\n  /*\n   * Internal\n   */\n\n\n  _forceRed(ctx) {\n    this.red = ctx;\n    return this;\n  }\n  /*\n   * Helpers\n   */\n\n\n  clone() {\n    return new BN().inject(this);\n  }\n\n  inject(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    this.n = num.n;\n    this.red = num.red;\n    return this;\n  }\n\n  set(num, endian) {\n    return this.fromNumber(num, endian);\n  }\n\n  swap(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    [this.n, num.n] = [num.n, this.n];\n    [this.red, num.red] = [num.red, this.red];\n    return this;\n  }\n\n  reverse() {\n    const neg = this.n < 0n;\n    const endian = ENDIAN === 'be' ? 'le' : 'be';\n    this.fromBuffer(this.toBuffer(endian), ENDIAN);\n    if (neg) this.n = -this.n;\n    return this;\n  }\n\n  byteLength() {\n    return byteLength(this.n);\n  }\n\n  bitLength() {\n    return bitLength(this.n);\n  }\n\n  zeroBits() {\n    return zeroBits(this.n);\n  }\n\n  isSafe() {\n    return this.n <= MAX_SAFE_INTEGER && this.n >= -MAX_SAFE_INTEGER;\n  }\n\n  word(pos) {\n    enforce(pos >>> 0 === pos, 'pos', 'uint32');\n    return word(this.n, pos);\n  }\n\n  [custom]() {\n    let prefix = 'BN';\n    if (this.red) prefix = 'BN-R';\n    return `<${prefix}: ${this.toString(10)}>`;\n  }\n  /*\n   * Constant Time (sort of)\n   */\n\n\n  csign() {\n    return this.cneg() * -2 + 1 - this.czero();\n  }\n\n  czero() {\n    return this.n === 0n | 0;\n  }\n\n  cneg() {\n    return this.n < 0n | 0;\n  }\n\n  cpos() {\n    return this.n >= 0n | 0;\n  }\n\n  ceq(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    return ceq(this.n, num.n);\n  }\n\n  ceqn(num) {\n    const neg = num >> 31 | 1;\n    const word = ((num | 0) * neg & 0x3ffffff) * neg;\n    return ceqn(this.n, word);\n  }\n\n  cswap(num, flag) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    const cond = (flag >> 31 | -flag >> 31) & 1;\n    [this.n, num.n] = cswap(this.n, num.n, cond);\n    return this;\n  }\n\n  cinject(num, flag) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    const cond = (flag >> 31 | -flag >> 31) & 1;\n    this.n = cinject(this.n, num.n, cond);\n    return this;\n  }\n\n  cset(num, flag) {\n    const cond = (flag >> 31 | -flag >> 31) & 1;\n    const neg = num >> 31 | 1;\n    const word = ((num | 0) * neg & 0x3ffffff) * neg;\n    this.n = cset(this.n, word, cond);\n    return this;\n  }\n  /*\n   * Conversion\n   */\n\n\n  toNumber() {\n    if (!this.isSafe()) throw new RangeError('Number can only safely store up to 53 bits.');\n    return Number(this.n);\n  }\n\n  toDouble() {\n    return Number(this.n);\n  }\n\n  valueOf() {\n    return this.toDouble();\n  }\n\n  toBigInt() {\n    return this.n;\n  }\n\n  toBool() {\n    return this.n !== 0n;\n  }\n\n  toString(base, padding) {\n    return toString(this.n, base, padding);\n  }\n\n  toJSON() {\n    return this.toString(16, 2);\n  }\n\n  toArray(endian, length) {\n    // 1.75x faster than the common case.\n    const buf = this.toBuffer(endian, length);\n    if (Array.from) return Array.from(buf);\n    return Array.prototype.slice.call(buf);\n  }\n\n  toBuffer(endian, length) {\n    return toBuffer(this.n, endian, length);\n  }\n\n  toArrayLike(ArrayType, endian, length) {\n    if (ArrayType === Buffer) return this.toBuffer(endian, length);\n    if (ArrayType === Array) return this.toArray(endian, length);\n\n    if (ArrayType === Int8Array || ArrayType === Uint8Array || ArrayType === Uint8ClampedArray) {\n      const buf = this.toBuffer(endian, length);\n      return new ArrayType(buf.buffer, buf.byteOffset, buf.byteLength);\n    }\n\n    return toArrayLike(this.n, ArrayType, endian, length);\n  }\n\n  encode(endian, length) {\n    return this.toBuffer(endian, length);\n  }\n  /*\n   * Instantiation\n   */\n\n\n  of(num, endian) {\n    return this.fromNumber(num, endian);\n  }\n\n  fromNumber(num, endian) {\n    if (endian == null) endian = 'be';\n    enforce(isInteger(num), 'num', 'integer');\n    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');\n    this.n = BigInt(num);\n    if (endian === 'le') this.reverse();\n    return this;\n  }\n\n  fromDouble(num, endian) {\n    if (endian == null) endian = 'be';\n    enforce(typeof num === 'number', 'num', 'double');\n    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');\n    if (!isFinite(num)) num = 0;\n    this.n = BigInt(Math.trunc(num));\n    if (endian === 'le') this.reverse();\n    return this;\n  }\n\n  fromBigInt(num, endian) {\n    if (endian == null) endian = 'be';\n    enforce(typeof num === 'bigint', 'num', 'bigint');\n    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');\n    this.n = num;\n    if (endian === 'le') this.reverse();\n    return this;\n  }\n\n  fromBool(value) {\n    enforce(typeof value === 'boolean', 'value', 'boolean');\n    return this.set(value ? 1 : 0);\n  }\n\n  fromString(str, base, endian) {\n    if (base === 'le' || base === 'be') [base, endian] = [endian, base];\n    if (endian == null) endian = 'be';\n    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');\n    this.n = fromString(str, base);\n    if (endian === 'le') this.reverse();\n    return this;\n  }\n\n  fromJSON(json) {\n    if (BN.isBN(json)) {\n      if (json.red) return json.fromRed();\n      return json.clone();\n    }\n\n    if (Array.isArray(json)) {\n      for (const chunk of json) enforce(typeof chunk === 'string', 'chunk', 'string');\n\n      json = json.join('');\n    }\n\n    return this.fromString(json, 16);\n  }\n\n  fromBN(num) {\n    return this.inject(num);\n  }\n\n  fromArray(data, endian) {\n    enforce(Array.isArray(data), 'data', 'array');\n    this.n = fromArrayLike(data, endian);\n    return this;\n  }\n\n  fromBuffer(data, endian) {\n    this.n = fromBuffer(data, endian);\n    return this;\n  }\n\n  fromArrayLike(data, endian) {\n    if (Buffer.isBuffer(data)) return this.fromBuffer(data, endian);\n    if (Array.isArray(data)) return this.fromArray(data, endian);\n\n    if (data instanceof Int8Array || data instanceof Uint8Array || data instanceof Uint8ClampedArray) {\n      const raw = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n      return this.fromBuffer(raw, endian);\n    }\n\n    this.n = fromArrayLike(data, endian);\n    return this;\n  }\n\n  decode(data, endian) {\n    return this.fromBuffer(data, endian);\n  }\n\n  from(num, base, endian) {\n    if (num == null) return this;\n    if (base === 'le' || base === 'be') [base, endian] = [endian, base];\n    if (typeof num === 'number') return this.fromNumber(num, endian);\n    if (typeof num === 'bigint') return this.fromBigInt(num, endian);\n    if (typeof num === 'string') return this.fromString(num, base, endian);\n\n    if (typeof num === 'object') {\n      if (BN.isBN(num)) return this.fromBN(num, endian);\n      if (Buffer.isBuffer(num)) return this.fromBuffer(num, endian);\n      if (num.length >>> 0 === num.length) return this.fromArrayLike(num, endian);\n    }\n\n    if (typeof num === 'boolean') return this.fromBool(num);\n    throw new TypeError('Non-numeric object passed to BN.');\n  }\n  /*\n   * Static Methods\n   */\n\n\n  static min() {\n    let min = null;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    for (const num of args) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      if (!min || num.cmp(min) < 0) min = num;\n    }\n\n    return min || new BN(0);\n  }\n\n  static max() {\n    let max = null;\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    for (const num of args) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      if (!max || num.cmp(max) > 0) max = num;\n    }\n\n    return max || new BN(0);\n  }\n\n  static cmp(a, b) {\n    enforce(BN.isBN(a), 'a', 'bignum');\n    return a.cmp(b);\n  }\n\n  static ucmp(a, b) {\n    enforce(BN.isBN(a), 'a', 'bignum');\n    return a.ucmp(b);\n  }\n\n  static red(num) {\n    return new Red(num, false);\n  }\n\n  static barret(num) {\n    return new Red(num, false);\n  }\n\n  static mont(num) {\n    return new Red(num, true);\n  }\n\n  static _prime(name) {\n    if (primes[name]) return primes[name];\n    let prime;\n    if (name === 'p192') prime = new P192();else if (name === 'p224') prime = new P224();else if (name === 'p521') prime = new P521();else if (name === 'k256') prime = new K256();else if (name === 'p25519') prime = new P25519();else if (name === 'p448') prime = new P448();else throw new Error(`Unknown prime: \"${name}\".`);\n    primes[name] = prime;\n    return prime;\n  }\n\n  static prime(name) {\n    return BN._prime(name).p.clone();\n  }\n\n  static pow(num, exp) {\n    if (num === 2) return BN.shift(1, exp);\n    return new BN().fromNumber(num).ipown(exp);\n  }\n\n  static shift(num, bits) {\n    return new BN().fromNumber(num).ishln(bits);\n  }\n\n  static mask(bits) {\n    return BN.shift(1, bits).isubn(1);\n  }\n\n  static randomBits(rng, bits) {\n    const n = randomBits(rng, bits);\n    return new BN(n);\n  }\n\n  static random(rng, min, max) {\n    const lo = BN.cast(min, 16);\n    const hi = BN.cast(max, 16);\n    const n = random(rng, lo.n, hi.n);\n    return new BN(n);\n  }\n\n  static of(num, endian) {\n    return new BN().of(num, endian);\n  }\n\n  static fromNumber(num, endian) {\n    return new BN().fromNumber(num, endian);\n  }\n\n  static fromDouble(num, endian) {\n    return new BN().fromDouble(num, endian);\n  }\n\n  static fromBigInt(num, endian) {\n    return new BN().fromBigInt(num, endian);\n  }\n\n  static fromBool(value) {\n    return new BN().fromBool(value);\n  }\n\n  static fromString(str, base, endian) {\n    return new BN().fromString(str, base, endian);\n  }\n\n  static fromJSON(json) {\n    return new BN().fromJSON(json);\n  }\n\n  static fromBN(num) {\n    return new BN().fromBN(num);\n  }\n\n  static fromArray(data, endian) {\n    return new BN().fromArray(data, endian);\n  }\n\n  static fromBuffer(data, endian) {\n    return new BN().fromBuffer(data, endian);\n  }\n\n  static fromArrayLike(data, endian) {\n    return new BN().fromArrayLike(data, endian);\n  }\n\n  static decode(data, endian) {\n    return new BN().decode(data, endian);\n  }\n\n  static from(num, base, endian) {\n    return new BN().from(num, base, endian);\n  }\n\n  static cast(num, base, endian) {\n    if (BN.isBN(num)) return num;\n    return new BN(num, base, endian);\n  }\n\n  static isBN(obj) {\n    return obj instanceof BN;\n  }\n\n}\n/*\n * Static\n */\n\n\nBN.BN = BN;\nBN.wordSize = 26;\nBN.native = 1;\n/**\n * Prime\n */\n\nclass Prime {\n  constructor(name, p) {\n    this.name = name;\n    this.p = new BN(p, 16);\n  }\n\n}\n/**\n * P192\n */\n\n\nclass P192 extends Prime {\n  constructor() {\n    // 2^192 - 2^64 - 1 (= 3 mod 4)\n    super('p192', 'ffffffff ffffffff ffffffff fffffffe' + 'ffffffff ffffffff');\n  }\n\n}\n/**\n * P224\n */\n\n\nclass P224 extends Prime {\n  constructor() {\n    // 2^224 - 2^96 + 1 (no congruence)\n    super('p224', 'ffffffff ffffffff ffffffff ffffffff' + '00000000 00000000 00000001');\n  }\n\n}\n/**\n * P521\n */\n\n\nclass P521 extends Prime {\n  constructor() {\n    // 2^521 - 1 (= 3 mod 4)\n    super('p521', '000001ff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff');\n  }\n\n}\n/**\n * K256\n */\n\n\nclass K256 extends Prime {\n  constructor() {\n    // 2^256 - 2^32 - 977 (= 3 mod 4)\n    super('k256', 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff fffffffe fffffc2f');\n  }\n\n}\n/**\n * P25519\n */\n\n\nclass P25519 extends Prime {\n  constructor() {\n    // 2^255 - 19 (= 5 mod 8)\n    super('p25519', '7fffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff ffffffed');\n  }\n\n}\n/**\n * P448\n */\n\n\nclass P448 extends Prime {\n  constructor() {\n    // 2^448 - 2^224 - 1 (= 3 mod 4)\n    super('p448', 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff fffffffe ffffffff' + 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff');\n  }\n\n}\n/**\n * Reduction Engine\n */\n\n\nclass Red {\n  constructor(m, coprime) {\n    let prime = null;\n\n    if (typeof m === 'string') {\n      prime = BN._prime(m);\n      m = prime.p;\n    }\n\n    enforce(BN.isBN(m), 'm', 'bignum');\n    nonred(!m.red, 'reduction');\n    range(m.n >= 1n, 'reduction');\n    this.m = m;\n    this.n = m.n;\n    this.prime = prime;\n    this.coprime = coprime;\n    this.sm1 = null;\n  }\n\n  _verify1(a) {\n    range(a.negative === 0, 'red');\n    red(a.red != null, 'red');\n  }\n\n  _verify2(a, b) {\n    range((a.negative | b.negative) === 0, 'red');\n    red(a.red != null && a.red === b.red, 'red');\n  }\n\n  get mont() {\n    return false;\n  }\n\n  precompute() {\n    // Precompute `sqrt(-1)` for primes congruent to 5 mod 8.\n    if (this.sm1 === null && (this.n & 7n) === 5n) {\n      // sqrt(-1) = 2^((p - 1) / 4) mod p\n      this.sm1 = powm(2n, this.n - 1n >> 2n, this.n);\n    }\n\n    return this;\n  }\n\n  convertTo(num) {\n    const res = new BN();\n    res.n = mod(num.n, this.n);\n    res.red = this;\n    return res;\n  }\n\n  convertFrom(num) {\n    const res = num.clone();\n    res.red = null;\n    return res;\n  }\n\n  iadd(a, b) {\n    this._verify2(a, b);\n\n    a.n += b.n;\n    if (a.n >= this.n) a.n -= this.n;\n    return a;\n  }\n\n  add(a, b) {\n    return this.iadd(a.clone(), b);\n  }\n\n  iaddn(a, num) {\n    this._verify1(a);\n\n    if (num < 0) return this.isubn(a, -num);\n    let n = BigInt(num);\n    if (this.n < 0x4000000n) n %= this.n;\n    a.n += n;\n    if (a.n >= this.n) a.n -= this.n;\n    return a;\n  }\n\n  addn(a, num) {\n    return this.iaddn(a.clone(), num);\n  }\n\n  isub(a, b) {\n    this._verify2(a, b);\n\n    a.n -= b.n;\n    if (a.n < 0n) a.n += this.n;\n    return a;\n  }\n\n  sub(a, b) {\n    return this.isub(a.clone(), b);\n  }\n\n  isubn(a, num) {\n    this._verify1(a);\n\n    if (num < 0) return this.iaddn(a, -num);\n    let n = BigInt(num);\n    if (this.n < 0x4000000n) n %= this.n;\n    a.n -= n;\n    if (a.n < 0n) a.n += this.n;\n    return a;\n  }\n\n  subn(a, num) {\n    return this.isubn(a.clone(), num);\n  }\n\n  imul(a, b) {\n    this._verify2(a, b);\n\n    a.n *= b.n;\n    a.n %= this.n;\n    return a;\n  }\n\n  mul(a, b) {\n    this._verify2(a, b);\n\n    return this.imul(a.clone(), b);\n  }\n\n  imuln(a, num) {\n    this._verify1(a);\n\n    a.n *= BigInt(num);\n    a.n = mod(a.n, this.n);\n    return a;\n  }\n\n  muln(a, num) {\n    return this.imuln(a.clone(), num);\n  }\n\n  idiv(a, b) {\n    a.n *= invert(b.n, this.n);\n    a.n %= this.n;\n    return a;\n  }\n\n  div(a, b) {\n    return this.idiv(a.clone(), b);\n  }\n\n  idivn(a, num) {\n    a.n *= invert(BigInt(num), this.n);\n    a.n %= this.n;\n    return a;\n  }\n\n  divn(a, num) {\n    return this.idivn(a.clone(), num);\n  }\n\n  ipow(a, num, size) {\n    this._verify1(a);\n\n    a.n = powm(a.n, num.n, this.n, size);\n    return a;\n  }\n\n  pow(a, num, size) {\n    return this.ipow(a.clone(), num, size);\n  }\n\n  ipown(a, num) {\n    this._verify1(a);\n\n    a.n = powm(a.n, BigInt(num), this.n);\n    return a;\n  }\n\n  pown(a, num) {\n    return this.ipown(a.clone(), num);\n  }\n\n  isqr(a) {\n    this._verify1(a);\n\n    a.n *= a.n;\n    a.n %= this.n;\n    return a;\n  }\n\n  sqr(a) {\n    return this.isqr(a.clone());\n  }\n\n  isqrt(a) {\n    this._verify1(a);\n\n    if (this.sm1 != null) a.n = sqrt5mod8sm1(a.n, this.n, this.sm1);else a.n = sqrtm(a.n, this.n);\n    return a;\n  }\n\n  sqrt(a) {\n    return this.isqrt(a.clone());\n  }\n\n  idivsqrt(u, v) {\n    this._verify2(u, v);\n\n    u.n = divsqrt(u.n, v.n, this.n, this.sm1);\n    return u;\n  }\n\n  divsqrt(u, v) {\n    return this.idivsqrt(u.clone(), v);\n  }\n\n  isSquare(a) {\n    this._verify1(a);\n\n    let symbol;\n    if (this.prime || this.coprime) symbol = legendre(a.n, this.n);else if (this.n & 1n) symbol = jacobi(a.n, this.n);else symbol = kronecker(a.n, this.n);\n    return Boolean(~symbol >>> 31);\n  }\n\n  ishl(a, num) {\n    this._verify1(a);\n\n    a.n <<= num.n;\n    a.n %= this.n;\n    return a;\n  }\n\n  shl(a, num) {\n    return this.ishl(a.clone(), num);\n  }\n\n  ishln(a, num) {\n    this._verify1(a);\n\n    a.n <<= BigInt(num);\n    a.n %= this.n;\n    return a;\n  }\n\n  shln(a, num) {\n    return this.ishln(a.clone(), num);\n  }\n\n  ineg(a) {\n    this._verify1(a);\n\n    if (a.n !== 0n) a.n = this.n - a.n;\n    return a;\n  }\n\n  neg(a) {\n    return this.ineg(a.clone());\n  }\n\n  eq(a, b) {\n    this._verify2(a, b);\n\n    return a.n === b.n;\n  }\n\n  eqn(a, num) {\n    this._verify1(a);\n\n    if (this.n < 0x4000000n) {\n      const m = Number(this.n);\n      num %= m;\n      if (num < 0) num += m; // eslint-disable-next-line\n\n      return a.n == num;\n    }\n\n    if (num < 0) return a.n === BigInt(num) + this.n; // eslint-disable-next-line\n\n    return a.n == num;\n  }\n\n  isHigh(a) {\n    return !this.isLow(a);\n  }\n\n  isLow(a) {\n    this._verify1(a);\n\n    return a.n <= this.n >> 1n;\n  }\n\n  isOdd(a) {\n    this._verify1(a);\n\n    return a.isOdd();\n  }\n\n  isEven(a) {\n    this._verify1(a);\n\n    return a.isEven();\n  }\n\n  legendre(a) {\n    this._verify1(a);\n\n    return legendre(a.n, this.n);\n  }\n\n  jacobi(a) {\n    this._verify1(a);\n\n    return jacobi(a.n, this.n);\n  }\n\n  kronecker(a) {\n    this._verify1(a);\n\n    return kronecker(a.n, this.n);\n  }\n\n  iinvert(a) {\n    this._verify1(a);\n\n    a.n = invert(a.n, this.n);\n    return a;\n  }\n\n  invert(a) {\n    return this.iinvert(a.clone());\n  }\n\n  ifermat(a) {\n    this._verify1(a);\n\n    a.n = fermat(a.n, this.n);\n    return a;\n  }\n\n  fermat(a) {\n    return this.ifermat(a.clone());\n  }\n\n  [custom]() {\n    if (this.prime) return `<Red: ${this.prime.name}>`;\n    return `<Red: ${this.n.toString(10)}>`;\n  }\n\n}\n/*\n * Helpers\n */\n\n\nfunction makeError(Error, msg, start) {\n  const err = new Error(msg);\n  if (Error.captureStackTrace) Error.captureStackTrace(err, start);\n  return err;\n}\n\nfunction assert(value, message) {\n  if (!value) {\n    const msg = message || 'Assertion failed.';\n    throw makeError(Error, msg, assert);\n  }\n}\n\nfunction enforce(value, name, type) {\n  if (!value) {\n    const msg = `\"${name}\" must be a(n) ${type}.`;\n    throw makeError(TypeError, msg, enforce);\n  }\n}\n\nfunction range(value, name) {\n  if (!value) {\n    const msg = `\"${name}\" only works with positive numbers.`;\n    throw makeError(RangeError, msg, range);\n  }\n}\n\nfunction red(value, name) {\n  if (!value) {\n    const msg = `\"${name}\" only works with red numbers.`;\n    throw makeError(TypeError, msg, red);\n  }\n}\n\nfunction nonred(value, name) {\n  if (!value) {\n    const msg = `\"${name}\" only works with normal numbers.`;\n    throw makeError(TypeError, msg, nonred);\n  }\n}\n\nfunction nonzero(value) {\n  if (!value) {\n    const msg = 'Cannot divide by zero.';\n    throw makeError(RangeError, msg, nonzero);\n  }\n}\n\nfunction isInteger(num) {\n  return Number.isSafeInteger(num);\n}\n\nfunction isSMI(num) {\n  return isInteger(num) && num >= -0x3ffffff && num <= 0x3ffffff;\n}\n\nfunction allocate(ArrayType, size) {\n  if (ArrayType.allocUnsafe) return ArrayType.allocUnsafe(size);\n  return new ArrayType(size);\n}\n\nfunction getBase(base) {\n  if (base == null) return 10;\n  if (typeof base === 'number') return base;\n\n  switch (base) {\n    case 'bin':\n      return 2;\n\n    case 'oct':\n      return 8;\n\n    case 'dec':\n      return 10;\n\n    case 'hex':\n      return 16;\n  }\n\n  return 0;\n}\n\nfunction isFastBase(base) {\n  switch (base) {\n    case 2:\n    case 8:\n    case 10:\n    case 16:\n      return true;\n  }\n\n  return false;\n}\n\nfunction reverse(data) {\n  for (let i = data.length - 1, j = 0; i > j; i--, j++) [data[i], data[j]] = [data[j], data[i]];\n\n  return data;\n}\n/*\n * Multiplication + Shift\n */\n\n\nfunction mulShift(x, y, bits) {\n  const shift = BigInt(bits);\n  const neg = x < 0n ^ y < 0n;\n  let r = x * y;\n  if (neg) r = -r;\n  const b = r >> shift - 1n & 1n;\n  r >>= shift;\n  r += b;\n  if (neg) r = -r;\n  return r;\n}\n/*\n * Truncation Division + Modulo\n */\n\n\nfunction quorem(x, y) {\n  assert(y !== 0n);\n  const q = x / y;\n  const r = x - q * y;\n  return [q, r];\n}\n/*\n * Modulo\n */\n\n\nfunction remrn(x, y) {\n  assert(y !== 0);\n  return Number(x % BigInt(y));\n}\n/*\n * Euclidean Division + Modulo\n */\n\n\nfunction divmod(x, y) {\n  assert(y !== 0n);\n  let q = x / y;\n  let r = x - q * y;\n\n  if (r < 0n) {\n    if (y < 0n) {\n      q += 1n;\n      r -= y;\n    } else {\n      q -= 1n;\n      r += y;\n    }\n  }\n\n  return [q, r];\n}\n/*\n * Euclidean Division\n */\n\n\nfunction div(x, y) {\n  assert(y !== 0n);\n  let q = x / y;\n  if (x >= 0n) return q;\n  const r = x - q * y;\n\n  if (r < 0n) {\n    if (y < 0n) q += 1n;else q -= 1n;\n  }\n\n  return q;\n}\n/*\n * Euclidean Modulo\n */\n\n\nfunction mod(x, y) {\n  assert(y !== 0n);\n  let r = x % y;\n\n  if (r < 0n) {\n    if (y < 0n) r -= y;else r += y;\n  }\n\n  return r;\n}\n\nfunction modrn(x, y) {\n  let r = remrn(x, y);\n\n  if (r < 0) {\n    if (y < 0) r -= y;else r += y;\n  }\n\n  return r;\n}\n/*\n * Round Division\n */\n\n\nfunction divRound(x, y) {\n  assert(y !== 0n);\n  const half = y < 0n ? -(-y >> 1n) : y >> 1n;\n  if (x < 0n ^ y < 0n) return (x - half) / y;\n  return (x + half) / y;\n}\n/*\n * Roots\n */\n\n\nfunction _rootrem(y, pow, rem) {\n  if (pow === 0) throw new RangeError('Zeroth root.');\n  if (~pow & y < 0n) throw new RangeError('Negative with even root.');\n  if (y === -1n || y === 0n || y === 1n) return [y, 0n];\n  const exp = BigInt(pow);\n  let u = 0n;\n  let t = 1n << BigInt(bitLength(y) / pow + 1 | 0);\n  let v, r;\n  if (y < 0n) t = -t;\n\n  if (pow === 2) {\n    do {\n      u = t;\n      t = y / u;\n      t += u;\n      t >>= 1n;\n    } while (ucmp(t, u) < 0);\n  } else {\n    do {\n      u = t;\n      t = u ** (exp - 1n);\n      t = y / t;\n      v = u * (exp - 1n);\n      t += v;\n      t /= exp;\n    } while (ucmp(t, u) < 0);\n  }\n\n  if (rem) {\n    t = u ** exp;\n    r = y - t;\n  }\n\n  return [u, r];\n}\n\nfunction rootrem(y, pow) {\n  return _rootrem(y, pow, 1);\n}\n\nfunction root(y, pow) {\n  return _rootrem(y, pow, 0)[0];\n}\n\nfunction isPower(y, pow) {\n  if (pow === 0 || ~pow & y < 0n) return false;\n  const [, r] = rootrem(y, pow);\n  return r === 0n;\n}\n\nfunction sqrtrem(y) {\n  return rootrem(y, 2);\n}\n\nfunction sqrt(y) {\n  return root(y, 2);\n}\n\nfunction isSquare(y) {\n  return isPower(y, 2);\n}\n/*\n * Bit Manipulation\n */\n\n\nfunction mask(width) {\n  return (1n << BigInt(width)) - 1n;\n}\n\nfunction uand(x, y) {\n  const neg = x < 0n;\n  const num = abs(x) & abs(y);\n  return neg ? -num : num;\n}\n\nfunction uandn(x, y) {\n  return uand(x, BigInt(y));\n}\n\nfunction uor(x, y) {\n  const neg = x < 0n;\n  const num = abs(x) | abs(y);\n  return neg ? -num : num;\n}\n\nfunction uorn(x, y) {\n  return uor(x, BigInt(y));\n}\n\nfunction uxor(x, y) {\n  const neg = x < 0n;\n  const num = abs(x) ^ abs(y);\n  return neg ? -num : num;\n}\n\nfunction uxorn(x, y) {\n  return uxor(x, BigInt(y));\n}\n\nfunction ushr(x, y) {\n  if (x < 0n) return -(-x >> y);\n  return x >> y;\n}\n\nfunction ushrn(x, y) {\n  return ushr(x, BigInt(y));\n}\n\nfunction notn(x, width) {\n  const neg = x < 0n;\n  if (neg) x = -x;\n  x ^= mask(width);\n  if (neg) x = -x;\n  return x;\n}\n\nfunction setn(x, bit, val) {\n  if (val) x |= 1n << BigInt(bit);else x &= ~(1n << BigInt(bit));\n  return x;\n}\n\nfunction usetn(x, bit, val) {\n  const neg = x < 0n;\n  if (neg) x = -x;\n  x = setn(x, bit, val);\n  if (neg) x = -x;\n  return x;\n}\n\nfunction testn(x, bit) {\n  return Number(x >> BigInt(bit) & 1n);\n}\n\nfunction utestn(x, bit) {\n  return testn(abs(x), bit);\n}\n\nfunction maskn(x, width) {\n  return x & mask(width);\n}\n\nfunction umaskn(x, width) {\n  const neg = x < 0n;\n  if (neg) x = -x;\n  x &= mask(width);\n  if (neg) x = -x;\n  return x;\n}\n\nfunction andln(x, y) {\n  if (x < 0n) x = -x;\n  return Number(x & BigInt(y & 0x3ffffff));\n}\n/*\n * Negation\n */\n\n\nfunction abs(x) {\n  return x < 0n ? -x : x;\n}\n/*\n * Comparisons\n */\n\n\nfunction cmp(x, y) {\n  if (x < y) return -1;\n  if (x > y) return 1;\n  return 0;\n}\n\nfunction cmpn(x, y) {\n  // No polymorphism.\n  if (x < y) return -1;\n  if (x > y) return 1;\n  return 0;\n}\n/*\n * Unsigned Comparison\n */\n\n\nfunction ucmp(x, y) {\n  return cmp(abs(x), abs(y));\n}\n\nfunction ucmpn(x, y) {\n  return cmpn(abs(x), Math.abs(y));\n}\n/*\n * Number Theoretic Functions\n */\n\n\nfunction legendre(x, y) {\n  range(y > 0n, 'legendre');\n  if ((y & 1n) === 0n) throw new Error('legendre: `num` must be odd.'); // Euler's criterion.\n\n  const s = powm(x, y - 1n >> 1n, y);\n  const a = ceq(s, 0n);\n  const b = ceq(s, 1n);\n  const c = ceq(s, y - 1n); // Must be one of these.\n\n  if ((a | b | c) === 0) throw new Error('Invalid prime.'); // Cannot be multiple.\n\n  assert(a + b + c === 1); // 0, 1, or -1.\n\n  return b - c;\n}\n\nfunction jacobi(x, y) {\n  if (y === 0n || (y & 1n) === 0n) throw new Error('jacobi: `num` must be odd.');\n  let a = x;\n  let b = y;\n  let j = 1;\n\n  if (b < 0n) {\n    if (a < 0n) j = -1;\n    b = -b;\n  }\n\n  if (a < 0n) a = mod(a, b);\n\n  for (;;) {\n    if (b === 1n) return j;\n    if (a === 0n) return 0;\n    a %= b;\n    if (a === 0n) return 0;\n    const s = zeroBits(a);\n\n    if (s & 1) {\n      const bmod8 = b & 7n;\n      if (bmod8 === 3n || bmod8 === 5n) j = -j;\n    }\n\n    const c = a >> BigInt(s);\n    if ((b & 3n) === 3n && (c & 3n) === 3n) j = -j;\n    a = b;\n    b = c;\n  }\n}\n\nfunction kronecker(x, y) {\n  const table = [0, 1, 0, -1, 0, -1, 0, 1];\n  let a = x;\n  let b = y;\n  let s = 1;\n  if (b === 0n) return abs(a) === 1n ? s : 0;\n  if ((a & 1n) === 0n && (b & 1n) === 0n) return 0;\n  const z = zeroBits(b);\n  b >>= BigInt(z);\n  if (z & 1) s = table[Number(abs(a) & 7n)];\n\n  if (b < 0n) {\n    if (a < 0n) s = -s;\n    b = -b;\n  }\n\n  for (;;) {\n    if (a === 0n) return b === 1n ? s : 0;\n    const z = zeroBits(a);\n    a >>= BigInt(z);\n    if (z & 1) s *= table[Number(b & 7n)];\n    const w = a < 0n ? -a ^ 3n : a;\n    if ((w & b & 2n) !== 0n) s = -s;\n    b = mod(b, a);\n    [a, b] = [b, a];\n    if (b < 0n) b = -b;\n  }\n}\n\nfunction gcd(x, y) {\n  x = abs(x);\n  y = abs(y);\n\n  while (y !== 0n) [x, y] = [y, x % y];\n\n  return x;\n}\n\nfunction lcm(x, y) {\n  if (x === 0n || y === 0n) return 0n;\n  return abs(x / gcd(x, y) * y);\n}\n\nfunction egcd(x, y) {\n  let s = 0n;\n  let os = 1n;\n  let t = 1n;\n  let ot = 0n;\n  let r = abs(y);\n  let or = abs(x);\n\n  while (r !== 0n) {\n    const q = or / r;\n    [or, r] = [r, or - q * r];\n    [os, s] = [s, os - q * s];\n    [ot, t] = [t, ot - q * t];\n  }\n\n  if (or < 0n) {\n    or = -or;\n    os = -os;\n    ot = -ot;\n  }\n\n  if (x < 0n) os = -os;\n  if (y < 0n) ot = -ot;\n  return [os, ot, or];\n}\n\nfunction invert(x, y) {\n  assert(y > 0n);\n  if (y === 1n) throw new RangeError('Not invertible.');\n  if (x < 0n || x >= y) x = mod(x, y);\n  let t = 0n;\n  let nt = 1n;\n  let r = y;\n  let nr = x;\n\n  while (nr !== 0n) {\n    const q = r / nr;\n    [t, nt] = [nt, t - q * nt];\n    [r, nr] = [nr, r - q * nr];\n  }\n\n  if (r < 0n) {\n    r = -r;\n    t = -t;\n  }\n\n  if (r !== 1n) throw new RangeError('Not invertible.');\n  if (t < 0n) t += y;\n  return t;\n}\n\nfunction fermat(x, y) {\n  assert(y > 0n);\n  if (y === 1n) throw new RangeError('Not invertible.'); // Invert using fermat's little theorem.\n\n  const inv = powm(x, y - 2n, y);\n  if (inv === 0n) throw new RangeError('Not invertible.');\n  return inv;\n}\n\nfunction powm(x, e, m, size) {\n  assert(m > 0n); // GMP behavior.\n\n  if (e < 0n) {\n    x = invert(x, m);\n    e = -e;\n  } else {\n    x = mod(x, m);\n  }\n\n  if (size != null) return climb(x, e, m, size);\n  return rtl(x, e, m);\n}\n\nfunction rtl(x, e, m) {\n  let r = 1n;\n\n  while (e > 0n) {\n    if ((e & 1n) === 1n) r = r * x % m;\n    x = x * x % m;\n    e >>= 1n;\n  }\n\n  return r;\n}\n\nfunction climb(x, e, m, size) {\n  const bits = Math.max(bitLength(e), size >>> 0);\n  const bytes = bits + 7 >>> 3;\n  const exp = toBuffer(e, 'le', bytes);\n  let y = 1n;\n  let swap = 0;\n\n  for (let i = bits - 1; i >= 0; i--) {\n    const bit = exp[i >> 3] >> (i & 7) & 1;\n    [x, y] = cswap(x, y, swap ^ bit);\n    x = x * y % m;\n    y = y * y % m;\n    swap = bit;\n  }\n\n  [x, y] = cswap(x, y, swap);\n  return y;\n}\n\nfunction sqrtm(x, p) {\n  assert(p > 0n);\n  if (x < 0n || x >= p) x = mod(x, p);\n  if ((p & 3n) === 3n) return sqrt3mod4(x, p);\n  if ((p & 7n) === 5n) return sqrt5mod8(x, p);\n  return sqrt0(x, p);\n}\n\nfunction sqrt3mod4(x, p) {\n  const e = p + 1n >> 2n;\n  const b = powm(x, e, p);\n  if (b * b % p !== x) throw new Error('X is not a square mod P.');\n  return b;\n}\n\nfunction sqrt5mod8(x, p) {\n  const e = p >> 3n;\n  const t = x << 1n;\n  const a = powm(t, e, p);\n  let b = a * a % p;\n  b = b * t % p;\n  b = mod(b - 1n, p);\n  b = b * x % p;\n  b = b * a % p;\n  if (b * b % p !== x) throw new Error('X is not a square mod P.');\n  return b;\n}\n\nfunction sqrt5mod8sm1(x, p, sm1) {\n  const e = p + 3n >> 3n;\n  let b = powm(x, e, p);\n\n  if (b * b % p !== x) {\n    b = b * sm1 % p;\n    if (b * b % p !== x) throw new Error('X is not a square mod P.');\n  }\n\n  return b;\n}\n\nfunction sqrt0(x, p) {\n  if (p === 1n || (p & 1n) === 0n) throw new Error('Invalid prime.');\n\n  switch (jacobi(x, p)) {\n    case -1:\n      throw new Error('X is not a square mod P.');\n\n    case 0:\n      return 0n;\n\n    case 1:\n      break;\n  }\n\n  let s = p - 1n;\n  const e = BigInt(zeroBits(s));\n  s >>= e;\n  let n = 2n;\n\n  while (jacobi(n, p) !== -1) n += 1n;\n\n  let y = powm(x, s + 1n >> 1n, p);\n  let b = powm(x, s, p);\n  let g = powm(n, s, p);\n  let k = e;\n\n  for (;;) {\n    let t = b;\n    let m = 0n;\n\n    while (t !== 1n) {\n      t = t * t % p;\n      m += 1n;\n    }\n\n    if (m === 0n) break;\n    assert(m < k);\n    t = 1n << k - m - 1n;\n    t = powm(g, t, p);\n    g = t * t % p;\n    y = y * t % p;\n    b = b * g % p;\n    k = m;\n  }\n\n  return y;\n}\n\nfunction divsqrt(u, v, p, sm1) {\n  assert(p > 0n);\n  if (u < 0n || u >= p) u = mod(u, p);\n  if (v < 0n || v >= p) v = mod(v, p); // v = 0\n\n  if (v === 0n) throw new RangeError('Not invertible.'); // p = 3 mod 4\n\n  if ((p & 3n) === 3n) return divsqrt3mod4(u, v, p); // p = 5 mod 8\n\n  if (sm1 != null && (p & 7n) === 5n) return divsqrt5mod8(u, v, p, sm1);\n  return sqrtm(u * invert(v, p), p);\n}\n\nfunction divsqrt3mod4(u, v, p) {\n  // x = u^3 * v * (u^5 * v^3)^((p - 3) / 4) mod p\n  const e = p - 3n >> 2n;\n  const u2 = u * u % p;\n  const u3 = u2 * u % p;\n  const u5 = u3 * u2 % p;\n  const v3 = v * v * v % p;\n  const q = powm(u5 * v3, e, p);\n  const x = u3 * v * q % p;\n  const c = v * x * x % p;\n  if (c === u) return x;\n  throw new Error('X is not a square mod P.');\n}\n\nfunction divsqrt5mod8(u, v, p, sm1) {\n  // x = u * v^3 * (u * v^7)^((p - 5) / 8) mod p\n  const e = p - 5n >> 3n;\n  const v3 = v * v * v % p;\n  const v7 = v3 * v3 * v % p;\n  const q = powm(u * v7, e, p);\n  const x = u * v3 * q % p;\n  const c = v * x * x % p;\n  if (c === u) return x;\n  if (c === mod(-u, p)) return x * sm1 % p;\n  throw new Error('X is not a square mod P.');\n}\n\nfunction sqrtpq(x, p, q) {\n  assert(p > 0n);\n  assert(q > 0n);\n  const sp = sqrtm(x, p);\n  const sq = sqrtm(x, q);\n  const [mp, mq] = egcd(p, q);\n  return mod(sq * mp * p + sp * mq * q, p * q);\n}\n/*\n * Primality Testing\n */\n\n\nfunction isPrimeMR(n, rng, reps) {\n  let force2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  enforce(reps >>> 0 === reps, 'reps', 'uint32');\n  enforce(reps > 0, 'reps', 'integer');\n  enforce(typeof force2 === 'boolean', 'force2', 'boolean');\n\n  if (n < 7n) {\n    return n === 2n || n === 3n || n === 5n;\n  }\n\n  if ((n & 1n) === 0n) return false;\n  const nm1 = n - 1n;\n  const nm3 = nm1 - 2n;\n  const k = zeroBits(nm1);\n  const q = nm1 >> BigInt(k);\n\n  next: for (let i = 0; i < reps; i++) {\n    let x, y;\n\n    if (i === reps - 1 && force2) {\n      x = 2n;\n    } else {\n      x = random(rng, 0n, nm3);\n      x += 2n;\n    }\n\n    y = powm(x, q, n);\n    if (y === 1n || y === nm1) continue;\n\n    for (let j = 1; j < k; j++) {\n      y = y * y % n;\n      if (y === nm1) continue next;\n      if (y === 1n) return false;\n    }\n\n    return false;\n  }\n\n  return true;\n}\n\nfunction isPrimeLucas(n) {\n  let limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  enforce(limit >>> 0 === limit, 'limit', 'uint32'); // Ignore 0 and 1.\n\n  if (n <= 1n) return false; // Two is the only even prime.\n\n  if ((n & 1n) === 0n) return n === 2n;\n  let p = 3n;\n\n  for (;;) {\n    if (p > 10000n) {\n      // Thought to be impossible.\n      throw new Error(`Cannot find (D/n) = -1 for ${n.toString(10)}.`);\n    }\n\n    if (limit !== 0 && p > limit) {\n      // Optional DoS limit.\n      return false;\n    }\n\n    const d = p * p - 4n;\n    const j = jacobi(d, n);\n    if (j === -1) break;\n    if (j === 0) return n === p + 2n;\n\n    if (p === 40n) {\n      if (isSquare(n)) return false;\n    }\n\n    p += 1n;\n  }\n\n  let s = n + 1n;\n  const r = zeroBits(s);\n  const nm2 = n - 2n;\n  let x = 2n;\n  let y = p;\n  s >>= BigInt(r);\n\n  for (let i = BigInt(bitLength(s)); i >= 0n; i--) {\n    if (s & 1n << i) {\n      x = mod(x * y + n - p, n);\n      y = mod(y * y + nm2, n);\n    } else {\n      y = mod(y * x + n - p, n);\n      x = mod(x * x + nm2, n);\n    }\n  }\n\n  if (x === 2n || x === nm2) {\n    let a = x * p;\n    let b = y << 1n;\n    if (a < b) [a, b] = [b, a];\n    if ((a - b) % n === 0n) return true;\n  }\n\n  for (let t = 0; t < r - 1; t++) {\n    if (x === 0n) return true;\n    if (x === 2n) return false;\n    x = mod(x * x - 2n, n);\n  }\n\n  return false;\n}\n/*\n * Twos Complement\n */\n\n\nfunction toTwos(x, width) {\n  if (x < 0n) return notn(-x, width) + 1n;\n  return x;\n}\n\nfunction fromTwos(x, width) {\n  if (testn(x, width - 1)) return -(notn(x, width) + 1n);\n  return x;\n}\n/*\n * Helpers\n */\n\n\nfunction countWords(x, w) {\n  if (x === 0n) return 0;\n  if (x < 0n) x = -x;\n  let i = 0;\n\n  while (x >= U256_MAX) {\n    i += 256;\n    x >>= 256n;\n  }\n\n  while (x >= U128_MAX) {\n    i += 128;\n    x >>= 128n;\n  }\n\n  while (x >= U64_MAX) {\n    i += 64;\n    x >>= 64n;\n  }\n\n  while (x >= U32_MAX) {\n    i += 32;\n    x >>= 32n;\n  }\n\n  while (x >= U16_MAX) {\n    i += 16;\n    x >>= 16n;\n  }\n\n  while (x >= U8_MAX) {\n    i += 8;\n    x >>= 8n;\n  }\n\n  while (x > 0n) {\n    i += 1;\n    x >>= 1n;\n  }\n\n  return (i + (w - 1)) / w >>> 0;\n}\n\nfunction byteLength(x) {\n  return countWords(x, 8);\n}\n\nfunction bitLength(x) {\n  return countWords(x, 1);\n}\n\nfunction zeroBits(x) {\n  if (x === 0n) return 0;\n  if (x < 0n) x = -x;\n  let i = 0;\n\n  while ((x & U32_MAX) === 0n) {\n    i += 32;\n    x >>= 32n;\n  }\n\n  while ((x & U16_MAX) === 0n) {\n    i += 16;\n    x >>= 16n;\n  }\n\n  while ((x & U8_MAX) === 0n) {\n    i += 8;\n    x >>= 8n;\n  }\n\n  while ((x & 1n) === 0n) {\n    i += 1;\n    x >>= 1n;\n  }\n\n  return i;\n}\n\nfunction word(n, pos) {\n  return Number(abs(n) >> BigInt(pos * 26) & 0x3ffffffn);\n}\n/*\n * Constant Time (sort of)\n */\n\n\nfunction ceq(x, y) {\n  return (x ^ y) === 0n | 0;\n}\n\nfunction ceqn(x, y) {\n  return (x ^ BigInt(y)) === 0n | 0;\n}\n\nfunction cswap(x, y, flag) {\n  const bit = BigInt(flag);\n  const a = x * (bit ^ 1n) + y * bit;\n  const b = y * (bit ^ 1n) + x * bit;\n  return [a, b];\n}\n\nfunction cinject(x, y, flag) {\n  const bit = BigInt(flag);\n  return x * (bit ^ 1n) + y * bit;\n}\n\nfunction cset(x, y, flag) {\n  const bit = BigInt(flag);\n  return x * (bit ^ 1n) + BigInt(y) * bit;\n}\n/*\n * Conversion\n */\n\n\nfunction toString(num, base, padding) {\n  base = getBase(base);\n  if (padding == null) padding = 0;\n  if (padding === 0) padding = 1;\n  enforce(base >>> 0 === base, 'base', 'uint32');\n  enforce(padding >>> 0 === padding, 'padding', 'uint32');\n  if (base < 2 || base > 36) throw new RangeError('Base ranges between 2 and 36.');\n  let neg = false;\n\n  if (num < 0n) {\n    neg = true;\n    num = -num;\n  }\n\n  let str = num.toString(base);\n\n  while (str.length % padding) str = '0' + str;\n\n  if (neg) str = '-' + str;\n  return str;\n}\n\nfunction fromString(str, base) {\n  base = getBase(base);\n  enforce(typeof str === 'string', 'str', 'string');\n  enforce(base >>> 0 === base, 'base', 'uint32');\n  if (base < 2 || base > 36) throw new RangeError('Base ranges between 2 and 36.');\n  if (isFastBase(base)) return fromStringFast(str, base);\n  let neg = false;\n  let i = 0;\n\n  for (; i < str.length; i++) {\n    const ch = str.charCodeAt(i);\n\n    switch (ch) {\n      case 0x09: // '\\t'\n\n      case 0x0a: // '\\n'\n\n      case 0x0d: // '\\r'\n\n      case 0x20:\n        // ' '\n        continue;\n    }\n\n    break;\n  }\n\n  if (i < str.length && str.charCodeAt(i) === 0x2d) {\n    neg = true;\n    i += 1;\n  }\n\n  const big = BigInt(base);\n  let num = 0n;\n\n  for (; i < str.length; i++) {\n    let ch = str.charCodeAt(i);\n\n    switch (ch) {\n      case 0x09: // '\\t'\n\n      case 0x0a: // '\\n'\n\n      case 0x0d: // '\\r'\n\n      case 0x20:\n        // ' '\n        continue;\n    }\n\n    if (ch >= 0x30 && ch <= 0x39) ch -= 0x30;else if (ch >= 0x41 && ch <= 0x5a) ch -= 0x41 - 10;else if (ch >= 0x61 && ch <= 0x7a) ch -= 0x61 - 10;else ch = base;\n    if (ch >= base) throw new Error('Invalid string.');\n    num *= big;\n    num += BigInt(ch);\n  }\n\n  if (neg) num = -num;\n  return num;\n}\n\nfunction fromStringFast(str, base) {\n  let neg = false;\n  let num;\n  str = str.replace(/\\s+/g, '');\n\n  if (str.length > 0 && str.charCodeAt(0) === 0x2d) {\n    str = str.substring(1);\n    neg = true;\n  }\n\n  switch (base) {\n    case 2:\n      str = '0b' + str;\n      break;\n\n    case 8:\n      str = '0o' + str;\n      break;\n\n    case 10:\n      if (str.length > 1) {\n        const ch = str.charCodeAt(1);\n        if (ch < 0x30 || ch > 0x39) throw new Error('Invalid string.');\n      }\n\n      break;\n\n    case 16:\n      str = '0x' + str;\n      break;\n\n    default:\n      throw new Error('Invalid base.');\n  }\n\n  try {\n    num = BigInt(str);\n  } catch (e) {\n    throw new Error('Invalid string.');\n  }\n\n  if (neg) num = -num;\n  return num;\n}\n\nfunction toBuffer(n, endian, length) {\n  if (endian == null) endian = 'be';\n  if (length == null) length = 0;\n  enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');\n  enforce(length >>> 0 === length, 'length', 'uint32'); // Leverage node's hex parser for faster\n  // serialization. To-stringing the number\n  // is 14 times faster than counting the\n  // bytes and shifting them off.\n\n  let str = abs(n).toString(16);\n  if (str.length & 1) str = '0' + str;\n  const bytes = str.length >>> 1;\n  const size = length || Math.max(1, bytes);\n  if (bytes > size) throw new RangeError('Byte array longer than desired length.');\n  const hex = str.padStart(size * 2, '00');\n  const out = Buffer.from(hex, 'hex'); // Reverse the buffer in-place.\n\n  if (endian === 'le') reverse(out);\n  return out;\n}\n\nfunction fromBuffer(data, endian) {\n  if (endian == null) endian = 'be'; // 13x speedup if on an arch with the same endianness\n  // and the data is properly aligned to 64 bits.\n  // 5.5x speedup if on an arch with differing endianness.\n\n  enforce(Buffer.isBuffer(data), 'data', 'buffer');\n  enforce(endian === 'be' || endian === 'le', 'endian', 'endianness'); // Convert to machine endianness.\n  // Note that the node.js buffer pool\n  // always aligns slices to 8 bytes.\n\n  if (endian !== ENDIAN) data = reverse(Buffer.from(data)); // Byte offsets for typed arrays must\n  // be aligned to their word size.\n\n  const unaligned = data.byteOffset & 7; // Forcefully align. We will read\n  // some data that's not our's.\n\n  if (unaligned) {\n    data = Buffer.from(data.buffer, data.byteOffset - unaligned, unaligned + data.byteLength);\n  } // Read buffer as a uint64 array.\n\n\n  const arr = new BigUint64Array(data.buffer, data.byteOffset, data.length >>> 3);\n  const left = data.length & 7;\n  const start = data.length - left;\n  let n = 0n;\n\n  if (ENDIAN === 'be') {\n    for (let i = 0; i < arr.length; i++) {\n      n <<= 64n;\n      n |= arr[i];\n    }\n\n    for (let i = start; i < data.length; i++) {\n      n <<= 8n;\n      n |= BigInt(data[i]);\n    } // Realign.\n\n\n    if (unaligned) n &= mask((data.length - unaligned) * 8);\n  } else {\n    for (let i = data.length - 1; i >= start; i--) {\n      n <<= 8n;\n      n |= BigInt(data[i]);\n    }\n\n    for (let i = arr.length - 1; i >= 0; i--) {\n      n <<= 64n;\n      n |= arr[i];\n    } // Realign.\n\n\n    if (unaligned) n >>= BigInt(unaligned * 8);\n  }\n\n  return n;\n}\n\nfunction toArrayLike(n, ArrayType, endian, length) {\n  if (endian == null) endian = 'be';\n  if (length == null) length = 0;\n  enforce(typeof ArrayType === 'function', 'ArrayType', 'function');\n  enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');\n  enforce(length >>> 0 === length, 'length', 'uint32');\n  const bytes = byteLength(n);\n  const size = length || Math.max(1, bytes);\n  if (bytes > size) throw new RangeError('Byte array longer than desired length.');\n  const res = allocate(ArrayType, size);\n  let q = abs(n);\n\n  if (endian === 'be') {\n    let i = size - 1;\n\n    while (q > 0n) {\n      res[i--] = Number(q & 0xffn);\n      q >>= 8n;\n    }\n\n    for (; i >= 0; i--) res[i] = 0x00;\n  } else {\n    let i = 0;\n\n    while (q > 0n) {\n      res[i++] = Number(q & 0xffn);\n      q >>= 8n;\n    }\n\n    for (; i < size; i++) res[i] = 0x00;\n  }\n\n  return res;\n}\n\nfunction fromArrayLike(data, endian) {\n  if (endian == null) endian = 'be';\n  enforce(data && data.length >>> 0 === data.length, 'data', 'array-like');\n  enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');\n  let n = 0n;\n\n  if (endian === 'be') {\n    for (let i = 0; i < data.length; i++) {\n      n <<= 8n;\n      n |= BigInt(data[i] & 0xff);\n    }\n  } else {\n    for (let i = data.length - 1; i >= 0; i--) {\n      n <<= 8n;\n      n |= BigInt(data[i] & 0xff);\n    }\n  }\n\n  return n;\n}\n/*\n * RNG\n */\n\n\nfunction randomBits(rng, bits) {\n  enforce(rng != null, 'rng', 'rng');\n  enforce(bits >>> 0 === bits, 'bits', 'uint32');\n\n  if (typeof rng === 'object') {\n    enforce(typeof rng.randomBytes === 'function', 'rng', 'rng');\n    const size = bits + 7 >>> 3;\n    const total = size * 8;\n    const bytes = rng.randomBytes(size);\n    enforce(Buffer.isBuffer(bytes), 'bytes', 'buffer');\n    if (bytes.length !== size) throw new RangeError('Invalid number of bytes returned from RNG.');\n    let num = fromBuffer(bytes);\n    if (total > bits) num >>= BigInt(total - bits);\n    return num;\n  }\n\n  enforce(typeof rng === 'function', 'rng', 'rng');\n  const num = rng(bits);\n  enforce(BN.isBN(num), 'num', 'bignum');\n  range(num.negative === 0, 'RNG');\n  nonred(!num.red, 'RNG');\n  if (num.bitLength() > bits) throw new RangeError('Invalid number of bits returned from RNG.');\n  return num.n;\n}\n\nfunction random(rng, min, max) {\n  if (min > max) throw new RangeError('Minimum cannot be greater than maximum.');\n  const space = abs(max - min);\n  const bits = bitLength(space);\n  if (bits === 0) return min;\n\n  for (;;) {\n    let num = randomBits(rng, bits); // Maximum is _exclusive_!\n\n    if (num >= space) continue; // Minimum is _inclusive_!\n\n    num += min;\n    return num;\n  }\n}\n/*\n * Expose\n */\n\n\nBN.Red = Red;\nmodule.exports = BN;","map":null,"metadata":{},"sourceType":"script"}