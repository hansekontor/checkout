{"ast":null,"code":"/*!\n * output.js - output object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bio = require('bufio');\n\nconst Amount = require('../btc/amount');\n\nconst Network = require('../protocol/network');\n\nconst Address = require('../primitives/address');\n\nconst Script = require('../script/script');\n\nconst SLP = require('../script/slp');\n\nconst policy = require('../protocol/policy');\n\nconst {\n  inspectSymbol\n} = require('../utils');\n/**\n * Represents a transaction output.\n * @alias module:primitives.Output\n * @property {Amount} value\n * @property {Script} script\n * @property {SlpCoinRecord?} slp\n */\n\n\nclass Output {\n  /**\n   * Create an output.\n   * @constructor\n   * @param {Object?} options\n   */\n  constructor(options) {\n    this.value = 0;\n    this.script = new Script();\n    if (options) this.fromOptions(options);\n  }\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n\n  fromOptions(options) {\n    assert(options, 'Output data is required.');\n\n    if (options.value) {\n      assert(Number.isSafeInteger(options.value) && options.value >= 0, 'Value must be a uint64.');\n      this.value = options.value;\n    }\n\n    if (options.script) this.script.fromOptions(options.script);\n    if (options.address) this.script.fromAddress(options.address);\n\n    if (options.slp) {\n      if (options.slp.constructor === SLP.SlpCoinRecord().constructor) this.slp = options.slp;\n    }\n\n    return this;\n  }\n  /**\n   * Instantiate output from options object.\n   * @param {Object} options\n   * @returns {Output}\n   */\n\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  } //   /**\n  //    * Inject properties from script/value pair.\n  //    * @private\n  //    * @param {Script|Address} script\n  //    * @param {Amount} value\n  //    * @returns {Output}\n  //    */\n  //   fromScript(script, value) {\n  //     if (typeof script === 'string')\n  //       script = Address.fromString(script);\n  //     if (script instanceof Address)\n  //       script = Script.fromAddress(script);\n  //     assert(script instanceof Script, 'Script must be a Script.');\n  //     assert(Number.isSafeInteger(value) && value >= 0,\n  //       'Value must be a uint64.');\n  //     this.script = script;\n  //     this.value = value;\n  //     return this;\n  //   }\n  //   /**\n  //    * Instantiate output from script/value pair.\n  //    * @param {Script|Address} script\n  //    * @param {Amount} value\n  //    * @returns {Output}\n  //    */\n  //   static fromScript(script, value) {\n  //     return new this().fromScript(script, value);\n  //   }\n  //   /**\n  //    * Clone the output.\n  //    * @returns {Output}\n  //    */\n  //   clone() {\n  //     const output = new this.constructor();\n  //     output.value = this.value;\n  //     output.script.inject(this.script);\n  //     return output;\n  //   }\n  //   /**\n  //    * Test equality against another output.\n  //    * @param {Output} output\n  //    * @returns {Boolean}\n  //    */\n  //   equals(output) {\n  //     assert(Output.isOutput(output));\n  //     return this.value === output.value\n  //       && this.script.equals(output.script);\n  //   }\n  //   /**\n  //    * Compare against another output (BIP69).\n  //    * @param {Output} output\n  //    * @returns {Number}\n  //    */\n  //   compare(output) {\n  //     assert(Output.isOutput(output));\n  //     const cmp = this.value - output.value;\n  //     if (cmp !== 0)\n  //       return cmp;\n  //     return this.script.compare(output.script);\n  //   }\n  //   /**\n  //    * Get the script type as a string.\n  //    * @returns {ScriptType} type\n  //    */\n  //   getType() {\n  //     return Script.typesByVal[this.script.getType()].toLowerCase();\n  //   }\n\n  /**\n   * Get the address.\n   * @returns {Address} address\n   */\n\n\n  getAddress() {\n    return this.script.getAddress();\n  }\n  /**\n   * Get the address hash.\n   * @param {String?} enc\n   * @returns {Hash} hash\n   */\n\n\n  getHash(enc) {\n    const addr = this.getAddress();\n    if (!addr) return null;\n    return addr.getHash(enc);\n  } //   /**\n  //    * Convert the input to a more user-friendly object.\n  //    * @returns {Object}\n  //    */\n  //   [inspectSymbol]() {\n  //     const hr = {\n  //       type: this.getType(),\n  //       value: Amount.btc(this.value),\n  //       script: this.script,\n  //       address: this.getAddress()\n  //     };\n  //     if (this.slp) {\n  //       return {\n  //         ...hr,\n  //         slp: this.slp\n  //       }\n  //     }\n  //     return hr;\n  //   }\n  //   /**\n  //    * Convert the output to an object suitable\n  //    * for JSON serialization.\n  //    * @returns {Object}\n  //    */\n  //   toJSON() {\n  //     return this.getJSON();\n  //   }\n  //   /**\n  //    * Convert the output to an object suitable\n  //    * for JSON serialization.\n  //    * @param {Network} network\n  //    * @returns {Object}\n  //    */\n  //   getJSON(network) {\n  //     let addr = this.getAddress();\n  //     network = Network.get(network);\n  //     if (addr)\n  //       addr = addr.toString(network);\n  //     const json = {\n  //       value: this.value,\n  //       script: this.script.toJSON(),\n  //       address: addr\n  //     };\n  //     if (this.slp) {\n  //       return {\n  //         ...json,\n  //         slp: this.slp.getJSON()\n  //       }\n  //     }\n  //     return json;\n  //   }\n  //   /**\n  //    * Calculate the dust threshold for this\n  //    * output, based on serialize size and rate.\n  //    * @param {Rate?} rate\n  //    * @returns {Amount}\n  //    */\n  //   getDustThreshold(rate) {\n  //     if (this.script.isUnspendable())\n  //       return 0;\n  //     let size = this.getSize();\n  //     size += 32 + 4 + 1 + 107 + 4;\n  //     return 3 * policy.getMinFee(size, rate);\n  //   }\n  //   /**\n  //    * Calculate size of serialized output.\n  //    * @returns {Number}\n  //    */\n  //   getSize() {\n  //     return 8 + this.script.getVarSize();\n  //   }\n  //   /**\n  //    * Test whether the output should be considered dust.\n  //    * @param {Rate?} rate\n  //    * @returns {Boolean}\n  //    */\n  //   isDust(rate) {\n  //     return this.value < this.getDustThreshold(rate);\n  //   }\n  //   /**\n  //    * Inject properties from a JSON object.\n  //    * @private\n  //    * @param {Object} json\n  //    */\n  //   fromJSON(json) {\n  //     assert(json, 'Output data is required.');\n  //     assert(Number.isSafeInteger(json.value) && json.value >= 0,\n  //       'Value must be a uint64.');\n  //     this.value = json.value;\n  //     this.script.fromJSON(json.script);\n  //     if (json.slp) {\n  //       this.slp = SLP.SlpCoinRecord().fromJSON(json.slp)\n  //     }\n  //     return this;\n  //   }\n  //   /**\n  //    * Instantiate an Output from a jsonified output object.\n  //    * @param {Object} json - The jsonified output object.\n  //    * @returns {Output}\n  //    */\n  //   static fromJSON(json) {\n  //     return new this().fromJSON(json);\n  //   }\n  //   /**\n  //    * Write the output to a buffer writer.\n  //    * @param {BufferWriter} bw\n  //    */\n  //   toWriter(bw) {\n  //     bw.writeI64(this.value);\n  //     bw.writeVarBytes(this.script.toRaw());\n  //     return bw;\n  //   }\n  //   /**\n  //    * Serialize the output.\n  //    * @param {String?} enc - Encoding, can be `'hex'` or null.\n  //    * @returns {Buffer|String}\n  //    */\n  //   toRaw() {\n  //     const size = this.getSize();\n  //     return this.toWriter(bio.write(size)).render();\n  //   }\n  //   /**\n  //    * Inject properties from buffer reader.\n  //    * @private\n  //    * @param {BufferReader} br\n  //    */\n  //   fromReader(br) {\n  //     this.value = br.readI64();\n  //     this.script.fromRaw(br.readVarBytes());\n  //     return this;\n  //   }\n  //   /**\n  //    * Inject properties from serialized data.\n  //    * @private\n  //    * @param {Buffer} data\n  //    */\n  //   fromRaw(data) {\n  //     return this.fromReader(bio.read(data));\n  //   }\n  //   /**\n  //    * Instantiate an output from a buffer reader.\n  //    * @param {BufferReader} br\n  //    * @returns {Output}\n  //    */\n  //   static fromReader(br) {\n  //     return new this().fromReader(br);\n  //   }\n  //   /**\n  //    * Instantiate an output from a serialized Buffer.\n  //    * @param {Buffer} data\n  //    * @param {String?} enc - Encoding, can be `'hex'` or null.\n  //    * @returns {Output}\n  //    */\n  //   static fromRaw(data, enc) {\n  //     if (typeof data === 'string')\n  //       data = Buffer.from(data, enc);\n  //     return new this().fromRaw(data);\n  //   }\n  //   /**\n  //    * Test an object to see if it is an Output.\n  //    * @param {Object} obj\n  //    * @returns {Boolean}\n  //    */\n  //   static isOutput(obj) {\n  //     return obj instanceof Output;\n  //   }\n\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = Output;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/primitives/output.js"],"names":["assert","require","bio","Amount","Network","Address","Script","SLP","policy","inspectSymbol","Output","constructor","options","value","script","fromOptions","Number","isSafeInteger","address","fromAddress","slp","SlpCoinRecord","getAddress","getHash","enc","addr","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,OAAD,CAAtB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,eAAD,CAAtB;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMI,OAAO,GAAGJ,OAAO,CAAC,uBAAD,CAAvB;;AACA,MAAMK,MAAM,GAAGL,OAAO,CAAC,kBAAD,CAAtB;;AACA,MAAMM,GAAG,GAAGN,OAAO,CAAC,eAAD,CAAnB;;AACA,MAAMO,MAAM,GAAGP,OAAO,CAAC,oBAAD,CAAtB;;AACA,MAAM;AAACQ,EAAAA;AAAD,IAAkBR,OAAO,CAAC,UAAD,CAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMS,MAAN,CAAa;AACX;AACF;AACA;AACA;AACA;AAEEC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB,SAAKC,KAAL,GAAa,CAAb;AACA,SAAKC,MAAL,GAAc,IAAIR,MAAJ,EAAd;AAEA,QAAIM,OAAJ,EACE,KAAKG,WAAL,CAAiBH,OAAjB;AACH;AAED;AACF;AACA;AACA;AACA;;;AAEEG,EAAAA,WAAW,CAACH,OAAD,EAAU;AACnBZ,IAAAA,MAAM,CAACY,OAAD,EAAU,0BAAV,CAAN;;AAEA,QAAIA,OAAO,CAACC,KAAZ,EAAmB;AACjBb,MAAAA,MAAM,CAACgB,MAAM,CAACC,aAAP,CAAqBL,OAAO,CAACC,KAA7B,KAAuCD,OAAO,CAACC,KAAR,IAAiB,CAAzD,EACJ,yBADI,CAAN;AAEA,WAAKA,KAAL,GAAaD,OAAO,CAACC,KAArB;AACD;;AAED,QAAID,OAAO,CAACE,MAAZ,EACE,KAAKA,MAAL,CAAYC,WAAZ,CAAwBH,OAAO,CAACE,MAAhC;AAEF,QAAIF,OAAO,CAACM,OAAZ,EACE,KAAKJ,MAAL,CAAYK,WAAZ,CAAwBP,OAAO,CAACM,OAAhC;;AAEF,QAAIN,OAAO,CAACQ,GAAZ,EAAiB;AACf,UAAIR,OAAO,CAACQ,GAAR,CAAYT,WAAZ,KAA4BJ,GAAG,CAACc,aAAJ,GAAoBV,WAApD,EACE,KAAKS,GAAL,GAAWR,OAAO,CAACQ,GAAnB;AACH;;AAED,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEoB,SAAXL,WAAW,CAACH,OAAD,EAAU;AAC1B,WAAO,IAAI,IAAJ,GAAWG,WAAX,CAAuBH,OAAvB,CAAP;AACD,GApDU,CAsDb;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEE;AACF;AACA;AACA;;;AAEEU,EAAAA,UAAU,GAAG;AACX,WAAO,KAAKR,MAAL,CAAYQ,UAAZ,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEEC,EAAAA,OAAO,CAACC,GAAD,EAAM;AACX,UAAMC,IAAI,GAAG,KAAKH,UAAL,EAAb;AAEA,QAAI,CAACG,IAAL,EACE,OAAO,IAAP;AAEF,WAAOA,IAAI,CAACF,OAAL,CAAaC,GAAb,CAAP;AACD,GAlKU,CAoKb;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AA7Wa;AAgXb;AACA;AACA;;;AAEAE,MAAM,CAACC,OAAP,GAAiBjB,MAAjB","sourcesContent":["/*!\n * output.js - output object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bio = require('bufio');\nconst Amount = require('../btc/amount');\nconst Network = require('../protocol/network');\nconst Address = require('../primitives/address');\nconst Script = require('../script/script');\nconst SLP = require('../script/slp');\nconst policy = require('../protocol/policy');\nconst {inspectSymbol} = require('../utils');\n\n/**\n * Represents a transaction output.\n * @alias module:primitives.Output\n * @property {Amount} value\n * @property {Script} script\n * @property {SlpCoinRecord?} slp\n */\n\nclass Output {\n  /**\n   * Create an output.\n   * @constructor\n   * @param {Object?} options\n   */\n\n  constructor(options) {\n    this.value = 0;\n    this.script = new Script();\n\n    if (options)\n      this.fromOptions(options);\n  }\n\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n  fromOptions(options) {\n    assert(options, 'Output data is required.');\n\n    if (options.value) {\n      assert(Number.isSafeInteger(options.value) && options.value >= 0,\n        'Value must be a uint64.');\n      this.value = options.value;\n    }\n\n    if (options.script)\n      this.script.fromOptions(options.script);\n\n    if (options.address)\n      this.script.fromAddress(options.address);\n\n    if (options.slp) {\n      if (options.slp.constructor === SLP.SlpCoinRecord().constructor)\n        this.slp = options.slp\n    }\n\n    return this;\n  }\n\n  /**\n   * Instantiate output from options object.\n   * @param {Object} options\n   * @returns {Output}\n   */\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n\n//   /**\n//    * Inject properties from script/value pair.\n//    * @private\n//    * @param {Script|Address} script\n//    * @param {Amount} value\n//    * @returns {Output}\n//    */\n\n//   fromScript(script, value) {\n//     if (typeof script === 'string')\n//       script = Address.fromString(script);\n\n//     if (script instanceof Address)\n//       script = Script.fromAddress(script);\n\n//     assert(script instanceof Script, 'Script must be a Script.');\n//     assert(Number.isSafeInteger(value) && value >= 0,\n//       'Value must be a uint64.');\n\n//     this.script = script;\n//     this.value = value;\n\n//     return this;\n//   }\n\n//   /**\n//    * Instantiate output from script/value pair.\n//    * @param {Script|Address} script\n//    * @param {Amount} value\n//    * @returns {Output}\n//    */\n\n//   static fromScript(script, value) {\n//     return new this().fromScript(script, value);\n//   }\n\n//   /**\n//    * Clone the output.\n//    * @returns {Output}\n//    */\n\n//   clone() {\n//     const output = new this.constructor();\n//     output.value = this.value;\n//     output.script.inject(this.script);\n//     return output;\n//   }\n\n//   /**\n//    * Test equality against another output.\n//    * @param {Output} output\n//    * @returns {Boolean}\n//    */\n\n//   equals(output) {\n//     assert(Output.isOutput(output));\n//     return this.value === output.value\n//       && this.script.equals(output.script);\n//   }\n\n//   /**\n//    * Compare against another output (BIP69).\n//    * @param {Output} output\n//    * @returns {Number}\n//    */\n\n//   compare(output) {\n//     assert(Output.isOutput(output));\n\n//     const cmp = this.value - output.value;\n\n//     if (cmp !== 0)\n//       return cmp;\n\n//     return this.script.compare(output.script);\n//   }\n\n//   /**\n//    * Get the script type as a string.\n//    * @returns {ScriptType} type\n//    */\n\n//   getType() {\n//     return Script.typesByVal[this.script.getType()].toLowerCase();\n//   }\n\n  /**\n   * Get the address.\n   * @returns {Address} address\n   */\n\n  getAddress() {\n    return this.script.getAddress();\n  }\n\n  /**\n   * Get the address hash.\n   * @param {String?} enc\n   * @returns {Hash} hash\n   */\n\n  getHash(enc) {\n    const addr = this.getAddress();\n\n    if (!addr)\n      return null;\n\n    return addr.getHash(enc);\n  }\n\n//   /**\n//    * Convert the input to a more user-friendly object.\n//    * @returns {Object}\n//    */\n\n//   [inspectSymbol]() {\n//     const hr = {\n//       type: this.getType(),\n//       value: Amount.btc(this.value),\n//       script: this.script,\n//       address: this.getAddress()\n//     };\n//     if (this.slp) {\n//       return {\n//         ...hr,\n//         slp: this.slp\n//       }\n//     }\n//     return hr;\n//   }\n\n//   /**\n//    * Convert the output to an object suitable\n//    * for JSON serialization.\n//    * @returns {Object}\n//    */\n\n//   toJSON() {\n//     return this.getJSON();\n//   }\n\n//   /**\n//    * Convert the output to an object suitable\n//    * for JSON serialization.\n//    * @param {Network} network\n//    * @returns {Object}\n//    */\n\n//   getJSON(network) {\n//     let addr = this.getAddress();\n\n//     network = Network.get(network);\n\n//     if (addr)\n//       addr = addr.toString(network);\n\n//     const json = {\n//       value: this.value,\n//       script: this.script.toJSON(),\n//       address: addr\n//     };\n\n//     if (this.slp) {\n//       return {\n//         ...json,\n//         slp: this.slp.getJSON()\n//       }\n//     }\n//     return json;\n//   }\n\n//   /**\n//    * Calculate the dust threshold for this\n//    * output, based on serialize size and rate.\n//    * @param {Rate?} rate\n//    * @returns {Amount}\n//    */\n\n//   getDustThreshold(rate) {\n//     if (this.script.isUnspendable())\n//       return 0;\n\n//     let size = this.getSize();\n\n//     size += 32 + 4 + 1 + 107 + 4;\n\n//     return 3 * policy.getMinFee(size, rate);\n//   }\n\n//   /**\n//    * Calculate size of serialized output.\n//    * @returns {Number}\n//    */\n\n//   getSize() {\n//     return 8 + this.script.getVarSize();\n//   }\n\n//   /**\n//    * Test whether the output should be considered dust.\n//    * @param {Rate?} rate\n//    * @returns {Boolean}\n//    */\n\n//   isDust(rate) {\n//     return this.value < this.getDustThreshold(rate);\n//   }\n\n//   /**\n//    * Inject properties from a JSON object.\n//    * @private\n//    * @param {Object} json\n//    */\n\n//   fromJSON(json) {\n//     assert(json, 'Output data is required.');\n//     assert(Number.isSafeInteger(json.value) && json.value >= 0,\n//       'Value must be a uint64.');\n//     this.value = json.value;\n//     this.script.fromJSON(json.script);\n//     if (json.slp) {\n//       this.slp = SLP.SlpCoinRecord().fromJSON(json.slp)\n//     }\n//     return this;\n//   }\n\n//   /**\n//    * Instantiate an Output from a jsonified output object.\n//    * @param {Object} json - The jsonified output object.\n//    * @returns {Output}\n//    */\n\n//   static fromJSON(json) {\n//     return new this().fromJSON(json);\n//   }\n\n//   /**\n//    * Write the output to a buffer writer.\n//    * @param {BufferWriter} bw\n//    */\n\n//   toWriter(bw) {\n//     bw.writeI64(this.value);\n//     bw.writeVarBytes(this.script.toRaw());\n//     return bw;\n//   }\n\n//   /**\n//    * Serialize the output.\n//    * @param {String?} enc - Encoding, can be `'hex'` or null.\n//    * @returns {Buffer|String}\n//    */\n\n//   toRaw() {\n//     const size = this.getSize();\n//     return this.toWriter(bio.write(size)).render();\n//   }\n\n//   /**\n//    * Inject properties from buffer reader.\n//    * @private\n//    * @param {BufferReader} br\n//    */\n\n//   fromReader(br) {\n//     this.value = br.readI64();\n//     this.script.fromRaw(br.readVarBytes());\n//     return this;\n//   }\n\n//   /**\n//    * Inject properties from serialized data.\n//    * @private\n//    * @param {Buffer} data\n//    */\n\n//   fromRaw(data) {\n//     return this.fromReader(bio.read(data));\n//   }\n\n//   /**\n//    * Instantiate an output from a buffer reader.\n//    * @param {BufferReader} br\n//    * @returns {Output}\n//    */\n\n//   static fromReader(br) {\n//     return new this().fromReader(br);\n//   }\n\n//   /**\n//    * Instantiate an output from a serialized Buffer.\n//    * @param {Buffer} data\n//    * @param {String?} enc - Encoding, can be `'hex'` or null.\n//    * @returns {Output}\n//    */\n\n//   static fromRaw(data, enc) {\n//     if (typeof data === 'string')\n//       data = Buffer.from(data, enc);\n//     return new this().fromRaw(data);\n//   }\n\n//   /**\n//    * Test an object to see if it is an Output.\n//    * @param {Object} obj\n//    * @returns {Boolean}\n//    */\n\n//   static isOutput(obj) {\n//     return obj instanceof Output;\n//   }\n}\n\n/*\n * Expose\n */\n\nmodule.exports = Output;\n"]},"metadata":{},"sourceType":"module"}