{"ast":null,"code":"/*!\n * box.js - nacl secretbox for bcrypto (crypto_secretbox_xsalsa20poly1305)\n * Copyright (c) 2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on golang/go:\n *   Copyright (c) 2009 The Go Authors. All rights reserved.\n *   https://github.com/golang/go\n *\n * Resources:\n *   https://nacl.cr.yp.to/secretbox.html\n *   https://github.com/golang/crypto/blob/master/nacl/box/box.go\n *   https://github.com/golang/crypto/blob/master/nacl/box/box_test.go\n *   https://github.com/golang/crypto/blob/master/nacl/box/example_test.go\n */\n'use strict';\n\nconst assert = require('assert');\n\nconst box = require('./secretbox');\n\nconst random = require('./random');\n\nconst x25519 = require('./x25519');\n/*\n * Box\n */\n// In the future, could be implemented as:\n//\n// function seal(msg, pub, priv = null) {\n//   return ecies.encrypt(x25519, null, msg, pub, priv);\n// }\n//\n// function open(msg, priv) {\n//   return ecies.decrypt(x25519, null, msg, priv);\n// }\n\n\nfunction seal(msg, pub) {\n  let priv = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (priv == null) priv = x25519.privateKeyGenerate();\n  const ourPub = x25519.publicKeyCreate(priv);\n  const secret = x25519.derive(pub, priv);\n  const key = box.derive(secret);\n  const nonce = random.randomBytes(24);\n  const sealed = box.seal(msg, key, nonce);\n  return Buffer.concat([ourPub, nonce, sealed]);\n}\n\nfunction open(msg, priv) {\n  assert(Buffer.isBuffer(msg));\n  if (msg.length < 32 + 24) throw new Error('Invalid secret box size.');\n  const theirPub = msg.slice(0, 32);\n  const nonce = msg.slice(32, 32 + 24);\n  const sealed = msg.slice(32 + 24);\n  const secret = x25519.derive(theirPub, priv);\n  const key = box.derive(secret);\n  return box.open(sealed, key, nonce);\n}\n/*\n * Expose\n */\n\n\nexports.native = 0;\nexports.seal = seal;\nexports.open = open;","map":null,"metadata":{},"sourceType":"script"}