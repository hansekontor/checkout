{"ast":null,"code":"/*!\n * merkle.js - merkle trees for bcrypto\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on bitcoin/bitcoin:\n *   Copyright (c) 2009-2019, The Bitcoin Core Developers (MIT License).\n *   Copyright (c) 2009-2019, The Bitcoin Developers (MIT License).\n *   https://github.com/bitcoin/bitcoin\n */\n'use strict';\n\nconst assert = require('./internal/assert'); // Notes about unbalanced merkle trees:\n//\n// Bitcoin hashes odd nodes with themselves,\n// allowing an attacker to add a duplicate\n// TXID, creating an even number of leaves\n// and computing the same root (CVE-2012-2459).\n// In contrast, RFC 6962 simply propagates\n// odd nodes up.\n//\n// RFC 6962:\n//\n//              R\n//             / \\\n//            /   \\\n//           /     \\\n//          /       \\\n//         /         \\\n//        k           j <-- same as below\n//       / \\          |\n//      /   \\         |\n//     /     \\        |\n//    h       i       j\n//   / \\     / \\     / \\\n//  a   b   c   d   e   f\n//\n// Bitcoin Behavior:\n//\n//              R\n//             / \\\n//            /   \\\n//           /     \\\n//          /       \\\n//         /         \\\n//        k           l <-- HASH(j || j)\n//       / \\          |\n//      /   \\         |\n//     /     \\        |\n//    h       i       j\n//   / \\     / \\     / \\\n//  a   b   c   d   e   f\n//\n// This creates a situation where these leaves:\n//\n//        R\n//       / \\\n//      /   \\\n//     /     \\\n//    d       e <-- HASH(c || c)\n//   / \\     / \\\n//  a   b   c   c\n//\n// Compute the same root as:\n//\n//       R\n//      / \\\n//     /   \\\n//    d     e <-- HASH(c || c)\n//   / \\    |\n//  a   b   c\n//\n// Why does this matter? Duplicate TXIDs are\n// invalid right? They're spending the same\n// inputs! The problem arises in certain\n// implementation optimizations which may\n// mark a block hash invalid. In other words,\n// an invalid block shares the same block\n// hash as a valid one!\n//\n// See:\n//   https://tools.ietf.org/html/rfc6962#section-2.1\n//   https://nvd.nist.gov/vuln/detail/CVE-2012-2459\n//   https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2459\n//   https://bitcointalk.org/?topic=81749\n\n/**\n * Build a merkle tree from leaves.\n * @param {Object} alg\n * @param {Buffer[]} leaves\n * @returns {Array} [nodes, malleated]\n */\n\n\nfunction createTree(alg, leaves) {\n  assert(alg && typeof alg.root === 'function');\n  assert(Array.isArray(leaves));\n  const nodes = new Array(leaves.length);\n\n  for (let i = 0; i < leaves.length; i++) nodes[i] = leaves[i];\n\n  let size = nodes.length;\n  let malleated = false;\n  let i = 0;\n\n  if (size === 0) {\n    nodes.push(alg.zero);\n    return [nodes, malleated];\n  }\n\n  while (size > 1) {\n    for (let j = 0; j < size; j += 2) {\n      const k = Math.min(j + 1, size - 1);\n      const left = nodes[i + j];\n      const right = nodes[i + k];\n\n      if (k === j + 1 && k + 1 === size && left.equals(right)) {\n        malleated = true;\n      }\n\n      const hash = alg.root(left, right);\n      nodes.push(hash);\n    }\n\n    i += size;\n    size = size + 1 >>> 1;\n  }\n\n  return [nodes, malleated];\n}\n/**\n * Calculate merkle root from leaves.\n * @param {Object} alg\n * @param {Buffer[]} leaves\n * @returns {Array} [root, malleated]\n */\n\n\nfunction createRoot(alg, leaves) {\n  assert(alg && typeof alg.root === 'function');\n  assert(Array.isArray(leaves));\n  const [nodes, malleated] = createTree(alg, leaves);\n  const root = nodes[nodes.length - 1];\n  return [root, malleated];\n}\n/**\n * Collect a merkle branch from vector index.\n * @param {Object} alg\n * @param {Number} index\n * @param {Buffer[]} leaves\n * @returns {Buffer[]} branch\n */\n\n\nfunction createBranch(alg, index, leaves) {\n  assert(alg && typeof alg.root === 'function');\n  assert(index >>> 0 === index);\n  assert(Array.isArray(leaves));\n  assert(index < leaves.length);\n  let size = leaves.length;\n  const [nodes] = createTree(alg, leaves);\n  const branch = [];\n  let i = 0;\n\n  while (size > 1) {\n    const j = Math.min(index ^ 1, size - 1);\n    branch.push(nodes[i + j]);\n    index >>>= 1;\n    i += size;\n    size = size + 1 >>> 1;\n  }\n\n  return branch;\n}\n/**\n * Derive merkle root from branch.\n * @param {Object} alg\n * @param {Buffer} hash\n * @param {Buffer[]} branch\n * @param {Number} index\n * @returns {Buffer} root\n */\n\n\nfunction deriveRoot(alg, hash, branch, index) {\n  assert(alg && typeof alg.root === 'function');\n  assert(Buffer.isBuffer(hash));\n  assert(Array.isArray(branch));\n  assert(index >>> 0 === index);\n  let root = hash;\n\n  for (const hash of branch) {\n    if (index & 1 && hash.equals(root)) return alg.zero;\n    if (index & 1) root = alg.root(hash, root);else root = alg.root(root, hash);\n    index >>>= 1;\n  }\n\n  return root;\n}\n/*\n * Expose\n */\n\n\nexports.createTree = createTree;\nexports.createRoot = createRoot;\nexports.createBranch = createBranch;\nexports.deriveRoot = deriveRoot;","map":null,"metadata":{},"sourceType":"script"}