{"ast":null,"code":"/*!\n * int64.js - int64 object for javascript.\n * Copyright (c) 2017, Christopher Jeffrey (MIT License).\n * https://github.com/chjj/n64\n */\n'use strict';\n/*\n * N64 (abstract)\n */\n\nfunction N64(sign) {\n  enforce(this instanceof N64, 'this', 'N64');\n  enforce(sign === 0 || sign === 1, 'sign', 'bit');\n  this.hi = 0;\n  this.lo = 0;\n  this.sign = sign;\n}\n/*\n * Addition\n */\n\n\nN64.prototype._add = function _add(bhi, blo) {\n  const ahi = this.hi;\n  const alo = this.lo; // Credit to @indutny for this method.\n\n  const lo = alo + blo | 0;\n  const s = lo >> 31;\n  const as = alo >> 31;\n  const bs = blo >> 31;\n  const c = (as & bs | ~s & (as ^ bs)) & 1;\n  const hi = (ahi + bhi | 0) + c;\n  this.hi = hi | 0;\n  this.lo = lo;\n  return this;\n};\n\nN64.prototype.iadd = function iadd(b) {\n  enforce(N64.isN64(b), 'operand', 'int64');\n  return this._add(b.hi, b.lo);\n};\n\nN64.prototype.iaddn = function iaddn(num) {\n  enforce(isNumber(num), 'operand', 'number');\n  return this._add(num >> 31 & -this.sign, num | 0);\n};\n\nN64.prototype.add = function add(b) {\n  return this.clone().iadd(b);\n};\n\nN64.prototype.addn = function addn(num) {\n  return this.clone().iaddn(num);\n};\n/*\n * Subtraction\n */\n\n\nN64.prototype._sub = function _sub(bhi, blo) {\n  bhi = ~bhi;\n  blo = ~blo;\n\n  if (blo === -1) {\n    blo = 0;\n    bhi += 1;\n    bhi |= 0;\n  } else {\n    blo += 1;\n  }\n\n  return this._add(bhi, blo);\n};\n\nN64.prototype.isub = function isub(b) {\n  enforce(N64.isN64(b), 'operand', 'int64');\n  return this._sub(b.hi, b.lo);\n};\n\nN64.prototype.isubn = function isubn(num) {\n  enforce(isNumber(num), 'operand', 'number');\n  return this._sub(num >> 31 & -this.sign, num | 0);\n};\n\nN64.prototype.sub = function sub(b) {\n  return this.clone().isub(b);\n};\n\nN64.prototype.subn = function subn(num) {\n  return this.clone().isubn(num);\n};\n/*\n * Multiplication\n */\n\n\nN64.prototype._mul = function _mul(bhi, blo) {\n  const ahi = this.hi;\n  const alo = this.lo;\n  const a48 = ahi >>> 16;\n  const a32 = ahi & 0xffff;\n  const a16 = alo >>> 16;\n  const a00 = alo & 0xffff;\n  const b48 = bhi >>> 16;\n  const b32 = bhi & 0xffff;\n  const b16 = blo >>> 16;\n  const b00 = blo & 0xffff;\n  let c48 = 0;\n  let c32 = 0;\n  let c16 = 0;\n  let c00 = 0;\n  c00 += a00 * b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xffff;\n  c16 += a16 * b00;\n  c32 += c16 >>> 16;\n  c16 &= 0xffff;\n  c16 += a00 * b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xffff;\n  c32 += a32 * b00;\n  c48 += c32 >>> 16;\n  c32 &= 0xffff;\n  c32 += a16 * b16;\n  c48 += c32 >>> 16;\n  c32 &= 0xffff;\n  c32 += a00 * b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xffff;\n  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n  c48 &= 0xffff;\n  const hi = c48 << 16 | c32;\n  const lo = c16 << 16 | c00;\n  this.hi = hi;\n  this.lo = lo;\n  return this;\n};\n\nN64.prototype.imul = function imul(b) {\n  enforce(N64.isN64(b), 'multiplicand', 'int64');\n  return this._mul(b.hi, b.lo);\n};\n\nN64.prototype.imuln = function imuln(num) {\n  enforce(isNumber(num), 'multiplicand', 'number');\n  return this._mul(num >> 31 & -this.sign, num | 0);\n};\n\nN64.prototype.mul = function mul(b) {\n  return this.clone().imul(b);\n};\n\nN64.prototype.muln = function muln(num) {\n  return this.clone().imuln(num);\n};\n/*\n * Division\n */\n\n\nN64.prototype.idiv = function idiv(b) {\n  let a = this;\n  enforce(N64.isN64(b), 'divisor', 'int64');\n  if (b.isZero()) throw new Error('Cannot divide by zero.');\n  if (a.isZero()) return a;\n  if (a.eq(b)) return a.set(1);\n\n  if (a.isSafe() && b.isSafe()) {\n    const n = a.toDouble();\n    const d = b.toDouble();\n    const q = floor(n / d);\n    return a.set(q);\n  }\n\n  let neg = false;\n\n  if (a.sign) {\n    if (a.hi < 0) {\n      if (b.hi < 0) {\n        a = a.ineg();\n        b = b.neg();\n      } else {\n        a = a.ineg();\n        neg = true;\n      }\n    } else if (b.hi < 0) {\n      b = b.neg();\n      neg = true;\n    }\n  }\n\n  const n = a.toU64();\n  const d = b.toU64();\n  if (n.lt(d)) return a.set(0);\n  if (n.ushrn(1).lt(d)) return a.set(neg ? -1 : 1);\n  const q = new U64();\n  const r = new U64();\n  let bit = n.bitLength();\n\n  while (bit--) {\n    r.ishln(1);\n    r.lo |= n.testn(bit);\n\n    if (r.gte(d)) {\n      r.isub(d);\n      q.setn(bit, 1);\n    }\n  }\n\n  a.hi = q.hi;\n  a.lo = q.lo;\n  if (neg) a.ineg();\n  return a;\n};\n\nN64.prototype.idivn = function idivn(num) {\n  enforce(isNumber(num), 'divisor', 'number');\n  return this.idiv(this._small(num));\n};\n\nN64.prototype.div = function div(b) {\n  return this.clone().idiv(b);\n};\n\nN64.prototype.divn = function divn(num) {\n  return this.clone().idivn(num);\n};\n/*\n * Modulo\n */\n\n\nN64.prototype.imod = function imod(b) {\n  const a = this;\n  enforce(N64.isN64(b), 'divisor', 'int64');\n  if (b.isZero()) throw new Error('Cannot divide by zero.');\n  if (a.isZero()) return a;\n  if (a.eq(b)) return a.set(0);\n\n  if (a.isSafe() && b.isSafe()) {\n    const n = a.toDouble();\n    const d = b.toDouble();\n    const r = n % d;\n    return a.set(r);\n  }\n\n  return a.isub(a.div(b).imul(b));\n};\n\nN64.prototype.imodn = function imodn(num) {\n  enforce(isNumber(num), 'divisor', 'number');\n  return this.imod(this._small(num));\n};\n\nN64.prototype.mod = function mod(b) {\n  return this.clone().imod(b);\n};\n\nN64.prototype.modn = function modn(num) {\n  return this.clone().imodn(num);\n};\n/*\n * Exponentiation\n */\n\n\nN64.prototype.ipow = function ipow(b) {\n  enforce(N64.isN64(b), 'exponent', 'int64');\n  return this.ipown(b.lo);\n};\n\nN64.prototype.ipown = function ipown(num) {\n  enforce(isNumber(num), 'exponent', 'number');\n  if (this.isZero()) return this;\n  const x = this.clone();\n  const n = this;\n  let y = num >>> 0;\n  n.set(1);\n\n  while (y > 0) {\n    if (y & 1) n.imul(x);\n    y >>>= 1;\n    x.imul(x);\n  }\n\n  return n;\n};\n\nN64.prototype.pow = function pow(b) {\n  return this.clone().ipow(b);\n};\n\nN64.prototype.pown = function pown(num) {\n  return this.clone().ipown(num);\n};\n\nN64.prototype.sqr = function sqr() {\n  return this.mul(this);\n};\n\nN64.prototype.isqr = function isqr() {\n  return this.imul(this);\n};\n/*\n * AND\n */\n\n\nN64.prototype.iand = function iand(b) {\n  enforce(N64.isN64(b), 'operand', 'int64');\n  this.hi &= b.hi;\n  this.lo &= b.lo;\n  return this;\n};\n\nN64.prototype.iandn = function iandn(num) {\n  enforce(isNumber(num), 'operand', 'number');\n  this.hi &= num >> 31 & -this.sign;\n  this.lo &= num | 0;\n  return this;\n};\n\nN64.prototype.and = function and(b) {\n  return this.clone().iand(b);\n};\n\nN64.prototype.andn = function andn(num) {\n  return this.clone().iandn(num);\n};\n/*\n * OR\n */\n\n\nN64.prototype.ior = function ior(b) {\n  enforce(N64.isN64(b), 'operand', 'int64');\n  this.hi |= b.hi;\n  this.lo |= b.lo;\n  return this;\n};\n\nN64.prototype.iorn = function iorn(num) {\n  enforce(isNumber(num), 'operand', 'number');\n  this.hi |= num >> 31 & -this.sign;\n  this.lo |= num | 0;\n  return this;\n};\n\nN64.prototype.or = function or(b) {\n  return this.clone().ior(b);\n};\n\nN64.prototype.orn = function orn(num) {\n  return this.clone().iorn(num);\n};\n/*\n * XOR\n */\n\n\nN64.prototype.ixor = function ixor(b) {\n  enforce(N64.isN64(b), 'operand', 'int64');\n  this.hi ^= b.hi;\n  this.lo ^= b.lo;\n  return this;\n};\n\nN64.prototype.ixorn = function ixorn(num) {\n  enforce(isNumber(num), 'operand', 'number');\n  this.hi ^= num >> 31 & -this.sign;\n  this.lo ^= num | 0;\n  return this;\n};\n\nN64.prototype.xor = function xor(b) {\n  return this.clone().ixor(b);\n};\n\nN64.prototype.xorn = function xorn(num) {\n  return this.clone().ixorn(num);\n};\n/*\n * NOT\n */\n\n\nN64.prototype.inot = function inot() {\n  this.hi = ~this.hi;\n  this.lo = ~this.lo;\n  return this;\n};\n\nN64.prototype.not = function not() {\n  return this.clone().inot();\n};\n/*\n * Left Shift\n */\n\n\nN64.prototype.ishl = function ishl(b) {\n  enforce(N64.isN64(b), 'bits', 'int64');\n  return this.ishln(b.lo);\n};\n\nN64.prototype.ishln = function ishln(bits) {\n  enforce(isNumber(bits), 'bits', 'number');\n  bits &= 63;\n  if (bits === 0) return this;\n  let hi = this.hi;\n  let lo = this.lo;\n\n  if (bits < 32) {\n    hi <<= bits;\n    hi |= lo >>> 32 - bits;\n    lo <<= bits;\n  } else {\n    hi = lo << bits - 32;\n    lo = 0;\n  }\n\n  this.hi = hi;\n  this.lo = lo;\n  return this;\n};\n\nN64.prototype.shl = function shl(b) {\n  return this.clone().ishl(b);\n};\n\nN64.prototype.shln = function shln(bits) {\n  return this.clone().ishln(bits);\n};\n/*\n * Right Shift\n */\n\n\nN64.prototype.ishr = function ishr(b) {\n  enforce(N64.isN64(b), 'bits', 'int64');\n  return this.ishrn(b.lo);\n};\n\nN64.prototype.ishrn = function ishrn(bits) {\n  if (!this.sign) return this.iushrn(bits);\n  enforce(isNumber(bits), 'bits', 'number');\n  bits &= 63;\n  if (bits === 0) return this;\n  let hi = this.hi;\n  let lo = this.lo;\n\n  if (bits < 32) {\n    lo >>>= bits;\n    lo |= hi << 32 - bits;\n    hi >>= bits;\n  } else {\n    lo = hi >> bits - 32;\n    hi = hi >> 31;\n  }\n\n  this.hi = hi;\n  this.lo = lo;\n  return this;\n};\n\nN64.prototype.shr = function shr(b) {\n  return this.clone().ishr(b);\n};\n\nN64.prototype.shrn = function shrn(bits) {\n  return this.clone().ishrn(bits);\n};\n/*\n * Unsigned Right Shift\n */\n\n\nN64.prototype.iushr = function iushr(b) {\n  enforce(N64.isN64(b), 'bits', 'int64');\n  return this.iushrn(b.lo);\n};\n\nN64.prototype.iushrn = function iushrn(bits) {\n  enforce(isNumber(bits), 'bits', 'number');\n  bits &= 63;\n  if (bits === 0) return this;\n  let hi = this.hi;\n  let lo = this.lo;\n\n  if (bits < 32) {\n    lo >>>= bits;\n    lo |= hi << 32 - bits;\n    hi >>>= bits;\n  } else {\n    lo = hi >>> bits - 32;\n    hi = 0;\n  }\n\n  this.hi = hi | 0;\n  this.lo = lo | 0;\n  return this;\n};\n\nN64.prototype.ushr = function ushr(b) {\n  return this.clone().iushr(b);\n};\n\nN64.prototype.ushrn = function ushrn(bits) {\n  return this.clone().iushrn(bits);\n};\n/*\n * Bit Manipulation\n */\n\n\nN64.prototype.setn = function setn(bit, val) {\n  enforce(isNumber(bit), 'bit', 'number');\n  bit &= 63;\n\n  if (bit < 32) {\n    if (val) this.lo |= 1 << bit;else this.lo &= ~(1 << bit);\n  } else {\n    if (val) this.hi |= 1 << bit - 32;else this.hi &= ~(1 << bit - 32);\n  }\n\n  return this;\n};\n\nN64.prototype.testn = function testn(bit) {\n  enforce(isNumber(bit), 'bit', 'number');\n  bit &= 63;\n  if (bit < 32) return this.lo >>> bit & 1;\n  return this.hi >>> bit - 32 & 1;\n};\n\nN64.prototype.setb = function setb(pos, ch) {\n  enforce(isNumber(pos), 'pos', 'number');\n  enforce(isNumber(ch), 'ch', 'number');\n  pos &= 7;\n  ch &= 0xff;\n\n  if (pos < 4) {\n    this.lo &= ~(0xff << pos * 8);\n    this.lo |= ch << pos * 8;\n  } else {\n    this.hi &= ~(0xff << (pos - 4) * 8);\n    this.hi |= ch << (pos - 4) * 8;\n  }\n\n  return this;\n};\n\nN64.prototype.orb = function orb(pos, ch) {\n  enforce(isNumber(pos), 'pos', 'number');\n  enforce(isNumber(ch), 'ch', 'number');\n  pos &= 7;\n  ch &= 0xff;\n  if (pos < 4) this.lo |= ch << pos * 8;else this.hi |= ch << (pos - 4) * 8;\n  return this;\n};\n\nN64.prototype.getb = function getb(pos) {\n  enforce(isNumber(pos), 'pos', 'number');\n  pos &= 7;\n  if (pos < 4) return this.lo >> pos * 8 & 0xff;\n  return this.hi >> (pos - 4) * 8 & 0xff;\n};\n\nN64.prototype.imaskn = function imaskn(bit) {\n  enforce(isNumber(bit), 'bit', 'number');\n  bit &= 63;\n\n  if (bit < 32) {\n    this.hi = 0;\n    this.lo &= (1 << bit) - 1;\n  } else {\n    this.hi &= (1 << bit - 32) - 1;\n    this.lo &= 0xffffffff;\n  }\n\n  return this;\n};\n\nN64.prototype.maskn = function maskn(bit) {\n  return this.clone().imaskn(bit);\n};\n\nN64.prototype.andln = function andln(num) {\n  enforce(isNumber(num), 'operand', 'number');\n  return this.lo & num;\n};\n/*\n * Negation\n */\n\n\nN64.prototype.ineg = function ineg() {\n  let hi = ~this.hi;\n  let lo = ~this.lo;\n\n  if (lo === -1) {\n    lo = 0;\n    hi += 1;\n    hi |= 0;\n  } else {\n    lo += 1;\n  }\n\n  this.hi = hi;\n  this.lo = lo;\n  return this;\n};\n\nN64.prototype.neg = function neg() {\n  return this.clone().ineg();\n};\n\nN64.prototype.iabs = function iabs() {\n  if (this.isNeg()) this.ineg();\n  return this;\n};\n\nN64.prototype.abs = function abs() {\n  return this.clone().iabs();\n};\n/*\n * Comparison\n */\n\n\nN64.prototype._cmp = function _cmp(bhi, blo) {\n  const a = this;\n  let ahi = a.hi;\n  let alo = a.lo;\n  if (ahi === bhi && alo === blo) return 0;\n  let neg = false;\n\n  if (a.sign) {\n    const x = ahi < 0;\n    const y = bhi < 0;\n    if (x && !y) return -1;\n    if (!x && y) return 1;\n    neg = x;\n  }\n\n  if (!neg) {\n    ahi >>>= 0;\n    bhi >>>= 0;\n  }\n\n  if (ahi < bhi) return -1;\n  if (ahi > bhi) return 1;\n  alo >>>= 0;\n  blo >>>= 0;\n  if (alo < blo) return -1;\n  return 1;\n};\n\nN64.prototype.cmp = function cmp(b) {\n  enforce(N64.isN64(b), 'value', 'int64');\n  return this._cmp(b.hi, b.lo);\n};\n\nN64.prototype.cmpn = function cmpn(num) {\n  enforce(isNumber(num), 'value', 'number');\n  return this._cmp(num >> 31 & -this.sign, num | 0);\n};\n\nN64.prototype.eq = function eq(b) {\n  enforce(N64.isN64(b), 'value', 'int64');\n  return this.hi === b.hi && this.lo === b.lo;\n};\n\nN64.prototype.eqn = function eqn(num) {\n  enforce(isNumber(num), 'value', 'number');\n  return this.hi === (num >> 31 & -this.sign) && this.lo === (num | 0);\n};\n\nN64.prototype.gt = function gt(b) {\n  return this.cmp(b) > 0;\n};\n\nN64.prototype.gtn = function gtn(num) {\n  return this.cmpn(num) > 0;\n};\n\nN64.prototype.gte = function gte(b) {\n  return this.cmp(b) >= 0;\n};\n\nN64.prototype.gten = function gten(num) {\n  return this.cmpn(num) >= 0;\n};\n\nN64.prototype.lt = function lt(b) {\n  return this.cmp(b) < 0;\n};\n\nN64.prototype.ltn = function ltn(num) {\n  return this.cmpn(num) < 0;\n};\n\nN64.prototype.lte = function lte(b) {\n  return this.cmp(b) <= 0;\n};\n\nN64.prototype.lten = function lten(num) {\n  return this.cmpn(num) <= 0;\n};\n\nN64.prototype.isZero = function isZero() {\n  return this.hi === 0 && this.lo === 0;\n};\n\nN64.prototype.isNeg = function isNeg() {\n  return this.sign === 1 && this.hi < 0;\n};\n\nN64.prototype.isOdd = function isOdd() {\n  return (this.lo & 1) === 1;\n};\n\nN64.prototype.isEven = function isEven() {\n  return (this.lo & 1) === 0;\n};\n/*\n * Helpers\n */\n\n\nN64.prototype.clone = function clone() {\n  const n = new this.constructor();\n  n.hi = this.hi;\n  n.lo = this.lo;\n  return n;\n};\n\nN64.prototype.inject = function inject(b) {\n  enforce(N64.isN64(b), 'value', 'int64');\n  this.hi = b.hi;\n  this.lo = b.lo;\n  return this;\n};\n\nN64.prototype.set = function set(num) {\n  enforce(isSafeInteger(num), 'number', 'integer');\n  let neg = false;\n\n  if (num < 0) {\n    num = -num;\n    neg = true;\n  }\n\n  this.hi = num * (1 / 0x100000000) | 0;\n  this.lo = num | 0;\n  if (neg) this.ineg();\n  return this;\n};\n\nN64.prototype.join = function join(hi, lo) {\n  enforce(isNumber(hi), 'hi', 'number');\n  enforce(isNumber(lo), 'lo', 'number');\n  this.hi = hi | 0;\n  this.lo = lo | 0;\n  return this;\n};\n\nN64.prototype._small = function _small(num) {\n  const n = new this.constructor();\n  n.hi = num >> 31 & -this.sign;\n  n.lo = num | 0;\n  return n;\n};\n\nN64.prototype.bitLength = function bitLength() {\n  let a = this;\n  if (this.isNeg()) a = this.neg();\n  if (a.hi === 0) return countBits(a.lo);\n  return countBits(a.hi) + 32;\n};\n\nN64.prototype.byteLength = function byteLength() {\n  return Math.ceil(this.bitLength() / 8);\n};\n\nN64.prototype.isSafe = function isSafe() {\n  let hi = this.hi;\n\n  if (this.isNeg()) {\n    hi = ~hi;\n    if (this.lo === 0) hi += 1;\n  }\n\n  return (hi & 0xffe00000) === 0;\n};\n\nN64.prototype.inspect = function inspect() {\n  let prefix = 'I64';\n  if (!this.sign) prefix = 'U64';\n  return `<${prefix}: ${this.toString(10)}>`;\n};\n/*\n * Encoding\n */\n\n\nN64.prototype.readLE = function readLE(data, off) {\n  enforce(data && typeof data.length === 'number', 'data', 'arraylike');\n  enforce(off >> 0 === off, 'offset', 'integer');\n  enforce(off + 8 <= data.length, 'offset', 'valid offset');\n  this.lo = readI32LE(data, off);\n  this.hi = readI32LE(data, off + 4);\n  return off + 8;\n};\n\nN64.prototype.readBE = function readBE(data, off) {\n  enforce(data && typeof data.length === 'number', 'data', 'arraylike');\n  enforce(off >> 0 === off, 'offset', 'integer');\n  enforce(off + 8 <= data.length, 'offset', 'valid offset');\n  this.hi = readI32BE(data, off);\n  this.lo = readI32BE(data, off + 4);\n  return off + 8;\n};\n\nN64.prototype.readRaw = function readRaw(data, off) {\n  return this.readLE(data, off);\n};\n\nN64.prototype.writeLE = function writeLE(data, off) {\n  enforce(data && typeof data.length === 'number', 'data', 'arraylike');\n  enforce(off >> 0 === off, 'offset', 'integer');\n  enforce(off + 8 <= data.length, 'offset', 'valid offset');\n  writeI32LE(data, this.lo, off);\n  writeI32LE(data, this.hi, off + 4);\n  return off + 8;\n};\n\nN64.prototype.writeBE = function writeBE(data, off) {\n  enforce(data && typeof data.length === 'number', 'data', 'arraylike');\n  enforce(off >> 0 === off, 'offset', 'integer');\n  enforce(off + 8 <= data.length, 'offset', 'valid offset');\n  writeI32BE(data, this.hi, off);\n  writeI32BE(data, this.lo, off + 4);\n  return off + 8;\n};\n\nN64.prototype.writeRaw = function writeRaw(data, off) {\n  return this.writeLE(data, off);\n};\n/*\n * Conversion\n */\n\n\nN64.prototype.toU64 = function toU64() {\n  const n = new U64();\n  n.hi = this.hi;\n  n.lo = this.lo;\n  return n;\n};\n\nN64.prototype.toI64 = function toI64() {\n  const n = new I64();\n  n.hi = this.hi;\n  n.lo = this.lo;\n  return n;\n};\n\nN64.prototype.toNumber = function toNumber() {\n  if (!this.isSafe()) throw new Error('Number exceeds 53 bits.');\n  return this.toDouble();\n};\n\nN64.prototype.toDouble = function toDouble() {\n  let hi = this.hi;\n  if (!this.sign) hi >>>= 0;\n  return hi * 0x100000000 + (this.lo >>> 0);\n};\n\nN64.prototype.toInt = function toInt() {\n  return this.sign ? this.lo : this.lo >>> 0;\n};\n\nN64.prototype.toBool = function toBool() {\n  return !this.isZero();\n};\n\nN64.prototype.toBits = function toBits() {\n  return [this.hi, this.lo];\n};\n\nN64.prototype.toObject = function toObject() {\n  return {\n    hi: this.hi,\n    lo: this.lo\n  };\n};\n\nN64.prototype.toString = function toString(base, pad) {\n  base = getBase(base);\n  if (pad == null) pad = 0;\n  enforce(base >>> 0 === base, 'base', 'integer');\n  enforce(pad >>> 0 === pad, 'pad', 'integer');\n  if (base < 2 || base > 16) throw new Error('Base ranges between 2 and 16.');\n  if (pad > 64) throw new Error('Maximum padding is 64 characters.');\n  let n = this;\n  let neg = false;\n\n  if (n.isNeg()) {\n    n = n.neg();\n    neg = true;\n  }\n\n  let hi = n.hi >>> 0;\n  let lo = n.lo >>> 0;\n  let str = '';\n\n  do {\n    const mhi = hi % base;\n    hi -= mhi;\n    hi /= base;\n    lo += mhi * 0x100000000;\n    const mlo = lo % base;\n    lo -= mlo;\n    lo /= base;\n    let ch = mlo;\n    if (ch < 10) ch += 0x30;else ch += 0x61 - 10;\n    str = String.fromCharCode(ch) + str;\n  } while (lo > 0 || hi > 0);\n\n  while (str.length < pad) str = '0' + str;\n\n  if (neg) str = '-' + str;\n  return str;\n};\n\nN64.prototype.toJSON = function toJSON() {\n  return this.toString(16, 16);\n};\n\nN64.prototype.toBN = function toBN(BN) {\n  const neg = this.isNeg();\n  let hi = this.hi;\n  let lo = this.lo;\n\n  if (neg) {\n    hi = ~hi;\n    lo = ~lo;\n\n    if (lo === -1) {\n      lo = 0;\n      hi += 1;\n      hi |= 0;\n    } else {\n      lo += 1;\n    }\n  }\n\n  hi >>>= 0;\n  lo >>>= 0;\n  const num = new BN(hi);\n  num.ishln(32);\n  num.iadd(new BN(lo));\n  if (neg) num.ineg();\n  return num;\n};\n\nN64.prototype.toLE = function toLE(ArrayLike) {\n  enforce(typeof ArrayLike === 'function', 'ArrayLike', 'constructor');\n  const data = alloc(ArrayLike, 8);\n  this.writeLE(data, 0);\n  return data;\n};\n\nN64.prototype.toBE = function toBE(ArrayLike) {\n  enforce(typeof ArrayLike === 'function', 'ArrayLike', 'constructor');\n  const data = alloc(ArrayLike, 8);\n  this.writeBE(data, 0);\n  return data;\n};\n\nN64.prototype.toRaw = function toRaw(ArrayLike) {\n  return this.toLE(ArrayLike);\n};\n/*\n * Instantiation\n */\n\n\nN64.prototype.fromNumber = function fromNumber(num) {\n  return this.set(num);\n};\n\nN64.prototype.fromInt = function fromInt(num) {\n  enforce(isNumber(num), 'integer', 'number');\n  return this.join(num >> 31 & -this.sign, num);\n};\n\nN64.prototype.fromBool = function fromBool(value) {\n  enforce(typeof value === 'boolean', 'value', 'boolean');\n  this.hi = 0;\n  this.lo = value ? 1 : 0;\n  return this;\n};\n\nN64.prototype.fromBits = function fromBits(hi, lo) {\n  return this.join(hi, lo);\n};\n\nN64.prototype.fromObject = function fromObject(num) {\n  enforce(num && typeof num === 'object', 'number', 'object');\n  return this.fromBits(num.hi, num.lo);\n};\n\nN64.prototype.fromString = function fromString(str, base) {\n  base = getBase(base);\n  enforce(typeof str === 'string', 'string', 'string');\n  enforce(base >>> 0 === base, 'base', 'integer');\n  if (base < 2 || base > 16) throw new Error('Base ranges between 2 and 16.');\n  let neg = false;\n  let i = 0;\n\n  if (str.length > 0 && str[0] === '-') {\n    i += 1;\n    neg = true;\n  }\n\n  if (str.length === i || str.length > i + 64) throw new Error('Invalid string (bad length).');\n  let hi = 0;\n  let lo = 0;\n\n  for (; i < str.length; i++) {\n    let ch = str.charCodeAt(i);\n    if (ch >= 0x30 && ch <= 0x39) ch -= 0x30;else if (ch >= 0x41 && ch <= 0x5a) ch -= 0x41 - 10;else if (ch >= 0x61 && ch <= 0x7a) ch -= 0x61 - 10;else ch = base;\n    if (ch >= base) throw new Error('Invalid string (parse error).');\n    lo *= base;\n    lo += ch;\n    hi *= base;\n\n    if (lo > 0xffffffff) {\n      ch = lo % 0x100000000;\n      hi += (lo - ch) / 0x100000000;\n      lo = ch;\n    }\n\n    if (hi > 0xffffffff) throw new Error('Invalid string (overflow).');\n  }\n\n  this.hi = hi | 0;\n  this.lo = lo | 0;\n  if (neg) this.ineg();\n  return this;\n};\n\nN64.prototype.fromJSON = function fromJSON(json) {\n  return this.fromString(json, 16);\n};\n\nN64.prototype.fromBN = function fromBN(num) {\n  enforce(num && isArray(num.words), 'number', 'big number');\n  const a = this;\n  const b = num.clone();\n  const neg = b.isNeg();\n  if (a.sign && b.testn(63)) throw new Error('Big number overflow.');\n  let i = 0;\n\n  while (!b.isZero()) {\n    if (i === 8) throw new Error('Big number overflow.');\n    a.orb(i, b.andln(0xff));\n    b.iushrn(8);\n    i++;\n  }\n\n  if (neg) a.ineg();\n  return a;\n};\n\nN64.prototype.fromLE = function fromLE(data) {\n  this.readLE(data, 0);\n  return this;\n};\n\nN64.prototype.fromBE = function fromBE(data) {\n  this.readBE(data, 0);\n  return this;\n};\n\nN64.prototype.fromRaw = function fromRaw(data) {\n  return this.fromLE(data);\n};\n\nN64.prototype.from = function from(num, base) {\n  if (num == null) return this;\n\n  if (typeof num === 'number') {\n    if (typeof base === 'number') return this.fromBits(num, base);\n    return this.fromNumber(num);\n  }\n\n  if (typeof num === 'string') return this.fromString(num, base);\n\n  if (typeof num === 'object') {\n    if (isArray(num.words)) return this.fromBN(num);\n    if (typeof num.length === 'number') return this.fromRaw(num);\n    return this.fromObject(num);\n  }\n\n  if (typeof num === 'boolean') return this.fromBool(num);\n  throw new TypeError('Non-numeric object passed to N64.');\n};\n/*\n * Static Methods\n */\n\n\nN64.min = function min(a, b) {\n  return a.cmp(b) < 0 ? a : b;\n};\n\nN64.max = function max(a, b) {\n  return a.cmp(b) > 0 ? a : b;\n};\n\nN64.random = function random() {\n  const n = new this();\n  n.hi = Math.random() * 0x100000000 | 0;\n  n.lo = Math.random() * 0x100000000 | 0;\n  return n;\n};\n\nN64.pow = function pow(num, exp) {\n  return new this().fromInt(num).ipown(exp);\n};\n\nN64.shift = function shift(num, bits) {\n  return new this().fromInt(num).ishln(bits);\n};\n\nN64.readLE = function readLE(data, off) {\n  const n = new this();\n  n.readLE(data, off);\n  return n;\n};\n\nN64.readBE = function readBE(data, off) {\n  const n = new this();\n  n.readBE(data, off);\n  return n;\n};\n\nN64.readRaw = function readRaw(data, off) {\n  const n = new this();\n  n.readRaw(data, off);\n  return n;\n};\n\nN64.fromNumber = function fromNumber(num) {\n  return new this().fromNumber(num);\n};\n\nN64.fromInt = function fromInt(num) {\n  return new this().fromInt(num);\n};\n\nN64.fromBool = function fromBool(value) {\n  return new this().fromBool(value);\n};\n\nN64.fromBits = function fromBits(hi, lo) {\n  return new this().fromBits(hi, lo);\n};\n\nN64.fromObject = function fromObject(obj) {\n  return new this().fromObject(obj);\n};\n\nN64.fromString = function fromString(str, base) {\n  return new this().fromString(str, base);\n};\n\nN64.fromJSON = function fromJSON(json) {\n  return new this().fromJSON(json);\n};\n\nN64.fromBN = function fromBN(num) {\n  return new this().fromBN(num);\n};\n\nN64.fromLE = function fromLE(data) {\n  return new this().fromLE(data);\n};\n\nN64.fromBE = function fromBE(data) {\n  return new this().fromBE(data);\n};\n\nN64.fromRaw = function fromRaw(data) {\n  return new this().fromRaw(data);\n};\n\nN64.from = function from(num, base) {\n  return new this().from(num, base);\n};\n\nN64.isN64 = function isN64(obj) {\n  return obj instanceof N64;\n};\n\nN64.isU64 = function isU64(obj) {\n  return obj instanceof U64;\n};\n\nN64.isI64 = function isI64(obj) {\n  return obj instanceof I64;\n};\n/*\n * U64\n */\n\n\nfunction U64(num, base) {\n  if (!(this instanceof U64)) return new U64(num, base);\n  N64.call(this, 0);\n  this.from(num, base);\n}\n\nU64.__proto__ = N64;\nU64.prototype.__proto__ = N64.prototype;\n/*\n * Constants\n */\n\nU64.ULONG_MIN = 0x00000000;\nU64.ULONG_MAX = 0xffffffff;\nU64.UINT32_MIN = U64(0x00000000, 0x00000000);\nU64.UINT32_MAX = U64(0x00000000, 0xffffffff);\nU64.UINT64_MIN = U64(0x00000000, 0x00000000);\nU64.UINT64_MAX = U64(0xffffffff, 0xffffffff);\n/*\n * I64\n */\n\nfunction I64(num, base) {\n  if (!(this instanceof I64)) return new I64(num, base);\n  N64.call(this, 1);\n  this.from(num, base);\n}\n\nI64.__proto__ = N64;\nI64.prototype.__proto__ = N64.prototype;\n/*\n * Constants\n */\n\nI64.LONG_MIN = -0x80000000;\nI64.LONG_MAX = 0x7fffffff;\nI64.INT32_MIN = I64(0xffffffff, 0x80000000);\nI64.INT32_MAX = I64(0x00000000, 0x7fffffff);\nI64.INT64_MIN = I64(0x80000000, 0x00000000);\nI64.INT64_MAX = I64(0x7fffffff, 0xffffffff);\n/*\n * Helpers\n */\n\nfunction getBase(base) {\n  if (base == null) return 10;\n  if (typeof base === 'number') return base;\n\n  switch (base) {\n    case 'bin':\n      return 2;\n\n    case 'oct':\n      return 8;\n\n    case 'dec':\n      return 10;\n\n    case 'hex':\n      return 16;\n  }\n\n  return 0;\n}\n\nfunction countBits(word) {\n  if (Math.clz32) return 32 - Math.clz32(word);\n  let bit = 31;\n\n  for (; bit >= 0; bit--) {\n    if ((word & 1 << bit) !== 0) break;\n  }\n\n  return bit + 1;\n}\n\nfunction floor(n) {\n  if (n < 0) return -Math.floor(-n);\n  return Math.floor(n);\n}\n\nfunction enforce(value, name, type) {\n  if (!value) {\n    const err = new TypeError(`'${name}' must be a(n) ${type}.`);\n    if (Error.captureStackTrace) Error.captureStackTrace(err, enforce);\n    throw err;\n  }\n}\n\nfunction isNumber(num) {\n  return typeof num === 'number' && isFinite(num);\n}\n\nfunction isArray(num) {\n  if (Array.isArray) return Array.isArray(num);\n  return {}.toString.call(num).slice(8, -1) === 'Array';\n}\n\nfunction isSafeInteger(num) {\n  if (Number.isSafeInteger) return Number.isSafeInteger(num);\n  return isNumber(num) && Math.floor(num) === num && num >= -0x001fffffffffffff && num <= 0x001fffffffffffff;\n}\n\nfunction alloc(ArrayLike, size) {\n  if (ArrayLike.allocUnsafe) return ArrayLike.allocUnsafe(size);\n  return new ArrayLike(size);\n}\n\nfunction readI32LE(data, off) {\n  return data[off] | data[off + 1] << 8 | data[off + 2] << 16 | data[off + 3] << 24;\n}\n\nfunction readI32BE(data, off) {\n  return data[off] << 24 | data[off + 1] << 16 | data[off + 2] << 8 | data[off + 3];\n}\n\nfunction writeI32LE(data, num, off) {\n  data[off] = num & 0xff;\n  data[off + 1] = num >>> 8 & 0xff;\n  data[off + 2] = num >>> 16 & 0xff;\n  data[off + 3] = num >>> 24 & 0xff;\n}\n\nfunction writeI32BE(data, num, off) {\n  data[off] = num >>> 24 & 0xff;\n  data[off + 1] = num >>> 16 & 0xff;\n  data[off + 2] = num >>> 8 & 0xff;\n  data[off + 3] = num & 0xff;\n}\n/*\n * Expose\n */\n\n\nexports.N64 = N64;\nexports.U64 = U64;\nexports.I64 = I64;","map":null,"metadata":{},"sourceType":"script"}