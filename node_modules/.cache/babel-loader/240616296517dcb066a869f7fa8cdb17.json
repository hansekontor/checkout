{"ast":null,"code":"/*!\n * pem.js - PEM for javascript\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail\n *   https://tools.ietf.org/html/rfc1421\n *   https://tools.ietf.org/html/rfc1422\n *   https://tools.ietf.org/html/rfc1423\n *   https://tools.ietf.org/html/rfc1424\n *   https://tools.ietf.org/html/rfc4880\n *   https://tls.mbed.org/kb/cryptography/asn1-key-structures-in-der-and-pem\n *   https://github.com/crypto-browserify/EVP_BytesToKey/blob/master/index.js\n *   https://github.com/openssl/openssl/blob/master/include/openssl/pem.h\n *   https://github.com/openssl/openssl/blob/master/crypto/pem/pem_lib.c\n *   https://github.com/openssl/openssl/blob/master/crypto/evp/evp_key.c\n *   https://github.com/openssl/openssl/blob/master/crypto/pem/pem_pkey.c\n */\n\n/* eslint spaced-comment: \"off\" */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst base64 = require('./base64');\n\nconst lines = require('./lines');\n/*\n * Constants\n */\n\n\nconst EMPTY = Buffer.alloc(0);\n/**\n * PEMBlock\n */\n\nclass PEMBlock {\n  constructor(type, data) {\n    if (type == null) type = 'PRIVACY-ENHANCED MESSAGE';\n    if (data == null) data = EMPTY;\n    assert(typeof type === 'string');\n    assert(Buffer.isBuffer(data));\n    this.type = type;\n    this.headers = new Map();\n    this.data = data;\n  }\n\n  toString(armor) {\n    return encode(this.type, this.headers, this.data, armor);\n  }\n\n  fromString(str, armor) {\n    const iter = decode(str, armor);\n    const it = iter.next();\n    if (it.done) throw new Error('No PEM data found.');\n    const block = it.value;\n    this.type = block.type;\n    this.headers = block.headers;\n    this.data = block.data;\n    return this;\n  }\n\n  getProcType() {\n    const hdr = this.headers.get('Proc-Type');\n    if (!hdr) return null;\n    return ProcType.fromString(hdr);\n  }\n\n  setProcType(version, state) {\n    assert(version != null && state);\n    const proc = new ProcType(version, state);\n    this.headers.set('Proc-Type', proc.toString());\n    return this;\n  }\n\n  unsetProcType() {\n    this.headers.delete('Proc-Type');\n    return this;\n  }\n\n  getDEKInfo() {\n    const hdr = this.headers.get('DEK-Info');\n    if (!hdr) return null;\n    return DEKInfo.fromString(hdr);\n  }\n\n  setDEKInfo(name, iv) {\n    assert(name);\n    const info = new DEKInfo(name, iv);\n    this.headers.set('DEK-Info', info.toString());\n    return this;\n  }\n\n  unsetDEKInfo() {\n    this.headers.delete('DEK-Info');\n    return this;\n  }\n\n  isEncrypted() {\n    let type;\n\n    try {\n      type = this.getProcType();\n    } catch (e) {\n      return false;\n    }\n\n    if (!type) return false;\n    return type.version === 4 && type.state === 'ENCRYPTED';\n  }\n\n  static fromString(str, armor) {\n    return new this().fromString(str, armor);\n  }\n\n}\n/**\n * ProcType\n */\n\n\nclass ProcType {\n  constructor(version, state) {\n    if (version == null) version = 0;\n    if (state == null) state = 'NONE';\n    assert(version >>> 0 === version);\n    assert(typeof state === 'string');\n    this.version = version;\n    this.state = state.toUpperCase();\n  }\n\n  toString() {\n    return `${this.version},${this.state}`;\n  }\n\n  fromString(str) {\n    assert(typeof str === 'string');\n    const parts = str.split(',', 3);\n    if (parts.length !== 2) throw new Error('Invalid Proc-Type.');\n    this.version = parseU32(parts[0]);\n    this.state = parts[1].toUpperCase();\n    return this;\n  }\n\n  static fromString(str) {\n    return new this().fromString(str);\n  }\n\n}\n/**\n * DEKInfo\n */\n\n\nclass DEKInfo {\n  constructor(name, iv) {\n    if (name == null) name = 'AES-128-ECB';\n    if (iv == null) iv = EMPTY;\n    assert(typeof name === 'string');\n    assert(Buffer.isBuffer(iv));\n    this.name = name.toUpperCase();\n    this.iv = iv;\n  }\n\n  toString() {\n    const name = this.name;\n    if (this.iv.length === 0) return name;\n    const iv = this.iv.toString('hex');\n    return `${name},${iv.toUpperCase()}`;\n  }\n\n  fromString(str) {\n    assert(typeof str === 'string');\n    const parts = str.split(',', 3);\n    if (parts.length < 1 || parts.length > 2) throw new Error('Invalid DEK-Info.');\n    const name = parts[0];\n    if (name.length === 0) throw new Error('Invalid DEK-Info name.');\n    this.name = name.toUpperCase();\n    this.iv = EMPTY;\n\n    if (parts.length > 1) {\n      const hex = parts[1];\n      const iv = Buffer.from(hex, 'hex');\n      if (iv.length !== hex.length >>> 1) throw new Error('Invalid DEK-Info IV.');\n      this.iv = iv;\n    }\n\n    return this;\n  }\n\n  static fromString(str) {\n    return new this().fromString(str);\n  }\n\n}\n/*\n * PEM\n */\n\n\nfunction encode(type, headers, data) {\n  let armor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  assert(typeof type === 'string');\n  assert(headers instanceof Map);\n  assert(Buffer.isBuffer(data));\n  assert(typeof armor === 'boolean');\n  let str = '';\n  str += `-----BEGIN ${type}-----\\n`;\n\n  if (headers.size > 0) {\n    for (const [key, value] of headers) str += `${key}: ${value}\\n`;\n\n    str += '\\n';\n  }\n\n  const s = base64.encode(data);\n\n  for (let i = 0; i < s.length; i += 64) str += s.substring(i, i + 64) + '\\n';\n\n  if (armor) {\n    const crc = crc24(data);\n    str += `=${base64.encode(crc)}\\n`;\n  }\n\n  str += `-----END ${type}-----\\n`;\n  return str;\n}\n\nfunction* decode(str) {\n  let armor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  assert(typeof str === 'string');\n  assert(typeof armor === 'boolean');\n  let chunk = '';\n  let block = null;\n  let crc = null;\n\n  for (const [, line] of lines(str)) {\n    const index = line.indexOf(':');\n\n    if (index !== -1) {\n      if (!block) throw new Error('PEM parse error (misplaced header).');\n      const key = line.substring(0, index).trim();\n      const value = line.substring(index + 1).trim();\n      block.headers.set(key, value);\n      continue;\n    }\n\n    if (line.length >= 15 && line.substring(0, 5) === '-----') {\n      if (line.slice(-5) !== '-----') throw new Error('PEM parse error (invalid preamble).');\n      const preamble = line.slice(5, -5);\n\n      if (preamble.substring(0, 6) === 'BEGIN ') {\n        if (block) throw new Error('PEM parse error (un-ended block).');\n        const type = preamble.substring(6).trim();\n        block = new PEMBlock();\n        block.type = type;\n        continue;\n      }\n\n      if (preamble.substring(0, 4) === 'END ') {\n        if (!block) throw new Error('PEM parse error (unexpected end).');\n        const type = preamble.substring(4).trim();\n        if (block.type !== type) throw new Error('PEM parse error (type mismatch).');\n        block.data = base64.decode(chunk);\n        if (crc && !crc24(block.data).equals(crc)) throw new Error('PEM parse error (invalid armor checksum).');\n        yield block;\n        chunk = '';\n        block = null;\n        crc = null;\n        continue;\n      }\n\n      throw new Error('PEM parse error (unknown preamble).');\n    }\n\n    if (!block) throw new Error('PEM parse error (unexpected data).');\n\n    if (line.length === 5 && line.charCodeAt(0) === 0x3d\n    /*'='*/\n    ) {\n      if (!armor) continue;\n      if (crc) throw new Error('PEM parse error (unexpected armor checksum).');\n      crc = base64.decode(line.substring(1));\n      continue;\n    }\n\n    if (line.length > 96) throw new Error('PEM parse error (line too long).');\n    chunk += line.replace(/[\\t\\v ]/g, '');\n  }\n\n  if (block || crc) throw new Error('PEM parse error (un-ended block).');\n  if (chunk.length !== 0) throw new Error('PEM parse error (trailing data).');\n}\n\nfunction toPEM(data, type, armor) {\n  assert(Buffer.isBuffer(data));\n  assert(typeof type === 'string');\n  const block = new PEMBlock();\n  block.type = type;\n  block.data = data;\n  return block.toString(armor);\n}\n\nfunction fromPEM(str, type, armor) {\n  assert(typeof str === 'string');\n  assert(typeof type === 'string');\n  const block = PEMBlock.fromString(str, armor);\n  if (block.type !== type) throw new Error('PEM type mismatch.');\n  return block.data;\n}\n/*\n * Helpers\n */\n\n\nfunction crc24(data) {\n  assert(Buffer.isBuffer(data));\n  let crc = 0xb704ce;\n\n  for (let i = 0; i < data.length; i++) {\n    const ch = data[i];\n    crc ^= ch << 16;\n\n    for (let j = 0; j < 8; j++) {\n      crc <<= 1;\n      if (crc & 0x1000000) crc ^= 0x1864cfb;\n    }\n  }\n\n  crc &= 0xffffff;\n  const buf = Buffer.allocUnsafe(3);\n  buf[2] = crc;\n  crc >>>= 8;\n  buf[1] = crc;\n  crc >>>= 8;\n  buf[0] = crc;\n  return buf;\n}\n\nfunction parseU32(str) {\n  assert(typeof str === 'string');\n  if (str.length < 1 || str.length > 10) throw new Error('Invalid integer.');\n  let word = 0;\n\n  for (let i = 0; i < str.length; i++) {\n    const ch = str.charCodeAt(i);\n    if (ch < 0x30 || ch > 0x39) throw new Error('Invalid integer.');\n    word *= 10;\n    word += ch - 0x30;\n    if (i > 0 && word === 0) throw new Error('Invalid integer.');\n    if (word > 0xffffffff) throw new Error('Invalid integer.');\n  }\n\n  return word;\n}\n/*\n * Expose\n */\n\n\nexports.PEMBlock = PEMBlock;\nexports.ProcType = ProcType;\nexports.DEKInfo = DEKInfo;\nexports.encode = encode;\nexports.decode = decode;\nexports.toPEM = toPEM;\nexports.fromPEM = fromPEM;","map":null,"metadata":{},"sourceType":"script"}