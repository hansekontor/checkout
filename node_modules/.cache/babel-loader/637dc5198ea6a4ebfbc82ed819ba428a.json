{"ast":null,"code":"import { currency } from '@components/Common/Ticker';\nimport BigNumber from 'bignumber.js';\nimport cashaddr from 'ecashaddrjs';\nexport const fromLegacyDecimals = function (amount) {\n  let cashDecimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currency.cashDecimals;\n  // Input 0.00000546 BCH\n  // Output 5.46 XEC or 0.00000546 BCH, depending on currency.cashDecimals\n  const amountBig = new BigNumber(amount);\n  const conversionFactor = new BigNumber(10 ** (8 - cashDecimals));\n  const amountSmallestDenomination = amountBig.times(conversionFactor).toNumber();\n  return amountSmallestDenomination;\n};\nexport const fromSmallestDenomination = function (amount) {\n  let cashDecimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currency.cashDecimals;\n  const amountBig = new BigNumber(amount);\n  const multiplier = new BigNumber(10 ** (-1 * cashDecimals));\n  const amountInBaseUnits = amountBig.times(multiplier);\n  return amountInBaseUnits.toNumber();\n};\nexport const toSmallestDenomination = function (sendAmount) {\n  let cashDecimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currency.cashDecimals;\n  // Replace the BCH.toSatoshi method with an equivalent function that works for arbitrary decimal places\n  // Example, for an 8 decimal place currency like Bitcoin\n  // Input: a BigNumber of the amount of Bitcoin to be sent\n  // Output: a BigNumber of the amount of satoshis to be sent, or false if input is invalid\n  // Validate\n  // Input should be a BigNumber with no more decimal places than cashDecimals\n  const isValidSendAmount = BigNumber.isBigNumber(sendAmount) && sendAmount.dp() <= cashDecimals;\n\n  if (!isValidSendAmount) {\n    return false;\n  }\n\n  const conversionFactor = new BigNumber(10 ** cashDecimals);\n  const sendAmountSmallestDenomination = sendAmount.times(conversionFactor);\n  return sendAmountSmallestDenomination;\n};\nexport const formatBalance = (unformattedBalance, optionalLocale) => {\n  try {\n    if (optionalLocale === undefined) {\n      return new Number(unformattedBalance).toLocaleString({\n        maximumFractionDigits: currency.cashDecimals\n      });\n    }\n\n    return new Number(unformattedBalance).toLocaleString(optionalLocale, {\n      maximumFractionDigits: currency.cashDecimals\n    });\n  } catch (err) {\n    console.log(`Error in formatBalance for ${unformattedBalance}`);\n    console.log(err);\n    return unformattedBalance;\n  }\n};\nexport const batchArray = (inputArray, batchSize) => {\n  // take an array of n elements, return an array of arrays each of length batchSize\n  const batchedArray = [];\n\n  for (let i = 0; i < inputArray.length; i += batchSize) {\n    const tempArray = inputArray.slice(i, i + batchSize);\n    batchedArray.push(tempArray);\n  }\n\n  return batchedArray;\n};\nexport const flattenBatchedHydratedUtxos = batchedHydratedUtxoDetails => {\n  // Return same result as if only the bulk API call were made\n  // to do this, just need to move all utxos under one slpUtxos\n\n  /*\n  given \n  [\n    {\n      slpUtxos: [\n          {\n              utxos: [],\n              address: '',\n          }\n        ],\n    },\n    {\n      slpUtxos: [\n          {\n              utxos: [],\n              address: '',\n          }\n        ],\n    }\n  ]\n  return [\n  {\n      slpUtxos: [\n          {\n          utxos: [],\n          address: ''\n          },\n          {\n          utxos: [],\n          address: ''\n          },\n        ]\n      }\n  */\n  const flattenedBatchedHydratedUtxos = {\n    slpUtxos: []\n  };\n\n  for (let i = 0; i < batchedHydratedUtxoDetails.length; i += 1) {\n    const theseSlpUtxos = batchedHydratedUtxoDetails[i].slpUtxos[0];\n    flattenedBatchedHydratedUtxos.slpUtxos.push(theseSlpUtxos);\n  }\n\n  return flattenedBatchedHydratedUtxos;\n};\nexport const loadStoredWallet = walletStateFromStorage => {\n  // Accept cached tokens array that does not save BigNumber type of BigNumbers\n  // Return array with BigNumbers converted\n  // See BigNumber.js api for how to create a BigNumber object from an object\n  // https://mikemcl.github.io/bignumber.js/\n  const liveWalletState = walletStateFromStorage;\n  const {\n    slpBalancesAndUtxos,\n    tokens\n  } = liveWalletState;\n\n  for (let i = 0; i < tokens.length; i += 1) {\n    const thisTokenBalance = tokens[i].balance; // Ensure only add property if thisTokenBalance is an object\n\n    if (typeof thisTokenBalance === 'object' && !Array.isArray(thisTokenBalance) && thisTokenBalance !== null) {\n      thisTokenBalance._isBigNumber = true;\n    }\n\n    tokens[i].balance = new BigNumber(thisTokenBalance);\n  } // Also confirm balance is correct\n  // Necessary step in case currency.decimals changed since last startup\n\n\n  const balancesRebased = normalizeBalance(slpBalancesAndUtxos);\n  liveWalletState.balances = balancesRebased;\n  return liveWalletState;\n};\nexport const normalizeBalance = slpBalancesAndUtxos => {\n  const totalBalanceInSatoshis = slpBalancesAndUtxos.nonSlpUtxos.reduce((previousBalance, utxo) => previousBalance + utxo.value, 0);\n  return {\n    totalBalanceInSatoshis,\n    totalBalance: fromSmallestDenomination(totalBalanceInSatoshis)\n  };\n};\nexport const isValidStoredWallet = walletStateFromStorage => {\n  return typeof walletStateFromStorage === 'object' && 'state' in walletStateFromStorage && typeof walletStateFromStorage.state === 'object' && 'balances' in walletStateFromStorage.state && 'utxos' in walletStateFromStorage.state && 'slpBalancesAndUtxos' in walletStateFromStorage.state && 'tokens' in walletStateFromStorage.state;\n};\nexport const getWalletState = wallet => {\n  if (!wallet || !wallet.state) {\n    return {\n      balances: {\n        totalBalance: 0,\n        totalBalanceInSatoshis: 0\n      },\n      hydratedUtxoDetails: {},\n      tokens: [],\n      slpBalancesAndUtxos: {},\n      parsedTxHistory: [],\n      utxos: []\n    };\n  }\n\n  return wallet.state;\n};\nexport function convertToEcashPrefix(bitcoincashPrefixedAddress) {\n  // Prefix-less addresses may be valid, but the cashaddr.decode function used below\n  // will throw an error without a prefix. Hence, must ensure prefix to use that function.\n  const hasPrefix = bitcoincashPrefixedAddress.includes(':');\n\n  if (hasPrefix) {\n    // Is it bitcoincash: or simpleledger:\n    const {\n      type,\n      hash,\n      prefix\n    } = cashaddr.decode(bitcoincashPrefixedAddress);\n    let newPrefix;\n\n    if (prefix === 'bitcoincash') {\n      newPrefix = 'ecash';\n    } else if (prefix === 'simpleledger') {\n      newPrefix = 'etoken';\n    } else {\n      return bitcoincashPrefixedAddress;\n    }\n\n    const convertedAddress = cashaddr.encode(newPrefix, type, hash);\n    return convertedAddress;\n  } else {\n    return bitcoincashPrefixedAddress;\n  }\n}\nexport function convertEtokenToSimpleledger(etokenPrefixedAddress) {\n  // Prefix-less addresses may be valid, but the cashaddr.decode function used below\n  // will throw an error without a prefix. Hence, must ensure prefix to use that function.\n  const hasPrefix = etokenPrefixedAddress.includes(':');\n\n  if (hasPrefix) {\n    // Is it bitcoincash: or simpleledger:\n    const {\n      type,\n      hash,\n      prefix\n    } = cashaddr.decode(etokenPrefixedAddress);\n    let newPrefix;\n\n    if (prefix === 'etoken') {\n      newPrefix = 'simpleledger';\n    } else {\n      // return address with no change\n      return etokenPrefixedAddress;\n    }\n\n    const convertedAddress = cashaddr.encode(newPrefix, type, hash);\n    return convertedAddress;\n  } else {\n    // return address with no change\n    return etokenPrefixedAddress;\n  }\n}\nexport const confirmNonEtokenUtxos = (hydratedUtxos, nonEtokenUtxos) => {\n  // scan through hydratedUtxoDetails\n  for (let i = 0; i < hydratedUtxos.length; i += 1) {\n    // Find utxos with txids matching nonEtokenUtxos\n    if (nonEtokenUtxos.includes(hydratedUtxos[i].txid)) {\n      // Confirm that such utxos are not eToken utxos\n      hydratedUtxos[i].isValid = false;\n    }\n  }\n\n  return hydratedUtxos;\n};\nexport const checkNullUtxosForTokenStatus = txDataResults => {\n  const nonEtokenUtxos = [];\n\n  for (let j = 0; j < txDataResults.length; j += 1) {\n    const thisUtxoTxid = txDataResults[j].txid;\n    const thisUtxoVout = txDataResults[j].details.vout; // Iterate over outputs\n\n    for (let k = 0; k < thisUtxoVout.length; k += 1) {\n      const thisOutput = thisUtxoVout[k];\n\n      if (thisOutput.scriptPubKey.type === 'nulldata') {\n        const asmOutput = thisOutput.scriptPubKey.asm;\n\n        if (asmOutput.includes('OP_RETURN 5262419')) {\n          // then it's an eToken tx that has not been properly validated\n          // Do not include it in nonEtokenUtxos\n          // App will ignore it until SLPDB is able to validate it\n          console.log(`utxo ${thisUtxoTxid} requires further eToken validation, ignoring`);\n        } else {\n          // Otherwise it's just an OP_RETURN tx that SLPDB has some issue with\n          // It should still be in the user's utxo set\n          // Include it in nonEtokenUtxos\n          console.log(`utxo ${thisUtxoTxid} is not an eToken tx, adding to nonSlpUtxos`);\n          nonEtokenUtxos.push(thisUtxoTxid);\n        }\n      }\n    }\n  }\n\n  return nonEtokenUtxos;\n};\nexport const isLegacyMigrationRequired = wallet => {\n  // If the wallet does not have Path1899,\n  // Or each Path1899, Path145, Path245 does not have a public key\n  // Or it is using bitcoincash prefix\n  // Then it requires migration\n  if (!wallet.Path1899 || !wallet.Path1899.publicKey || !wallet.Path145.publicKey || !wallet.Path245.publicKey || wallet.Path1899.cashAddress.split(':')[0] === 'bitcoincash') {\n    return true;\n  }\n\n  return false;\n};","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/cashMethods.js"],"names":["currency","BigNumber","cashaddr","fromLegacyDecimals","amount","cashDecimals","amountBig","conversionFactor","amountSmallestDenomination","times","toNumber","fromSmallestDenomination","multiplier","amountInBaseUnits","toSmallestDenomination","sendAmount","isValidSendAmount","isBigNumber","dp","sendAmountSmallestDenomination","formatBalance","unformattedBalance","optionalLocale","undefined","Number","toLocaleString","maximumFractionDigits","err","console","log","batchArray","inputArray","batchSize","batchedArray","i","length","tempArray","slice","push","flattenBatchedHydratedUtxos","batchedHydratedUtxoDetails","flattenedBatchedHydratedUtxos","slpUtxos","theseSlpUtxos","loadStoredWallet","walletStateFromStorage","liveWalletState","slpBalancesAndUtxos","tokens","thisTokenBalance","balance","Array","isArray","_isBigNumber","balancesRebased","normalizeBalance","balances","totalBalanceInSatoshis","nonSlpUtxos","reduce","previousBalance","utxo","value","totalBalance","isValidStoredWallet","state","getWalletState","wallet","hydratedUtxoDetails","parsedTxHistory","utxos","convertToEcashPrefix","bitcoincashPrefixedAddress","hasPrefix","includes","type","hash","prefix","decode","newPrefix","convertedAddress","encode","convertEtokenToSimpleledger","etokenPrefixedAddress","confirmNonEtokenUtxos","hydratedUtxos","nonEtokenUtxos","txid","isValid","checkNullUtxosForTokenStatus","txDataResults","j","thisUtxoTxid","thisUtxoVout","details","vout","k","thisOutput","scriptPubKey","asmOutput","asm","isLegacyMigrationRequired","Path1899","publicKey","Path145","Path245","cashAddress","split"],"mappings":"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","sourcesContent":["import { currency } from '@components/Common/Ticker';\nimport BigNumber from 'bignumber.js';\nimport cashaddr from 'ecashaddrjs';\n\nexport const fromLegacyDecimals = (\n    amount,\n    cashDecimals = currency.cashDecimals,\n) => {\n    // Input 0.00000546 BCH\n    // Output 5.46 XEC or 0.00000546 BCH, depending on currency.cashDecimals\n    const amountBig = new BigNumber(amount);\n    const conversionFactor = new BigNumber(10 ** (8 - cashDecimals));\n    const amountSmallestDenomination = amountBig\n        .times(conversionFactor)\n        .toNumber();\n    return amountSmallestDenomination;\n};\n\nexport const fromSmallestDenomination = (\n    amount,\n    cashDecimals = currency.cashDecimals,\n) => {\n    const amountBig = new BigNumber(amount);\n    const multiplier = new BigNumber(10 ** (-1 * cashDecimals));\n    const amountInBaseUnits = amountBig.times(multiplier);\n    return amountInBaseUnits.toNumber();\n};\n\nexport const toSmallestDenomination = (\n    sendAmount,\n    cashDecimals = currency.cashDecimals,\n) => {\n    // Replace the BCH.toSatoshi method with an equivalent function that works for arbitrary decimal places\n    // Example, for an 8 decimal place currency like Bitcoin\n    // Input: a BigNumber of the amount of Bitcoin to be sent\n    // Output: a BigNumber of the amount of satoshis to be sent, or false if input is invalid\n\n    // Validate\n    // Input should be a BigNumber with no more decimal places than cashDecimals\n    const isValidSendAmount =\n        BigNumber.isBigNumber(sendAmount) && sendAmount.dp() <= cashDecimals;\n    if (!isValidSendAmount) {\n        return false;\n    }\n    const conversionFactor = new BigNumber(10 ** cashDecimals);\n    const sendAmountSmallestDenomination = sendAmount.times(conversionFactor);\n    return sendAmountSmallestDenomination;\n};\n\nexport const formatBalance = (unformattedBalance, optionalLocale) => {\n    try {\n        if (optionalLocale === undefined) {\n            return new Number(unformattedBalance).toLocaleString({\n                maximumFractionDigits: currency.cashDecimals,\n            });\n        }\n        return new Number(unformattedBalance).toLocaleString(optionalLocale, {\n            maximumFractionDigits: currency.cashDecimals,\n        });\n    } catch (err) {\n        console.log(`Error in formatBalance for ${unformattedBalance}`);\n        console.log(err);\n        return unformattedBalance;\n    }\n};\n\nexport const batchArray = (inputArray, batchSize) => {\n    // take an array of n elements, return an array of arrays each of length batchSize\n\n    const batchedArray = [];\n    for (let i = 0; i < inputArray.length; i += batchSize) {\n        const tempArray = inputArray.slice(i, i + batchSize);\n        batchedArray.push(tempArray);\n    }\n    return batchedArray;\n};\n\nexport const flattenBatchedHydratedUtxos = batchedHydratedUtxoDetails => {\n    // Return same result as if only the bulk API call were made\n    // to do this, just need to move all utxos under one slpUtxos\n    /*\n    given \n    [\n      {\n        slpUtxos: [\n            {\n                utxos: [],\n                address: '',\n            }\n          ],\n      },\n      {\n        slpUtxos: [\n            {\n                utxos: [],\n                address: '',\n            }\n          ],\n      }\n    ]\n  return [\n    {\n        slpUtxos: [\n            {\n            utxos: [],\n            address: ''\n            },\n            {\n            utxos: [],\n            address: ''\n            },\n          ]\n        }\n  */\n    const flattenedBatchedHydratedUtxos = { slpUtxos: [] };\n    for (let i = 0; i < batchedHydratedUtxoDetails.length; i += 1) {\n        const theseSlpUtxos = batchedHydratedUtxoDetails[i].slpUtxos[0];\n        flattenedBatchedHydratedUtxos.slpUtxos.push(theseSlpUtxos);\n    }\n    return flattenedBatchedHydratedUtxos;\n};\n\nexport const loadStoredWallet = walletStateFromStorage => {\n    // Accept cached tokens array that does not save BigNumber type of BigNumbers\n    // Return array with BigNumbers converted\n    // See BigNumber.js api for how to create a BigNumber object from an object\n    // https://mikemcl.github.io/bignumber.js/\n    const liveWalletState = walletStateFromStorage;\n    const { slpBalancesAndUtxos, tokens } = liveWalletState;\n    for (let i = 0; i < tokens.length; i += 1) {\n        const thisTokenBalance = tokens[i].balance;\n        // Ensure only add property if thisTokenBalance is an object\n        if (\n            typeof thisTokenBalance === 'object' &&\n            !Array.isArray(thisTokenBalance) &&\n            thisTokenBalance !== null\n        ) {\n            thisTokenBalance._isBigNumber = true;\n        }\n        tokens[i].balance = new BigNumber(thisTokenBalance);\n    }\n\n    // Also confirm balance is correct\n    // Necessary step in case currency.decimals changed since last startup\n    const balancesRebased = normalizeBalance(slpBalancesAndUtxos);\n    liveWalletState.balances = balancesRebased;\n    return liveWalletState;\n};\n\nexport const normalizeBalance = slpBalancesAndUtxos => {\n    const totalBalanceInSatoshis = slpBalancesAndUtxos.nonSlpUtxos.reduce(\n        (previousBalance, utxo) => previousBalance + utxo.value,\n        0,\n    );\n    return {\n        totalBalanceInSatoshis,\n        totalBalance: fromSmallestDenomination(totalBalanceInSatoshis),\n    };\n};\n\nexport const isValidStoredWallet = walletStateFromStorage => {\n    return (\n        typeof walletStateFromStorage === 'object' &&\n        'state' in walletStateFromStorage &&\n        typeof walletStateFromStorage.state === 'object' &&\n        'balances' in walletStateFromStorage.state &&\n        'utxos' in walletStateFromStorage.state &&\n        'slpBalancesAndUtxos' in walletStateFromStorage.state &&\n        'tokens' in walletStateFromStorage.state\n    );\n};\n\nexport const getWalletState = wallet => {\n    if (!wallet || !wallet.state) {\n        return {\n            balances: { totalBalance: 0, totalBalanceInSatoshis: 0 },\n            hydratedUtxoDetails: {},\n            tokens: [],\n            slpBalancesAndUtxos: {},\n            parsedTxHistory: [],\n            utxos: [],\n        };\n    }\n\n    return wallet.state;\n};\n\nexport function convertToEcashPrefix(bitcoincashPrefixedAddress) {\n    // Prefix-less addresses may be valid, but the cashaddr.decode function used below\n    // will throw an error without a prefix. Hence, must ensure prefix to use that function.\n    const hasPrefix = bitcoincashPrefixedAddress.includes(':');\n    if (hasPrefix) {\n        // Is it bitcoincash: or simpleledger:\n        const { type, hash, prefix } = cashaddr.decode(\n            bitcoincashPrefixedAddress,\n        );\n\n        let newPrefix;\n        if (prefix === 'bitcoincash') {\n            newPrefix = 'ecash';\n        } else if (prefix === 'simpleledger') {\n            newPrefix = 'etoken';\n        } else {\n            return bitcoincashPrefixedAddress;\n        }\n\n        const convertedAddress = cashaddr.encode(newPrefix, type, hash);\n\n        return convertedAddress;\n    } else {\n        return bitcoincashPrefixedAddress;\n    }\n}\n\nexport function convertEtokenToSimpleledger(etokenPrefixedAddress) {\n    // Prefix-less addresses may be valid, but the cashaddr.decode function used below\n    // will throw an error without a prefix. Hence, must ensure prefix to use that function.\n    const hasPrefix = etokenPrefixedAddress.includes(':');\n    if (hasPrefix) {\n        // Is it bitcoincash: or simpleledger:\n        const { type, hash, prefix } = cashaddr.decode(etokenPrefixedAddress);\n\n        let newPrefix;\n        if (prefix === 'etoken') {\n            newPrefix = 'simpleledger';\n        } else {\n            // return address with no change\n\n            return etokenPrefixedAddress;\n        }\n\n        const convertedAddress = cashaddr.encode(newPrefix, type, hash);\n\n        return convertedAddress;\n    } else {\n        // return address with no change\n        return etokenPrefixedAddress;\n    }\n}\n\nexport const confirmNonEtokenUtxos = (hydratedUtxos, nonEtokenUtxos) => {\n    // scan through hydratedUtxoDetails\n    for (let i = 0; i < hydratedUtxos.length; i += 1) {\n        // Find utxos with txids matching nonEtokenUtxos\n        if (nonEtokenUtxos.includes(hydratedUtxos[i].txid)) {\n            // Confirm that such utxos are not eToken utxos\n            hydratedUtxos[i].isValid = false;\n        }\n    }\n    return hydratedUtxos;\n};\n\nexport const checkNullUtxosForTokenStatus = txDataResults => {\n    const nonEtokenUtxos = [];\n    for (let j = 0; j < txDataResults.length; j += 1) {\n        const thisUtxoTxid = txDataResults[j].txid;\n        const thisUtxoVout = txDataResults[j].details.vout;\n        // Iterate over outputs\n        for (let k = 0; k < thisUtxoVout.length; k += 1) {\n            const thisOutput = thisUtxoVout[k];\n            if (thisOutput.scriptPubKey.type === 'nulldata') {\n                const asmOutput = thisOutput.scriptPubKey.asm;\n                if (asmOutput.includes('OP_RETURN 5262419')) {\n                    // then it's an eToken tx that has not been properly validated\n                    // Do not include it in nonEtokenUtxos\n                    // App will ignore it until SLPDB is able to validate it\n                    console.log(\n                        `utxo ${thisUtxoTxid} requires further eToken validation, ignoring`,\n                    );\n                } else {\n                    // Otherwise it's just an OP_RETURN tx that SLPDB has some issue with\n                    // It should still be in the user's utxo set\n                    // Include it in nonEtokenUtxos\n                    console.log(\n                        `utxo ${thisUtxoTxid} is not an eToken tx, adding to nonSlpUtxos`,\n                    );\n                    nonEtokenUtxos.push(thisUtxoTxid);\n                }\n            }\n        }\n    }\n    return nonEtokenUtxos;\n};\n\nexport const isLegacyMigrationRequired = wallet => {\n    // If the wallet does not have Path1899,\n    // Or each Path1899, Path145, Path245 does not have a public key\n    // Or it is using bitcoincash prefix\n    // Then it requires migration\n    if (\n        !wallet.Path1899 ||\n        !wallet.Path1899.publicKey ||\n        !wallet.Path145.publicKey ||\n        !wallet.Path245.publicKey ||\n        wallet.Path1899.cashAddress.split(':')[0] === 'bitcoincash'\n    ) {\n        return true;\n    }\n\n    return false;\n};\n"]},"metadata":{},"sourceType":"module"}