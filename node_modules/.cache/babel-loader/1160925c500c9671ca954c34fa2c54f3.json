{"ast":null,"code":"/*!\n * dsa.js - DSA for javascript\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on golang/go:\n *   Copyright (c) 2009, The Go Authors. All rights reserved.\n *   https://github.com/golang/go\n *\n * References:\n *\n *   [FIPS186] Federal Information Processing Standards Publication\n *     National Institute of Standards and Technology\n *     http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf\n *\n *   [DSA] Digital Signature Algorithm (wikipedia)\n *     https://en.wikipedia.org/wiki/Digital_Signature_Algorithm\n *\n *   [RFC6979] Deterministic Usage of the Digital Signature\n *             Algorithm (DSA) and Elliptic Curve Digital\n *             Signature Algorithm (ECDSA)\n *     T. Pornin\n *     https://tools.ietf.org/html/rfc6979\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst BN = require('../bn');\n\nconst rng = require('../random');\n\nconst HmacDRBG = require('../hmac-drbg');\n\nconst SHA256 = require('../sha256');\n\nconst {\n  isProbablePrime\n} = require('../internal/primes');\n\nconst asn1 = require('../internal/asn1');\n/*\n * Constants\n */\n\n\nconst DEFAULT_BITS = 2048;\nconst MIN_BITS = 512;\nconst MAX_BITS = 10000;\n/**\n * DSAParams\n */\n\nclass DSAParams {\n  constructor() {\n    this.p = new BN(0);\n    this.q = new BN(0);\n    this.g = new BN(0);\n  }\n\n  bits() {\n    return this.p.bitLength();\n  }\n\n  size() {\n    return this.q.byteLength();\n  }\n\n  isSane() {\n    if (this.p.sign() < 0 || this.q.sign() < 0) return false;\n    const pbits = this.p.bitLength();\n    const qbits = this.q.bitLength();\n    if (pbits < MIN_BITS || pbits > MAX_BITS) return false;\n    if (qbits !== 160 && qbits !== 224 && qbits !== 256) return false;\n    if (this.g.cmpn(2) < 0 || this.g.cmp(this.p.subn(1)) >= 0) return false;\n    if (!this.p.isOdd()) return false;\n    if (!this.q.isOdd()) return false;\n    return true;\n  }\n\n  verify() {\n    return this.g.powm(this.q, this.p).cmpn(1) === 0;\n  }\n\n  generate(L, N) {\n    // [FIPS186] Page 31, Appendix A.1.\n    //           Page 41, Appendix A.2.\n    // [DSA] \"Parameter generation\".\n    assert(L >>> 0 === L);\n    assert(N >>> 0 === N);\n\n    if (!(L === 1024 && N === 160) && !(L === 2048 && N === 224) && !(L === 2048 && N === 256) && !(L === 3072 && N === 256)) {\n      throw new Error('Invalid parameter sizes.');\n    }\n\n    if (L < MIN_BITS || L > MAX_BITS || (N & 7) !== 0) throw new Error('Invalid parameter sizes.');\n    let q = null;\n    let p = null;\n\n    outer: for (;;) {\n      q = BN.randomBits(rng, N);\n      q.setn(N - 1, 1);\n      q.setn(0, 1);\n      if (!isProbablePrime(q, 64)) continue;\n\n      for (let i = 0; i < 4 * L; i++) {\n        p = BN.randomBits(rng, L);\n        p.setn(L - 1, 1);\n        p.setn(0, 1);\n        p.isub(p.mod(q).isubn(1));\n        const bits = p.bitLength();\n        if (bits < L || bits > MAX_BITS) continue;\n        if (!isProbablePrime(p, 64)) continue;\n        break outer;\n      }\n    }\n\n    const h = new BN(2);\n    const pm1 = p.subn(1);\n    const e = pm1.div(q);\n\n    for (;;) {\n      const g = h.powm(e, p);\n\n      if (g.cmpn(1) === 0) {\n        h.iaddn(1);\n        continue;\n      }\n\n      this.p = p;\n      this.q = q;\n      this.g = g;\n      return this;\n    }\n  }\n\n  toParams() {\n    const group = new DSAParams();\n    group.p = this.p;\n    group.q = this.q;\n    group.g = this.g;\n    return group;\n  }\n\n  encode() {\n    let size = 0;\n    size += asn1.sizeInt(this.p);\n    size += asn1.sizeInt(this.q);\n    size += asn1.sizeInt(this.g);\n    const out = Buffer.alloc(asn1.sizeSeq(size));\n    let pos = 0;\n    pos = asn1.writeSeq(out, pos, size);\n    pos = asn1.writeInt(out, pos, this.p);\n    pos = asn1.writeInt(out, pos, this.q);\n    pos = asn1.writeInt(out, pos, this.g);\n    assert(pos === out.length);\n    return out;\n  }\n\n  decode(data) {\n    assert(Buffer.isBuffer(data));\n    let pos = 0;\n    pos = asn1.readSeq(data, pos);\n    [this.p, pos] = asn1.readInt(data, pos);\n    [this.q, pos] = asn1.readInt(data, pos);\n    [this.g, pos] = asn1.readInt(data, pos);\n    if (pos !== data.length) throw new Error('Trailing bytes.');\n    return this;\n  }\n\n  static generate(L, N) {\n    return new DSAParams().generate(L, N);\n  }\n\n  static decode(data) {\n    return new DSAParams().decode(data);\n  }\n\n}\n/**\n * DSAPublicKey\n */\n\n\nclass DSAPublicKey extends DSAParams {\n  constructor() {\n    super();\n    this.y = new BN(0);\n  }\n\n  isSane() {\n    if (!super.isSane()) return false;\n    if (this.y.cmpn(2) < 0 || this.y.cmp(this.p.subn(1)) >= 0) return false;\n    return true;\n  }\n\n  verify() {\n    if (!super.verify()) return false;\n    return this.y.powm(this.q, this.p).cmpn(1) === 0;\n  }\n\n  encode() {\n    let size = 0;\n    size += asn1.sizeInt(this.y);\n    size += asn1.sizeInt(this.p);\n    size += asn1.sizeInt(this.q);\n    size += asn1.sizeInt(this.g);\n    const out = Buffer.alloc(asn1.sizeSeq(size));\n    let pos = 0;\n    pos = asn1.writeSeq(out, pos, size);\n    pos = asn1.writeInt(out, pos, this.y);\n    pos = asn1.writeInt(out, pos, this.p);\n    pos = asn1.writeInt(out, pos, this.q);\n    pos = asn1.writeInt(out, pos, this.g);\n    assert(pos === out.length);\n    return out;\n  }\n\n  decode(data) {\n    assert(Buffer.isBuffer(data));\n    let pos = 0;\n    pos = asn1.readSeq(data, pos);\n    [this.y, pos] = asn1.readInt(data, pos);\n    [this.p, pos] = asn1.readInt(data, pos);\n    [this.q, pos] = asn1.readInt(data, pos);\n    [this.g, pos] = asn1.readInt(data, pos);\n    if (pos !== data.length) throw new Error('Trailing bytes.');\n    return this;\n  }\n\n  static decode(data) {\n    return new DSAPublicKey().decode(data);\n  }\n\n}\n/**\n * DSAPrivateKey\n */\n\n\nclass DSAPrivateKey extends DSAPublicKey {\n  constructor() {\n    super();\n    this.x = new BN(0);\n  }\n\n  isSane() {\n    if (!super.isSane()) return false;\n    if (this.x.sign() <= 0 || this.x.cmp(this.q) >= 0) return false;\n    return true;\n  }\n\n  isSaneCompute() {\n    const group = new DSAParams();\n    group.p = this.p;\n    group.q = this.q;\n    group.g = this.g;\n    if (!group.isSane()) return false;\n    if (this.x.sign() <= 0 || this.x.cmp(this.q) >= 0) return false;\n    return true;\n  }\n\n  verify() {\n    if (!super.verify()) return false;\n    const y = this.g.powm(this.x, this.p);\n    return this.y.eq(y);\n  }\n\n  toPublic() {\n    const pub = new DSAPublicKey();\n    pub.p = this.p;\n    pub.q = this.q;\n    pub.g = this.g;\n    pub.y = this.y;\n    return pub;\n  }\n\n  encode() {\n    let size = 0;\n    size += asn1.sizeVersion(0);\n    size += asn1.sizeInt(this.p);\n    size += asn1.sizeInt(this.q);\n    size += asn1.sizeInt(this.g);\n    size += asn1.sizeInt(this.y);\n    size += asn1.sizeInt(this.x);\n    const out = Buffer.alloc(asn1.sizeSeq(size));\n    let pos = 0;\n    pos = asn1.writeSeq(out, pos, size);\n    pos = asn1.writeVersion(out, pos, 0);\n    pos = asn1.writeInt(out, pos, this.p);\n    pos = asn1.writeInt(out, pos, this.q);\n    pos = asn1.writeInt(out, pos, this.g);\n    pos = asn1.writeInt(out, pos, this.y);\n    pos = asn1.writeInt(out, pos, this.x);\n    assert(pos === out.length);\n    return out;\n  }\n\n  decode(data) {\n    assert(Buffer.isBuffer(data));\n    let pos = 0;\n    pos = asn1.readSeq(data, pos);\n    pos = asn1.readVersion(data, pos, 0);\n    [this.p, pos] = asn1.readInt(data, pos);\n    [this.q, pos] = asn1.readInt(data, pos);\n    [this.g, pos] = asn1.readInt(data, pos);\n    [this.y, pos] = asn1.readInt(data, pos);\n    [this.x, pos] = asn1.readInt(data, pos);\n    if (pos !== data.length) throw new Error('Trailing bytes.');\n    return this;\n  }\n\n  static decode(data) {\n    return new DSAPrivateKey().decode(data);\n  }\n\n}\n/**\n * DSASignature\n */\n\n\nclass DSASignature {\n  constructor() {\n    this.r = new BN(0);\n    this.s = new BN(0);\n  }\n\n  encode() {\n    const size = asn1.sizeInt(this.r) + asn1.sizeInt(this.s);\n    const out = Buffer.alloc(asn1.sizeSeq(size));\n    let pos = 0;\n    pos = asn1.writeSeq(out, pos, size);\n    pos = asn1.writeInt(out, pos, this.r);\n    pos = asn1.writeInt(out, pos, this.s);\n    assert(pos === out.length);\n    return out;\n  }\n\n  decode(data) {\n    assert(Buffer.isBuffer(data));\n    let pos = 0;\n    pos = asn1.readSeq(data, pos);\n    [this.r, pos] = asn1.readInt(data, pos);\n    [this.s, pos] = asn1.readInt(data, pos);\n    if (pos !== data.length) throw new Error('Trailing bytes.');\n    return this;\n  }\n\n  encodeRS(size) {\n    assert(size >> 0 === size);\n    return Buffer.concat([this.r.encode('be', size), this.s.encode('be', size)]);\n  }\n\n  decodeRS(data, size) {\n    assert(Buffer.isBuffer(data));\n    if (size == null) size = data.length >>> 1;\n    assert(size >> 0 === size);\n    assert(data.length === size * 2);\n    this.r = BN.decode(data.slice(0, size));\n    this.s = BN.decode(data.slice(size, size * 2));\n    return this;\n  }\n\n  static decode(data) {\n    return new DSASignature().decode(data);\n  }\n\n  static decodeRS(data, size) {\n    return new DSASignature().decodeRS(data, size);\n  }\n\n}\n/**\n * Create params from key.\n * @param {Buffer} key\n * @returns {Buffer}\n */\n\n\nfunction paramsCreate(key) {\n  assert(Buffer.isBuffer(key));\n  let k;\n\n  try {\n    k = DSAPrivateKey.decode(key);\n  } catch (e) {\n    k = DSAPublicKey.decode(key);\n  }\n\n  const group = k.toParams();\n  if (!group.isSane()) throw new Error('Invalid DSA key.');\n  return group.encode();\n}\n/**\n * Generate params.\n * @param {Number} [bits=2048]\n * @returns {Buffer}\n */\n\n\nfunction paramsGenerate(bits) {\n  if (bits == null) bits = DEFAULT_BITS;\n  assert(bits >>> 0 === bits);\n  if (bits < MIN_BITS || bits > MAX_BITS) throw new RangeError(`\"bits\" ranges from ${MIN_BITS} to ${MAX_BITS}.`); // OpenSSL behavior.\n\n  const L = bits;\n  const N = bits < 2048 ? 160 : 256;\n  return DSAParams.generate(L, N).encode();\n}\n/**\n * Generate params.\n * @param {Number} [bits=2048]\n * @returns {Buffer}\n */\n\n\nasync function paramsGenerateAsync(bits) {\n  return paramsGenerate(bits);\n}\n/**\n * Get params prime size in bits.\n * @param {Buffer} params\n * @returns {Number}\n */\n\n\nfunction paramsBits(params) {\n  const group = DSAParams.decode(params);\n  if (!group.isSane()) throw new Error('Invalid DSA params.');\n  return group.bits();\n}\n/**\n * Verify params.\n * @param {Buffer} params\n * @returns {Boolean}\n */\n\n\nfunction paramsVerify(params) {\n  assert(Buffer.isBuffer(params));\n  let group;\n\n  try {\n    group = DSAParams.decode(params);\n  } catch (e) {\n    return false;\n  }\n\n  if (!group.isSane()) return false;\n  return group.verify();\n}\n/**\n * Import params from an object.\n * @param {Object} json\n * @returns {Buffer}\n */\n\n\nfunction paramsImport(json) {\n  assert(json && typeof json === 'object');\n  const group = new DSAParams();\n  if (json.p != null) group.p = BN.decode(json.p);\n  if (json.q != null) group.q = BN.decode(json.q);\n  if (json.g != null) group.g = BN.decode(json.g);\n  if (!group.isSane()) throw new Error('Invalid DSA parameters.');\n  return group.encode();\n}\n/**\n * Export params to an object.\n * @param {Buffer} params\n * @returns {Object}\n */\n\n\nfunction paramsExport(params) {\n  const group = DSAParams.decode(params);\n  if (!group.isSane()) throw new Error('Invalid DSA parameters.');\n  return {\n    p: group.p.encode(),\n    q: group.q.encode(),\n    g: group.g.encode()\n  };\n}\n/**\n * Generate private key from params.\n * @param {Buffer} params\n * @returns {Buffer}\n */\n\n\nfunction privateKeyCreate(params) {\n  // [FIPS186] Page 46, Appendix B.1.\n  // [DSA] \"Per-user keys\".\n  const group = DSAParams.decode(params);\n  if (!group.isSane()) throw new Error('Invalid DSA parameters.');\n  const {\n    p,\n    q,\n    g\n  } = group;\n  const x = BN.random(rng, 1, q);\n  const y = g.powm(x, p);\n  const key = new DSAPrivateKey();\n  key.p = p;\n  key.q = q;\n  key.g = g;\n  key.x = x;\n  key.y = y;\n  return key.encode();\n}\n/**\n * Generate private key.\n * @param {Number} [bits=2048]\n * @returns {Buffer}\n */\n\n\nfunction privateKeyGenerate(bits) {\n  const params = paramsGenerate(bits);\n  return privateKeyCreate(params);\n}\n/**\n * Generate private key.\n * @param {Number} [bits=2048]\n * @returns {Buffer}\n */\n\n\nasync function privateKeyGenerateAsync(bits) {\n  const params = await paramsGenerateAsync(bits);\n  return privateKeyCreate(params);\n}\n/**\n * Get private key prime size in bits.\n * @param {Buffer} key\n * @returns {Number}\n */\n\n\nfunction privateKeyBits(key) {\n  const k = DSAPrivateKey.decode(key);\n  if (!k.isSane()) throw new Error('Invalid DSA private key.');\n  return k.bits();\n}\n/**\n * Verify a private key.\n * @param {Buffer} key\n * @returns {Boolean}\n */\n\n\nfunction privateKeyVerify(key) {\n  assert(Buffer.isBuffer(key));\n  let k;\n\n  try {\n    k = DSAPrivateKey.decode(key);\n  } catch (e) {\n    return false;\n  }\n\n  if (!k.isSane()) return false;\n  return k.verify();\n}\n/**\n * Import a private key from an object.\n * @param {Object} json\n * @returns {Buffer}\n */\n\n\nfunction privateKeyImport(json) {\n  assert(json && typeof json === 'object');\n  const k = new DSAPrivateKey();\n  if (json.p != null) k.p = BN.decode(json.p);\n  if (json.q != null) k.q = BN.decode(json.q);\n  if (json.g != null) k.g = BN.decode(json.g);\n  if (json.y != null) k.y = BN.decode(json.y);\n  if (json.x != null) k.x = BN.decode(json.x);\n\n  if (k.y.isZero()) {\n    if (!k.isSaneCompute()) throw new Error('Invalid DSA private key.');\n    k.y = k.g.powm(k.x, k.p);\n  } else {\n    if (!k.isSane()) throw new Error('Invalid DSA private key.');\n  }\n\n  return k.encode();\n}\n/**\n * Export a private key in OpenSSL ASN.1 format.\n * @param {Buffer} key\n * @returns {Buffer}\n */\n\n\nfunction privateKeyExport(key) {\n  const k = DSAPrivateKey.decode(key);\n  if (!k.isSane()) throw new Error('Invalid RSA private key.');\n  return {\n    p: k.p.encode(),\n    q: k.q.encode(),\n    g: k.g.encode(),\n    y: k.y.encode(),\n    x: k.x.encode()\n  };\n}\n/**\n * Create a public key from a private key.\n * @param {Buffer} key\n * @returns {Buffer}\n */\n\n\nfunction publicKeyCreate(key) {\n  const k = DSAPrivateKey.decode(key);\n  if (!k.isSane()) throw new Error('Invalid DSA private key.');\n  const p = k.toPublic();\n  return p.encode();\n}\n/**\n * Get public key prime size in bits.\n * @param {Buffer} key\n * @returns {Number}\n */\n\n\nfunction publicKeyBits(key) {\n  const k = DSAPublicKey.decode(key);\n  if (!k.isSane()) throw new Error('Invalid DSA public key.');\n  return k.bits();\n}\n/**\n * Verify a public key.\n * @param {Buffer} key\n * @returns {Boolean}\n */\n\n\nfunction publicKeyVerify(key) {\n  let k;\n\n  try {\n    k = DSAPublicKey.decode(key);\n  } catch (e) {\n    return false;\n  }\n\n  if (!k.isSane()) return false;\n  return k.verify();\n}\n/**\n * Import a public key to an object.\n * @param {Object} json\n * @returns {Buffer}\n */\n\n\nfunction publicKeyImport(json) {\n  assert(json && typeof json === 'object');\n  const k = new DSAPublicKey();\n  if (json.p != null) k.p = BN.decode(json.p);\n  if (json.q != null) k.q = BN.decode(json.q);\n  if (json.g != null) k.g = BN.decode(json.g);\n  if (json.y != null) k.y = BN.decode(json.y);\n  if (!k.isSane()) throw new Error('Invalid DSA public key.');\n  return k.encode();\n}\n/**\n * Export a public key to an object.\n * @param {Buffer} key\n * @returns {Object}\n */\n\n\nfunction publicKeyExport(key) {\n  const k = DSAPublicKey.decode(key);\n  if (!k.isSane()) throw new Error('Invalid DSA public key.');\n  return {\n    p: k.p.encode(),\n    q: k.q.encode(),\n    g: k.g.encode(),\n    y: k.y.encode()\n  };\n}\n/**\n * Convert DER signature to R/S.\n * @param {Buffer} sig\n * @param {Number} size\n * @returns {Buffer} R/S-formatted signature.\n */\n\n\nfunction signatureImport(sig, size) {\n  const S = DSASignature.decode(sig);\n  return S.encodeRS(size);\n}\n/**\n * Convert R/S signature to DER.\n * @param {Buffer} sig\n * @param {Number} size\n * @returns {Buffer} DER-formatted signature.\n */\n\n\nfunction signatureExport(sig, size) {\n  const S = DSASignature.decodeRS(sig, size);\n  return S.encode();\n}\n/**\n * Sign a message (R/S).\n * @param {Buffer} msg\n * @param {Buffer} key - Private key.\n * @returns {Buffer} R/S-formatted signature.\n */\n\n\nfunction sign(msg, key) {\n  const k = DSAPrivateKey.decode(key);\n\n  const S = _sign(msg, k);\n\n  return S.encodeRS(k.size());\n}\n/**\n * Sign a message (DER).\n * @param {Buffer} msg\n * @param {Buffer} key - Private key.\n * @returns {Buffer} DER-formatted signature.\n */\n\n\nfunction signDER(msg, key) {\n  const k = DSAPrivateKey.decode(key);\n\n  const S = _sign(msg, k);\n\n  return S.encode();\n}\n/**\n * Sign a message.\n * @private\n * @param {Buffer} msg\n * @param {Buffer} key\n * @returns {Signature}\n */\n\n\nfunction _sign(msg, key) {\n  // DSA Signing.\n  //\n  // [FIPS186] Page 19, Section 4.6.\n  // [DSA] \"Signing\".\n  // [RFC6979] Page 9, Section 2.4.\n  // [RFC6979] Page 10, Section 3.2.\n  //\n  // Assumptions:\n  //\n  //   - Let `m` be an integer reduced from bytes.\n  //   - Let `x` be a secret non-zero scalar.\n  //   - Let `k` be a random non-zero scalar.\n  //   - r != 0, s != 0.\n  //\n  // Computation:\n  //\n  //   k = random integer in [1,q-1]\n  //   r' = g^k mod p\n  //   r = r' mod q\n  //   s = (r * x + m) / k mod q\n  //   S = (r, s)\n  //\n  // We can blind the scalar arithmetic\n  // with a random integer `b` like so:\n  //\n  //   b = random integer in [1,q-1]\n  //   s = (r * (x * b) + m * b) / (k * b) mod q\n  //\n  // Note that `k` must remain secret,\n  // otherwise an attacker can compute:\n  //\n  //   x = (s * k - m) / r mod q\n  //\n  // This means that if two signatures\n  // share the same `r` value, an attacker\n  // can compute:\n  //\n  //   k = (m1 - m2) / (s1 - s2) mod q\n  //   x = (s1 * k - m1) / r mod q\n  //\n  // Assuming:\n  //\n  //   s1 = (r * x + m1) / k mod q\n  //   s2 = (r * x + m2) / k mod q\n  //\n  // To mitigate this, `k` can be generated\n  // deterministically using the HMAC-DRBG\n  // construction described in [RFC6979].\n  assert(Buffer.isBuffer(msg));\n  assert(key instanceof DSAPrivateKey);\n  if (!key.isSane()) throw new Error('Invalid DSA private key.');\n  const {\n    p,\n    q,\n    g,\n    x\n  } = key;\n  const bytes = q.byteLength();\n  const m = reduce(msg, q);\n  const entropy = x.encode('be', bytes);\n  const nonce = m.encode('be', bytes);\n  const drbg = new HmacDRBG(SHA256, entropy, nonce);\n\n  for (;;) {\n    const k = truncate(drbg.generate(bytes), q);\n    if (k.isZero() || k.cmp(q) >= 0) continue;\n    const re = powBlind(g, k, p, q);\n    const r = re.mod(q);\n    if (r.isZero()) continue;\n    const b = BN.random(rng, 1, q);\n    const ki = k.mul(b).fermat(q);\n    const bx = x.mul(b).imod(q);\n    const bm = m.mul(b).imod(q);\n    const sk = r.mul(bx).iadd(bm).imod(q);\n    const s = sk.mul(ki).imod(q);\n    if (s.isZero()) continue;\n    const S = new DSASignature();\n    S.r = r;\n    S.s = s;\n    return S;\n  }\n}\n/**\n * Verify a signature (R/S).\n * @private\n * @param {Buffer} msg\n * @param {Buffer} sig - R/S-formatted.\n * @param {Buffer} key\n * @returns {Boolean}\n */\n\n\nfunction verify(msg, sig, key) {\n  assert(Buffer.isBuffer(msg));\n  assert(Buffer.isBuffer(sig));\n  assert(Buffer.isBuffer(key));\n  let k;\n\n  try {\n    k = DSAPublicKey.decode(key);\n  } catch (e) {\n    return false;\n  }\n\n  let S;\n\n  try {\n    S = DSASignature.decodeRS(sig, k.size());\n  } catch (e) {\n    return false;\n  }\n\n  try {\n    return _verify(msg, S, k);\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * Verify a signature (DER).\n * @param {Buffer} msg\n * @param {Buffer} sig - DER-formatted.\n * @param {Buffer} key\n * @returns {Boolean}\n */\n\n\nfunction verifyDER(msg, sig, key) {\n  assert(Buffer.isBuffer(msg));\n  assert(Buffer.isBuffer(sig));\n  assert(Buffer.isBuffer(key));\n  let k;\n\n  try {\n    k = DSAPublicKey.decode(key);\n  } catch (e) {\n    return false;\n  }\n\n  let S;\n\n  try {\n    S = DSASignature.decode(sig);\n  } catch (e) {\n    return false;\n  }\n\n  try {\n    return _verify(msg, S, k);\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * Verify a signature.\n * @private\n * @param {Buffer} msg\n * @param {Signature} S\n * @param {Buffer} key\n * @returns {Boolean}\n */\n\n\nfunction _verify(msg, S, key) {\n  // DSA Verification.\n  //\n  // [FIPS186] Page 19, Section 4.7.\n  // [DSA] \"Verifying a signature\".\n  //\n  // Assumptions:\n  //\n  //   - Let `m` be an integer reduced from bytes.\n  //   - Let `r` and `s` be signature elements.\n  //   - Let `y` be a valid group element.\n  //   - r != 0, r < q.\n  //   - s != 0, s < q.\n  //\n  // Computation:\n  //\n  //   u1 = m / s mod q\n  //   u2 = r / s mod q\n  //   r' = g^u1 * y^u2 mod p\n  //   r == r' mod q\n  const {\n    r,\n    s\n  } = S;\n  const {\n    p,\n    q,\n    g,\n    y\n  } = key;\n  if (!key.isSane()) return false;\n  if (r.isZero() || r.cmp(q) >= 0) return false;\n  if (s.isZero() || s.cmp(q) >= 0) return false;\n  const m = reduce(msg, q);\n  const si = s.invert(q);\n  const u1 = m.mul(si).imod(q);\n  const u2 = r.mul(si).imod(q);\n  const e1 = g.powm(u1, p);\n  const e2 = y.powm(u2, p);\n  const re = e1.mul(e2).imod(p);\n  return re.imod(q).eq(r);\n}\n/**\n * Perform a diffie-hellman.\n * @param {Buffer} pub\n * @param {Buffer} priv\n * @returns {Buffer}\n */\n\n\nfunction derive(pub, priv) {\n  const k1 = DSAPublicKey.decode(pub);\n  const k2 = DSAPrivateKey.decode(priv);\n  if (!k1.isSane()) throw new Error('Invalid DSA public key.');\n  if (!k2.isSane()) throw new Error('Invalid DSA private key.');\n  const {\n    p,\n    q,\n    g,\n    x\n  } = k2;\n  const {\n    y\n  } = k1;\n  if (!k1.p.eq(p) || !k1.q.eq(q) || !k1.g.eq(g)) throw new Error('Incompatible DSA parameters.');\n  if (!k1.verify()) throw new Error('Invalid DSA public key.');\n  const e = powConst(y, x, p, q);\n  return e.encode('be', p.byteLength());\n}\n/*\n * Helpers\n */\n\n\nfunction truncate(msg, q) {\n  // Byte array to integer conversion.\n  //\n  // [FIPS186] Page 68, Appendix C.2.\n  //\n  // Note that the FIPS186 behavior\n  // differs from OpenSSL's behavior.\n  // We replicate OpenSSL which takes\n  // the left-most ceil(log2(n+1)) bits\n  // modulo `q`.\n  assert(Buffer.isBuffer(msg));\n  assert(q instanceof BN);\n  const bits = q.bitLength();\n  assert((bits & 7) === 0);\n  const bytes = bits >>> 3;\n  if (msg.length > bytes) msg = msg.slice(0, bytes);\n  return BN.decode(msg);\n}\n\nfunction reduce(msg, q) {\n  return truncate(msg, q).imod(q);\n}\n\nfunction powBlind(g, x, p, q, size) {\n  // Idea: exponentiate by scalar with a\n  // blinding factor, similar to how we\n  // blind multiplications in EC. Note\n  // that it would be safer if we had the\n  // blinding factor pregenerated for each\n  // key.\n  //\n  // Computation:\n  //\n  //   b = random integer in [1,q-1]\n  //   k = (x - b) mod q\n  //   e = g^k * g^b mod p\n  //\n  // In theory, we could also speed up\n  // the calculation of `e` with a multi\n  // exponentiation algorithm.\n  assert(g instanceof BN);\n  assert(x instanceof BN);\n  assert(p instanceof BN);\n  assert(q instanceof BN);\n  const G = g.toRed(BN.mont(p));\n  const b = BN.random(rng, 1, q);\n  const k = x.sub(b).imod(q);\n  const e1 = G.redPow(k, size);\n  const e2 = G.redPow(b, size);\n  const e = e1.redMul(e2);\n  return e.fromRed();\n}\n\nfunction powConst(g, x, p, q) {\n  assert(q instanceof BN);\n  return powBlind(g, x, p, q, q.bitLength());\n}\n/*\n * Expose\n */\n\n\nexports.native = 0;\nexports.paramsCreate = paramsCreate;\nexports.paramsGenerate = paramsGenerate;\nexports.paramsGenerateAsync = paramsGenerateAsync;\nexports.paramsBits = paramsBits;\nexports.paramsVerify = paramsVerify;\nexports.paramsImport = paramsImport;\nexports.paramsExport = paramsExport;\nexports.privateKeyCreate = privateKeyCreate;\nexports.privateKeyGenerate = privateKeyGenerate;\nexports.privateKeyGenerateAsync = privateKeyGenerateAsync;\nexports.privateKeyBits = privateKeyBits;\nexports.privateKeyVerify = privateKeyVerify;\nexports.privateKeyImport = privateKeyImport;\nexports.privateKeyExport = privateKeyExport;\nexports.publicKeyCreate = publicKeyCreate;\nexports.publicKeyBits = publicKeyBits;\nexports.publicKeyVerify = publicKeyVerify;\nexports.publicKeyImport = publicKeyImport;\nexports.publicKeyExport = publicKeyExport;\nexports.signatureImport = signatureImport;\nexports.signatureExport = signatureExport;\nexports.sign = sign;\nexports.signDER = signDER;\nexports.verify = verify;\nexports.verifyDER = verifyDER;\nexports.derive = derive;","map":null,"metadata":{},"sourceType":"script"}