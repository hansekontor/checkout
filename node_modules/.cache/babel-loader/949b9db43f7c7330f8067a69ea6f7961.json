{"ast":null,"code":"import mainLogo from '@assets/logo_primary.png';\nimport tokenLogo from '@assets/logo_secondary.png';\nimport cashaddr from 'ecashaddrjs';\nimport BigNumber from 'bignumber.js';\nexport const currency = {\n  name: 'eCash',\n  ticker: 'XEC',\n  appUrl: 'cashtab.com',\n  logo: mainLogo,\n  legacyPrefix: 'bitcoincash',\n  prefixes: ['ecash'],\n  coingeckoId: 'ecash',\n  defaultFee: 1.01,\n  dustSats: 550,\n  etokenSats: 546,\n  cashDecimals: 2,\n  blockExplorerUrl: 'https://explorer.bitcoinabc.org',\n  tokenExplorerUrl: 'https://explorer.e.cash',\n  blockExplorerUrlTestnet: 'https://texplorer.bitcoinabc.org',\n  tokenName: 'eToken',\n  tokenTicker: 'eToken',\n  tokenIconSubmitApi: 'https://icons.etokens.cash/new',\n  tokenLogo: tokenLogo,\n  tokenPrefixes: ['etoken'],\n  tokenIconsUrl: 'https://etoken-icons.s3.us-west-2.amazonaws.com',\n  postageUrl: 'https://pay.badger.cash/postage',\n  txHistoryCount: 5,\n  hydrateUtxoBatchSize: 20,\n  defaultSettings: {\n    fiatCurrency: 'usd'\n  },\n  notificationDurationShort: 3,\n  notificationDurationLong: 5,\n  newTokenDefaultUrl: 'https://cashtab.com/',\n  opReturn: {\n    opReturnPrefixHex: '6a',\n    opReturnPushDataHex: '04',\n    opReturnAppPrefixLengthHex: '04',\n    appPrefixesHex: {\n      eToken: '534c5000',\n      cashtab: '00746162'\n    }\n  },\n  settingsValidation: {\n    fiatCurrency: ['usd', 'idr', 'krw', 'cny', 'zar', 'vnd', 'cad', 'nok', 'eur', 'gbp', 'jpy', 'try', 'rub', 'inr', 'brl', 'php', 'ils', 'clp', 'twd', 'hkd', 'bhd', 'sar', 'aud', 'nzd']\n  },\n  fiatCurrencies: {\n    usd: {\n      name: 'US Dollar',\n      symbol: '$',\n      slug: 'usd'\n    },\n    aud: {\n      name: 'Australian Dollar',\n      symbol: '$',\n      slug: 'aud'\n    },\n    bhd: {\n      name: 'Bahraini Dinar',\n      symbol: 'BD',\n      slug: 'bhd'\n    },\n    brl: {\n      name: 'Brazilian Real',\n      symbol: 'R$',\n      slug: 'brl'\n    },\n    gbp: {\n      name: 'British Pound',\n      symbol: '£',\n      slug: 'gbp'\n    },\n    cad: {\n      name: 'Canadian Dollar',\n      symbol: '$',\n      slug: 'cad'\n    },\n    clp: {\n      name: 'Chilean Peso',\n      symbol: '$',\n      slug: 'clp'\n    },\n    cny: {\n      name: 'Chinese Yuan',\n      symbol: '元',\n      slug: 'cny'\n    },\n    eur: {\n      name: 'Euro',\n      symbol: '€',\n      slug: 'eur'\n    },\n    hkd: {\n      name: 'Hong Kong Dollar',\n      symbol: 'HK$',\n      slug: 'hkd'\n    },\n    inr: {\n      name: 'Indian Rupee',\n      symbol: '₹',\n      slug: 'inr'\n    },\n    idr: {\n      name: 'Indonesian Rupiah',\n      symbol: 'Rp',\n      slug: 'idr'\n    },\n    ils: {\n      name: 'Israeli Shekel',\n      symbol: '₪',\n      slug: 'ils'\n    },\n    jpy: {\n      name: 'Japanese Yen',\n      symbol: '¥',\n      slug: 'jpy'\n    },\n    krw: {\n      name: 'Korean Won',\n      symbol: '₩',\n      slug: 'krw'\n    },\n    nzd: {\n      name: 'New Zealand Dollar',\n      symbol: '$',\n      slug: 'nzd'\n    },\n    nok: {\n      name: 'Norwegian Krone',\n      symbol: 'kr',\n      slug: 'nok'\n    },\n    php: {\n      name: 'Philippine Peso',\n      symbol: '₱',\n      slug: 'php'\n    },\n    rub: {\n      name: 'Russian Ruble',\n      symbol: 'р.',\n      slug: 'rub'\n    },\n    twd: {\n      name: 'New Taiwan Dollar',\n      symbol: 'NT$',\n      slug: 'twd'\n    },\n    sar: {\n      name: 'Saudi Riyal',\n      symbol: 'SAR',\n      slug: 'sar'\n    },\n    zar: {\n      name: 'South African Rand',\n      symbol: 'R',\n      slug: 'zar'\n    },\n    try: {\n      name: 'Turkish Lira',\n      symbol: '₺',\n      slug: 'try'\n    },\n    vnd: {\n      name: 'Vietnamese đồng',\n      symbol: 'đ',\n      slug: 'vnd'\n    }\n  },\n  selfMintTokens: ['7e7dacd72dcdb14e00a03dd3aff47f019ed51a6f1f4e4f532ae50692f62bc4e5']\n};\nexport function getETokenEncodingSubstring() {\n  let encodingStr = currency.opReturn.opReturnPrefixHex + // 6a\n  currency.opReturn.opReturnAppPrefixLengthHex + // 04\n  currency.opReturn.appPrefixesHex.eToken; // 534c5000\n\n  return encodingStr;\n}\nexport function getCashtabEncodingSubstring() {\n  let encodingStr = currency.opReturn.opReturnPrefixHex + // 6a\n  currency.opReturn.opReturnAppPrefixLengthHex + // 04\n  currency.opReturn.appPrefixesHex.cashtab; // 00746162\n\n  return encodingStr;\n}\nexport function isCashtabOutput(hexStr) {\n  if (!hexStr || typeof hexStr !== 'string') {\n    return false;\n  }\n\n  return hexStr.startsWith(getCashtabEncodingSubstring());\n}\nexport function isEtokenOutput(hexStr) {\n  if (!hexStr || typeof hexStr !== 'string') {\n    return false;\n  }\n\n  return hexStr.startsWith(getETokenEncodingSubstring());\n}\nexport function extractCashtabMessage(hexSubstring) {\n  if (!hexSubstring || typeof hexSubstring !== 'string') {\n    return '';\n  }\n\n  let substring = hexSubstring.replace(getCashtabEncodingSubstring(), ''); // remove the cashtab encoding\n\n  substring = substring.slice(2); // remove the 2 bytes indicating the size of the next element on the stack e.g. a0 -> 160 bytes\n\n  return substring;\n}\nexport function extractExternalMessage(hexSubstring) {\n  if (!hexSubstring || typeof hexSubstring !== 'string') {\n    return '';\n  }\n\n  let substring = hexSubstring.slice(4); // remove the preceding OP_RETURN prefixes\n\n  return substring;\n}\nexport function isValidCashPrefix(addressString) {\n  // Note that this function validates prefix only\n  // Check for prefix included in currency.prefixes array\n  // For now, validation is handled by converting to bitcoincash: prefix and checksum\n  // and relying on legacy validation methods of bitcoincash: prefix addresses\n  // Also accept an address with no prefix, as some exchanges provide these\n  for (let i = 0; i < currency.prefixes.length; i += 1) {\n    // If the addressString being tested starts with an accepted prefix or no prefix at all\n    if (addressString.startsWith(currency.prefixes[i] + ':') || !addressString.includes(':')) {\n      return true;\n    }\n  }\n\n  return false;\n}\nexport function isValidTokenPrefix(addressString) {\n  // Check for prefix included in currency.tokenPrefixes array\n  // For now, validation is handled by converting to simpleledger: prefix and checksum\n  // and relying on legacy validation methods of simpleledger: prefix addresses\n  // For token addresses, do not accept an address with no prefix\n  for (let i = 0; i < currency.tokenPrefixes.length; i += 1) {\n    if (addressString.startsWith(currency.tokenPrefixes[i] + ':')) {\n      return true;\n    }\n  }\n\n  return false;\n}\nexport function toLegacy(address) {\n  let testedAddress;\n  let legacyAddress;\n\n  try {\n    if (isValidCashPrefix(address)) {\n      // Prefix-less addresses may be valid, but the cashaddr.decode function used below\n      // will throw an error without a prefix. Hence, must ensure prefix to use that function.\n      const hasPrefix = address.includes(':');\n\n      if (!hasPrefix) {\n        testedAddress = currency.legacyPrefix + ':' + address;\n      } else {\n        testedAddress = address;\n      } // Note: an `ecash:` checksum address with no prefix will not be validated by\n      // parseAddress in Send.js\n      // Only handle the case of prefixless address that is valid `bitcoincash:` address\n\n\n      const {\n        type,\n        hash\n      } = cashaddr.decode(testedAddress);\n      legacyAddress = cashaddr.encode(currency.legacyPrefix, type, hash);\n    } else {\n      console.log(`Error: ${address} is not a cash address`);\n      throw new Error('Address prefix is not a valid cash address with a prefix from the Ticker.prefixes array');\n    }\n  } catch (err) {\n    return err;\n  }\n\n  return legacyAddress;\n}\nexport function toCleanArray(addressArray) {\n  let cleanArray = []; // array of bch converted addresses to be returned\n\n  try {\n    if (addressArray === null || addressArray === undefined || !addressArray.length || addressArray === '') {\n      throw new Error('Invalid addressArray input');\n    }\n\n    const arrayLength = addressArray.length;\n\n    for (let i = 0; i < arrayLength; i++) {\n      let testedAddress;\n      let legacyAddress;\n      let addressValueArr = addressArray[i].split(',');\n      let address = addressValueArr[0];\n      let value = addressValueArr[1];\n\n      if (isValidCashPrefix(address)) {\n        // Prefix-less addresses may be valid, but the cashaddr.decode function used below\n        // will throw an error without a prefix. Hence, must ensure prefix to use that function.\n        const hasPrefix = address.includes(':');\n\n        if (!hasPrefix) {\n          testedAddress = currency.legacyPrefix + ':' + address;\n        } else {\n          testedAddress = address;\n        } // Note: an `ecash:` checksum address with no prefix will not be validated by\n        // parseAddress in Send.js\n        // Only handle the case of prefixless address that is valid `bitcoincash:` address\n\n\n        const {\n          type,\n          hash\n        } = cashaddr.decode(testedAddress);\n        legacyAddress = cashaddr.encode(currency.prefixes[0], type, hash);\n        let convertedArrayData = legacyAddress + ',' + value + '\\n';\n        cleanArray.push(convertedArrayData);\n      } else {\n        console.log(`Error: ${address} is not a cash address`);\n        throw new Error('Address prefix is not a valid cash address with a prefix from the Ticker.prefixes array');\n      }\n    }\n  } catch (err) {\n    return err;\n  }\n\n  return cleanArray;\n}\nexport function parseAddress(addressString) {\n  let isToken = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  // Build return obj\n  const addressInfo = {\n    address: '',\n    isValid: false,\n    queryString: null,\n    amount: null\n  }; // Parse address string for parameters\n\n  const paramCheck = addressString.split('?');\n  let cleanAddress = paramCheck[0];\n  addressInfo.address = cleanAddress; // Validate address\n\n  let isValidAddress;\n\n  try {\n    // Only accept addresses with ecash: prefix\n    const {\n      prefix\n    } = cashaddr.decode(cleanAddress); // If the address does not have a valid prefix or token prefix\n\n    if (!isToken && !currency.prefixes.includes(prefix) || isToken && !currency.tokenPrefixes.includes(prefix)) {\n      // then it is not a valid destination address for XEC sends\n      isValidAddress = false;\n    } else {\n      isValidAddress = true;\n    }\n  } catch (err) {\n    isValidAddress = false;\n  }\n\n  addressInfo.isValid = isValidAddress; // Check for parameters\n  // only the amount param is currently supported\n\n  let queryString = null;\n  let amount = null;\n\n  if (paramCheck.length > 1) {\n    queryString = paramCheck[1];\n    addressInfo.queryString = queryString;\n    const addrParams = new URLSearchParams(queryString);\n\n    if (addrParams.has('amount')) {\n      // Amount in satoshis\n      try {\n        amount = new BigNumber(parseInt(addrParams.get('amount'))).div(10 ** currency.cashDecimals).toString();\n      } catch (err) {\n        amount = null;\n      }\n    }\n  }\n\n  addressInfo.amount = amount;\n  return addressInfo;\n}","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/components/Common/Ticker.js"],"names":["mainLogo","tokenLogo","cashaddr","BigNumber","currency","name","ticker","appUrl","logo","legacyPrefix","prefixes","coingeckoId","defaultFee","dustSats","etokenSats","cashDecimals","blockExplorerUrl","tokenExplorerUrl","blockExplorerUrlTestnet","tokenName","tokenTicker","tokenIconSubmitApi","tokenPrefixes","tokenIconsUrl","postageUrl","txHistoryCount","hydrateUtxoBatchSize","defaultSettings","fiatCurrency","notificationDurationShort","notificationDurationLong","newTokenDefaultUrl","opReturn","opReturnPrefixHex","opReturnPushDataHex","opReturnAppPrefixLengthHex","appPrefixesHex","eToken","cashtab","settingsValidation","fiatCurrencies","usd","symbol","slug","aud","bhd","brl","gbp","cad","clp","cny","eur","hkd","inr","idr","ils","jpy","krw","nzd","nok","php","rub","twd","sar","zar","try","vnd","selfMintTokens","getETokenEncodingSubstring","encodingStr","getCashtabEncodingSubstring","isCashtabOutput","hexStr","startsWith","isEtokenOutput","extractCashtabMessage","hexSubstring","substring","replace","slice","extractExternalMessage","isValidCashPrefix","addressString","i","length","includes","isValidTokenPrefix","toLegacy","address","testedAddress","legacyAddress","hasPrefix","type","hash","decode","encode","console","log","Error","err","toCleanArray","addressArray","cleanArray","undefined","arrayLength","addressValueArr","split","value","convertedArrayData","push","parseAddress","isToken","addressInfo","isValid","queryString","amount","paramCheck","cleanAddress","isValidAddress","prefix","addrParams","URLSearchParams","has","parseInt","get","div","toString"],"mappings":"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","sourcesContent":["import mainLogo from '@assets/logo_primary.png';\nimport tokenLogo from '@assets/logo_secondary.png';\nimport cashaddr from 'ecashaddrjs';\nimport BigNumber from 'bignumber.js';\n\nexport const currency = {\n    name: 'eCash',\n    ticker: 'XEC',\n    appUrl: 'cashtab.com',\n    logo: mainLogo,\n    legacyPrefix: 'bitcoincash',\n    prefixes: ['ecash'],\n    coingeckoId: 'ecash',\n    defaultFee: 1.01,\n    dustSats: 550,\n    etokenSats: 546,\n    cashDecimals: 2,\n    blockExplorerUrl: 'https://explorer.bitcoinabc.org',\n    tokenExplorerUrl: 'https://explorer.e.cash',\n    blockExplorerUrlTestnet: 'https://texplorer.bitcoinabc.org',\n    tokenName: 'eToken',\n    tokenTicker: 'eToken',\n    tokenIconSubmitApi: 'https://icons.etokens.cash/new',\n    tokenLogo: tokenLogo,\n    tokenPrefixes: ['etoken'],\n    tokenIconsUrl: 'https://etoken-icons.s3.us-west-2.amazonaws.com',\n    postageUrl: 'https://pay.badger.cash/postage',\n    txHistoryCount: 5,\n    hydrateUtxoBatchSize: 20,\n    defaultSettings: { fiatCurrency: 'usd' },\n    notificationDurationShort: 3,\n    notificationDurationLong: 5,\n    newTokenDefaultUrl: 'https://cashtab.com/',\n    opReturn: {\n        opReturnPrefixHex: '6a',\n        opReturnPushDataHex: '04',\n        opReturnAppPrefixLengthHex: '04',\n        appPrefixesHex: {\n            eToken: '534c5000',\n            cashtab: '00746162',\n        },\n    },\n    settingsValidation: {\n        fiatCurrency: [\n            'usd',\n            'idr',\n            'krw',\n            'cny',\n            'zar',\n            'vnd',\n            'cad',\n            'nok',\n            'eur',\n            'gbp',\n            'jpy',\n            'try',\n            'rub',\n            'inr',\n            'brl',\n            'php',\n            'ils',\n            'clp',\n            'twd',\n            'hkd',\n            'bhd',\n            'sar',\n            'aud',\n            'nzd',\n        ],\n    },\n    fiatCurrencies: {\n        usd: { name: 'US Dollar', symbol: '$', slug: 'usd' },\n        aud: { name: 'Australian Dollar', symbol: '$', slug: 'aud' },\n        bhd: { name: 'Bahraini Dinar', symbol: 'BD', slug: 'bhd' },\n        brl: { name: 'Brazilian Real', symbol: 'R$', slug: 'brl' },\n        gbp: { name: 'British Pound', symbol: '£', slug: 'gbp' },\n        cad: { name: 'Canadian Dollar', symbol: '$', slug: 'cad' },\n        clp: { name: 'Chilean Peso', symbol: '$', slug: 'clp' },\n        cny: { name: 'Chinese Yuan', symbol: '元', slug: 'cny' },\n        eur: { name: 'Euro', symbol: '€', slug: 'eur' },\n        hkd: { name: 'Hong Kong Dollar', symbol: 'HK$', slug: 'hkd' },\n        inr: { name: 'Indian Rupee', symbol: '₹', slug: 'inr' },\n        idr: { name: 'Indonesian Rupiah', symbol: 'Rp', slug: 'idr' },\n        ils: { name: 'Israeli Shekel', symbol: '₪', slug: 'ils' },\n        jpy: { name: 'Japanese Yen', symbol: '¥', slug: 'jpy' },\n        krw: { name: 'Korean Won', symbol: '₩', slug: 'krw' },\n        nzd: { name: 'New Zealand Dollar', symbol: '$', slug: 'nzd' },\n        nok: { name: 'Norwegian Krone', symbol: 'kr', slug: 'nok' },\n        php: { name: 'Philippine Peso', symbol: '₱', slug: 'php' },\n        rub: { name: 'Russian Ruble', symbol: 'р.', slug: 'rub' },\n        twd: { name: 'New Taiwan Dollar', symbol: 'NT$', slug: 'twd' },\n        sar: { name: 'Saudi Riyal', symbol: 'SAR', slug: 'sar' },\n        zar: { name: 'South African Rand', symbol: 'R', slug: 'zar' },\n        try: { name: 'Turkish Lira', symbol: '₺', slug: 'try' },\n        vnd: { name: 'Vietnamese đồng', symbol: 'đ', slug: 'vnd' },\n    },\n    selfMintTokens: [\n        '7e7dacd72dcdb14e00a03dd3aff47f019ed51a6f1f4e4f532ae50692f62bc4e5'\n    ]\n};\n\nexport function getETokenEncodingSubstring() {\n    let encodingStr =\n        currency.opReturn.opReturnPrefixHex + // 6a\n        currency.opReturn.opReturnAppPrefixLengthHex + // 04\n        currency.opReturn.appPrefixesHex.eToken; // 534c5000\n\n    return encodingStr;\n}\n\nexport function getCashtabEncodingSubstring() {\n    let encodingStr =\n        currency.opReturn.opReturnPrefixHex + // 6a\n        currency.opReturn.opReturnAppPrefixLengthHex + // 04\n        currency.opReturn.appPrefixesHex.cashtab; // 00746162\n\n    return encodingStr;\n}\n\nexport function isCashtabOutput(hexStr) {\n    if (!hexStr || typeof hexStr !== 'string') {\n        return false;\n    }\n    return hexStr.startsWith(getCashtabEncodingSubstring());\n}\n\nexport function isEtokenOutput(hexStr) {\n    if (!hexStr || typeof hexStr !== 'string') {\n        return false;\n    }\n    return hexStr.startsWith(getETokenEncodingSubstring());\n}\n\nexport function extractCashtabMessage(hexSubstring) {\n    if (!hexSubstring || typeof hexSubstring !== 'string') {\n        return '';\n    }\n    let substring = hexSubstring.replace(getCashtabEncodingSubstring(), ''); // remove the cashtab encoding\n    substring = substring.slice(2); // remove the 2 bytes indicating the size of the next element on the stack e.g. a0 -> 160 bytes\n    return substring;\n}\n\nexport function extractExternalMessage(hexSubstring) {\n    if (!hexSubstring || typeof hexSubstring !== 'string') {\n        return '';\n    }\n    let substring = hexSubstring.slice(4); // remove the preceding OP_RETURN prefixes\n    return substring;\n}\n\nexport function isValidCashPrefix(addressString) {\n    // Note that this function validates prefix only\n    // Check for prefix included in currency.prefixes array\n    // For now, validation is handled by converting to bitcoincash: prefix and checksum\n    // and relying on legacy validation methods of bitcoincash: prefix addresses\n\n    // Also accept an address with no prefix, as some exchanges provide these\n    for (let i = 0; i < currency.prefixes.length; i += 1) {\n        // If the addressString being tested starts with an accepted prefix or no prefix at all\n        if (\n            addressString.startsWith(currency.prefixes[i] + ':') ||\n            !addressString.includes(':')\n        ) {\n            return true;\n        }\n    }\n    return false;\n}\n\nexport function isValidTokenPrefix(addressString) {\n    // Check for prefix included in currency.tokenPrefixes array\n    // For now, validation is handled by converting to simpleledger: prefix and checksum\n    // and relying on legacy validation methods of simpleledger: prefix addresses\n\n    // For token addresses, do not accept an address with no prefix\n    for (let i = 0; i < currency.tokenPrefixes.length; i += 1) {\n        if (addressString.startsWith(currency.tokenPrefixes[i] + ':')) {\n            return true;\n        }\n    }\n    return false;\n}\n\nexport function toLegacy(address) {\n    let testedAddress;\n    let legacyAddress;\n\n    try {\n        if (isValidCashPrefix(address)) {\n            // Prefix-less addresses may be valid, but the cashaddr.decode function used below\n            // will throw an error without a prefix. Hence, must ensure prefix to use that function.\n            const hasPrefix = address.includes(':');\n            if (!hasPrefix) {\n                testedAddress = currency.legacyPrefix + ':' + address;\n            } else {\n                testedAddress = address;\n            }\n\n            // Note: an `ecash:` checksum address with no prefix will not be validated by\n            // parseAddress in Send.js\n\n            // Only handle the case of prefixless address that is valid `bitcoincash:` address\n\n            const { type, hash } = cashaddr.decode(testedAddress);\n            legacyAddress = cashaddr.encode(currency.legacyPrefix, type, hash);\n        } else {\n            console.log(`Error: ${address} is not a cash address`);\n            throw new Error(\n                'Address prefix is not a valid cash address with a prefix from the Ticker.prefixes array',\n            );\n        }\n    } catch (err) {\n        return err;\n    }\n    return legacyAddress;\n}\n\nexport function toCleanArray(addressArray) {\n    let cleanArray = []; // array of bch converted addresses to be returned\n\n    try {\n        if (\n            addressArray === null ||\n            addressArray === undefined ||\n            !addressArray.length ||\n            addressArray === ''\n        ) {\n            throw new Error('Invalid addressArray input');\n        }\n\n        const arrayLength = addressArray.length;\n\n        for (let i = 0; i < arrayLength; i++) {\n            let testedAddress;\n            let legacyAddress;\n            let addressValueArr = addressArray[i].split(',');\n            let address = addressValueArr[0];\n            let value = addressValueArr[1];\n\n            if (isValidCashPrefix(address)) {\n                // Prefix-less addresses may be valid, but the cashaddr.decode function used below\n                // will throw an error without a prefix. Hence, must ensure prefix to use that function.\n                const hasPrefix = address.includes(':');\n                if (!hasPrefix) {\n                    testedAddress = currency.legacyPrefix + ':' + address;\n                } else {\n                    testedAddress = address;\n                }\n\n                // Note: an `ecash:` checksum address with no prefix will not be validated by\n                // parseAddress in Send.js\n\n                // Only handle the case of prefixless address that is valid `bitcoincash:` address\n                const { type, hash } = cashaddr.decode(testedAddress);\n                legacyAddress = cashaddr.encode(\n                    currency.prefixes[0],\n                    type,\n                    hash,\n                );\n\n                let convertedArrayData = legacyAddress + ',' + value + '\\n';\n                cleanArray.push(convertedArrayData);\n            } else {\n                console.log(`Error: ${address} is not a cash address`);\n                throw new Error(\n                    'Address prefix is not a valid cash address with a prefix from the Ticker.prefixes array',\n                );\n            }\n        }\n    } catch (err) {\n        return err;\n    }\n    return cleanArray;\n}\n\nexport function parseAddress(addressString, isToken = false) {\n    // Build return obj\n    const addressInfo = {\n        address: '',\n        isValid: false,\n        queryString: null,\n        amount: null,\n    };\n    // Parse address string for parameters\n    const paramCheck = addressString.split('?');\n\n    let cleanAddress = paramCheck[0];\n    addressInfo.address = cleanAddress;\n\n    // Validate address\n    let isValidAddress;\n    try {\n        // Only accept addresses with ecash: prefix\n        const { prefix } = cashaddr.decode(cleanAddress);\n        // If the address does not have a valid prefix or token prefix\n        if (\n            (!isToken && !currency.prefixes.includes(prefix)) ||\n            (isToken && !currency.tokenPrefixes.includes(prefix))\n        ) {\n            // then it is not a valid destination address for XEC sends\n            isValidAddress = false;\n        } else {\n            isValidAddress = true;\n        }\n    } catch (err) {\n        isValidAddress = false;\n    }\n\n    addressInfo.isValid = isValidAddress;\n\n    // Check for parameters\n    // only the amount param is currently supported\n    let queryString = null;\n    let amount = null;\n    if (paramCheck.length > 1) {\n        queryString = paramCheck[1];\n        addressInfo.queryString = queryString;\n\n        const addrParams = new URLSearchParams(queryString);\n\n        if (addrParams.has('amount')) {\n            // Amount in satoshis\n            try {\n                amount = new BigNumber(parseInt(addrParams.get('amount')))\n                    .div(10 ** currency.cashDecimals)\n                    .toString();\n            } catch (err) {\n                amount = null;\n            }\n        }\n    }\n\n    addressInfo.amount = amount;\n    return addressInfo;\n}\n"]},"metadata":{},"sourceType":"module"}