{"ast":null,"code":"/*!\n * x509.js - x509 handling for bcoin\n * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst sha256 = require('bcrypto/lib/sha256');\n\nconst ASN1 = require('./utils/asn1');\n\nconst crypto = require('./crypto');\n\nconst certs = require('./certs');\n/**\n * @exports bip70/x509\n */\n\n\nconst x509 = exports;\n/**\n * Map of trusted root certs.\n * @type {Set}\n */\n\nx509.trusted = new Set();\n/**\n * Whether to allow untrusted root\n * certs during verification.\n * @type {Boolean}\n */\n\nx509.allowUntrusted = false;\n/**\n * OID to algorithm map for PKI.\n * @const {Object}\n * @see https://www.ietf.org/rfc/rfc2459.txt\n * @see https://tools.ietf.org/html/rfc3279\n * @see http://oid-info.com/get/1.2.840.10040.4\n * @see http://oid-info.com/get/1.2.840.113549.1.1\n * @see http://oid-info.com/get/1.2.840.10045.4.3\n * @see https://tools.ietf.org/html/draft-jivsov-openpgp-sha3-01\n */\n\nx509.oid = {\n  '1.2.840.10040.4.1': {\n    key: 'dsa',\n    hash: null\n  },\n  '1.2.840.10040.4.2': {\n    key: 'dsa',\n    hash: null\n  },\n  '1.2.840.10040.4.3': {\n    key: 'dsa',\n    hash: 'sha1'\n  },\n  '1.2.840.113549.1.1.1': {\n    key: 'rsa',\n    hash: null\n  },\n  '1.2.840.113549.1.1.2': {\n    key: 'rsa',\n    hash: 'md2'\n  },\n  '1.2.840.113549.1.1.3': {\n    key: 'rsa',\n    hash: 'md4'\n  },\n  '1.2.840.113549.1.1.4': {\n    key: 'rsa',\n    hash: 'md5'\n  },\n  '1.2.840.113549.1.1.5': {\n    key: 'rsa',\n    hash: 'sha1'\n  },\n  '1.2.840.113549.1.1.11': {\n    key: 'rsa',\n    hash: 'sha256'\n  },\n  '1.2.840.113549.1.1.12': {\n    key: 'rsa',\n    hash: 'sha384'\n  },\n  '1.2.840.113549.1.1.13': {\n    key: 'rsa',\n    hash: 'sha512'\n  },\n  '1.2.840.113549.1.1.14': {\n    key: 'rsa',\n    hash: 'sha224'\n  },\n  '2.16.840.1.101.3.4.2.8': {\n    key: 'rsa',\n    hash: 'sha3-256'\n  },\n  '2.16.840.1.101.3.4.2.9': {\n    key: 'rsa',\n    hash: 'sha3-384'\n  },\n  '2.16.840.1.101.3.4.2.10': {\n    key: 'rsa',\n    hash: 'sha3-512'\n  },\n  '1.2.840.10045.2.1': {\n    key: 'ecdsa',\n    hash: null\n  },\n  '1.2.840.10045.4.1': {\n    key: 'ecdsa',\n    hash: 'sha1'\n  },\n  '1.2.840.10045.4.3.1': {\n    key: 'ecdsa',\n    hash: 'sha224'\n  },\n  '1.2.840.10045.4.3.2': {\n    key: 'ecdsa',\n    hash: 'sha256'\n  },\n  '1.2.840.10045.4.3.3': {\n    key: 'ecdsa',\n    hash: 'sha384'\n  },\n  '1.2.840.10045.4.3.4': {\n    key: 'ecdsa',\n    hash: 'sha512'\n  }\n};\n/**\n * OID to curve name map for ECDSA.\n * @type {Object}\n */\n\nx509.curves = {\n  '1.3.132.0.33': 'p224',\n  '1.2.840.10045.3.1.7': 'p256',\n  '1.3.132.0.34': 'p384',\n  '1.3.132.0.35': 'p521'\n};\n/**\n * Retrieve cert value by OID.\n * @param {Object} cert\n * @param {String} oid\n * @returns {String}\n */\n\nx509.getSubjectOID = function getSubjectOID(cert, oid) {\n  const subject = cert.tbs.subject;\n\n  for (const entry of subject) {\n    if (entry.type === oid) return entry.value;\n  }\n\n  return null;\n};\n/**\n * Try to retrieve CA name by checking\n * for a few different OIDs.\n * @param {Object} cert\n * @returns {String}\n */\n\n\nx509.getCAName = function getCAName(cert) {\n  // This seems to work the best in practice\n  // for getting a human-readable and\n  // descriptive name for the CA.\n  // See:\n  //   http://oid-info.com/get/2.5.4\n  // Precedence:\n  //   (3) commonName\n  //   (11) organizationUnitName\n  //   (10) organizationName\n  return x509.getSubjectOID(cert, '2.5.4.3') || x509.getSubjectOID(cert, '2.5.4.11') || x509.getSubjectOID(cert, '2.5.4.10') || 'Unknown';\n};\n/**\n * Test whether a cert is trusted by hashing\n * and looking it up in the trusted map.\n * @param {Object} cert\n * @returns {Buffer}\n */\n\n\nx509.isTrusted = function isTrusted(cert) {\n  const fingerprint = sha256.digest(cert.raw);\n  const hash = fingerprint.toString('hex');\n  return x509.trusted.has(hash);\n};\n/**\n * Add root certificates to the trusted map.\n * @param {Buffer[]} certs\n */\n\n\nx509.setTrust = function setTrust(certs) {\n  assert(Array.isArray(certs), 'Certs must be an array.');\n\n  for (const raw of certs) {\n    assert(Buffer.isBuffer(raw), 'Certificates must be DER.');\n    const cert = x509.parse(raw);\n    const hash = sha256.digest(cert.raw);\n    const fingerprint = hash.toString('hex');\n    x509.trusted.add(fingerprint);\n  }\n};\n/**\n * Add root certificate fingerprints to the trusted map.\n * @param {Hash[]} hashes\n */\n\n\nx509.setFingerprints = function setFingerprints(hashes) {\n  assert(Array.isArray(hashes), 'Certs must be an array.');\n\n  for (const hash of hashes) {\n    assert(Buffer.isBuffer(hash), 'Fingerprint must be a buffer.');\n    assert(hash.length === 32, 'Fingerprint must be a sha256 hash.');\n    const fingerprint = hash.toString('hex');\n    x509.trusted.add(fingerprint);\n  }\n};\n/**\n * Retrieve key algorithm from cert.\n * @param {Object} cert\n * @returns {Object}\n */\n\n\nx509.getKeyAlgorithm = function getKeyAlgorithm(cert) {\n  const oid = cert.tbs.pubkey.alg.alg;\n  const alg = x509.oid[oid];\n  if (!alg) throw new Error(`Unknown key algorithm: ${oid}.`);\n  return alg;\n};\n/**\n * Retrieve signature algorithm from cert.\n * @param {Object} cert\n * @returns {Object}\n */\n\n\nx509.getSigAlgorithm = function getSigAlgorithm(cert) {\n  const oid = cert.sigAlg.alg;\n  const alg = x509.oid[oid];\n  if (!alg || !alg.hash) throw new Error(`Unknown signature algorithm: ${oid}.`);\n  return alg;\n};\n/**\n * Lookup curve based on key parameters.\n * @param {Buffer} params\n * @returns {Object}\n */\n\n\nx509.getCurve = function getCurve(params) {\n  let oid;\n\n  try {\n    oid = ASN1.parseOID(params);\n  } catch (e) {\n    throw new Error('Could not parse curve OID.');\n  }\n\n  const curve = x509.curves[oid];\n  if (!curve) throw new Error(`Unknown ECDSA curve: ${oid}.`);\n  return curve;\n};\n/**\n * Parse a DER formatted cert.\n * @param {Buffer} der\n * @returns {Object|null}\n */\n\n\nx509.parse = function parse(der) {\n  try {\n    return ASN1.parseCert(der);\n  } catch (e) {\n    throw new Error('Could not parse DER certificate.');\n  }\n};\n/**\n * Get cert public key.\n * @param {Object} cert\n * @returns {Object|null}\n */\n\n\nx509.getPublicKey = function getPublicKey(cert) {\n  const alg = x509.getKeyAlgorithm(cert);\n  const key = cert.tbs.pubkey.pubkey;\n  const params = cert.tbs.pubkey.alg.params;\n  let curve = null;\n\n  if (alg.key === 'ecdsa') {\n    if (!params) throw new Error('No curve selected for ECDSA (cert).');\n    curve = x509.getCurve(params);\n  }\n\n  return {\n    alg: alg.key,\n    data: key,\n    params: params,\n    curve: curve\n  };\n};\n/**\n * Verify cert expiration time.\n * @param {Object} cert\n * @returns {Boolean}\n */\n\n\nx509.verifyTime = function verifyTime(cert) {\n  const time = cert.tbs.validity;\n  const now = Math.floor(Date.now() / 1000);\n  return now > time.notBefore && now < time.notAfter;\n};\n/**\n * Get signature key info from cert chain.\n * @param {Buffer} key\n * @param {Buffer[]} chain\n * @returns {Object}\n */\n\n\nx509.getSigningKey = function getSigningKey(key, chain) {\n  assert(chain.length !== 0, 'No chain available.');\n  const cert = x509.parse(chain[0]);\n  const pub = x509.getPublicKey(cert);\n  return {\n    alg: pub.alg,\n    data: key,\n    params: pub.params,\n    curve: pub.curve\n  };\n};\n/**\n * Sign a hash with the chain signing key.\n * @param {String} hash\n * @param {Buffer} msg\n * @param {Buffer} key\n * @param {Buffer[]} chain\n * @returns {Buffer}\n */\n\n\nx509.signSubject = function signSubject(hash, msg, key, chain) {\n  const priv = x509.getSigningKey(key, chain);\n  return crypto.sign(hash, msg, priv);\n};\n/**\n * Get chain verification key.\n * @param {Buffer[]} chain\n * @returns {Object|null}\n */\n\n\nx509.getVerifyKey = function getVerifyKey(chain) {\n  if (chain.length === 0) throw new Error('No verify key available (cert chain).');\n  const cert = x509.parse(chain[0]);\n  return x509.getPublicKey(cert);\n};\n/**\n * Verify a sighash against chain verification key.\n * @param {String} hash\n * @param {Buffer} msg\n * @param {Buffer} sig\n * @param {Buffer[]} chain\n * @returns {Boolean}\n */\n\n\nx509.verifySubject = function verifySubject(hash, msg, sig, chain) {\n  const key = x509.getVerifyKey(chain);\n  return crypto.verify(hash, msg, sig, key);\n};\n/**\n * Parse certificate chain.\n * @param {Buffer[]} chain\n * @returns {Object[]}\n */\n\n\nx509.parseChain = function parseChain(chain) {\n  const certs = [];\n\n  for (const item of chain) {\n    const cert = x509.parse(item);\n    certs.push(cert);\n  }\n\n  return certs;\n};\n/**\n * Verify all expiration times in a certificate chain.\n * @param {Object[]} chain\n * @returns {Boolean}\n */\n\n\nx509.verifyTimes = function verifyTimes(chain) {\n  for (const cert of chain) {\n    if (!x509.verifyTime(cert)) return false;\n  }\n\n  return true;\n};\n/**\n * Verify that at least one parent\n * cert in the chain is trusted.\n * @param {Object[]} chain\n * @returns {Boolean}\n */\n\n\nx509.verifyTrust = function verifyTrust(chain) {\n  // If trust hasn't been\n  // setup, just return.\n  if (x509.allowUntrusted) return true; // Make sure we trust one\n  // of the certs in the chain.\n\n  for (const cert of chain) {\n    // If any certificate in the chain\n    // is trusted, assume we also trust\n    // the parent.\n    if (x509.isTrusted(cert)) return true;\n  } // No trusted certs present.\n\n\n  return false;\n};\n/**\n * Verify certificate chain.\n * @param {Object[]} certs\n */\n\n\nx509.verifyChain = function verifyChain(certs) {\n  const chain = x509.parseChain(certs); // Parse certificates and\n  // check validity time.\n\n  if (!x509.verifyTimes(chain)) throw new Error('Invalid certificate times.'); // Verify signatures.\n\n  for (let i = 1; i < chain.length; i++) {\n    const child = chain[i - 1];\n    const parent = chain[i];\n    const alg = x509.getSigAlgorithm(child);\n    const key = x509.getPublicKey(parent);\n    const msg = child.tbs.raw;\n    const sig = child.sig;\n    if (!crypto.verify(alg.hash, msg, sig, key)) throw new Error(`${alg.key} verification failed for chain.`);\n  } // Make sure we trust one\n  // of the certs in the chain.\n\n\n  if (!x509.verifyTrust(chain)) throw new Error('Certificate chain is untrusted.');\n  return true;\n};\n/*\n * Load trusted certs.\n */\n\n\nx509.setFingerprints(certs);","map":null,"metadata":{},"sourceType":"script"}