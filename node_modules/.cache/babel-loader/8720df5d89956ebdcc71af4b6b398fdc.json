{"ast":null,"code":"/*!\n * pgp.js - PGP for javascript\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on golang/crypto:\n *   Copyright (c) 2009 The Go Authors. All rights reserved.\n *   https://github.com/golang/crypto\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/Pretty_Good_Privacy#OpenPGP\n *   https://tools.ietf.org/html/rfc4880\n *   https://github.com/golang/crypto/tree/master/openpgp\n *   https://github.com/gpg/gnupg/blob/master/common/openpgpdefs.h\n *   https://github.com/gpg/gnupg/blob/master/g10/parse-packet.c\n */\n'use strict';\n\nconst assert = require('./internal/assert');\n\nconst bio = require('bufio');\n\nconst {\n  PEMBlock\n} = require('./encoding/pem');\n\nconst {\n  countLeft\n} = require('./encoding/util');\n\nconst cipher = require('./cipher');\n\nconst MD5 = require('./md5');\n\nconst SHA1 = require('./sha1');\n\nconst RIPEMD160 = require('./ripemd160');\n\nconst SHA224 = require('./sha224');\n\nconst SHA256 = require('./sha256');\n\nconst SHA384 = require('./sha384');\n\nconst SHA512 = require('./sha512');\n/*\n * Constants\n */\n\n\nconst packetTypes = {\n  NONE: 0,\n  PUBKEY_ENC: 1,\n  SIGNATURE: 2,\n  SYMKEY_ENC: 3,\n  ONEPASS_SIG: 4,\n  PRIVATE_KEY: 5,\n  PUBLIC_KEY: 6,\n  PRIVATE_SUBKEY: 7,\n  COMPRESSED: 8,\n  ENCRYPTED: 9,\n  MARKER: 10,\n  PLAINTEXT: 11,\n  RING_TRUST: 12,\n  USER_ID: 13,\n  PUBLIC_SUBKEY: 14,\n  OLD_COMMENT: 16,\n  ATTRIBUTE: 17,\n  ENCRYPTED_MDC: 18,\n  MDC: 19,\n  ENCRYPTED_AEAD: 20\n};\nconst packetTypesByVal = {\n  0: 'NONE',\n  1: 'PUBKEY_ENC',\n  2: 'SIGNATURE',\n  3: 'SYMKEY_ENC',\n  4: 'ONEPASS_SIG',\n  5: 'PRIVATE_KEY',\n  6: 'PUBLIC_KEY',\n  7: 'PRIVATE_SUBKEY',\n  8: 'COMPRESSED',\n  9: 'ENCRYPTED',\n  10: 'MARKER',\n  11: 'PLAINTEXT',\n  12: 'RING_TRUST',\n  13: 'USER_ID',\n  14: 'PUBLIC_SUBKEY',\n  16: 'OLD_COMMENT',\n  17: 'ATTRIBUTE',\n  18: 'ENCRYPTED_MDC',\n  19: 'MDC',\n  20: 'ENCRYPTED_AEAD'\n};\nconst sigTypes = {\n  BINARY: 0x00,\n  TEXT: 0x01,\n  GENERIC_CERT: 0x10,\n  PERSONA_CERT: 0x11,\n  CASUAL_CERT: 0x12,\n  POSITIVE_CERT: 0x13,\n  SUBKEY_BINDING: 0x18,\n  PRIMARY_KEY_BINDING: 0x19,\n  DIRECT_SIGNATURE: 0x1f,\n  KEY_REVOCATION: 0x20,\n  SUBKEY_REVOCATION: 0x28\n};\nconst sigTypesByVal = {\n  0x00: 'BINARY',\n  0x01: 'TEXT',\n  0x10: 'GENERIC_CERT',\n  0x11: 'PERSONA_CERT',\n  0x12: 'CASUAL_CERT',\n  0x13: 'POSITIVE_CERT',\n  0x18: 'SUBKEY_BINDING',\n  0x19: 'PRIMARY_KEY_BINDING',\n  0x1f: 'DIRECT_SIGNATURE',\n  0x20: 'KEY_REVOCATION',\n  0x28: 'SUBKEY_REVOCATION'\n};\nconst keyTypes = {\n  RSA: 1,\n  RSA_ENCRYPT_ONLY: 2,\n  RSA_SIGN_ONLY: 3,\n  ELGAMAL: 16,\n  DSA: 17,\n  ECDH: 18,\n  ECDSA: 19,\n  ELGAMAL_LEGACY: 20,\n  EDDSA: 22\n};\nconst keyTypesByVal = {\n  1: 'RSA',\n  2: 'RSA_ENCRYPT_ONLY',\n  3: 'RSA_SIGN_ONLY',\n  16: 'ELGAMAL',\n  17: 'DSA',\n  18: 'ECDH',\n  19: 'ECDSA',\n  20: 'ELGAMAL_LEGACY',\n  22: 'EDDSA'\n};\nconst cipherTypes = {\n  NONE: 0,\n  IDEA: 1,\n  DES3: 2,\n  CAST5: 3,\n  BLOWFISH: 4,\n  AES128: 7,\n  AES192: 8,\n  AES256: 9,\n  TWOFISH: 10,\n  CAMELLIA128: 11,\n  CAMELLIA192: 12,\n  CAMELLIA256: 13\n};\nconst cipherTypesByVal = {\n  0: 'NONE',\n  1: 'IDEA',\n  2: 'DES3',\n  3: 'CAST5',\n  4: 'BLOWFISH',\n  7: 'AES128',\n  8: 'AES192',\n  9: 'AES256',\n  10: 'TWOFISH',\n  11: 'CAMELLIA128',\n  12: 'CAMELLIA192',\n  13: 'CAMELLIA256'\n};\nconst hashTypes = {\n  MD5: 1,\n  SHA1: 2,\n  RIPEMD160: 3,\n  SHA256: 8,\n  SHA384: 9,\n  SHA512: 10,\n  SHA224: 11\n};\nconst hashTypesByVal = {\n  1: 'MD5',\n  2: 'SHA1',\n  3: 'RIPEMD160',\n  8: 'SHA256',\n  9: 'SHA384',\n  10: 'SHA512',\n  11: 'SHA224'\n};\nconst hashToHash = {\n  1: MD5,\n  2: SHA1,\n  3: RIPEMD160,\n  8: SHA256,\n  9: SHA384,\n  10: SHA512,\n  11: SHA224\n};\nconst compressTypes = {\n  NONE: 0,\n  ZIP: 1,\n  ZLIB: 2,\n  BZIP2: 3\n};\nconst compressTypesByVal = {\n  0: 'NONE',\n  1: 'ZIP',\n  2: 'ZLIB',\n  3: 'BZIP2'\n};\nconst curveTypes = {\n  NONE: 0,\n  P256: 1,\n  P384: 2,\n  P521: 3,\n  SECP256K1: 4,\n  X25519: 5,\n  BRAINPOOLP256: 6,\n  BRAINPOOLP384: 7,\n  BRAINPOOLP512: 8,\n  ED25519: 9\n};\nconst curveTypesByVal = {\n  0: 'NONE',\n  1: 'P256',\n  2: 'P384',\n  3: 'P521',\n  4: 'SECP256K1',\n  5: 'X25519',\n  6: 'BRAINPOOLP256',\n  7: 'BRAINPOOLP384',\n  8: 'BRAINPOOLP512',\n  9: 'ED25519'\n};\nconst oids = {\n  P256: Buffer.from('2a8648ce3d030107', 'hex'),\n  P384: Buffer.from('2b81040022', 'hex'),\n  P521: Buffer.from('2b81040023', 'hex'),\n  SECP256K1: Buffer.from('2b8104000a', 'hex'),\n  X25519: Buffer.from('2b060104019755010501', 'hex'),\n  BRAINPOOLP256: Buffer.from('2b2403030208010107', 'hex'),\n  BRAINPOOLP384: Buffer.from('2b240303020801010b', 'hex'),\n  BRAINPOOLP512: Buffer.from('2b240303020801010d', 'hex'),\n  ED25519: Buffer.from('2b06010401da470f01', 'hex')\n};\nconst EMPTY = Buffer.alloc(0);\nconst ZERO = Buffer.alloc(1);\n/**\n * PGP Message\n */\n\nclass PGPMessage extends bio.Struct {\n  constructor() {\n    super();\n    this.packets = [];\n  }\n\n  getSize() {\n    let size = 0;\n\n    for (const pkt of this.packets) size += pkt.getSize();\n\n    return size;\n  }\n\n  write(bw) {\n    for (const pkt of this.packets) pkt.write(bw);\n\n    return bw;\n  }\n\n  read(br) {\n    while (br.left()) {\n      const pkt = PGPPacket.read(br);\n      this.packets.push(pkt);\n    }\n\n    return this;\n  }\n\n  toString() {\n    let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'PGP MESSAGE';\n    assert(typeof type === 'string');\n    const block = new PEMBlock();\n    block.type = type;\n    block.data = this.encode();\n    return block.toString(true);\n  }\n\n  fromString(str) {\n    const block = PEMBlock.fromString(str, true);\n    if (block.type.substring(0, 4) !== 'PGP ') throw new Error('PEM type mismatch.');\n    return this.decode(block.data);\n  }\n\n  format() {\n    return {\n      packets: this.packets\n    };\n  }\n\n}\n/**\n * PGP Packet\n */\n\n\nclass PGPPacket extends bio.Struct {\n  constructor() {\n    super();\n    this.type = 0;\n    this.body = new PGPUnknown();\n  }\n\n  getSize() {\n    const len = this.body.getSize();\n    let size = 0;\n    size += 1;\n\n    if (len < 192) {\n      size += 1;\n    } else if (len < 8384) {\n      size += 2;\n    } else {\n      size += 5;\n    }\n\n    size += len;\n    return size;\n  }\n\n  write(bw) {\n    let len = this.body.getSize();\n    bw.writeU8(0x80 | 0x40 | this.type);\n\n    if (len < 192) {\n      bw.writeU8(len);\n    } else if (len < 8384) {\n      len -= 192;\n      bw.writeU8(192 + (len >>> 8));\n      bw.writeU8(len & 0xff);\n    } else {\n      bw.writeU8(255);\n      bw.writeU32BE(len);\n    }\n\n    this.body.write(bw);\n    return bw;\n  }\n\n  read(br) {\n    const ch = br.readU8();\n    if ((ch & 0x80) === 0) throw new Error('Hi bit unset in PGP packet header.');\n    let type = 0;\n    let child = null;\n\n    if ((ch & 0x40) === 0) {\n      const t = (ch & 0x3f) >>> 2;\n      const s = 1 << (ch & 3);\n      let size = 0;\n\n      switch (s) {\n        case 1:\n          size = br.readU8();\n          break;\n\n        case 2:\n          size = br.readU16BE();\n          break;\n\n        case 4:\n          size = br.readU32BE();\n          break;\n\n        case 8:\n          size = br.left();\n          break;\n      }\n\n      type = t;\n      child = br.readChild(size);\n    } else {\n      const t = ch & 0x3f;\n      const s = br.readU8();\n      let size = 0;\n\n      if (s < 192) {\n        size = s;\n      } else if (s < 224) {\n        size = (s - 192) * 0x100;\n        size += br.readU8() + 192;\n      } else if (s < 255) {\n        throw new Error('Cannot handle PGP partial length.');\n      } else {\n        size = br.readU32BE();\n      }\n\n      type = t;\n      child = br.readChild(size);\n    }\n\n    this.type = type;\n\n    switch (this.type) {\n      case packetTypes.PUBKEY_ENC:\n        this.body = PGPUnknown.read(child);\n        break;\n\n      case packetTypes.SIGNATURE:\n        this.body = PGPUnknown.read(child);\n        break;\n\n      case packetTypes.SYMKEY_ENC:\n        this.body = PGPUnknown.read(child);\n        break;\n\n      case packetTypes.ONEPASS_SIG:\n        this.body = PGPUnknown.read(child);\n        break;\n\n      case packetTypes.PRIVATE_KEY:\n        this.body = PGPPrivateKey.read(child);\n        break;\n\n      case packetTypes.PUBLIC_KEY:\n        this.body = PGPPublicKey.read(child);\n        break;\n\n      case packetTypes.PRIVATE_SUBKEY:\n        this.body = PGPPrivateKey.read(child);\n        break;\n\n      case packetTypes.COMPRESSED:\n        this.body = PGPUnknown.read(child);\n        break;\n\n      case packetTypes.ENCRYPTED:\n        this.body = PGPUnknown.read(child);\n        break;\n\n      case packetTypes.MARKER:\n        this.body = PGPUnknown.read(child);\n        break;\n\n      case packetTypes.PLAINTEXT:\n        this.body = PGPUnknown.read(child);\n        break;\n\n      case packetTypes.RING_TRUST:\n        this.body = PGPUnknown.read(child);\n        break;\n\n      case packetTypes.USER_ID:\n        this.body = PGPUserID.read(child);\n        break;\n\n      case packetTypes.PUBLIC_SUBKEY:\n        this.body = PGPPublicKey.read(child);\n        break;\n\n      case packetTypes.OLD_COMMENT:\n        this.body = PGPPublicKey.read(child);\n        break;\n\n      case packetTypes.ATTRIBUTE:\n        this.body = PGPUnknown.read(child);\n        break;\n\n      case packetTypes.ENCRYPTED_MDC:\n        this.body = PGPUnknown.read(child);\n        break;\n\n      case packetTypes.MDC:\n        this.body = PGPUnknown.read(child);\n        break;\n\n      case packetTypes.ENCRYPTED_AEAD:\n        this.body = PGPUnknown.read(child);\n        break;\n\n      default:\n        this.body = PGPUnknown.read(child);\n        break;\n    }\n\n    return this;\n  }\n\n  format() {\n    return {\n      type: packetTypesByVal[this.type] || 'UNKNOWN',\n      body: this.body\n    };\n  }\n\n}\n/**\n * PGP Body\n */\n\n\nclass PGPBody extends bio.Struct {\n  constructor() {\n    super();\n  }\n\n}\n/**\n * PGP Unknown\n */\n\n\nclass PGPUnknown extends PGPBody {\n  constructor() {\n    super();\n    this.data = EMPTY;\n  }\n\n  getSize() {\n    return this.data.length;\n  }\n\n  write(bw) {\n    bw.writeBytes(this.data);\n    return bw;\n  }\n\n  read(br) {\n    this.data = br.readBytes(br.left());\n    return this;\n  }\n\n  format() {\n    return {\n      data: this.data.toString('hex')\n    };\n  }\n\n}\n/**\n * PGP Public Key\n */\n\n\nclass PGPPublicKey extends PGPBody {\n  constructor() {\n    super();\n    this.version = 4;\n    this.algorithm = 0;\n    this.expires = 0;\n    this.timestamp = 0; // RSA\n\n    this.n = new MPI();\n    this.e = new MPI(); // El Gamal\n\n    this.p = new MPI();\n    this.g = new MPI();\n    this.y = new MPI(); // DSA\n\n    this.p;\n    this.q = new MPI();\n    this.g;\n    this.y; // ECDH\n\n    this.oid = EMPTY;\n    this.point = new MPI();\n    this.kdfHash = 0;\n    this.kdfAlg = 0; // ECDSA\n\n    this.oid;\n    this.point; // Unknown\n\n    this.data = EMPTY;\n  }\n\n  get curve() {\n    if (this.oid.equals(oids.P256)) return curveTypes.P256;\n    if (this.oid.equals(oids.P384)) return curveTypes.P384;\n    if (this.oid.equals(oids.P521)) return curveTypes.P521;\n    if (this.oid.equals(oids.SECP256K1)) return curveTypes.SECP256K1;\n    if (this.oid.equals(oids.X25519)) return curveTypes.X25519;\n    if (this.oid.equals(oids.BRAINPOOLP256)) return curveTypes.BRAINPOOLP256;\n    if (this.oid.equals(oids.BRAINPOOLP384)) return curveTypes.BRAINPOOLP384;\n    if (this.oid.equals(oids.BRAINPOOLP512)) return curveTypes.BRAINPOOLP512;\n    if (this.oid.equals(oids.ED25519)) return curveTypes.ED25519;\n    return 0;\n  }\n\n  set curve(value) {\n    switch (value) {\n      case curveTypes.P256:\n        this.oid = oids.P256;\n        break;\n\n      case curveTypes.P384:\n        this.oid = oids.P384;\n        break;\n\n      case curveTypes.P521:\n        this.oid = oids.P521;\n        break;\n\n      case curveTypes.SECP256K1:\n        this.oid = oids.SECP256K1;\n        break;\n\n      case curveTypes.X25519:\n        this.oid = oids.X25519;\n        break;\n\n      case curveTypes.BRAINPOOLP256:\n        this.oid = oids.BRAINPOOLP256;\n        break;\n\n      case curveTypes.BRAINPOOLP384:\n        this.oid = oids.BRAINPOOLP384;\n        break;\n\n      case curveTypes.BRAINPOOLP512:\n        this.oid = oids.BRAINPOOLP512;\n        break;\n\n      case curveTypes.ED25519:\n        this.oid = oids.ED25519;\n        break;\n    }\n  }\n\n  isRSA() {\n    switch (this.algorithm) {\n      case keyTypes.RSA:\n      case keyTypes.RSA_ENCRYPT_ONLY:\n      case keyTypes.RSA_SIGN_ONLY:\n        return true;\n    }\n\n    return false;\n  }\n\n  isElgamal() {\n    switch (this.algorithm) {\n      case keyTypes.ELGAMAL:\n      case keyTypes.ELGAMAL_LEGACY:\n        return true;\n    }\n\n    return false;\n  }\n\n  getSize() {\n    let size = 0;\n    size += 1;\n\n    switch (this.version) {\n      case 2:\n      case 3:\n        {\n          size += 4;\n          size += 2;\n          size += 1;\n          break;\n        }\n\n      case 4:\n        {\n          size += 4;\n          size += 1;\n          break;\n        }\n\n      default:\n        {\n          throw new Error('Unknown PGP key version.');\n        }\n    }\n\n    switch (this.algorithm) {\n      case keyTypes.RSA:\n      case keyTypes.RSA_ENCRYPT_ONLY:\n      case keyTypes.RSA_SIGN_ONLY:\n        {\n          size += this.n.getSize();\n          size += this.e.getSize();\n          break;\n        }\n\n      case keyTypes.ELGAMAL:\n      case keyTypes.ELGAMAL_LEGACY:\n        {\n          size += this.p.getSize();\n          size += this.g.getSize();\n          size += this.y.getSize();\n          break;\n        }\n\n      case keyTypes.DSA:\n        {\n          size += this.p.getSize();\n          size += this.q.getSize();\n          size += this.g.getSize();\n          size += this.y.getSize();\n          break;\n        }\n\n      case keyTypes.ECDH:\n        {\n          size += 1;\n          size += this.oid.length;\n          size += this.point.getSize();\n          size += 4;\n          break;\n        }\n\n      case keyTypes.ECDSA:\n      case keyTypes.EDDSA:\n        {\n          size += 1;\n          size += this.oid.length;\n          size += this.point.getSize();\n          break;\n        }\n\n      default:\n        {\n          size += this.data.length;\n          break;\n        }\n    }\n\n    return size;\n  }\n\n  write(bw) {\n    bw.writeU8(this.version);\n\n    switch (this.version) {\n      case 2:\n      case 3:\n        {\n          if (!this.isRSA()) throw new Error('Unknown PGP key algorithm.');\n          bw.writeU32BE(this.timestamp);\n          bw.writeU16BE(this.expires);\n          bw.writeU8(this.algorithm);\n          break;\n        }\n\n      case 4:\n        {\n          bw.writeU32BE(this.timestamp);\n          bw.writeU8(this.algorithm);\n          break;\n        }\n\n      default:\n        {\n          throw new Error('Unknown PGP key version.');\n        }\n    }\n\n    switch (this.algorithm) {\n      case keyTypes.RSA:\n      case keyTypes.RSA_ENCRYPT_ONLY:\n      case keyTypes.RSA_SIGN_ONLY:\n        {\n          this.n.write(bw);\n          this.e.write(bw);\n          break;\n        }\n\n      case keyTypes.ELGAMAL:\n      case keyTypes.ELGAMAL_LEGACY:\n        {\n          this.p.write(bw);\n          this.g.write(bw);\n          this.y.write(bw);\n          break;\n        }\n\n      case keyTypes.DSA:\n        {\n          this.p.write(bw);\n          this.q.write(bw);\n          this.g.write(bw);\n          this.y.write(bw);\n          break;\n        }\n\n      case keyTypes.ECDH:\n        {\n          bw.writeU8(this.oid.length);\n          bw.writeBytes(this.oid);\n          this.point.write(bw);\n          bw.writeU8(3);\n          bw.writeU8(0x01);\n          bw.writeU8(this.kdfHash);\n          bw.writeU8(this.kdfAlg);\n          break;\n        }\n\n      case keyTypes.ECDSA:\n      case keyTypes.EDDSA:\n        {\n          bw.writeU8(this.oid.length);\n          bw.writeBytes(this.oid);\n          this.point.write(bw);\n          break;\n        }\n\n      default:\n        {\n          bw.writeBytes(this.data);\n          break;\n        }\n    }\n\n    return bw;\n  }\n\n  read(br) {\n    this.version = br.readU8();\n\n    switch (this.version) {\n      case 2:\n      case 3:\n        {\n          this.timestamp = br.readU32BE();\n          this.expires = br.readU16BE();\n          this.algorithm = br.readU8();\n\n          if (!this.isRSA()) {\n            if (this.version === 3 && this.isElgamal()) {\n              this.expires = 0;\n              this.version = 4;\n            } else {\n              throw new Error('Unknown PGP key algorithm.');\n            }\n          }\n\n          break;\n        }\n\n      case 4:\n        {\n          this.timestamp = br.readU32BE();\n          this.algorithm = br.readU8();\n          break;\n        }\n\n      default:\n        {\n          throw new Error('Unknown PGP key version.');\n        }\n    }\n\n    switch (this.algorithm) {\n      case keyTypes.RSA:\n      case keyTypes.RSA_ENCRYPT_ONLY:\n      case keyTypes.RSA_SIGN_ONLY:\n        {\n          this.n.read(br);\n          this.e.read(br);\n          break;\n        }\n\n      case keyTypes.ELGAMAL:\n      case keyTypes.ELGAMAL_LEGACY:\n        {\n          this.p.read(br);\n          this.g.read(br);\n          this.y.read(br);\n          break;\n        }\n\n      case keyTypes.DSA:\n        {\n          this.p.read(br);\n          this.q.read(br);\n          this.g.read(br);\n          this.y.read(br);\n          break;\n        }\n\n      case keyTypes.ECDH:\n        {\n          this.oid = br.readBytes(br.readU8());\n          this.point.read(br);\n          const size = br.readU8();\n          if (size < 3 || size > br.left()) throw new Error('Invalid ECDH params.'); // Reserved.\n\n          if (br.readU8() !== 0x01) throw new Error('Invalid ECDH reserved byte.');\n          this.kdfHash = br.readU8();\n          this.kdfAlg = br.readU8();\n          break;\n        }\n\n      case keyTypes.ECDSA:\n      case keyTypes.EDDSA:\n        {\n          this.oid = br.readBytes(br.readU8());\n          this.point.read(br);\n          break;\n        }\n\n      default:\n        {\n          this.data = br.readBytes(br.left());\n          break;\n        }\n    }\n\n    return this;\n  }\n\n  fingerprint() {\n    switch (this.version) {\n      case 2:\n      case 3:\n        {\n          if (!this.isRSA()) throw new Error('Unknown PGP key algorithm.');\n          const data = bio.concat(this.n.data, this.e.data);\n          return MD5.digest(data);\n        }\n\n      case 4:\n        {\n          const size = this.getSize();\n          const bw = bio.write(3 + size);\n          bw.writeU8(0x99);\n          bw.writeU16BE(size);\n          this.write(bw);\n          return SHA1.digest(bw.render());\n        }\n\n      default:\n        {\n          throw new Error('Unknown PGP key version.');\n        }\n    }\n  }\n\n  id() {\n    switch (this.version) {\n      case 2:\n      case 3:\n        {\n          if (!this.isRSA()) throw new Error('Unknown PGP key algorithm.');\n          if (this.n.data.length < 8) throw new Error('Unknown PGP key algorithm.');\n          return this.n.data.slice(this.n.data.length - 8);\n        }\n\n      case 4:\n        {\n          return this.fingerprint().slice(12, 20);\n        }\n\n      default:\n        {\n          throw new Error('Unknown PGP key version.');\n        }\n    }\n  }\n\n  long() {\n    return this.id();\n  }\n\n  short() {\n    return this.id().slice(4, 8);\n  }\n\n  matches(id) {\n    if (typeof id === 'string') id = decodeID(id);\n\n    switch (id.length) {\n      case 4:\n        return this.short().equals(id);\n\n      case 8:\n        return this.long().equals(id);\n\n      case 16:\n      case 20:\n        return this.fingerprint().equals(id);\n\n      default:\n        return false;\n    }\n  }\n\n  keyHash() {\n    let size = 6;\n    if (this.version !== 4) size += 2; // Create a real key hash without any bullshit.\n\n    const raw = this.encode().slice(size - 1);\n    raw[0] = this.algorithm;\n    return SHA256.digest(raw);\n  }\n\n  format() {\n    const algorithm = keyTypesByVal[this.algorithm] || 'UNKNOWN';\n    const version = this.version;\n    const timestamp = this.timestamp;\n    const expires = this.expires;\n\n    switch (this.algorithm) {\n      case keyTypes.RSA:\n      case keyTypes.RSA_ENCRYPT_ONLY:\n      case keyTypes.RSA_SIGN_ONLY:\n        {\n          return {\n            version,\n            algorithm,\n            timestamp,\n            expires,\n            n: this.n.data.toString('hex'),\n            e: this.e.data.toString('hex')\n          };\n        }\n\n      case keyTypes.ELGAMAL:\n      case keyTypes.ELGAMAL_LEGACY:\n        {\n          return {\n            version,\n            algorithm,\n            timestamp,\n            expires,\n            p: this.p.data.toString('hex'),\n            g: this.g.data.toString('hex'),\n            y: this.y.data.toString('hex')\n          };\n        }\n\n      case keyTypes.DSA:\n        {\n          return {\n            version,\n            algorithm,\n            timestamp,\n            expires,\n            p: this.p.data.toString('hex'),\n            q: this.q.data.toString('hex'),\n            g: this.g.data.toString('hex'),\n            y: this.y.data.toString('hex')\n          };\n        }\n\n      case keyTypes.ECDH:\n        {\n          return {\n            version,\n            algorithm,\n            timestamp,\n            expires,\n            curve: curveTypesByVal[this.curve] || 'UNKNOWN',\n            point: this.point.data.toString('hex'),\n            kdfHash: this.kdfHash,\n            kdfAlg: this.kdfAlg\n          };\n        }\n\n      case keyTypes.ECDSA:\n      case keyTypes.EDDSA:\n        {\n          return {\n            version,\n            algorithm,\n            timestamp,\n            expires,\n            curve: curveTypesByVal[this.curve] || 'UNKNOWN',\n            point: this.point.data.toString('hex')\n          };\n        }\n\n      default:\n        {\n          return {\n            version,\n            algorithm,\n            timestamp,\n            expires,\n            data: this.data.toString('hex')\n          };\n        }\n    }\n  }\n\n}\n/**\n * PGP Private Key\n */\n\n\nclass PGPPrivateKey extends PGPBody {\n  constructor() {\n    super();\n    this.key = new PGPPublicKey();\n    this.params = new CipherParams();\n    this.data = EMPTY;\n  }\n\n  secret(passphrase) {\n    let data = this.data;\n\n    if (this.params.encrypted) {\n      if (passphrase == null) throw new Error('Key requires a passphrase.');\n      data = this.params.decrypt(data, passphrase);\n    }\n\n    return SecretKey.decode(data, this.key.algorithm);\n  }\n\n  getSize() {\n    let size = 0;\n    size += this.key.getSize();\n    size += this.params.getSize();\n    size += this.data.length;\n    return size;\n  }\n\n  write(bw) {\n    this.key.write(bw);\n    this.params.write(bw);\n    bw.writeBytes(this.data);\n    return bw;\n  }\n\n  read(br) {\n    this.key.read(br);\n    this.params.read(br);\n    this.data = br.readBytes(br.left());\n    return this;\n  }\n\n  format() {\n    let params = null;\n    let data = null;\n\n    if (this.params.encrypted) {\n      params = this.params;\n      data = this.data.toString('hex');\n    } else {\n      params = null;\n      data = this.secret();\n    }\n\n    return {\n      key: this.key,\n      params,\n      data\n    };\n  }\n\n}\n/**\n * Cipher Params\n */\n\n\nclass CipherParams extends bio.Struct {\n  constructor() {\n    super();\n    this.encrypted = false;\n    this.checksum = false;\n    this.cipher = 0;\n    this.s2k = new S2K();\n    this.iv = EMPTY;\n  }\n\n  blockSize() {\n    switch (this.cipher) {\n      case cipherTypes.IDEA:\n      case cipherTypes.DES3:\n      case cipherTypes.CAST5:\n      case cipherTypes.BLOWFISH:\n        return 8;\n\n      case cipherTypes.AES128:\n      case cipherTypes.AES192:\n      case cipherTypes.AES256:\n      case cipherTypes.TWOFISH:\n      case cipherTypes.CAMELLIA128:\n      case cipherTypes.CAMELLIA192:\n      case cipherTypes.CAMELLIA256:\n        return 16;\n\n      default:\n        throw new Error('Unknown cipher type.');\n    }\n  }\n\n  keySize() {\n    switch (this.cipher) {\n      case cipherTypes.IDEA:\n        return 16;\n\n      case cipherTypes.DES3:\n        return 24;\n\n      case cipherTypes.CAST5:\n        return 16;\n\n      case cipherTypes.BLOWFISH:\n        return 16;\n\n      case cipherTypes.AES128:\n        return 16;\n\n      case cipherTypes.AES192:\n        return 24;\n\n      case cipherTypes.AES256:\n        return 32;\n\n      case cipherTypes.TWOFISH:\n        return 32;\n\n      case cipherTypes.CAMELLIA128:\n        return 16;\n\n      case cipherTypes.CAMELLIA192:\n        return 24;\n\n      case cipherTypes.CAMELLIA256:\n        return 32;\n\n      default:\n        throw new Error('Unknown cipher type.');\n    }\n  }\n\n  algName() {\n    switch (this.cipher) {\n      case cipherTypes.IDEA:\n        return 'IDEA-CFB';\n\n      case cipherTypes.DES3:\n        return 'DES-EDE3-CFB';\n\n      case cipherTypes.CAST5:\n        return 'CAST5-CFB';\n\n      case cipherTypes.BLOWFISH:\n        return 'BF-CFB';\n\n      case cipherTypes.AES128:\n        return 'AES-128-CFB';\n\n      case cipherTypes.AES192:\n        return 'AES-192-CFB';\n\n      case cipherTypes.AES256:\n        return 'AES-256-CFB';\n\n      case cipherTypes.TWOFISH:\n        return 'TWOFISH-256-CFB';\n\n      case cipherTypes.CAMELLIA128:\n        return 'CAMELLIA-128-CFB';\n\n      case cipherTypes.CAMELLIA192:\n        return 'CAMELLIA-192-CFB';\n\n      case cipherTypes.CAMELLIA256:\n        return 'CAMELLIA-256-CFB';\n\n      default:\n        throw new Error('Unknown cipher type.');\n    }\n  }\n\n  derive(passphrase) {\n    if (!this.encrypted) throw new Error('Cannot derive passphrase.');\n    return this.s2k.derive(passphrase, this.keySize());\n  }\n\n  encipher(pt, key) {\n    assert(Buffer.isBuffer(pt));\n    const name = this.algName();\n    const add = this.checksum ? 20 : 2;\n    const padded = Buffer.allocUnsafe(pt.length + add);\n    pt.copy(padded, 0);\n\n    if (this.checksum) {\n      SHA1.digest(pt).copy(padded, pt.length);\n    } else {\n      let sum = 0;\n\n      for (let i = 0; i < pt.length; i++) {\n        sum += pt[i];\n        sum &= 0xffff;\n      }\n\n      bio.writeU16BE(padded, sum, pt.length);\n    }\n\n    return cipher.encrypt(name, key, this.iv, padded);\n  }\n\n  decipher(ct, key) {\n    const name = this.algName();\n    const padded = cipher.decrypt(name, key, this.iv, ct);\n\n    if (this.checksum) {\n      if (padded.length < 20) throw new Error('Truncated data.');\n      const pt = padded.slice(0, -20);\n      const chk = padded.slice(-20);\n      const sum = SHA1.digest(pt);\n      if (!sum.equals(chk)) throw new Error('Invalid checksum.');\n      return pt;\n    }\n\n    if (padded.length < 2) throw new Error('Truncated data.');\n    const pt = padded.slice(0, -2);\n    const chk = bio.readU16BE(padded, padded.length - 2);\n    let sum = 0;\n\n    for (let i = 0; i < pt.length; i++) {\n      sum += pt[i];\n      sum &= 0xffff;\n    }\n\n    if (sum !== chk) throw new Error('Invalid checksum.');\n    return pt;\n  }\n\n  encrypt(data, passphrase) {\n    const key = this.derive(passphrase);\n    return this.encipher(data, key);\n  }\n\n  decrypt(data, passphrase) {\n    const key = this.derive(passphrase);\n    return this.decipher(data, key);\n  }\n\n  getSize() {\n    let size = 0;\n\n    if (this.encrypted) {\n      size += 1;\n      size += 1;\n      size += this.s2k.getSize();\n      size += this.iv.length;\n    } else {\n      size += 1;\n    }\n\n    return size;\n  }\n\n  write(bw) {\n    if (this.encrypted) {\n      assert(this.iv.length === this.blockSize());\n      bw.writeU8(this.checksum ? 0xfe : 0xff);\n      bw.writeU8(this.cipher);\n      this.s2k.write(bw);\n      bw.writeBytes(this.iv);\n    } else {\n      bw.writeU8(0x00);\n    }\n\n    return bw;\n  }\n\n  read(br) {\n    const type = br.readU8();\n\n    switch (type) {\n      case 0x00:\n        break;\n\n      case 0xfe:\n      case 0xff:\n        this.encrypted = true;\n        this.checksum = type === 0xfe;\n        this.cipher = br.readU8();\n        this.s2k.read(br);\n        this.iv = br.readBytes(this.blockSize());\n        break;\n\n      default:\n        throw new Error('Unknown S2K type.');\n    }\n\n    return this;\n  }\n\n  format() {\n    return {\n      encrypted: this.encrypted,\n      checksum: this.checksum,\n      cipher: cipherTypesByVal[this.cipher] || 'UNKNOWN',\n      s2k: this.s2k,\n      iv: this.iv.toString('hex')\n    };\n  }\n\n}\n/**\n * S2K\n */\n\n\nclass S2K extends bio.Struct {\n  constructor() {\n    super();\n    this.mode = 0;\n    this.hash = 0;\n    this.count = 0;\n    this.salt = EMPTY;\n    this.serial = EMPTY;\n  }\n\n  derive(passphrase, size) {\n    assert(typeof passphrase === 'string');\n    assert(size >>> 0 === size);\n    const input = Buffer.from(passphrase, 'binary');\n    const hash = hashToHash[this.hash];\n    if (!hash) throw new Error('Unknown hash.');\n\n    switch (this.mode) {\n      case 0:\n        return this._simple(hash, input, size);\n\n      case 1:\n        return this._salted(hash, input, size);\n\n      case 3:\n        return this._iterated(hash, input, size);\n\n      default:\n        throw new Error('Unknown S2K mode.');\n    }\n  }\n\n  _simple(hash, input, size) {\n    return this._hash(hash, input, EMPTY, size);\n  }\n\n  _salted(hash, input, size) {\n    return this._hash(hash, input, this.salt, size);\n  }\n\n  _hash(hash, input, salt, size) {\n    assert(hash && typeof hash.id === 'string');\n    assert(Buffer.isBuffer(input));\n    assert(Buffer.isBuffer(salt));\n    assert(size >>> 0 === size); // eslint-disable-next-line\n\n    const ctx = new hash();\n    const out = Buffer.alloc(size);\n    let i = 0;\n    let pos = 0;\n\n    while (pos < size) {\n      ctx.init();\n\n      for (let j = 0; j < i; j++) ctx.update(ZERO);\n\n      ctx.update(salt);\n      ctx.update(input);\n      pos += ctx.final().copy(out, pos);\n      i += 1;\n    }\n\n    return out;\n  }\n\n  _iterated(hash, input, size) {\n    assert(hash && typeof hash.id === 'string');\n    assert(Buffer.isBuffer(input));\n    assert(size >>> 0 === size);\n    const salt = this.salt; // eslint-disable-next-line\n\n    const ctx = new hash();\n    const out = Buffer.alloc(size);\n    const combined = bio.concat(salt, input);\n    let count = this.count;\n    if (count < combined.length) count = combined.length;\n    let i = 0;\n    let pos = 0;\n\n    while (pos < size) {\n      ctx.init();\n\n      for (let j = 0; j < i; j++) ctx.update(ZERO);\n\n      let w = 0;\n\n      while (w < count) {\n        if (w + combined.length > count) {\n          const todo = count - w;\n          ctx.update(combined.slice(0, todo));\n          w = count;\n        } else {\n          ctx.update(combined);\n          w += combined.length;\n        }\n      }\n\n      pos += ctx.final().copy(out, pos);\n      i += 1;\n    }\n\n    return out;\n  }\n\n  getSize() {\n    let size = 2;\n\n    switch (this.mode) {\n      case 0:\n        break;\n\n      case 1:\n        size += 8;\n        break;\n\n      case 3:\n        size += 8;\n        size += 1;\n        break;\n\n      case 1001:\n        size += 3;\n        size += 1;\n        break;\n\n      case 1002:\n        size += 3;\n        size += 1;\n        size += 1;\n        size += this.serial.length;\n        break;\n\n      default:\n        throw new Error('Unknown S2K function.');\n    }\n\n    return size;\n  }\n\n  write(bw) {\n    bw.writeU8(this.mode > 0xff ? 101 : this.mode);\n    bw.writeU8(this.hash);\n\n    switch (this.mode) {\n      case 0:\n        break;\n\n      case 1:\n        bw.writeBytes(this.salt);\n        break;\n\n      case 3:\n        bw.writeBytes(this.salt);\n        bw.writeU8(encodeCount(this.count));\n        break;\n\n      case 1001:\n        bw.writeString('GNU', 'binary');\n        bw.writeU8(1);\n        break;\n\n      case 1002:\n        bw.writeString('GNU', 'binary');\n        bw.writeU8(2);\n        bw.writeU8(this.serial.length);\n        bw.writeBytes(this.serial);\n        break;\n\n      default:\n        throw new Error('Unknown S2K function.');\n    }\n\n    return bw;\n  }\n\n  read(br) {\n    this.mode = br.readU8();\n    this.hash = br.readU8();\n\n    switch (this.mode) {\n      case 0:\n        {\n          break;\n        }\n\n      case 1:\n        {\n          this.salt = br.readBytes(8);\n          break;\n        }\n\n      case 3:\n        {\n          this.salt = br.readBytes(8);\n          this.count = decodeCount(br.readU8());\n          break;\n        }\n\n      case 101:\n        {\n          // GNU extensions.\n          // See: https://github.com/handshake-org/hs-airdrop/issues/44\n          const tag = br.readString(3, 'binary');\n          if (tag !== 'GNU') throw new Error('Unknown S2K function.');\n          this.mode = 1000 + br.readU8();\n\n          switch (this.mode) {\n            case 1001:\n              // gnu-dummy\n              break;\n\n            case 1002:\n              // gnu-divert-to-card\n              this.serial = br.readBytes(Math.min(br.readU8(), 16));\n              break;\n\n            default:\n              throw new Error('Unknown S2K function.');\n          }\n\n          break;\n        }\n\n      default:\n        {\n          throw new Error('Unknown S2K function.');\n        }\n    }\n\n    return this;\n  }\n\n  format() {\n    return {\n      mode: this.mode,\n      hash: hashTypesByVal[this.hash] || 'UNKNOWN',\n      count: this.count,\n      salt: this.salt.toString('hex'),\n      serial: this.serial.toString('hex')\n    };\n  }\n\n}\n/**\n * Secret Key\n */\n\n\nclass SecretKey extends bio.Struct {\n  constructor() {\n    super(); // RSA\n\n    this.d = new MPI();\n    this.q = new MPI();\n    this.p = new MPI();\n    this.qi = new MPI(); // DSA\n\n    this.x = new MPI(); // El Gamal\n\n    this.x; // ECDSA\n\n    this.d;\n  }\n\n  getSize(algorithm) {\n    assert((algorithm & 0xff) === algorithm);\n    let size = 0;\n\n    switch (algorithm) {\n      case keyTypes.RSA:\n      case keyTypes.RSA_ENCRYPT_ONLY:\n      case keyTypes.RSA_SIGN_ONLY:\n        {\n          size += this.d.getSize();\n          size += this.q.getSize();\n          size += this.p.getSize();\n          size += this.qi.getSize();\n          break;\n        }\n\n      case keyTypes.ELGAMAL:\n      case keyTypes.ELGAMAL_LEGACY:\n        {\n          size += this.x.getSize();\n          break;\n        }\n\n      case keyTypes.DSA:\n        {\n          size += this.x.getSize();\n          break;\n        }\n\n      case keyTypes.ECDSA:\n      case keyTypes.EDDSA:\n        {\n          size += this.d.getSize();\n          break;\n        }\n\n      default:\n        {\n          throw new Error('Unknown key type.');\n        }\n    }\n\n    return size;\n  }\n\n  write(bw, algorithm) {\n    assert((algorithm & 0xff) === algorithm);\n\n    switch (algorithm) {\n      case keyTypes.RSA:\n      case keyTypes.RSA_ENCRYPT_ONLY:\n      case keyTypes.RSA_SIGN_ONLY:\n        {\n          this.d.write(bw);\n          this.q.write(bw);\n          this.p.write(bw);\n          this.qi.write(bw);\n          break;\n        }\n\n      case keyTypes.ELGAMAL:\n      case keyTypes.ELGAMAL_LEGACY:\n        {\n          this.x.write(bw);\n          break;\n        }\n\n      case keyTypes.DSA:\n        {\n          this.x.write(bw);\n          break;\n        }\n\n      case keyTypes.ECDSA:\n      case keyTypes.EDDSA:\n        {\n          this.d.write(bw);\n          break;\n        }\n\n      default:\n        {\n          throw new Error('Unknown key type.');\n        }\n    }\n\n    return bw;\n  }\n\n  read(br, algorithm) {\n    assert((algorithm & 0xff) === algorithm);\n\n    switch (algorithm) {\n      case keyTypes.RSA:\n      case keyTypes.RSA_ENCRYPT_ONLY:\n      case keyTypes.RSA_SIGN_ONLY:\n        {\n          this.d.read(br);\n          this.q.read(br);\n          this.p.read(br);\n          this.qi.read(br);\n          break;\n        }\n\n      case keyTypes.ELGAMAL:\n      case keyTypes.ELGAMAL_LEGACY:\n        {\n          this.x.read(br);\n          break;\n        }\n\n      case keyTypes.DSA:\n        {\n          this.x.read(br);\n          break;\n        }\n\n      case keyTypes.ECDSA:\n      case keyTypes.EDDSA:\n        {\n          this.d.read(br);\n          break;\n        }\n\n      default:\n        {\n          throw new Error('Unknown key type.');\n        }\n    }\n\n    return this;\n  }\n\n  format() {\n    if (this.p.data.length > 0) {\n      return {\n        d: this.d.data.toString('hex'),\n        q: this.q.data.toString('hex'),\n        p: this.p.data.toString('hex'),\n        qi: this.qi.data.toString('hex')\n      };\n    }\n\n    if (this.x.data.length > 0) {\n      return {\n        x: this.x.data.toString('hex')\n      };\n    }\n\n    if (this.d.data.length > 0) {\n      return {\n        d: this.d.data.toString('hex')\n      };\n    }\n\n    return {\n      d: this.d.data.toString('hex'),\n      q: this.q.data.toString('hex'),\n      p: this.p.data.toString('hex'),\n      qi: this.qi.data.toString('hex'),\n      x: this.x.data.toString('hex')\n    };\n  }\n\n}\n/**\n * PGP User ID\n */\n\n\nclass PGPUserID extends PGPBody {\n  constructor() {\n    super();\n    this.id = '';\n  }\n\n  getSize() {\n    return Buffer.byteLength(this.id, 'utf8');\n  }\n\n  write(bw) {\n    bw.writeString(this.id, 'utf8');\n    return bw;\n  }\n\n  read(br) {\n    this.id = br.readString(br.left(), 'utf8');\n    return this;\n  }\n\n  format() {\n    return {\n      id: this.id\n    };\n  }\n\n}\n/**\n * MPI\n */\n\n\nclass MPI extends bio.Struct {\n  constructor(data) {\n    super();\n    this.bits = 0;\n    this.data = EMPTY;\n    if (data != null) this.fromOptions(data);\n  }\n\n  get() {\n    return this.data;\n  }\n\n  set(data) {\n    return this.fromOptions(data);\n  }\n\n  fromOptions(data) {\n    assert(Buffer.isBuffer(data));\n    this.bits = countLeft(data);\n    this.data = data;\n    return this;\n  }\n\n  getSize() {\n    return 2 + this.data.length;\n  }\n\n  write(bw) {\n    bw.writeU16BE(this.bits);\n    bw.writeBytes(this.data);\n    return bw;\n  }\n\n  read(br) {\n    if (br.left() === 0) return this;\n    const bits = br.readU16BE();\n    const size = bits + 7 >>> 3;\n    const s = Math.min(size, br.left());\n    const data = br.readBytes(s);\n    this.bits = bits;\n    this.data = data;\n    return this;\n  }\n\n}\n/*\n * ID Parsing\n */\n\n\nfunction encodeID(raw) {\n  assert(Buffer.isBuffer(raw));\n\n  switch (raw.length) {\n    case 4:\n    case 8:\n    case 16:\n    case 20:\n      break;\n\n    default:\n      throw new Error('Invalid PGP key id/fingerprint.');\n  }\n\n  const id = raw.toString('hex');\n  return `0x${id.toUpperCase()}`;\n}\n\nfunction decodeID(id) {\n  assert(typeof id === 'string');\n  id = id.replace(/[\\t ]/g, '');\n\n  if (id.length >= 2 && id.charCodeAt(0) === 0x30 && (id.charCodeAt(1) | 0x20) === 0x78) {\n    id = id.substring(2);\n  }\n\n  if (id.length > 40) throw new Error('Invalid PGP key id/fingerprint.');\n  const raw = Buffer.from(id, 'hex');\n  if (raw.length !== id.length >>> 1) throw new Error('Invalid PGP key id/fingerprint.');\n\n  switch (raw.length) {\n    case 4:\n    case 8:\n    case 16:\n    case 20:\n      break;\n\n    default:\n      throw new Error('Invalid PGP key id/fingerprint.');\n  }\n\n  return raw;\n}\n/*\n * Helpers\n */\n\n\nfunction encodeCount(i) {\n  assert(i >>> 0 === i);\n  if (i < 1024 || i > 65011712) throw new RangeError('Invalid iteration count.');\n\n  for (let j = 0; j < 256; j++) {\n    const c = decodeCount(j);\n    if (c >= i) return j;\n  }\n\n  return 255;\n}\n\nfunction decodeCount(c) {\n  assert((c & 0xff) === c);\n  return 16 + (c & 15) << (c >>> 4) + 6;\n}\n/*\n * Expose\n */\n\n\nexports.packetTypes = packetTypes;\nexports.packetTypesByVal = packetTypesByVal;\nexports.sigTypes = sigTypes;\nexports.sigTypesByVal = sigTypesByVal;\nexports.keyTypes = keyTypes;\nexports.keyTypesByVal = keyTypesByVal;\nexports.cipherTypes = cipherTypes;\nexports.cipherTypesByVal = cipherTypesByVal;\nexports.hashTypes = hashTypes;\nexports.hashTypesByVal = hashTypesByVal;\nexports.compressTypes = compressTypes;\nexports.compressTypesByVal = compressTypesByVal;\nexports.curveTypes = curveTypes;\nexports.curveTypesByVal = curveTypesByVal;\nexports.oids = oids;\nexports.PGPMessage = PGPMessage;\nexports.PGPPacket = PGPPacket;\nexports.PGPBody = PGPBody;\nexports.PGPUnknown = PGPUnknown;\nexports.PGPPublicKey = PGPPublicKey;\nexports.PGPPrivateKey = PGPPrivateKey;\nexports.CipherParams = CipherParams;\nexports.S2K = S2K;\nexports.SecretKey = SecretKey;\nexports.PGPUserID = PGPUserID;\nexports.MPI = MPI;\nexports.encodeID = encodeID;\nexports.decodeID = decodeID;","map":null,"metadata":{},"sourceType":"script"}