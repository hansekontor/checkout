{"ast":null,"code":"/*!\n * mtx.js - mutable transaction object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst {\n  encoding\n} = require('bufio');\n\nconst {\n  BufferMap\n} = require('buffer-map');\n\nconst Script = require('../script/script');\n\nconst TX = require('./tx');\n\nconst Input = require('./input');\n\nconst Output = require('./output');\n\nconst Coin = require('./coin');\n\nconst Outpoint = require('./outpoint');\n\nconst CoinView = require('../coins/coinview');\n\nconst Address = require('./address');\n\nconst consensus = require('../protocol/consensus');\n\nconst policy = require('../protocol/policy');\n\nconst Amount = require('../btc/amount');\n\nconst Stack = require('../script/stack');\n\nconst util = require('../utils/util');\n\nconst {\n  inspectSymbol\n} = require('../utils');\n/**\n * MTX\n * A mutable transaction object.\n * @alias module:primitives.MTX\n * @extends TX\n * @property {Number} changeIndex\n * @property {CoinView} view\n */\n\n\nclass MTX extends TX {\n  /**\n   * Create a mutable transaction.\n   * @alias module:primitives.MTX\n   * @constructor\n   * @param {Object} options\n   */\n  constructor(options) {\n    super();\n    this.mutable = true;\n    this.changeIndex = -1;\n    this.view = new CoinView();\n    if (options) this.fromOptions(options);\n  }\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n\n  fromOptions(options) {\n    if (options.version != null) {\n      assert(options.version >>> 0 === options.version, 'Version must a be uint32.');\n      this.version = options.version;\n    }\n\n    if (options.inputs) {\n      assert(Array.isArray(options.inputs), 'Inputs must be an array.');\n\n      for (const input of options.inputs) this.addInput(input);\n    }\n\n    if (options.outputs) {\n      assert(Array.isArray(options.outputs), 'Outputs must be an array.');\n\n      for (const output of options.outputs) this.addOutput(output);\n    }\n\n    if (options.locktime != null) {\n      assert(options.locktime >>> 0 === options.locktime, 'Locktime must be a uint32.');\n      this.locktime = options.locktime;\n    }\n\n    if (options.changeIndex != null) {\n      if (options.changeIndex !== -1) {\n        assert(options.changeIndex >>> 0 === options.changeIndex, 'Change index must be a uint32.');\n        this.changeIndex = options.changeIndex;\n      } else {\n        this.changeIndex = -1;\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Instantiate MTX from options.\n   * @param {Object} options\n   * @returns {MTX}\n   */\n\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n  /**\n   * Clone the transaction. Note that\n   * this will not carry over the view.\n   * @returns {MTX}\n   */\n\n\n  clone() {\n    const mtx = new this.constructor();\n    mtx.inject(this);\n    mtx.changeIndex = this.changeIndex;\n    return mtx;\n  }\n  /**\n   * Add an input to the transaction.\n   * @param {Input|Object} options\n   * @returns {Input}\n   *\n   * @example\n   * mtx.addInput({ prevout: { hash: ... }, script: ... });\n   * mtx.addInput(new Input());\n   */\n\n\n  addInput(options) {\n    const input = Input.fromOptions(options);\n    this.inputs.push(input);\n    return input;\n  }\n  /**\n   * Add an outpoint as an input.\n   * @param {Outpoint|Object} outpoint\n   * @returns {Input}\n   *\n   * @example\n   * mtx.addOutpoint({ hash: ..., index: 0 });\n   * mtx.addOutpoint(new Outpoint(hash, index));\n   */\n\n\n  addOutpoint(outpoint) {\n    const prevout = Outpoint.fromOptions(outpoint);\n    const input = Input.fromOutpoint(prevout);\n    this.inputs.push(input);\n    return input;\n  }\n  /**\n   * Add a coin as an input. Note that this will\n   * add the coin to the internal coin viewpoint.\n   * @param {Coin} coin\n   * @returns {Input}\n   *\n   * @example\n   * mtx.addCoin(Coin.fromTX(tx, 0, -1));\n   */\n\n\n  addCoin(coin) {\n    assert(coin instanceof Coin, 'Cannot add non-coin.');\n    const input = Input.fromCoin(coin);\n    this.inputs.push(input);\n    this.view.addCoin(coin);\n    return input;\n  }\n  /**\n   * Add a transaction as an input. Note that\n   * this will add the coin to the internal\n   * coin viewpoint.\n   * @param {TX} tx\n   * @param {Number} index\n   * @param {Number?} height\n   * @returns {Input}\n   *\n   * @example\n   * mtx.addTX(tx, 0);\n   */\n\n\n  addTX(tx, index, height) {\n    assert(tx instanceof TX, 'Cannot add non-transaction.');\n    if (height == null) height = -1;\n    const input = Input.fromTX(tx, index);\n    this.inputs.push(input);\n    this.view.addIndex(tx, index, height);\n    return input;\n  }\n  /**\n   * Add an output.\n   * @param {Address|Script|Output|Object} script - Script or output options.\n   * @param {Amount?} value\n   * @returns {Output}\n   *\n   * @example\n   * mtx.addOutput(new Output());\n   * mtx.addOutput({ address: ..., value: 100000 });\n   * mtx.addOutput(address, 100000);\n   * mtx.addOutput(script, 100000);\n   */\n\n\n  addOutput(script, value) {\n    let output;\n    if (value != null) output = Output.fromScript(script, value);else output = Output.fromOptions(script);\n    this.outputs.push(output);\n    return output;\n  }\n  /**\n   * Verify all transaction inputs.\n   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n   * @returns {Boolean} Whether the inputs are valid.\n   * @throws {ScriptError} on invalid inputs\n   */\n\n\n  check(flags) {\n    return super.check(this.view, flags);\n  }\n  /**\n   * Verify the transaction inputs on the worker pool\n   * (if workers are enabled).\n   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n   * @param {WorkerPool?} pool\n   * @returns {Promise}\n   */\n\n\n  checkAsync(flags, pool) {\n    return super.checkAsync(this.view, flags, pool);\n  }\n  /**\n   * Verify all transaction inputs.\n   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n   * @returns {Boolean} Whether the inputs are valid.\n   */\n\n\n  verify(flags) {\n    try {\n      this.check(flags);\n    } catch (e) {\n      if (e.type === 'ScriptError') return false;\n      throw e;\n    }\n\n    return true;\n  }\n  /**\n   * Verify the transaction inputs on the worker pool\n   * (if workers are enabled).\n   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n   * @param {WorkerPool?} pool\n   * @returns {Promise}\n   */\n\n\n  async verifyAsync(flags, pool) {\n    try {\n      await this.checkAsync(flags, pool);\n    } catch (e) {\n      if (e.type === 'ScriptError') return false;\n      throw e;\n    }\n\n    return true;\n  }\n  /**\n   * Calculate the fee for the transaction.\n   * @returns {Amount} fee (zero if not all coins are available).\n   */\n\n\n  getFee() {\n    return super.getFee(this.view);\n  }\n  /**\n   * Calculate the total input value.\n   * @returns {Amount} value\n   */\n\n\n  getInputValue() {\n    return super.getInputValue(this.view);\n  }\n  /**\n   * Get all input addresses.\n   * @returns {Address[]} addresses\n   */\n\n\n  getInputAddresses() {\n    return super.getInputAddresses(this.view);\n  }\n  /**\n   * Get all addresses.\n   * @returns {Address[]} addresses\n   */\n\n\n  getAddresses() {\n    return super.getAddresses(this.view);\n  }\n  /**\n   * Get all input address hashes.\n   * @returns {Hash[]} hashes\n   */\n\n\n  getInputHashes(enc) {\n    return super.getInputHashes(this.view, enc);\n  }\n  /**\n   * Get all address hashes.\n   * @returns {Hash[]} hashes\n   */\n\n\n  getHashes(enc) {\n    return super.getHashes(this.view, enc);\n  }\n  /**\n   * Test whether the transaction has\n   * all coins available/filled.\n   * @returns {Boolean}\n   */\n\n\n  hasCoins() {\n    return super.hasCoins(this.view);\n  }\n  /**\n   * Calculate virtual sigop count.\n   * @param {VerifyFlags?} flags\n   * @returns {Number} sigop count\n   */\n\n\n  getSigops(flags) {\n    return super.getSigops(this.view, flags);\n  }\n  /**\n   *  Calculate sigops count.\n   *  @param {CoinView} view\n   *  @param {VerifyFlags?} flags\n   *  @returns {Number} sigop count\n   */\n\n\n  getSigopsCount(flags) {\n    return super.getSigopsCount(this.view, flags);\n  }\n  /**\n   * Perform contextual checks to verify input, output,\n   * and fee values, as well as coinbase spend maturity\n   * (coinbases can only be spent 100 blocks or more\n   * after they're created). Note that this function is\n   * consensus critical.\n   * @param {Number} height - Height at which the\n   * transaction is being spent. In the mempool this is\n   * the chain height plus one at the time it entered the pool.\n   * @returns {Boolean}\n   */\n\n\n  verifyInputs(height) {\n    const [fee] = this.checkInputs(height);\n    return fee !== -1;\n  }\n  /**\n   * Perform contextual checks to verify input, output,\n   * and fee values, as well as coinbase spend maturity\n   * (coinbases can only be spent 100 blocks or more\n   * after they're created). Note that this function is\n   * consensus critical.\n   * @param {Number} height - Height at which the\n   * transaction is being spent. In the mempool this is\n   * the chain height plus one at the time it entered the pool.\n   * @returns {Array} [fee, reason, score]\n   */\n\n\n  checkInputs(height) {\n    return super.checkInputs(this.view, height);\n  }\n  /**\n   * Build input script (or witness) templates (with\n   * OP_0 in place of signatures).\n   * @param {Number} index - Input index.\n   * @param {Coin|Output} coin\n   * @param {KeyRing} ring\n   * @returns {Boolean} Whether the script was able to be built.\n   */\n\n\n  scriptInput(index, coin, ring) {\n    const input = this.inputs[index];\n    assert(input, 'Input does not exist.');\n    assert(coin, 'No coin passed.'); // Don't bother with any below calculation\n    // if the output is already templated.\n\n    if (input.script.raw.length !== 0) return true; // Get the previous output's script\n\n    const prev = coin.script; // This is easily the hardest part about\n    // building a transaction with segwit:\n    // figuring out where the redeem script\n    // and witness redeem scripts go.\n\n    const sh = prev.getScripthash();\n\n    if (sh) {\n      const redeem = ring.getRedeem(sh);\n      if (!redeem) return false; // Regular P2SH.\n\n      const vector = this.scriptVector(redeem, ring);\n      if (!vector) return false;\n      vector.push(redeem.toRaw());\n      input.script.fromStack(vector);\n      return true;\n    }\n\n    const vector = this.scriptVector(prev, ring);\n    if (!vector) return false;\n    input.script.fromStack(vector);\n    return true;\n  }\n  /**\n   * Build script for a single vector\n   * based on a previous script.\n   * @param {Script} prev\n   * @param {Buffer} ring\n   * @return {Stack}\n   */\n\n\n  scriptVector(prev, ring) {\n    // P2PK\n    const pk = prev.getPubkey();\n\n    if (pk) {\n      if (!pk.equals(ring.publicKey)) return null;\n      const stack = new Stack();\n      stack.pushInt(0);\n      return stack;\n    } // P2PKH\n\n\n    const pkh = prev.getPubkeyhash();\n\n    if (pkh) {\n      if (!pkh.equals(ring.getKeyHash())) return null;\n      const stack = new Stack();\n      stack.pushInt(0);\n      stack.pushData(ring.publicKey);\n      return stack;\n    } // Multisig\n\n\n    const [, n] = prev.getMultisig();\n\n    if (n !== -1) {\n      if (prev.indexOf(ring.publicKey) === -1) return null; // Technically we should create m signature slots,\n      // but we create n signature slots so we can order\n      // the signatures properly.\n\n      const stack = new Stack();\n      stack.pushInt(0); // Fill script with `n` signature slots.\n\n      for (let i = 0; i < n; i++) stack.pushInt(0);\n\n      return stack;\n    }\n\n    return null;\n  }\n  /**\n   * Sign a transaction input on the worker pool\n   * (if workers are enabled).\n   * @param {Number} index\n   * @param {Coin|Output} coin\n   * @param {KeyRing} ring\n   * @param {SighashType?} type\n   * @param {WorkerPool?} pool\n   * @returns {Promise}\n   */\n\n\n  async signInputAsync(index, coin, ring, type, pool) {\n    if (!pool) return this.signInput(index, coin, ring, type);\n    return await pool.signInput(this, index, coin, ring, type, pool);\n  }\n  /**\n   * Sign an input.\n   * @param {Number} index - Index of input being signed.\n   * @param {Coin|Output} coin\n   * @param {KeyRing} ring - Private key.\n   * @param {SighashType} type\n   * @returns {Boolean} Whether the input was able to be signed.\n   */\n\n\n  signInput(index, coin, ring, type) {\n    const input = this.inputs[index];\n    const key = ring.privateKey;\n    assert(input, 'Input does not exist.');\n    assert(coin, 'No coin passed.'); // Get the previous output's script\n\n    const value = coin.value;\n    let prev = coin.script;\n    const vector = input.script;\n    let redeem = false;\n    if (type == null) type = Script.hashType.ALL;\n    type |= Script.hashType.SIGHASH_FORKID;\n    const flags = Script.flags.VERIFY_SIGHASH_FORKID; // Grab regular p2sh redeem script.\n\n    if (prev.isScripthash()) {\n      prev = input.script.getRedeem();\n      if (!prev) throw new Error('Input has not been templated.');\n      redeem = true;\n    } // Create our signature.\n\n\n    const sig = this.signature(index, prev, value, key, type, flags);\n\n    if (redeem) {\n      const stack = vector.toStack();\n      const redeem = stack.pop();\n      const result = this.signVector(prev, stack, sig, ring);\n      if (!result) return false;\n      result.push(redeem);\n      vector.fromStack(result);\n      return true;\n    }\n\n    const stack = vector.toStack();\n    const result = this.signVector(prev, stack, sig, ring);\n    if (!result) return false;\n    vector.fromStack(result);\n    return true;\n  }\n  /**\n   * Add a signature to a vector\n   * based on a previous script.\n   * @param {Script} prev\n   * @param {Stack} vector\n   * @param {Buffer} sig\n   * @param {KeyRing} ring\n   * @return {Boolean}\n   */\n\n\n  signVector(prev, vector, sig, ring) {\n    // P2PK\n    const pk = prev.getPubkey();\n\n    if (pk) {\n      // Make sure the pubkey is ours.\n      if (!ring.publicKey.equals(pk)) return null;\n      if (vector.length === 0) throw new Error('Input has not been templated.'); // Already signed.\n\n      if (vector.get(0).length > 0) return vector;\n      vector.set(0, sig);\n      return vector;\n    } // P2PKH\n\n\n    const pkh = prev.getPubkeyhash();\n\n    if (pkh) {\n      // Make sure the pubkey hash is ours.\n      if (!ring.getKeyHash().equals(pkh)) return null;\n      if (vector.length !== 2) throw new Error('Input has not been templated.');\n      if (vector.get(1).length === 0) throw new Error('Input has not been templated.'); // Already signed.\n\n      if (vector.get(0).length > 0) return vector;\n      vector.set(0, sig);\n      return vector;\n    } // Multisig\n\n\n    const [m, n] = prev.getMultisig();\n\n    if (m !== -1) {\n      if (vector.length < 2) throw new Error('Input has not been templated.');\n      if (vector.get(0).length !== 0) throw new Error('Input has not been templated.'); // Too many signature slots. Abort.\n\n      if (vector.length - 1 > n) throw new Error('Input has not been templated.'); // Count the number of current signatures.\n\n      let total = 0;\n\n      for (let i = 1; i < vector.length; i++) {\n        const item = vector.get(i);\n        if (item.length > 0) total += 1;\n      } // Signatures are already finalized.\n\n\n      if (total === m && vector.length - 1 === m) return vector; // Add some signature slots for us to use if\n      // there was for some reason not enough.\n\n      while (vector.length - 1 < n) vector.pushInt(0); // Grab the redeem script's keys to figure\n      // out where our key should go.\n\n\n      const keys = [];\n\n      for (const op of prev.code) {\n        if (op.data) keys.push(op.data);\n      } // Find the key index so we can place\n      // the signature in the same index.\n\n\n      let keyIndex = -1;\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n\n        if (key.equals(ring.publicKey)) {\n          keyIndex = i;\n          break;\n        }\n      } // Our public key is not in the prev_out\n      // script. We tried to sign a transaction\n      // that is not redeemable by us.\n\n\n      if (keyIndex === -1) return null; // Offset key index by one to turn it into\n      // \"sig index\". Accounts for OP_0 byte at\n      // the start.\n\n      keyIndex += 1; // Add our signature to the correct slot\n      // and increment the total number of\n      // signatures.\n\n      if (keyIndex < vector.length && total < m) {\n        if (vector.get(keyIndex).length === 0) {\n          vector.set(keyIndex, sig);\n          total += 1;\n        }\n      } // All signatures added. Finalize.\n\n\n      if (total >= m) {\n        // Remove empty slots left over.\n        for (let i = vector.length - 1; i >= 1; i--) {\n          const item = vector.get(i);\n          if (item.length === 0) vector.remove(i);\n        } // Remove signatures which are not required.\n        // This should never happen.\n\n\n        while (total > m) {\n          vector.pop();\n          total -= 1;\n        } // Sanity checks.\n\n\n        assert(total === m);\n        assert(vector.length - 1 === m);\n      }\n\n      return vector;\n    }\n\n    return null;\n  }\n  /**\n   * Test whether the transaction is fully-signed.\n   * @returns {Boolean}\n   */\n\n\n  isSigned() {\n    for (let i = 0; i < this.inputs.length; i++) {\n      const {\n        prevout\n      } = this.inputs[i];\n      const coin = this.view.getOutput(prevout);\n      if (!coin) return false;\n      if (!this.isInputSigned(i, coin)) return false;\n    }\n\n    return true;\n  }\n  /**\n   * Test whether an input is fully-signed.\n   * @param {Number} index\n   * @param {Coin|Output} coin\n   * @returns {Boolean}\n   */\n\n\n  isInputSigned(index, coin) {\n    const input = this.inputs[index];\n    assert(input, 'Input does not exist.');\n    assert(coin, 'No coin passed.');\n    const vector = input.script;\n    let prev = coin.script;\n    let redeem = false; // Grab redeem script if possible.\n\n    if (prev.isScripthash()) {\n      prev = input.script.getRedeem();\n      if (!prev) return false;\n      redeem = true;\n    }\n\n    const stack = vector.toStack();\n    if (redeem) stack.pop();\n    return this.isVectorSigned(prev, stack);\n  }\n  /**\n   * Test whether a vector is fully-signed.\n   * @param {Script} prev\n   * @param {Stack} vector\n   * @returns {Boolean}\n   */\n\n\n  isVectorSigned(prev, vector) {\n    if (prev.isPubkey()) {\n      if (vector.length !== 1) return false;\n      if (vector.get(0).length === 0) return false;\n      return true;\n    }\n\n    if (prev.isPubkeyhash()) {\n      if (vector.length !== 2) return false;\n      if (vector.get(0).length === 0) return false;\n      if (vector.get(1).length === 0) return false;\n      return true;\n    }\n\n    const [m] = prev.getMultisig();\n\n    if (m !== -1) {\n      // Ensure we have the correct number\n      // of required signatures.\n      if (vector.length - 1 !== m) return false; // Ensure all members are signatures.\n\n      for (let i = 1; i < vector.length; i++) {\n        const item = vector.get(i);\n        if (item.length === 0) return false;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Build input scripts (or witnesses).\n   * @param {KeyRing} ring - Address used to sign. The address\n   * must be able to redeem the coin.\n   * @returns {Number} Number of inputs templated.\n   */\n\n\n  template(ring) {\n    if (Array.isArray(ring)) {\n      let total = 0;\n\n      for (const key of ring) total += this.template(key);\n\n      return total;\n    }\n\n    let total = 0;\n\n    for (let i = 0; i < this.inputs.length; i++) {\n      const {\n        prevout\n      } = this.inputs[i];\n      const coin = this.view.getOutput(prevout);\n      if (!coin) continue;\n      if (!ring.ownOutput(coin)) continue; // Build script for input\n\n      if (!this.scriptInput(i, coin, ring)) continue;\n      total += 1;\n    }\n\n    return total;\n  }\n  /**\n   * Built input scripts (or witnesses) and sign the inputs.\n   * @param {KeyRing} ring - Address used to sign. The address\n   * must be able to redeem the coin.\n   * @param {SighashType} type\n   * @returns {Number} Number of inputs signed.\n   */\n\n\n  sign(ring, type) {\n    if (Array.isArray(ring)) {\n      let total = 0;\n\n      for (const key of ring) total += this.sign(key, type);\n\n      return total;\n    }\n\n    assert(ring.privateKey, 'No private key available.');\n    let total = 0;\n\n    for (let i = 0; i < this.inputs.length; i++) {\n      const {\n        prevout\n      } = this.inputs[i];\n      const coin = this.view.getOutput(prevout);\n      if (!coin) continue;\n      if (!ring.ownOutput(coin)) continue; // Build script for input\n\n      if (!this.scriptInput(i, coin, ring)) continue; // Sign input\n\n      if (!this.signInput(i, coin, ring, type)) continue;\n      total += 1;\n    }\n\n    return total;\n  }\n  /**\n   * Sign the transaction inputs on the worker pool\n   * (if workers are enabled).\n   * @param {KeyRing} ring\n   * @param {SighashType?} type\n   * @param {WorkerPool?} pool\n   * @returns {Promise}\n   */\n\n\n  async signAsync(ring, type, pool) {\n    if (!pool) return this.sign(ring, type);\n    return await pool.sign(this, ring, type);\n  }\n  /**\n   * Estimate maximum possible size.\n   * @param {Function?} estimate - Input script size estimator.\n   * @returns {Number}\n   */\n\n\n  async estimateSize(estimate) {\n    let total = 0; // Calculate the size, minus the input scripts.\n\n    total += 4;\n    total += encoding.sizeVarint(this.inputs.length);\n    total += this.inputs.length * 40;\n    total += encoding.sizeVarint(this.outputs.length);\n\n    for (const output of this.outputs) total += output.getSize();\n\n    total += 4; // Add size for signatures and public keys\n\n    for (const {\n      prevout\n    } of this.inputs) {\n      const coin = this.view.getOutput(prevout); // We're out of luck here.\n      // Just assume it's a p2pkh.\n\n      if (!coin) {\n        total += 110;\n        continue;\n      } // Previous output script.\n\n\n      const prev = coin.script; // P2PK\n\n      if (prev.isPubkey()) {\n        // varint script size\n        total += 1; // OP_PUSHDATA0 [signature]\n\n        total += 1 + 73;\n        continue;\n      } // P2PKH\n\n\n      if (prev.isPubkeyhash()) {\n        // varint script size\n        total += 1; // OP_PUSHDATA0 [signature]\n\n        total += 1 + 73; // OP_PUSHDATA0 [key]\n\n        total += 1 + 33;\n        continue;\n      }\n\n      const [m] = prev.getMultisig();\n\n      if (m !== -1) {\n        let size = 0; // Bare Multisig\n        // OP_0\n\n        size += 1; // OP_PUSHDATA0 [signature] ...\n\n        size += (1 + 73) * m; // varint len\n\n        size += encoding.sizeVarint(size);\n        total += size;\n        continue;\n      } // Call out to the custom estimator.\n\n\n      if (estimate) {\n        const size = await estimate(prev);\n\n        if (size !== -1) {\n          total += size;\n          continue;\n        }\n      } // P2SH\n\n\n      if (prev.isScripthash()) {\n        // varint size\n        total += 1; // 2-of-3 multisig input\n\n        total += 149;\n        continue;\n      } // Unknown.\n\n\n      total += 110;\n    }\n\n    return total;\n  }\n  /**\n   * Select necessary coins based on total output value.\n   * @param {Coin[]} coins\n   * @param {Object?} options\n   * @returns {CoinSelection}\n   * @throws on not enough funds available.\n   */\n\n\n  selectCoins(coins, options) {\n    const selector = new CoinSelector(this, options);\n    return selector.select(coins);\n  }\n  /**\n   * Attempt to subtract a fee from a single output.\n   * @param {Number} index\n   * @param {Amount} fee\n   */\n\n\n  subtractIndex(index, fee) {\n    assert(typeof index === 'number');\n    assert(typeof fee === 'number');\n    const output = this.outputs[index];\n    if (!output) throw new Error('Subtraction index does not exist.');\n    if (output.value < fee + output.getDustThreshold()) throw new Error('Could not subtract fee.');\n    output.value -= fee;\n  }\n  /**\n   * Attempt to subtract a fee from all outputs evenly.\n   * @param {Amount} fee\n   */\n\n\n  subtractFee(fee) {\n    assert(typeof fee === 'number');\n    let outputs = 0;\n\n    for (const output of this.outputs) {\n      // Ignore nulldatas and\n      // other OP_RETURN scripts.\n      if (output.script.isUnspendable()) continue;\n      outputs += 1;\n    }\n\n    if (outputs === 0) throw new Error('Could not subtract fee.');\n    const left = fee % outputs;\n    const share = (fee - left) / outputs; // First pass, remove even shares.\n\n    for (const output of this.outputs) {\n      if (output.script.isUnspendable()) continue;\n      if (output.value < share + output.getDustThreshold()) throw new Error('Could not subtract fee.');\n      output.value -= share;\n    } // Second pass, remove the remainder\n    // for the one unlucky output.\n\n\n    for (const output of this.outputs) {\n      if (output.script.isUnspendable()) continue;\n\n      if (output.value >= left + output.getDustThreshold()) {\n        output.value -= left;\n        return;\n      }\n    }\n\n    throw new Error('Could not subtract fee.');\n  }\n  /**\n   * Select coins and fill the inputs.\n   * @param {Coin[]} coins\n   * @param {Object} options - See {@link MTX#selectCoins} options.\n   * @returns {CoinSelector}\n   */\n\n\n  async fund(coins, options) {\n    assert(options, 'Options are required.');\n    assert(options.changeAddress, 'Change address is required.');\n    assert(this.inputs.length === 0, 'TX is already funded.'); // Select necessary coins.\n\n    const select = await this.selectCoins(coins, options); // Add coins to transaction.\n\n    for (const coin of select.chosen) this.addCoin(coin); // Attempt to subtract fee.\n\n\n    if (select.subtractFee) {\n      const index = select.subtractIndex;\n      if (index !== -1) this.subtractIndex(index, select.fee);else this.subtractFee(select.fee);\n    } // Add a change output.\n\n\n    const output = new Output();\n    output.value = select.change;\n    output.script.fromAddress(select.changeAddress);\n\n    if (output.isDust(policy.MIN_RELAY)) {\n      // Do nothing. Change is added to fee.\n      this.changeIndex = -1;\n      assert.strictEqual(this.getFee(), select.fee + select.change);\n    } else {\n      this.outputs.push(output);\n      this.changeIndex = this.outputs.length - 1;\n      assert.strictEqual(this.getFee(), select.fee);\n    }\n\n    return select;\n  }\n  /**\n   * Sort inputs and outputs according to BIP69.\n   * @see https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki\n   */\n\n\n  sortMembers() {\n    let changeOutput = null;\n\n    if (this.changeIndex !== -1) {\n      changeOutput = this.outputs[this.changeIndex];\n      assert(changeOutput);\n    }\n\n    this.inputs.sort(sortInputs);\n    this.outputs.sort(sortOutputs);\n\n    if (this.changeIndex !== -1) {\n      this.changeIndex = this.outputs.indexOf(changeOutput);\n      assert(this.changeIndex !== -1);\n    }\n  }\n  /**\n   * Avoid fee sniping.\n   * @param {Number} - Current chain height.\n   * @see bitcoin/src/wallet/wallet.cpp\n   */\n\n\n  avoidFeeSniping(height) {\n    assert(typeof height === 'number', 'Must pass in height.');\n\n    if ((Math.random() * 10 | 0) === 0) {\n      height -= Math.random() * 100 | 0;\n      if (height < 0) height = 0;\n    }\n\n    this.setLocktime(height);\n  }\n  /**\n   * Set locktime and sequences appropriately.\n   * @param {Number} locktime\n   */\n\n\n  setLocktime(locktime) {\n    assert(locktime >>> 0 === locktime, 'Locktime must be a uint32.');\n    assert(this.inputs.length > 0, 'Cannot set sequence with no inputs.');\n\n    for (const input of this.inputs) {\n      if (input.sequence === 0xffffffff) input.sequence = 0xfffffffe;\n    }\n\n    this.locktime = locktime;\n  }\n  /**\n   * Set sequence locktime.\n   * @param {Number} index - Input index.\n   * @param {Number} locktime\n   * @param {Boolean?} seconds\n   */\n\n\n  setSequence(index, locktime, seconds) {\n    const input = this.inputs[index];\n    assert(input, 'Input does not exist.');\n    assert(locktime >>> 0 === locktime, 'Locktime must be a uint32.');\n    this.version = 2;\n\n    if (seconds) {\n      locktime >>>= consensus.SEQUENCE_GRANULARITY;\n      locktime &= consensus.SEQUENCE_MASK;\n      locktime |= consensus.SEQUENCE_TYPE_FLAG;\n    } else {\n      locktime &= consensus.SEQUENCE_MASK;\n    }\n\n    input.sequence = locktime;\n  }\n  /**\n   * Inspect the transaction.\n   * @returns {Object}\n   */\n\n\n  [inspectSymbol]() {\n    return this.format();\n  }\n  /**\n   * Inspect the transaction.\n   * @returns {Object}\n   */\n\n\n  format() {\n    return super.format(this.view);\n  }\n  /**\n   * Convert transaction to JSON.\n   * @returns {Object}\n   */\n\n\n  toJSON() {\n    return super.toJSON(null, this.view);\n  }\n  /**\n   * Convert transaction to JSON.\n   * @param {Network} network\n   * @returns {Object}\n   */\n\n\n  getJSON(network) {\n    return super.getJSON(network, this.view);\n  }\n  /**\n   * Inject properties from a json object\n   * @param {Object} json\n   */\n\n\n  fromJSON(json) {\n    super.fromJSON(json);\n\n    for (let i = 0; i < json.inputs.length; i++) {\n      const input = json.inputs[i];\n      const {\n        prevout\n      } = input;\n      if (!input.coin) continue;\n      const coin = Coin.fromJSON(input.coin);\n      coin.hash = util.fromRev(prevout.hash);\n      coin.index = prevout.index;\n      this.view.addCoin(coin);\n    }\n\n    return this;\n  }\n  /**\n   * Instantiate a transaction from a\n   * jsonified transaction object.\n   * @param {Object} json - The jsonified transaction object.\n   * @returns {MTX}\n   */\n\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n  /**\n   * Instantiate a transaction from a buffer reader.\n   * @param {BufferReader} br\n   * @returns {MTX}\n   */\n\n\n  static fromReader(br) {\n    return new this().fromReader(br);\n  }\n  /**\n   * Instantiate a transaction from a serialized Buffer.\n   * @param {Buffer} data\n   * @param {String?} enc - Encoding, can be `'hex'` or null.\n   * @returns {MTX}\n   */\n\n\n  static fromRaw(data, enc) {\n    if (typeof data === 'string') data = Buffer.from(data, enc);\n    return new this().fromRaw(data);\n  }\n  /**\n   * Convert the MTX to a TX.\n   * @returns {TX}\n   */\n\n\n  toTX() {\n    return new TX().inject(this);\n  }\n  /**\n   * Convert the MTX to a TX.\n   * @returns {Array} [tx, view]\n   */\n\n\n  commit() {\n    return [this.toTX(), this.view];\n  }\n  /**\n   * Instantiate MTX from TX.\n   * @param {TX} tx\n   * @returns {MTX}\n   */\n\n\n  static fromTX(tx) {\n    return new this().inject(tx);\n  }\n  /**\n   * Test whether an object is an MTX.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n\n  static isMTX(obj) {\n    return obj instanceof MTX;\n  }\n\n}\n/**\n * Coin Selector\n * @alias module:primitives.CoinSelector\n */\n\n\nclass CoinSelector {\n  /**\n   * Create a coin selector.\n   * @constructor\n   * @param {TX} tx\n   * @param {Object?} options\n   */\n  constructor(tx, options) {\n    this.tx = tx.clone();\n    this.coins = [];\n    this.outputValue = 0;\n    this.index = 0;\n    this.chosen = [];\n    this.change = 0;\n    this.fee = CoinSelector.MIN_FEE;\n    this.selection = 'value';\n    this.subtractFee = false;\n    this.subtractIndex = -1;\n    this.height = -1;\n    this.depth = -1;\n    this.hardFee = -1;\n    this.rate = CoinSelector.FEE_RATE;\n    this.maxFee = -1;\n    this.round = false;\n    this.changeAddress = null;\n    this.inputs = new BufferMap(); // Needed for size estimation.\n\n    this.estimate = null;\n    this.injectInputs();\n    if (options) this.fromOptions(options);\n  }\n  /**\n   * Initialize selector options.\n   * @param {Object} options\n   * @private\n   */\n\n\n  fromOptions(options) {\n    if (options.selection) {\n      assert(typeof options.selection === 'string');\n      this.selection = options.selection;\n    }\n\n    if (options.subtractFee != null) {\n      if (typeof options.subtractFee === 'number') {\n        assert(Number.isSafeInteger(options.subtractFee));\n        assert(options.subtractFee >= -1);\n        this.subtractIndex = options.subtractFee;\n        this.subtractFee = this.subtractIndex !== -1;\n      } else {\n        assert(typeof options.subtractFee === 'boolean');\n        this.subtractFee = options.subtractFee;\n      }\n    }\n\n    if (options.subtractIndex != null) {\n      assert(Number.isSafeInteger(options.subtractIndex));\n      assert(options.subtractIndex >= -1);\n      this.subtractIndex = options.subtractIndex;\n      this.subtractFee = this.subtractIndex !== -1;\n    }\n\n    if (options.height != null) {\n      assert(Number.isSafeInteger(options.height));\n      assert(options.height >= -1);\n      this.height = options.height;\n    }\n\n    if (options.confirmations != null) {\n      assert(Number.isSafeInteger(options.confirmations));\n      assert(options.confirmations >= -1);\n      this.depth = options.confirmations;\n    }\n\n    if (options.depth != null) {\n      assert(Number.isSafeInteger(options.depth));\n      assert(options.depth >= -1);\n      this.depth = options.depth;\n    }\n\n    if (options.hardFee != null) {\n      assert(Number.isSafeInteger(options.hardFee));\n      assert(options.hardFee >= -1);\n      this.hardFee = options.hardFee;\n    }\n\n    if (options.rate != null) {\n      assert(Number.isSafeInteger(options.rate));\n      assert(options.rate >= 0);\n      this.rate = options.rate;\n    }\n\n    if (options.maxFee != null) {\n      assert(Number.isSafeInteger(options.maxFee));\n      assert(options.maxFee >= -1);\n      this.maxFee = options.maxFee;\n    }\n\n    if (options.round != null) {\n      assert(typeof options.round === 'boolean');\n      this.round = options.round;\n    }\n\n    if (options.changeAddress) {\n      const addr = options.changeAddress;\n\n      if (typeof addr === 'string') {\n        this.changeAddress = Address.fromString(addr);\n      } else {\n        assert(addr instanceof Address);\n        this.changeAddress = addr;\n      }\n    }\n\n    if (options.estimate) {\n      assert(typeof options.estimate === 'function');\n      this.estimate = options.estimate;\n    }\n\n    if (options.inputs) {\n      assert(Array.isArray(options.inputs));\n\n      for (let i = 0; i < options.inputs.length; i++) {\n        const prevout = options.inputs[i];\n        assert(prevout && typeof prevout === 'object');\n        const {\n          hash,\n          index\n        } = prevout;\n        assert(Buffer.isBuffer(hash));\n        assert(typeof index === 'number');\n        this.inputs.set(Outpoint.toKey(hash, index), i);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Attempt to inject existing inputs.\n   * @private\n   */\n\n\n  injectInputs() {\n    if (this.tx.inputs.length > 0) {\n      for (let i = 0; i < this.tx.inputs.length; i++) {\n        const {\n          prevout\n        } = this.tx.inputs[i];\n        this.inputs.set(prevout.toKey(), i);\n      }\n    }\n  }\n  /**\n   * Initialize the selector with coins to select from.\n   * @param {Coin[]} coins\n   */\n\n\n  init(coins) {\n    this.coins = coins.slice();\n    this.outputValue = this.tx.getOutputValue();\n    this.index = 0;\n    this.chosen = [];\n    this.change = 0;\n    this.fee = CoinSelector.MIN_FEE;\n    this.tx.inputs.length = 0;\n\n    switch (this.selection) {\n      case 'all':\n      case 'random':\n        this.coins.sort(sortRandom);\n        break;\n\n      case 'age':\n        this.coins.sort(sortAge);\n        break;\n\n      case 'value':\n        this.coins.sort(sortValue);\n        break;\n\n      default:\n        throw new FundingError(`Bad selection type: ${this.selection}.`);\n    }\n  }\n  /**\n   * Calculate total value required.\n   * @returns {Amount}\n   */\n\n\n  total() {\n    if (this.subtractFee) return this.outputValue;\n    return this.outputValue + this.fee;\n  }\n  /**\n   * Test whether the selector has\n   * completely funded the transaction.\n   * @returns {Boolean}\n   */\n\n\n  isFull() {\n    return this.tx.getInputValue() >= this.total();\n  }\n  /**\n   * Test whether a coin is spendable\n   * with regards to the options.\n   * @param {Coin} coin\n   * @returns {Boolean}\n   */\n\n\n  isSpendable(coin) {\n    if (this.tx.view.hasEntry(coin)) return false;\n    if (this.height === -1) return true;\n\n    if (coin.coinbase) {\n      if (coin.height === -1) return false;\n      if (this.height + 1 < coin.height + consensus.COINBASE_MATURITY) return false;\n      return true;\n    }\n\n    if (this.depth === -1) return true;\n    const depth = coin.getDepth(this.height);\n    if (depth < this.depth) return false;\n    return true;\n  }\n  /**\n   * Get the current fee based on a size.\n   * @param {Number} size\n   * @returns {Amount}\n   */\n\n\n  getFee(size) {\n    // This is mostly here for testing.\n    // i.e. A fee rounded to the nearest\n    // kb is easier to predict ahead of time.\n    if (this.round) {\n      const fee = policy.getRoundFee(size, this.rate);\n      return Math.min(fee, CoinSelector.MAX_FEE);\n    }\n\n    const fee = policy.getMinFee(size, this.rate);\n    return Math.min(fee, CoinSelector.MAX_FEE);\n  }\n  /**\n   * Fund the transaction with more\n   * coins if the `output value + fee`\n   * total was updated.\n   */\n\n\n  fund() {\n    // Ensure all preferred inputs first.\n    if (this.inputs.size > 0) {\n      const coins = [];\n\n      for (let i = 0; i < this.inputs.size; i++) coins.push(null);\n\n      for (const coin of this.coins) {\n        const {\n          hash,\n          index\n        } = coin;\n        const key = Outpoint.toKey(hash, index);\n        const i = this.inputs.get(key);\n\n        if (i != null) {\n          coins[i] = coin;\n          this.inputs.delete(key);\n        }\n      }\n\n      if (this.inputs.size > 0) throw new Error('Could not resolve preferred inputs.');\n\n      for (const coin of coins) {\n        this.tx.addCoin(coin);\n        this.chosen.push(coin);\n      }\n    }\n\n    while (this.index < this.coins.length) {\n      const coin = this.coins[this.index++];\n      if (!this.isSpendable(coin)) continue;\n      this.tx.addCoin(coin);\n      this.chosen.push(coin);\n      if (this.selection === 'all') continue;\n      if (this.isFull()) break;\n    }\n  }\n  /**\n   * Initiate selection from `coins`.\n   * @param {Coin[]} coins\n   * @returns {CoinSelector}\n   */\n\n\n  async select(coins) {\n    this.init(coins);\n\n    if (this.hardFee !== -1) {\n      this.selectHard();\n    } else {\n      // This is potentially asynchronous:\n      // it may invoke the size estimator\n      // required for redeem scripts (we\n      // may be calling out to a wallet\n      // or something similar).\n      await this.selectEstimate();\n    }\n\n    if (!this.isFull()) {\n      // Still failing to get enough funds.\n      throw new FundingError('Not enough funds.', this.tx.getInputValue(), this.total());\n    } // How much money is left after filling outputs.\n\n\n    this.change = this.tx.getInputValue() - this.total();\n    return this;\n  }\n  /**\n   * Initialize selection based on size estimate.\n   */\n\n\n  async selectEstimate() {\n    // Set minimum fee and do\n    // an initial round of funding.\n    this.fee = CoinSelector.MIN_FEE;\n    this.fund(); // Add dummy output for change.\n\n    const change = new Output();\n\n    if (this.changeAddress) {\n      change.script.fromAddress(this.changeAddress);\n    } else {\n      // In case we don't have a change address,\n      // we use a fake p2pkh output to gauge size.\n      change.script.fromPubkeyhash(Buffer.allocUnsafe(20));\n    }\n\n    this.tx.outputs.push(change); // Keep recalculating the fee and funding\n    // until we reach some sort of equilibrium.\n\n    do {\n      const size = await this.tx.estimateSize(this.estimate);\n      this.fee = this.getFee(size);\n      if (this.maxFee > 0 && this.fee > this.maxFee) throw new FundingError('Fee is too high.'); // Failed to get enough funds, add more coins.\n\n      if (!this.isFull()) this.fund();\n    } while (!this.isFull() && this.index < this.coins.length);\n  }\n  /**\n   * Initiate selection based on a hard fee.\n   */\n\n\n  selectHard() {\n    this.fee = Math.min(this.hardFee, CoinSelector.MAX_FEE);\n    this.fund();\n  }\n\n}\n/**\n * Default fee rate\n * for coin selection.\n * @const {Amount}\n * @default\n */\n\n\nCoinSelector.FEE_RATE = 10000;\n/**\n * Minimum fee to start with\n * during coin selection.\n * @const {Amount}\n * @default\n */\n\nCoinSelector.MIN_FEE = 10000;\n/**\n * Maximum fee to allow\n * after coin selection.\n * @const {Amount}\n * @default\n */\n\nCoinSelector.MAX_FEE = consensus.COIN / 10;\n/**\n * Funding Error\n * An error thrown from the coin selector.\n * @ignore\n * @extends Error\n * @property {String} message - Error message.\n * @property {Amount} availableFunds\n * @property {Amount} requiredFunds\n */\n\nclass FundingError extends Error {\n  /**\n   * Create a funding error.\n   * @constructor\n   * @param {String} msg\n   * @param {Amount} available\n   * @param {Amount} required\n   */\n  constructor(msg, available, required) {\n    super();\n    this.type = 'FundingError';\n    this.message = msg;\n    this.availableFunds = -1;\n    this.requiredFunds = -1;\n\n    if (available != null) {\n      this.message += ` (available=${Amount.btc(available)},`;\n      this.message += ` required=${Amount.btc(required)})`;\n      this.availableFunds = available;\n      this.requiredFunds = required;\n    }\n\n    if (Error.captureStackTrace) Error.captureStackTrace(this, FundingError);\n  }\n\n}\n/*\n * Helpers\n */\n\n\nfunction sortAge(a, b) {\n  a = a.height === -1 ? 0x7fffffff : a.height;\n  b = b.height === -1 ? 0x7fffffff : b.height;\n  return a - b;\n}\n\nfunction sortRandom(a, b) {\n  return Math.random() > 0.5 ? 1 : -1;\n}\n\nfunction sortValue(a, b) {\n  if (a.height === -1 && b.height !== -1) return 1;\n  if (a.height !== -1 && b.height === -1) return -1;\n  return b.value - a.value;\n}\n\nfunction sortInputs(a, b) {\n  return a.compare(b);\n}\n\nfunction sortOutputs(a, b) {\n  return a.compare(b);\n}\n/*\n * Expose\n */\n\n\nexports = MTX;\nexports.MTX = MTX;\nexports.Selector = CoinSelector;\nexports.FundingError = FundingError;\nmodule.exports = exports;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/primitives/mtx.js"],"names":["assert","require","encoding","BufferMap","Script","TX","Input","Output","Coin","Outpoint","CoinView","Address","consensus","policy","Amount","Stack","util","inspectSymbol","MTX","constructor","options","mutable","changeIndex","view","fromOptions","version","inputs","Array","isArray","input","addInput","outputs","output","addOutput","locktime","clone","mtx","inject","push","addOutpoint","outpoint","prevout","fromOutpoint","addCoin","coin","fromCoin","addTX","tx","index","height","fromTX","addIndex","script","value","fromScript","check","flags","checkAsync","pool","verify","e","type","verifyAsync","getFee","getInputValue","getInputAddresses","getAddresses","getInputHashes","enc","getHashes","hasCoins","getSigops","getSigopsCount","verifyInputs","fee","checkInputs","scriptInput","ring","raw","length","prev","sh","getScripthash","redeem","getRedeem","vector","scriptVector","toRaw","fromStack","pk","getPubkey","equals","publicKey","stack","pushInt","pkh","getPubkeyhash","getKeyHash","pushData","n","getMultisig","indexOf","i","signInputAsync","signInput","key","privateKey","hashType","ALL","SIGHASH_FORKID","VERIFY_SIGHASH_FORKID","isScripthash","Error","sig","signature","toStack","pop","result","signVector","get","set","m","total","item","keys","op","code","data","keyIndex","remove","isSigned","getOutput","isInputSigned","isVectorSigned","isPubkey","isPubkeyhash","template","ownOutput","sign","signAsync","estimateSize","estimate","sizeVarint","getSize","size","selectCoins","coins","selector","CoinSelector","select","subtractIndex","getDustThreshold","subtractFee","isUnspendable","left","share","fund","changeAddress","chosen","change","fromAddress","isDust","MIN_RELAY","strictEqual","sortMembers","changeOutput","sort","sortInputs","sortOutputs","avoidFeeSniping","Math","random","setLocktime","sequence","setSequence","seconds","SEQUENCE_GRANULARITY","SEQUENCE_MASK","SEQUENCE_TYPE_FLAG","format","toJSON","getJSON","network","fromJSON","json","hash","fromRev","fromReader","br","fromRaw","Buffer","from","toTX","commit","isMTX","obj","outputValue","MIN_FEE","selection","depth","hardFee","rate","FEE_RATE","maxFee","round","injectInputs","Number","isSafeInteger","confirmations","addr","fromString","isBuffer","toKey","init","slice","getOutputValue","sortRandom","sortAge","sortValue","FundingError","isFull","isSpendable","hasEntry","coinbase","COINBASE_MATURITY","getDepth","getRoundFee","min","MAX_FEE","getMinFee","delete","selectHard","selectEstimate","fromPubkeyhash","allocUnsafe","COIN","msg","available","required","message","availableFunds","requiredFunds","btc","captureStackTrace","a","b","compare","exports","Selector","module"],"mappings":"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","sourcesContent":["/*!\n * mtx.js - mutable transaction object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst {encoding} = require('bufio');\nconst {BufferMap} = require('buffer-map');\nconst Script = require('../script/script');\nconst TX = require('./tx');\nconst Input = require('./input');\nconst Output = require('./output');\nconst Coin = require('./coin');\nconst Outpoint = require('./outpoint');\nconst CoinView = require('../coins/coinview');\nconst Address = require('./address');\nconst consensus = require('../protocol/consensus');\nconst policy = require('../protocol/policy');\nconst Amount = require('../btc/amount');\nconst Stack = require('../script/stack');\nconst util = require('../utils/util');\nconst {inspectSymbol} = require('../utils');\n\n/**\n * MTX\n * A mutable transaction object.\n * @alias module:primitives.MTX\n * @extends TX\n * @property {Number} changeIndex\n * @property {CoinView} view\n */\n\nclass MTX extends TX {\n  /**\n   * Create a mutable transaction.\n   * @alias module:primitives.MTX\n   * @constructor\n   * @param {Object} options\n   */\n\n  constructor(options) {\n    super();\n\n    this.mutable = true;\n    this.changeIndex = -1;\n    this.view = new CoinView();\n\n    if (options)\n      this.fromOptions(options);\n  }\n\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n  fromOptions(options) {\n    if (options.version != null) {\n      assert((options.version >>> 0) === options.version,\n        'Version must a be uint32.');\n      this.version = options.version;\n    }\n\n    if (options.inputs) {\n      assert(Array.isArray(options.inputs), 'Inputs must be an array.');\n      for (const input of options.inputs)\n        this.addInput(input);\n    }\n\n    if (options.outputs) {\n      assert(Array.isArray(options.outputs), 'Outputs must be an array.');\n      for (const output of options.outputs)\n        this.addOutput(output);\n    }\n\n    if (options.locktime != null) {\n      assert((options.locktime >>> 0) === options.locktime,\n        'Locktime must be a uint32.');\n      this.locktime = options.locktime;\n    }\n\n    if (options.changeIndex != null) {\n      if (options.changeIndex !== -1) {\n        assert((options.changeIndex >>> 0) === options.changeIndex,\n          'Change index must be a uint32.');\n        this.changeIndex = options.changeIndex;\n      } else {\n        this.changeIndex = -1;\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Instantiate MTX from options.\n   * @param {Object} options\n   * @returns {MTX}\n   */\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n\n  /**\n   * Clone the transaction. Note that\n   * this will not carry over the view.\n   * @returns {MTX}\n   */\n\n  clone() {\n    const mtx = new this.constructor();\n    mtx.inject(this);\n    mtx.changeIndex = this.changeIndex;\n    return mtx;\n  }\n\n  /**\n   * Add an input to the transaction.\n   * @param {Input|Object} options\n   * @returns {Input}\n   *\n   * @example\n   * mtx.addInput({ prevout: { hash: ... }, script: ... });\n   * mtx.addInput(new Input());\n   */\n\n  addInput(options) {\n    const input = Input.fromOptions(options);\n    this.inputs.push(input);\n    return input;\n  }\n\n  /**\n   * Add an outpoint as an input.\n   * @param {Outpoint|Object} outpoint\n   * @returns {Input}\n   *\n   * @example\n   * mtx.addOutpoint({ hash: ..., index: 0 });\n   * mtx.addOutpoint(new Outpoint(hash, index));\n   */\n\n  addOutpoint(outpoint) {\n    const prevout = Outpoint.fromOptions(outpoint);\n    const input = Input.fromOutpoint(prevout);\n    this.inputs.push(input);\n    return input;\n  }\n\n  /**\n   * Add a coin as an input. Note that this will\n   * add the coin to the internal coin viewpoint.\n   * @param {Coin} coin\n   * @returns {Input}\n   *\n   * @example\n   * mtx.addCoin(Coin.fromTX(tx, 0, -1));\n   */\n\n  addCoin(coin) {\n    assert(coin instanceof Coin, 'Cannot add non-coin.');\n\n    const input = Input.fromCoin(coin);\n\n    this.inputs.push(input);\n    this.view.addCoin(coin);\n\n    return input;\n  }\n\n  /**\n   * Add a transaction as an input. Note that\n   * this will add the coin to the internal\n   * coin viewpoint.\n   * @param {TX} tx\n   * @param {Number} index\n   * @param {Number?} height\n   * @returns {Input}\n   *\n   * @example\n   * mtx.addTX(tx, 0);\n   */\n\n  addTX(tx, index, height) {\n    assert(tx instanceof TX, 'Cannot add non-transaction.');\n\n    if (height == null)\n      height = -1;\n\n    const input = Input.fromTX(tx, index);\n\n    this.inputs.push(input);\n\n    this.view.addIndex(tx, index, height);\n\n    return input;\n  }\n\n  /**\n   * Add an output.\n   * @param {Address|Script|Output|Object} script - Script or output options.\n   * @param {Amount?} value\n   * @returns {Output}\n   *\n   * @example\n   * mtx.addOutput(new Output());\n   * mtx.addOutput({ address: ..., value: 100000 });\n   * mtx.addOutput(address, 100000);\n   * mtx.addOutput(script, 100000);\n   */\n\n  addOutput(script, value) {\n    let output;\n\n    if (value != null)\n      output = Output.fromScript(script, value);\n    else\n      output = Output.fromOptions(script);\n\n    this.outputs.push(output);\n\n    return output;\n  }\n\n  /**\n   * Verify all transaction inputs.\n   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n   * @returns {Boolean} Whether the inputs are valid.\n   * @throws {ScriptError} on invalid inputs\n   */\n\n  check(flags) {\n    return super.check(this.view, flags);\n  }\n\n  /**\n   * Verify the transaction inputs on the worker pool\n   * (if workers are enabled).\n   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n   * @param {WorkerPool?} pool\n   * @returns {Promise}\n   */\n\n  checkAsync(flags, pool) {\n    return super.checkAsync(this.view, flags, pool);\n  }\n\n  /**\n   * Verify all transaction inputs.\n   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n   * @returns {Boolean} Whether the inputs are valid.\n   */\n\n  verify(flags) {\n    try {\n      this.check(flags);\n    } catch (e) {\n      if (e.type === 'ScriptError')\n        return false;\n      throw e;\n    }\n    return true;\n  }\n\n  /**\n   * Verify the transaction inputs on the worker pool\n   * (if workers are enabled).\n   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n   * @param {WorkerPool?} pool\n   * @returns {Promise}\n   */\n\n  async verifyAsync(flags, pool) {\n    try {\n      await this.checkAsync(flags, pool);\n    } catch (e) {\n      if (e.type === 'ScriptError')\n        return false;\n      throw e;\n    }\n    return true;\n  }\n\n  /**\n   * Calculate the fee for the transaction.\n   * @returns {Amount} fee (zero if not all coins are available).\n   */\n\n  getFee() {\n    return super.getFee(this.view);\n  }\n\n  /**\n   * Calculate the total input value.\n   * @returns {Amount} value\n   */\n\n  getInputValue() {\n    return super.getInputValue(this.view);\n  }\n\n  /**\n   * Get all input addresses.\n   * @returns {Address[]} addresses\n   */\n\n  getInputAddresses() {\n    return super.getInputAddresses(this.view);\n  }\n\n  /**\n   * Get all addresses.\n   * @returns {Address[]} addresses\n   */\n\n  getAddresses() {\n    return super.getAddresses(this.view);\n  }\n\n  /**\n   * Get all input address hashes.\n   * @returns {Hash[]} hashes\n   */\n\n  getInputHashes(enc) {\n    return super.getInputHashes(this.view, enc);\n  }\n\n  /**\n   * Get all address hashes.\n   * @returns {Hash[]} hashes\n   */\n\n  getHashes(enc) {\n    return super.getHashes(this.view, enc);\n  }\n\n  /**\n   * Test whether the transaction has\n   * all coins available/filled.\n   * @returns {Boolean}\n   */\n\n  hasCoins() {\n    return super.hasCoins(this.view);\n  }\n\n  /**\n   * Calculate virtual sigop count.\n   * @param {VerifyFlags?} flags\n   * @returns {Number} sigop count\n   */\n\n  getSigops(flags) {\n    return super.getSigops(this.view, flags);\n  }\n\n  /**\n   *  Calculate sigops count.\n   *  @param {CoinView} view\n   *  @param {VerifyFlags?} flags\n   *  @returns {Number} sigop count\n   */\n\n  getSigopsCount(flags) {\n    return super.getSigopsCount(this.view, flags);\n  }\n\n  /**\n   * Perform contextual checks to verify input, output,\n   * and fee values, as well as coinbase spend maturity\n   * (coinbases can only be spent 100 blocks or more\n   * after they're created). Note that this function is\n   * consensus critical.\n   * @param {Number} height - Height at which the\n   * transaction is being spent. In the mempool this is\n   * the chain height plus one at the time it entered the pool.\n   * @returns {Boolean}\n   */\n\n  verifyInputs(height) {\n    const [fee] = this.checkInputs(height);\n    return fee !== -1;\n  }\n\n  /**\n   * Perform contextual checks to verify input, output,\n   * and fee values, as well as coinbase spend maturity\n   * (coinbases can only be spent 100 blocks or more\n   * after they're created). Note that this function is\n   * consensus critical.\n   * @param {Number} height - Height at which the\n   * transaction is being spent. In the mempool this is\n   * the chain height plus one at the time it entered the pool.\n   * @returns {Array} [fee, reason, score]\n   */\n\n  checkInputs(height) {\n    return super.checkInputs(this.view, height);\n  }\n\n  /**\n   * Build input script (or witness) templates (with\n   * OP_0 in place of signatures).\n   * @param {Number} index - Input index.\n   * @param {Coin|Output} coin\n   * @param {KeyRing} ring\n   * @returns {Boolean} Whether the script was able to be built.\n   */\n\n  scriptInput(index, coin, ring) {\n    const input = this.inputs[index];\n\n    assert(input, 'Input does not exist.');\n    assert(coin, 'No coin passed.');\n\n    // Don't bother with any below calculation\n    // if the output is already templated.\n    if (input.script.raw.length !== 0)\n      return true;\n\n    // Get the previous output's script\n    const prev = coin.script;\n\n    // This is easily the hardest part about\n    // building a transaction with segwit:\n    // figuring out where the redeem script\n    // and witness redeem scripts go.\n    const sh = prev.getScripthash();\n\n    if (sh) {\n      const redeem = ring.getRedeem(sh);\n\n      if (!redeem)\n        return false;\n\n      // Regular P2SH.\n      const vector = this.scriptVector(redeem, ring);\n\n      if (!vector)\n        return false;\n\n      vector.push(redeem.toRaw());\n\n      input.script.fromStack(vector);\n\n      return true;\n    }\n\n    const vector = this.scriptVector(prev, ring);\n\n    if (!vector)\n      return false;\n\n    input.script.fromStack(vector);\n\n    return true;\n  }\n\n  /**\n   * Build script for a single vector\n   * based on a previous script.\n   * @param {Script} prev\n   * @param {Buffer} ring\n   * @return {Stack}\n   */\n\n  scriptVector(prev, ring) {\n    // P2PK\n    const pk = prev.getPubkey();\n    if (pk) {\n      if (!pk.equals(ring.publicKey))\n        return null;\n\n      const stack = new Stack();\n\n      stack.pushInt(0);\n\n      return stack;\n    }\n\n    // P2PKH\n    const pkh = prev.getPubkeyhash();\n    if (pkh) {\n      if (!pkh.equals(ring.getKeyHash()))\n        return null;\n\n      const stack = new Stack();\n\n      stack.pushInt(0);\n      stack.pushData(ring.publicKey);\n\n      return stack;\n    }\n\n    // Multisig\n    const [, n] = prev.getMultisig();\n    if (n !== -1) {\n      if (prev.indexOf(ring.publicKey) === -1)\n        return null;\n\n      // Technically we should create m signature slots,\n      // but we create n signature slots so we can order\n      // the signatures properly.\n      const stack = new Stack();\n\n      stack.pushInt(0);\n\n      // Fill script with `n` signature slots.\n      for (let i = 0; i < n; i++)\n        stack.pushInt(0);\n\n      return stack;\n    }\n\n    return null;\n  }\n\n  /**\n   * Sign a transaction input on the worker pool\n   * (if workers are enabled).\n   * @param {Number} index\n   * @param {Coin|Output} coin\n   * @param {KeyRing} ring\n   * @param {SighashType?} type\n   * @param {WorkerPool?} pool\n   * @returns {Promise}\n   */\n\n  async signInputAsync(index, coin, ring, type, pool) {\n    if (!pool)\n      return this.signInput(index, coin, ring, type);\n\n    return await pool.signInput(this, index, coin, ring, type, pool);\n  }\n\n  /**\n   * Sign an input.\n   * @param {Number} index - Index of input being signed.\n   * @param {Coin|Output} coin\n   * @param {KeyRing} ring - Private key.\n   * @param {SighashType} type\n   * @returns {Boolean} Whether the input was able to be signed.\n   */\n\n  signInput(index, coin, ring, type) {\n    const input = this.inputs[index];\n    const key = ring.privateKey;\n\n    assert(input, 'Input does not exist.');\n    assert(coin, 'No coin passed.');\n\n    // Get the previous output's script\n    const value = coin.value;\n    let prev = coin.script;\n    const vector = input.script;\n    let redeem = false;\n\n    if (type == null)\n      type = Script.hashType.ALL;\n\n    type |= Script.hashType.SIGHASH_FORKID;\n    const flags = Script.flags.VERIFY_SIGHASH_FORKID;\n\n    // Grab regular p2sh redeem script.\n    if (prev.isScripthash()) {\n      prev = input.script.getRedeem();\n      if (!prev)\n        throw new Error('Input has not been templated.');\n      redeem = true;\n    }\n\n    // Create our signature.\n    const sig = this.signature(index, prev, value, key, type, flags);\n\n    if (redeem) {\n      const stack = vector.toStack();\n      const redeem = stack.pop();\n\n      const result = this.signVector(prev, stack, sig, ring);\n\n      if (!result)\n        return false;\n\n      result.push(redeem);\n\n      vector.fromStack(result);\n\n      return true;\n    }\n\n    const stack = vector.toStack();\n    const result = this.signVector(prev, stack, sig, ring);\n\n    if (!result)\n      return false;\n\n    vector.fromStack(result);\n\n    return true;\n  }\n\n  /**\n   * Add a signature to a vector\n   * based on a previous script.\n   * @param {Script} prev\n   * @param {Stack} vector\n   * @param {Buffer} sig\n   * @param {KeyRing} ring\n   * @return {Boolean}\n   */\n\n  signVector(prev, vector, sig, ring) {\n    // P2PK\n    const pk = prev.getPubkey();\n    if (pk) {\n      // Make sure the pubkey is ours.\n      if (!ring.publicKey.equals(pk))\n        return null;\n\n      if (vector.length === 0)\n        throw new Error('Input has not been templated.');\n\n      // Already signed.\n      if (vector.get(0).length > 0)\n        return vector;\n\n      vector.set(0, sig);\n\n      return vector;\n    }\n\n    // P2PKH\n    const pkh = prev.getPubkeyhash();\n    if (pkh) {\n      // Make sure the pubkey hash is ours.\n      if (!ring.getKeyHash().equals(pkh))\n        return null;\n\n      if (vector.length !== 2)\n        throw new Error('Input has not been templated.');\n\n      if (vector.get(1).length === 0)\n        throw new Error('Input has not been templated.');\n\n      // Already signed.\n      if (vector.get(0).length > 0)\n        return vector;\n\n      vector.set(0, sig);\n\n      return vector;\n    }\n\n    // Multisig\n    const [m, n] = prev.getMultisig();\n    if (m !== -1) {\n      if (vector.length < 2)\n        throw new Error('Input has not been templated.');\n\n      if (vector.get(0).length !== 0)\n        throw new Error('Input has not been templated.');\n\n      // Too many signature slots. Abort.\n      if (vector.length - 1 > n)\n        throw new Error('Input has not been templated.');\n\n      // Count the number of current signatures.\n      let total = 0;\n      for (let i = 1; i < vector.length; i++) {\n        const item = vector.get(i);\n        if (item.length > 0)\n          total += 1;\n      }\n\n      // Signatures are already finalized.\n      if (total === m && vector.length - 1 === m)\n        return vector;\n\n      // Add some signature slots for us to use if\n      // there was for some reason not enough.\n      while (vector.length - 1 < n)\n        vector.pushInt(0);\n\n      // Grab the redeem script's keys to figure\n      // out where our key should go.\n      const keys = [];\n      for (const op of prev.code) {\n        if (op.data)\n          keys.push(op.data);\n      }\n\n      // Find the key index so we can place\n      // the signature in the same index.\n      let keyIndex = -1;\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if (key.equals(ring.publicKey)) {\n          keyIndex = i;\n          break;\n        }\n      }\n\n      // Our public key is not in the prev_out\n      // script. We tried to sign a transaction\n      // that is not redeemable by us.\n      if (keyIndex === -1)\n        return null;\n\n      // Offset key index by one to turn it into\n      // \"sig index\". Accounts for OP_0 byte at\n      // the start.\n      keyIndex += 1;\n\n      // Add our signature to the correct slot\n      // and increment the total number of\n      // signatures.\n      if (keyIndex < vector.length && total < m) {\n        if (vector.get(keyIndex).length === 0) {\n          vector.set(keyIndex, sig);\n          total += 1;\n        }\n      }\n\n      // All signatures added. Finalize.\n      if (total >= m) {\n        // Remove empty slots left over.\n        for (let i = vector.length - 1; i >= 1; i--) {\n          const item = vector.get(i);\n          if (item.length === 0)\n            vector.remove(i);\n        }\n\n        // Remove signatures which are not required.\n        // This should never happen.\n        while (total > m) {\n          vector.pop();\n          total -= 1;\n        }\n\n        // Sanity checks.\n        assert(total === m);\n        assert(vector.length - 1 === m);\n      }\n\n      return vector;\n    }\n\n    return null;\n  }\n\n  /**\n   * Test whether the transaction is fully-signed.\n   * @returns {Boolean}\n   */\n\n  isSigned() {\n    for (let i = 0; i < this.inputs.length; i++) {\n      const {prevout} = this.inputs[i];\n      const coin = this.view.getOutput(prevout);\n\n      if (!coin)\n        return false;\n\n      if (!this.isInputSigned(i, coin))\n        return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Test whether an input is fully-signed.\n   * @param {Number} index\n   * @param {Coin|Output} coin\n   * @returns {Boolean}\n   */\n\n  isInputSigned(index, coin) {\n    const input = this.inputs[index];\n\n    assert(input, 'Input does not exist.');\n    assert(coin, 'No coin passed.');\n\n    const vector = input.script;\n    let prev = coin.script;\n    let redeem = false;\n\n    // Grab redeem script if possible.\n    if (prev.isScripthash()) {\n      prev = input.script.getRedeem();\n      if (!prev)\n        return false;\n      redeem = true;\n    }\n\n    const stack = vector.toStack();\n\n    if (redeem)\n      stack.pop();\n\n    return this.isVectorSigned(prev, stack);\n  }\n\n  /**\n   * Test whether a vector is fully-signed.\n   * @param {Script} prev\n   * @param {Stack} vector\n   * @returns {Boolean}\n   */\n\n  isVectorSigned(prev, vector) {\n    if (prev.isPubkey()) {\n      if (vector.length !== 1)\n        return false;\n\n      if (vector.get(0).length === 0)\n        return false;\n\n      return true;\n    }\n\n    if (prev.isPubkeyhash()) {\n      if (vector.length !== 2)\n        return false;\n\n      if (vector.get(0).length === 0)\n        return false;\n\n      if (vector.get(1).length === 0)\n        return false;\n\n      return true;\n    }\n\n    const [m] = prev.getMultisig();\n\n    if (m !== -1) {\n      // Ensure we have the correct number\n      // of required signatures.\n      if (vector.length - 1 !== m)\n        return false;\n\n      // Ensure all members are signatures.\n      for (let i = 1; i < vector.length; i++) {\n        const item = vector.get(i);\n        if (item.length === 0)\n          return false;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Build input scripts (or witnesses).\n   * @param {KeyRing} ring - Address used to sign. The address\n   * must be able to redeem the coin.\n   * @returns {Number} Number of inputs templated.\n   */\n\n  template(ring) {\n    if (Array.isArray(ring)) {\n      let total = 0;\n      for (const key of ring)\n        total += this.template(key);\n      return total;\n    }\n\n    let total = 0;\n\n    for (let i = 0; i < this.inputs.length; i++) {\n      const {prevout} = this.inputs[i];\n      const coin = this.view.getOutput(prevout);\n\n      if (!coin)\n        continue;\n\n      if (!ring.ownOutput(coin))\n        continue;\n\n      // Build script for input\n      if (!this.scriptInput(i, coin, ring))\n        continue;\n\n      total += 1;\n    }\n\n    return total;\n  }\n\n  /**\n   * Built input scripts (or witnesses) and sign the inputs.\n   * @param {KeyRing} ring - Address used to sign. The address\n   * must be able to redeem the coin.\n   * @param {SighashType} type\n   * @returns {Number} Number of inputs signed.\n   */\n\n  sign(ring, type) {\n    if (Array.isArray(ring)) {\n      let total = 0;\n      for (const key of ring)\n        total += this.sign(key, type);\n      return total;\n    }\n\n    assert(ring.privateKey, 'No private key available.');\n\n    let total = 0;\n\n    for (let i = 0; i < this.inputs.length; i++) {\n      const {prevout} = this.inputs[i];\n      const coin = this.view.getOutput(prevout);\n\n      if (!coin)\n        continue;\n\n      if (!ring.ownOutput(coin))\n        continue;\n\n      // Build script for input\n      if (!this.scriptInput(i, coin, ring))\n        continue;\n\n      // Sign input\n      if (!this.signInput(i, coin, ring, type))\n        continue;\n\n      total += 1;\n    }\n\n    return total;\n  }\n\n  /**\n   * Sign the transaction inputs on the worker pool\n   * (if workers are enabled).\n   * @param {KeyRing} ring\n   * @param {SighashType?} type\n   * @param {WorkerPool?} pool\n   * @returns {Promise}\n   */\n\n  async signAsync(ring, type, pool) {\n    if (!pool)\n      return this.sign(ring, type);\n\n    return await pool.sign(this, ring, type);\n  }\n\n  /**\n   * Estimate maximum possible size.\n   * @param {Function?} estimate - Input script size estimator.\n   * @returns {Number}\n   */\n\n  async estimateSize(estimate) {\n    let total = 0;\n\n    // Calculate the size, minus the input scripts.\n    total += 4;\n    total += encoding.sizeVarint(this.inputs.length);\n    total += this.inputs.length * 40;\n\n    total += encoding.sizeVarint(this.outputs.length);\n\n    for (const output of this.outputs)\n      total += output.getSize();\n\n    total += 4;\n\n    // Add size for signatures and public keys\n    for (const {prevout} of this.inputs) {\n      const coin = this.view.getOutput(prevout);\n\n      // We're out of luck here.\n      // Just assume it's a p2pkh.\n      if (!coin) {\n        total += 110;\n        continue;\n      }\n\n      // Previous output script.\n      const prev = coin.script;\n\n      // P2PK\n      if (prev.isPubkey()) {\n        // varint script size\n        total += 1;\n        // OP_PUSHDATA0 [signature]\n        total += 1 + 73;\n        continue;\n      }\n\n      // P2PKH\n      if (prev.isPubkeyhash()) {\n        // varint script size\n        total += 1;\n        // OP_PUSHDATA0 [signature]\n        total += 1 + 73;\n        // OP_PUSHDATA0 [key]\n        total += 1 + 33;\n        continue;\n      }\n\n      const [m] = prev.getMultisig();\n      if (m !== -1) {\n        let size = 0;\n        // Bare Multisig\n        // OP_0\n        size += 1;\n        // OP_PUSHDATA0 [signature] ...\n        size += (1 + 73) * m;\n        // varint len\n        size += encoding.sizeVarint(size);\n        total += size;\n        continue;\n      }\n\n      // Call out to the custom estimator.\n      if (estimate) {\n        const size = await estimate(prev);\n        if (size !== -1) {\n          total += size;\n          continue;\n        }\n      }\n\n      // P2SH\n      if (prev.isScripthash()) {\n        // varint size\n        total += 1;\n        // 2-of-3 multisig input\n        total += 149;\n        continue;\n      }\n\n      // Unknown.\n      total += 110;\n    }\n\n    return total;\n  }\n\n  /**\n   * Select necessary coins based on total output value.\n   * @param {Coin[]} coins\n   * @param {Object?} options\n   * @returns {CoinSelection}\n   * @throws on not enough funds available.\n   */\n\n  selectCoins(coins, options) {\n    const selector = new CoinSelector(this, options);\n    return selector.select(coins);\n  }\n\n  /**\n   * Attempt to subtract a fee from a single output.\n   * @param {Number} index\n   * @param {Amount} fee\n   */\n\n  subtractIndex(index, fee) {\n    assert(typeof index === 'number');\n    assert(typeof fee === 'number');\n\n    const output = this.outputs[index];\n\n    if (!output)\n      throw new Error('Subtraction index does not exist.');\n\n    if (output.value < fee + output.getDustThreshold())\n      throw new Error('Could not subtract fee.');\n\n    output.value -= fee;\n  }\n\n  /**\n   * Attempt to subtract a fee from all outputs evenly.\n   * @param {Amount} fee\n   */\n\n  subtractFee(fee) {\n    assert(typeof fee === 'number');\n\n    let outputs = 0;\n\n    for (const output of this.outputs) {\n      // Ignore nulldatas and\n      // other OP_RETURN scripts.\n      if (output.script.isUnspendable())\n        continue;\n      outputs += 1;\n    }\n\n    if (outputs === 0)\n      throw new Error('Could not subtract fee.');\n\n    const left = fee % outputs;\n    const share = (fee - left) / outputs;\n\n    // First pass, remove even shares.\n    for (const output of this.outputs) {\n      if (output.script.isUnspendable())\n        continue;\n\n      if (output.value < share + output.getDustThreshold())\n        throw new Error('Could not subtract fee.');\n\n      output.value -= share;\n    }\n\n    // Second pass, remove the remainder\n    // for the one unlucky output.\n    for (const output of this.outputs) {\n      if (output.script.isUnspendable())\n        continue;\n\n      if (output.value >= left + output.getDustThreshold()) {\n        output.value -= left;\n        return;\n      }\n    }\n\n    throw new Error('Could not subtract fee.');\n  }\n\n  /**\n   * Select coins and fill the inputs.\n   * @param {Coin[]} coins\n   * @param {Object} options - See {@link MTX#selectCoins} options.\n   * @returns {CoinSelector}\n   */\n\n  async fund(coins, options) {\n    assert(options, 'Options are required.');\n    assert(options.changeAddress, 'Change address is required.');\n    assert(this.inputs.length === 0, 'TX is already funded.');\n\n    // Select necessary coins.\n    const select = await this.selectCoins(coins, options);\n\n    // Add coins to transaction.\n    for (const coin of select.chosen)\n      this.addCoin(coin);\n\n    // Attempt to subtract fee.\n    if (select.subtractFee) {\n      const index = select.subtractIndex;\n      if (index !== -1)\n        this.subtractIndex(index, select.fee);\n      else\n        this.subtractFee(select.fee);\n    }\n\n    // Add a change output.\n    const output = new Output();\n    output.value = select.change;\n    output.script.fromAddress(select.changeAddress);\n\n    if (output.isDust(policy.MIN_RELAY)) {\n      // Do nothing. Change is added to fee.\n      this.changeIndex = -1;\n      assert.strictEqual(this.getFee(), select.fee + select.change);\n    } else {\n      this.outputs.push(output);\n      this.changeIndex = this.outputs.length - 1;\n      assert.strictEqual(this.getFee(), select.fee);\n    }\n\n    return select;\n  }\n\n  /**\n   * Sort inputs and outputs according to BIP69.\n   * @see https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki\n   */\n\n  sortMembers() {\n    let changeOutput = null;\n\n    if (this.changeIndex !== -1) {\n      changeOutput = this.outputs[this.changeIndex];\n      assert(changeOutput);\n    }\n\n    this.inputs.sort(sortInputs);\n    this.outputs.sort(sortOutputs);\n\n    if (this.changeIndex !== -1) {\n      this.changeIndex = this.outputs.indexOf(changeOutput);\n      assert(this.changeIndex !== -1);\n    }\n  }\n\n  /**\n   * Avoid fee sniping.\n   * @param {Number} - Current chain height.\n   * @see bitcoin/src/wallet/wallet.cpp\n   */\n\n  avoidFeeSniping(height) {\n    assert(typeof height === 'number', 'Must pass in height.');\n\n    if ((Math.random() * 10 | 0) === 0) {\n      height -= Math.random() * 100 | 0;\n\n      if (height < 0)\n        height = 0;\n    }\n\n    this.setLocktime(height);\n  }\n\n  /**\n   * Set locktime and sequences appropriately.\n   * @param {Number} locktime\n   */\n\n  setLocktime(locktime) {\n    assert((locktime >>> 0) === locktime, 'Locktime must be a uint32.');\n    assert(this.inputs.length > 0, 'Cannot set sequence with no inputs.');\n\n    for (const input of this.inputs) {\n      if (input.sequence === 0xffffffff)\n        input.sequence = 0xfffffffe;\n    }\n\n    this.locktime = locktime;\n  }\n\n  /**\n   * Set sequence locktime.\n   * @param {Number} index - Input index.\n   * @param {Number} locktime\n   * @param {Boolean?} seconds\n   */\n\n  setSequence(index, locktime, seconds) {\n    const input = this.inputs[index];\n\n    assert(input, 'Input does not exist.');\n    assert((locktime >>> 0) === locktime, 'Locktime must be a uint32.');\n\n    this.version = 2;\n\n    if (seconds) {\n      locktime >>>= consensus.SEQUENCE_GRANULARITY;\n      locktime &= consensus.SEQUENCE_MASK;\n      locktime |= consensus.SEQUENCE_TYPE_FLAG;\n    } else {\n      locktime &= consensus.SEQUENCE_MASK;\n    }\n\n    input.sequence = locktime;\n  }\n\n  /**\n   * Inspect the transaction.\n   * @returns {Object}\n   */\n\n  [inspectSymbol]() {\n    return this.format();\n  }\n\n  /**\n   * Inspect the transaction.\n   * @returns {Object}\n   */\n\n  format() {\n    return super.format(this.view);\n  }\n\n  /**\n   * Convert transaction to JSON.\n   * @returns {Object}\n   */\n\n  toJSON() {\n    return super.toJSON(null, this.view);\n  }\n\n  /**\n   * Convert transaction to JSON.\n   * @param {Network} network\n   * @returns {Object}\n   */\n\n  getJSON(network) {\n    return super.getJSON(network, this.view);\n  }\n\n  /**\n   * Inject properties from a json object\n   * @param {Object} json\n   */\n\n  fromJSON(json) {\n    super.fromJSON(json);\n\n    for (let i = 0; i < json.inputs.length; i++) {\n      const input = json.inputs[i];\n      const {prevout} = input;\n\n      if (!input.coin)\n        continue;\n\n      const coin = Coin.fromJSON(input.coin);\n\n      coin.hash = util.fromRev(prevout.hash);\n      coin.index = prevout.index;\n\n      this.view.addCoin(coin);\n    }\n\n    return this;\n  }\n\n  /**\n   * Instantiate a transaction from a\n   * jsonified transaction object.\n   * @param {Object} json - The jsonified transaction object.\n   * @returns {MTX}\n   */\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n\n  /**\n   * Instantiate a transaction from a buffer reader.\n   * @param {BufferReader} br\n   * @returns {MTX}\n   */\n\n  static fromReader(br) {\n    return new this().fromReader(br);\n  }\n\n  /**\n   * Instantiate a transaction from a serialized Buffer.\n   * @param {Buffer} data\n   * @param {String?} enc - Encoding, can be `'hex'` or null.\n   * @returns {MTX}\n   */\n\n  static fromRaw(data, enc) {\n    if (typeof data === 'string')\n      data = Buffer.from(data, enc);\n    return new this().fromRaw(data);\n  }\n\n  /**\n   * Convert the MTX to a TX.\n   * @returns {TX}\n   */\n\n  toTX() {\n    return new TX().inject(this);\n  }\n\n  /**\n   * Convert the MTX to a TX.\n   * @returns {Array} [tx, view]\n   */\n\n  commit() {\n    return [this.toTX(), this.view];\n  }\n\n  /**\n   * Instantiate MTX from TX.\n   * @param {TX} tx\n   * @returns {MTX}\n   */\n\n  static fromTX(tx) {\n    return new this().inject(tx);\n  }\n\n  /**\n   * Test whether an object is an MTX.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n  static isMTX(obj) {\n    return obj instanceof MTX;\n  }\n}\n\n/**\n * Coin Selector\n * @alias module:primitives.CoinSelector\n */\n\nclass CoinSelector {\n  /**\n   * Create a coin selector.\n   * @constructor\n   * @param {TX} tx\n   * @param {Object?} options\n   */\n\n  constructor(tx, options) {\n    this.tx = tx.clone();\n    this.coins = [];\n    this.outputValue = 0;\n    this.index = 0;\n    this.chosen = [];\n    this.change = 0;\n    this.fee = CoinSelector.MIN_FEE;\n\n    this.selection = 'value';\n    this.subtractFee = false;\n    this.subtractIndex = -1;\n    this.height = -1;\n    this.depth = -1;\n    this.hardFee = -1;\n    this.rate = CoinSelector.FEE_RATE;\n    this.maxFee = -1;\n    this.round = false;\n    this.changeAddress = null;\n    this.inputs = new BufferMap();\n\n    // Needed for size estimation.\n    this.estimate = null;\n\n    this.injectInputs();\n\n    if (options)\n      this.fromOptions(options);\n  }\n\n  /**\n   * Initialize selector options.\n   * @param {Object} options\n   * @private\n   */\n\n  fromOptions(options) {\n    if (options.selection) {\n      assert(typeof options.selection === 'string');\n      this.selection = options.selection;\n    }\n\n    if (options.subtractFee != null) {\n      if (typeof options.subtractFee === 'number') {\n        assert(Number.isSafeInteger(options.subtractFee));\n        assert(options.subtractFee >= -1);\n        this.subtractIndex = options.subtractFee;\n        this.subtractFee = this.subtractIndex !== -1;\n      } else {\n        assert(typeof options.subtractFee === 'boolean');\n        this.subtractFee = options.subtractFee;\n      }\n    }\n\n    if (options.subtractIndex != null) {\n      assert(Number.isSafeInteger(options.subtractIndex));\n      assert(options.subtractIndex >= -1);\n      this.subtractIndex = options.subtractIndex;\n      this.subtractFee = this.subtractIndex !== -1;\n    }\n\n    if (options.height != null) {\n      assert(Number.isSafeInteger(options.height));\n      assert(options.height >= -1);\n      this.height = options.height;\n    }\n\n    if (options.confirmations != null) {\n      assert(Number.isSafeInteger(options.confirmations));\n      assert(options.confirmations >= -1);\n      this.depth = options.confirmations;\n    }\n\n    if (options.depth != null) {\n      assert(Number.isSafeInteger(options.depth));\n      assert(options.depth >= -1);\n      this.depth = options.depth;\n    }\n\n    if (options.hardFee != null) {\n      assert(Number.isSafeInteger(options.hardFee));\n      assert(options.hardFee >= -1);\n      this.hardFee = options.hardFee;\n    }\n\n    if (options.rate != null) {\n      assert(Number.isSafeInteger(options.rate));\n      assert(options.rate >= 0);\n      this.rate = options.rate;\n    }\n\n    if (options.maxFee != null) {\n      assert(Number.isSafeInteger(options.maxFee));\n      assert(options.maxFee >= -1);\n      this.maxFee = options.maxFee;\n    }\n\n    if (options.round != null) {\n      assert(typeof options.round === 'boolean');\n      this.round = options.round;\n    }\n\n    if (options.changeAddress) {\n      const addr = options.changeAddress;\n      if (typeof addr === 'string') {\n        this.changeAddress = Address.fromString(addr);\n      } else {\n        assert(addr instanceof Address);\n        this.changeAddress = addr;\n      }\n    }\n\n    if (options.estimate) {\n      assert(typeof options.estimate === 'function');\n      this.estimate = options.estimate;\n    }\n\n    if (options.inputs) {\n      assert(Array.isArray(options.inputs));\n      for (let i = 0; i < options.inputs.length; i++) {\n        const prevout = options.inputs[i];\n        assert(prevout && typeof prevout === 'object');\n        const {hash, index} = prevout;\n        assert(Buffer.isBuffer(hash));\n        assert(typeof index === 'number');\n        this.inputs.set(Outpoint.toKey(hash, index), i);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Attempt to inject existing inputs.\n   * @private\n   */\n\n  injectInputs() {\n    if (this.tx.inputs.length > 0) {\n      for (let i = 0; i < this.tx.inputs.length; i++) {\n        const {prevout} = this.tx.inputs[i];\n        this.inputs.set(prevout.toKey(), i);\n      }\n    }\n  }\n\n  /**\n   * Initialize the selector with coins to select from.\n   * @param {Coin[]} coins\n   */\n\n  init(coins) {\n    this.coins = coins.slice();\n    this.outputValue = this.tx.getOutputValue();\n    this.index = 0;\n    this.chosen = [];\n    this.change = 0;\n    this.fee = CoinSelector.MIN_FEE;\n    this.tx.inputs.length = 0;\n\n    switch (this.selection) {\n      case 'all':\n      case 'random':\n        this.coins.sort(sortRandom);\n        break;\n      case 'age':\n        this.coins.sort(sortAge);\n        break;\n      case 'value':\n        this.coins.sort(sortValue);\n        break;\n      default:\n        throw new FundingError(`Bad selection type: ${this.selection}.`);\n    }\n  }\n\n  /**\n   * Calculate total value required.\n   * @returns {Amount}\n   */\n\n  total() {\n    if (this.subtractFee)\n      return this.outputValue;\n    return this.outputValue + this.fee;\n  }\n\n  /**\n   * Test whether the selector has\n   * completely funded the transaction.\n   * @returns {Boolean}\n   */\n\n  isFull() {\n    return this.tx.getInputValue() >= this.total();\n  }\n\n  /**\n   * Test whether a coin is spendable\n   * with regards to the options.\n   * @param {Coin} coin\n   * @returns {Boolean}\n   */\n\n  isSpendable(coin) {\n    if (this.tx.view.hasEntry(coin))\n      return false;\n\n    if (this.height === -1)\n      return true;\n\n    if (coin.coinbase) {\n      if (coin.height === -1)\n        return false;\n\n      if (this.height + 1 < coin.height + consensus.COINBASE_MATURITY)\n        return false;\n\n      return true;\n    }\n\n    if (this.depth === -1)\n      return true;\n\n    const depth = coin.getDepth(this.height);\n\n    if (depth < this.depth)\n      return false;\n\n    return true;\n  }\n\n  /**\n   * Get the current fee based on a size.\n   * @param {Number} size\n   * @returns {Amount}\n   */\n\n  getFee(size) {\n    // This is mostly here for testing.\n    // i.e. A fee rounded to the nearest\n    // kb is easier to predict ahead of time.\n    if (this.round) {\n      const fee = policy.getRoundFee(size, this.rate);\n      return Math.min(fee, CoinSelector.MAX_FEE);\n    }\n\n    const fee = policy.getMinFee(size, this.rate);\n    return Math.min(fee, CoinSelector.MAX_FEE);\n  }\n\n  /**\n   * Fund the transaction with more\n   * coins if the `output value + fee`\n   * total was updated.\n   */\n\n  fund() {\n    // Ensure all preferred inputs first.\n    if (this.inputs.size > 0) {\n      const coins = [];\n\n      for (let i = 0; i < this.inputs.size; i++)\n        coins.push(null);\n\n      for (const coin of this.coins) {\n        const {hash, index} = coin;\n        const key = Outpoint.toKey(hash, index);\n        const i = this.inputs.get(key);\n\n        if (i != null) {\n          coins[i] = coin;\n          this.inputs.delete(key);\n        }\n      }\n\n      if (this.inputs.size > 0)\n        throw new Error('Could not resolve preferred inputs.');\n\n      for (const coin of coins) {\n        this.tx.addCoin(coin);\n        this.chosen.push(coin);\n      }\n    }\n\n    while (this.index < this.coins.length) {\n      const coin = this.coins[this.index++];\n\n      if (!this.isSpendable(coin))\n        continue;\n\n      this.tx.addCoin(coin);\n      this.chosen.push(coin);\n\n      if (this.selection === 'all')\n        continue;\n\n      if (this.isFull())\n        break;\n    }\n  }\n\n  /**\n   * Initiate selection from `coins`.\n   * @param {Coin[]} coins\n   * @returns {CoinSelector}\n   */\n\n  async select(coins) {\n    this.init(coins);\n\n    if (this.hardFee !== -1) {\n      this.selectHard();\n    } else {\n      // This is potentially asynchronous:\n      // it may invoke the size estimator\n      // required for redeem scripts (we\n      // may be calling out to a wallet\n      // or something similar).\n      await this.selectEstimate();\n    }\n\n    if (!this.isFull()) {\n      // Still failing to get enough funds.\n      throw new FundingError(\n        'Not enough funds.',\n        this.tx.getInputValue(),\n        this.total());\n    }\n\n    // How much money is left after filling outputs.\n    this.change = this.tx.getInputValue() - this.total();\n\n    return this;\n  }\n\n  /**\n   * Initialize selection based on size estimate.\n   */\n\n  async selectEstimate() {\n    // Set minimum fee and do\n    // an initial round of funding.\n    this.fee = CoinSelector.MIN_FEE;\n    this.fund();\n\n    // Add dummy output for change.\n    const change = new Output();\n\n    if (this.changeAddress) {\n      change.script.fromAddress(this.changeAddress);\n    } else {\n      // In case we don't have a change address,\n      // we use a fake p2pkh output to gauge size.\n      change.script.fromPubkeyhash(Buffer.allocUnsafe(20));\n    }\n\n    this.tx.outputs.push(change);\n\n    // Keep recalculating the fee and funding\n    // until we reach some sort of equilibrium.\n    do {\n      const size = await this.tx.estimateSize(this.estimate);\n\n      this.fee = this.getFee(size);\n\n      if (this.maxFee > 0 && this.fee > this.maxFee)\n        throw new FundingError('Fee is too high.');\n\n      // Failed to get enough funds, add more coins.\n      if (!this.isFull())\n        this.fund();\n    } while (!this.isFull() && this.index < this.coins.length);\n  }\n\n  /**\n   * Initiate selection based on a hard fee.\n   */\n\n  selectHard() {\n    this.fee = Math.min(this.hardFee, CoinSelector.MAX_FEE);\n    this.fund();\n  }\n}\n\n/**\n * Default fee rate\n * for coin selection.\n * @const {Amount}\n * @default\n */\n\nCoinSelector.FEE_RATE = 10000;\n\n/**\n * Minimum fee to start with\n * during coin selection.\n * @const {Amount}\n * @default\n */\n\nCoinSelector.MIN_FEE = 10000;\n\n/**\n * Maximum fee to allow\n * after coin selection.\n * @const {Amount}\n * @default\n */\n\nCoinSelector.MAX_FEE = consensus.COIN / 10;\n\n/**\n * Funding Error\n * An error thrown from the coin selector.\n * @ignore\n * @extends Error\n * @property {String} message - Error message.\n * @property {Amount} availableFunds\n * @property {Amount} requiredFunds\n */\n\nclass FundingError extends Error {\n  /**\n   * Create a funding error.\n   * @constructor\n   * @param {String} msg\n   * @param {Amount} available\n   * @param {Amount} required\n   */\n\n  constructor(msg, available, required) {\n    super();\n\n    this.type = 'FundingError';\n    this.message = msg;\n    this.availableFunds = -1;\n    this.requiredFunds = -1;\n\n    if (available != null) {\n      this.message += ` (available=${Amount.btc(available)},`;\n      this.message += ` required=${Amount.btc(required)})`;\n      this.availableFunds = available;\n      this.requiredFunds = required;\n    }\n\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(this, FundingError);\n  }\n}\n\n/*\n * Helpers\n */\n\nfunction sortAge(a, b) {\n  a = a.height === -1 ? 0x7fffffff : a.height;\n  b = b.height === -1 ? 0x7fffffff : b.height;\n  return a - b;\n}\n\nfunction sortRandom(a, b) {\n  return Math.random() > 0.5 ? 1 : -1;\n}\n\nfunction sortValue(a, b) {\n  if (a.height === -1 && b.height !== -1)\n    return 1;\n\n  if (a.height !== -1 && b.height === -1)\n    return -1;\n\n  return b.value - a.value;\n}\n\nfunction sortInputs(a, b) {\n  return a.compare(b);\n}\n\nfunction sortOutputs(a, b) {\n  return a.compare(b);\n}\n\n/*\n * Expose\n */\n\nexports = MTX;\nexports.MTX = MTX;\nexports.Selector = CoinSelector;\nexports.FundingError = FundingError;\n\nmodule.exports = exports;\n"]},"metadata":{},"sourceType":"module"}