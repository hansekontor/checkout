{"ast":null,"code":"/*!\n * common.js - common functions for hd\n * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst LRU = require('blru');\n\nconst common = exports;\n/**\n * Index at which hardening begins.\n * @const {Number}\n * @default\n */\n\ncommon.HARDENED = 0x80000000;\n/**\n * Min entropy bits.\n * @const {Number}\n * @default\n */\n\ncommon.MIN_ENTROPY = 128;\n/**\n * Max entropy bits.\n * @const {Number}\n * @default\n */\n\ncommon.MAX_ENTROPY = 512;\n/**\n * LRU cache to avoid deriving keys twice.\n * @type {LRU}\n */\n\ncommon.cache = new LRU(500);\n/**\n * Parse a derivation path and return an array of indexes.\n * @see https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\n * @param {String} path\n * @param {Boolean} hard\n * @returns {Number[]}\n */\n\ncommon.parsePath = function parsePath(path, hard) {\n  assert(typeof path === 'string');\n  assert(typeof hard === 'boolean');\n  assert(path.length >= 1);\n  assert(path.length <= 3062);\n  const parts = path.split('/');\n  const root = parts[0];\n\n  if (root !== 'm' && root !== 'M' && root !== 'm\\'' && root !== 'M\\'') {\n    throw new Error('Invalid path root.');\n  }\n\n  const result = [];\n\n  for (let i = 1; i < parts.length; i++) {\n    let part = parts[i];\n    const hardened = part[part.length - 1] === '\\'';\n    if (hardened) part = part.slice(0, -1);\n    if (part.length > 10) throw new Error('Path index too large.');\n    if (!/^\\d+$/.test(part)) throw new Error('Path index is non-numeric.');\n    let index = parseInt(part, 10);\n    if (index >>> 0 !== index) throw new Error('Path index out of range.');\n\n    if (hardened) {\n      index |= common.HARDENED;\n      index >>>= 0;\n    }\n\n    if (!hard && index & common.HARDENED) throw new Error('Path index cannot be hardened.');\n    result.push(index);\n  }\n\n  return result;\n};\n/**\n * Test whether the key is a master key.\n * @param {HDPrivateKey|HDPublicKey} key\n * @returns {Boolean}\n */\n\n\ncommon.isMaster = function isMaster(key) {\n  return key.depth === 0 && key.childIndex === 0 && key.parentFingerPrint === 0;\n};\n/**\n * Test whether the key is (most likely) a BIP44 account key.\n * @param {HDPrivateKey|HDPublicKey} key\n * @param {Number?} account\n * @returns {Boolean}\n */\n\n\ncommon.isAccount = function isAccount(key, account) {\n  if (account != null) {\n    const index = (common.HARDENED | account) >>> 0;\n    if (key.childIndex !== index) return false;\n  }\n\n  return key.depth === 3 && (key.childIndex & common.HARDENED) !== 0;\n};\n/**\n * A compressed pubkey of all zeroes.\n * @const {Buffer}\n * @default\n */\n\n\ncommon.ZERO_KEY = Buffer.alloc(33, 0x00);","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/hd/common.js"],"names":["assert","require","LRU","common","exports","HARDENED","MIN_ENTROPY","MAX_ENTROPY","cache","parsePath","path","hard","length","parts","split","root","Error","result","i","part","hardened","slice","test","index","parseInt","push","isMaster","key","depth","childIndex","parentFingerPrint","isAccount","account","ZERO_KEY","Buffer","alloc"],"mappings":"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","sourcesContent":["/*!\n * common.js - common functions for hd\n * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst LRU = require('blru');\nconst common = exports;\n\n/**\n * Index at which hardening begins.\n * @const {Number}\n * @default\n */\n\ncommon.HARDENED = 0x80000000;\n\n/**\n * Min entropy bits.\n * @const {Number}\n * @default\n */\n\ncommon.MIN_ENTROPY = 128;\n\n/**\n * Max entropy bits.\n * @const {Number}\n * @default\n */\n\ncommon.MAX_ENTROPY = 512;\n\n/**\n * LRU cache to avoid deriving keys twice.\n * @type {LRU}\n */\n\ncommon.cache = new LRU(500);\n\n/**\n * Parse a derivation path and return an array of indexes.\n * @see https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\n * @param {String} path\n * @param {Boolean} hard\n * @returns {Number[]}\n */\n\ncommon.parsePath = function parsePath(path, hard) {\n  assert(typeof path === 'string');\n  assert(typeof hard === 'boolean');\n  assert(path.length >= 1);\n  assert(path.length <= 3062);\n\n  const parts = path.split('/');\n  const root = parts[0];\n\n  if (root !== 'm'\n      && root !== 'M'\n      && root !== 'm\\''\n      && root !== 'M\\'') {\n    throw new Error('Invalid path root.');\n  }\n\n  const result = [];\n\n  for (let i = 1; i < parts.length; i++) {\n    let part = parts[i];\n\n    const hardened = part[part.length - 1] === '\\'';\n\n    if (hardened)\n      part = part.slice(0, -1);\n\n    if (part.length > 10)\n      throw new Error('Path index too large.');\n\n    if (!/^\\d+$/.test(part))\n      throw new Error('Path index is non-numeric.');\n\n    let index = parseInt(part, 10);\n\n    if ((index >>> 0) !== index)\n      throw new Error('Path index out of range.');\n\n    if (hardened) {\n      index |= common.HARDENED;\n      index >>>= 0;\n    }\n\n    if (!hard && (index & common.HARDENED))\n      throw new Error('Path index cannot be hardened.');\n\n    result.push(index);\n  }\n\n  return result;\n};\n\n/**\n * Test whether the key is a master key.\n * @param {HDPrivateKey|HDPublicKey} key\n * @returns {Boolean}\n */\n\ncommon.isMaster = function isMaster(key) {\n  return key.depth === 0\n    && key.childIndex === 0\n    && key.parentFingerPrint === 0;\n};\n\n/**\n * Test whether the key is (most likely) a BIP44 account key.\n * @param {HDPrivateKey|HDPublicKey} key\n * @param {Number?} account\n * @returns {Boolean}\n */\n\ncommon.isAccount = function isAccount(key, account) {\n  if (account != null) {\n    const index = (common.HARDENED | account) >>> 0;\n    if (key.childIndex !== index)\n      return false;\n  }\n  return key.depth === 3 && (key.childIndex & common.HARDENED) !== 0;\n};\n\n/**\n * A compressed pubkey of all zeroes.\n * @const {Buffer}\n * @default\n */\n\ncommon.ZERO_KEY = Buffer.alloc(33, 0x00);\n"]},"metadata":{},"sourceType":"module"}