{"ast":null,"code":"/*!\n * input.js - input object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bio = require('bufio');\n\nconst Network = require('../protocol/network');\n\nconst Script = require('../script/script');\n\nconst Outpoint = require('./outpoint');\n\nconst {\n  inspectSymbol\n} = require('../utils');\n/**\n * Input\n * Represents a transaction input.\n * @alias module:primitives.Input\n * @property {Outpoint} prevout - Outpoint.\n * @property {Script} script - Input script / scriptSig.\n * @property {Number} sequence - nSequence.\n */\n\n\nclass Input {\n  /**\n   * Create transaction input.\n   * @constructor\n   * @param {Object} options\n   */\n  constructor(options) {\n    this.prevout = new Outpoint();\n    this.script = new Script();\n    this.sequence = 0xffffffff;\n    if (options) this.fromOptions(options);\n  }\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n\n  fromOptions(options) {\n    assert(options, 'Input data is required.');\n    this.prevout.fromOptions(options.prevout);\n    if (options.script) this.script.fromOptions(options.script);\n\n    if (options.sequence != null) {\n      assert(options.sequence >>> 0 === options.sequence, 'Sequence must be a uint32.');\n      this.sequence = options.sequence;\n    }\n\n    return this;\n  }\n  /**\n   * Instantiate an Input from options object.\n   * @param {Object} options\n   * @returns {Input}\n   */\n\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  } //   /**\n  //    * Clone the input.\n  //    * @returns {Input}\n  //    */\n  //   clone() {\n  //     const input = new this.constructor();\n  //     input.prevout = this.prevout;\n  //     input.script.inject(this.script);\n  //     input.sequence = this.sequence;\n  //     return input;\n  //   }\n  //   /**\n  //    * Test equality against another input.\n  //    * @param {Input} input\n  //    * @returns {Boolean}\n  //    */\n  //   equals(input) {\n  //     assert(Input.isInput(input));\n  //     return this.prevout.equals(input.prevout);\n  //   }\n  //   /**\n  //    * Compare against another input (BIP69).\n  //    * @param {Input} input\n  //    * @returns {Number}\n  //    */\n  //   compare(input) {\n  //     assert(Input.isInput(input));\n  //     return this.prevout.compare(input.prevout);\n  //   }\n  //   /**\n  //    * Get the previous output script type as a string.\n  //    * Will \"guess\" based on the input script and/or\n  //    * witness if coin is not available.\n  //    * @param {Coin?} coin\n  //    * @returns {ScriptType} type\n  //    */\n  //   getType(coin) {\n  //     if (this.isCoinbase())\n  //       return 'coinbase';\n  //     if (coin)\n  //       return coin.getType();\n  //     const type = this.script.getInputType();\n  //     return Script.typesByVal[type].toLowerCase();\n  //   }\n  //   /**\n  //    * Get the redeem script.\n  //    * @param {Coin?} coin\n  //    * @returns {Script?} Redeem script.\n  //    */\n  //   getRedeem(coin) {\n  //     if (this.isCoinbase())\n  //       return null;\n  //     if (!coin) {\n  //       if (this.script.isScripthashInput())\n  //         return this.script.getRedeem();\n  //       return null;\n  //     }\n  //     let prev = coin.script;\n  //     let redeem = null;\n  //     if (prev.isScripthash()) {\n  //       prev = this.script.getRedeem();\n  //       redeem = prev;\n  //     }\n  //     return redeem;\n  //   }\n  //   /**\n  //    * Get the redeem script type.\n  //    * @param {Coin?} coin\n  //    * @returns {String} subtype\n  //    */\n  //   getSubtype(coin) {\n  //     if (this.isCoinbase())\n  //       return null;\n  //     const redeem = this.getRedeem(coin);\n  //     if (!redeem)\n  //       return null;\n  //     const type = redeem.getType();\n  //     return Script.typesByVal[type].toLowerCase();\n  //   }\n  //   /**\n  //    * Get the previous output script's address. Will \"guess\"\n  //    * based on the input script and/or witness if coin\n  //    * is not available.\n  //    * @param {Coin?} coin\n  //    * @returns {Address?} addr\n  //    */\n  //   getAddress(coin) {\n  //     if (this.isCoinbase())\n  //       return null;\n  //     if (coin)\n  //       return coin.getAddress();\n  //     if (this.script.code.length > 0)\n  //       return this.script.getInputAddress();\n  //     return null;\n  //   }\n  //   /**\n  //    * Get the address hash.\n  //    * @param {Coin?} coin\n  //    * @param {String?} enc\n  //    * @returns {Hash} hash\n  //    */\n  //   getHash(coin, enc) {\n  //     const addr = this.getAddress(coin);\n  //     if (!addr)\n  //       return null;\n  //     return addr.getHash(enc);\n  //   }\n  //   /**\n  //    * Test to see if nSequence is equal to uint32max.\n  //    * @returns {Boolean}\n  //    */\n  //   isFinal() {\n  //     return this.sequence === 0xffffffff;\n  //   }\n  //   /**\n  //    * Test to see if nSequence is less than 0xfffffffe.\n  //    * @returns {Boolean}\n  //    */\n  //   isRBF() {\n  //     return this.sequence < 0xfffffffe;\n  //   }\n  //   /**\n  //    * Test to see if outpoint is null.\n  //    * @returns {Boolean}\n  //    */\n  //   isCoinbase() {\n  //     return this.prevout.isNull();\n  //   }\n  //   /**\n  //    * Convert the input to a more user-friendly object.\n  //    * @returns {Object}\n  //    */\n  //   [inspectSymbol]() {\n  //     return this.format();\n  //   }\n  //   /**\n  //    * Convert the input to a more user-friendly object.\n  //    * @param {Coin?} coin\n  //    * @returns {Object}\n  //    */\n  //   format(coin) {\n  //     return {\n  //       type: this.getType(coin),\n  //       subtype: this.getSubtype(coin),\n  //       address: this.getAddress(coin),\n  //       script: this.script,\n  //       redeem: this.getRedeem(coin),\n  //       sequence: this.sequence,\n  //       prevout: this.prevout,\n  //       coin: coin || null\n  //     };\n  //   }\n  //   /**\n  //    * Convert the input to an object suitable\n  //    * for JSON serialization.\n  //    * @returns {Object}\n  //    */\n  //   toJSON(network, coin) {\n  //     return this.getJSON();\n  //   }\n  //   /**\n  //    * Convert the input to an object suitable\n  //    * for JSON serialization. Note that the hashes\n  //    * will be reversed to abide by bitcoind's legacy\n  //    * of little-endian uint256s.\n  //    * @param {Network} network\n  //    * @param {Coin} coin\n  //    * @returns {Object}\n  //    */\n  //   getJSON(network, coin) {\n  //     network = Network.get(network);\n  //     let addr;\n  //     if (!coin) {\n  //       addr = this.getAddress();\n  //       if (addr)\n  //         addr = addr.toString(network);\n  //     }\n  //     return {\n  //       prevout: this.prevout.toJSON(),\n  //       script: this.script.toJSON(),\n  //       sequence: this.sequence,\n  //       address: addr,\n  //       coin: coin ? coin.getJSON(network, true) : undefined\n  //     };\n  //   }\n  //   /**\n  //    * Inject properties from a JSON object.\n  //    * @private\n  //    * @param {Object} json\n  //    */\n  //   fromJSON(json) {\n  //     assert(json, 'Input data is required.');\n  //     assert((json.sequence >>> 0) === json.sequence,\n  //       'Sequence must be a uint32.');\n  //     this.prevout.fromJSON(json.prevout);\n  //     this.script.fromJSON(json.script);\n  //     this.sequence = json.sequence;\n  //     return this;\n  //   }\n  //   /**\n  //    * Instantiate an Input from a jsonified input object.\n  //    * @param {Object} json - The jsonified input object.\n  //    * @returns {Input}\n  //    */\n  //   static fromJSON(json) {\n  //     return new this().fromJSON(json);\n  //   }\n  //   /**\n  //    * Calculate size of serialized input.\n  //    * @returns {Number}\n  //    */\n  //   getSize() {\n  //     return 40 + this.script.getVarSize();\n  //   }\n  //   /**\n  //    * Serialize the input.\n  //    * @param {String?} enc - Encoding, can be `'hex'` or null.\n  //    * @returns {Buffer|String}\n  //    */\n  //   toRaw() {\n  //     const size = this.getSize();\n  //     return this.toWriter(bio.write(size)).render();\n  //   }\n  //   /**\n  //    * Write the input to a buffer writer.\n  //    * @param {BufferWriter} bw\n  //    */\n  //   toWriter(bw) {\n  //     this.prevout.toWriter(bw);\n  //     bw.writeVarBytes(this.script.toRaw());\n  //     bw.writeU32(this.sequence);\n  //     return bw;\n  //   }\n  //   /**\n  //    * Inject properties from buffer reader.\n  //    * @private\n  //    * @param {BufferReader} br\n  //    */\n  //   fromReader(br) {\n  //     this.prevout.fromReader(br);\n  //     this.script.fromRaw(br.readVarBytes());\n  //     this.sequence = br.readU32();\n  //     return this;\n  //   }\n  //   /**\n  //    * Inject properties from serialized data.\n  //    * @param {Buffer} data\n  //    */\n  //   fromRaw(data) {\n  //     return this.fromReader(bio.read(data));\n  //   }\n  //   /**\n  //    * Instantiate an input from a buffer reader.\n  //    * @param {BufferReader} br\n  //    * @returns {Input}\n  //    */\n  //   static fromReader(br) {\n  //     return new this().fromReader(br);\n  //   }\n  //   /**\n  //    * Instantiate an input from a serialized Buffer.\n  //    * @param {Buffer} data\n  //    * @param {String?} enc - Encoding, can be `'hex'` or null.\n  //    * @returns {Input}\n  //    */\n  //   static fromRaw(data, enc) {\n  //     if (typeof data === 'string')\n  //       data = Buffer.from(data, enc);\n  //     return new this().fromRaw(data);\n  //   }\n  //   /**\n  //    * Inject properties from outpoint.\n  //    * @private\n  //    * @param {Outpoint} outpoint\n  //    */\n  //   fromOutpoint(outpoint) {\n  //     assert(Buffer.isBuffer(outpoint.hash));\n  //     assert(typeof outpoint.index === 'number');\n  //     this.prevout.hash = outpoint.hash;\n  //     this.prevout.index = outpoint.index;\n  //     return this;\n  //   }\n  //   /**\n  //    * Instantiate input from outpoint.\n  //    * @param {Outpoint}\n  //    * @returns {Input}\n  //    */\n  //   static fromOutpoint(outpoint) {\n  //     return new this().fromOutpoint(outpoint);\n  //   }\n  //   /**\n  //    * Inject properties from coin.\n  //    * @private\n  //    * @param {Coin} coin\n  //    */\n  //   fromCoin(coin) {\n  //     assert(Buffer.isBuffer(coin.hash));\n  //     assert(typeof coin.index === 'number');\n  //     this.prevout.hash = coin.hash;\n  //     this.prevout.index = coin.index;\n  //     return this;\n  //   }\n  //   /**\n  //    * Instantiate input from coin.\n  //    * @param {Coin}\n  //    * @returns {Input}\n  //    */\n  //   static fromCoin(coin) {\n  //     return new this().fromCoin(coin);\n  //   }\n  //   /**\n  //    * Inject properties from transaction.\n  //    * @private\n  //    * @param {TX} tx\n  //    * @param {Number} index\n  //    */\n  //   fromTX(tx, index) {\n  //     assert(tx);\n  //     assert(typeof index === 'number');\n  //     assert(index >= 0 && index < tx.outputs.length);\n  //     this.prevout.hash = tx.hash();\n  //     this.prevout.index = index;\n  //     return this;\n  //   }\n  //   /**\n  //    * Instantiate input from tx.\n  //    * @param {TX} tx\n  //    * @param {Number} index\n  //    * @returns {Input}\n  //    */\n  //   static fromTX(tx, index) {\n  //     return new this().fromTX(tx, index);\n  //   }\n  //   /**\n  //    * Test an object to see if it is an Input.\n  //    * @param {Object} obj\n  //    * @returns {Boolean}\n  //    */\n  //   static isInput(obj) {\n  //     return obj instanceof Input;\n  //   }\n\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = Input;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/primitives/input.js"],"names":["assert","require","bio","Network","Script","Outpoint","inspectSymbol","Input","constructor","options","prevout","script","sequence","fromOptions","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,OAAD,CAAtB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,kBAAD,CAAtB;;AACA,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAM;AAACK,EAAAA;AAAD,IAAkBL,OAAO,CAAC,UAAD,CAA/B;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMM,KAAN,CAAY;AACV;AACF;AACA;AACA;AACA;AAEEC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB,SAAKC,OAAL,GAAe,IAAIL,QAAJ,EAAf;AACA,SAAKM,MAAL,GAAc,IAAIP,MAAJ,EAAd;AACA,SAAKQ,QAAL,GAAgB,UAAhB;AAEA,QAAIH,OAAJ,EACE,KAAKI,WAAL,CAAiBJ,OAAjB;AACH;AAED;AACF;AACA;AACA;AACA;;;AAEEI,EAAAA,WAAW,CAACJ,OAAD,EAAU;AACnBT,IAAAA,MAAM,CAACS,OAAD,EAAU,yBAAV,CAAN;AAEA,SAAKC,OAAL,CAAaG,WAAb,CAAyBJ,OAAO,CAACC,OAAjC;AAEA,QAAID,OAAO,CAACE,MAAZ,EACE,KAAKA,MAAL,CAAYE,WAAZ,CAAwBJ,OAAO,CAACE,MAAhC;;AAEF,QAAIF,OAAO,CAACG,QAAR,IAAoB,IAAxB,EAA8B;AAC5BZ,MAAAA,MAAM,CAAES,OAAO,CAACG,QAAR,KAAqB,CAAtB,KAA6BH,OAAO,CAACG,QAAtC,EACJ,4BADI,CAAN;AAEA,WAAKA,QAAL,GAAgBH,OAAO,CAACG,QAAxB;AACD;;AAED,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEoB,SAAXC,WAAW,CAACJ,OAAD,EAAU;AAC1B,WAAO,IAAI,IAAJ,GAAWI,WAAX,CAAuBJ,OAAvB,CAAP;AACD,GA/CS,CAiDZ;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AArdY;AAwdZ;AACA;AACA;;;AAEAK,MAAM,CAACC,OAAP,GAAiBR,KAAjB","sourcesContent":["/*!\n * input.js - input object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bio = require('bufio');\nconst Network = require('../protocol/network');\nconst Script = require('../script/script');\nconst Outpoint = require('./outpoint');\nconst {inspectSymbol} = require('../utils');\n\n\n/**\n * Input\n * Represents a transaction input.\n * @alias module:primitives.Input\n * @property {Outpoint} prevout - Outpoint.\n * @property {Script} script - Input script / scriptSig.\n * @property {Number} sequence - nSequence.\n */\n\nclass Input {\n  /**\n   * Create transaction input.\n   * @constructor\n   * @param {Object} options\n   */\n\n  constructor(options) {\n    this.prevout = new Outpoint();\n    this.script = new Script();\n    this.sequence = 0xffffffff;\n\n    if (options)\n      this.fromOptions(options);\n  }\n\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n  fromOptions(options) {\n    assert(options, 'Input data is required.');\n\n    this.prevout.fromOptions(options.prevout);\n\n    if (options.script)\n      this.script.fromOptions(options.script);\n\n    if (options.sequence != null) {\n      assert((options.sequence >>> 0) === options.sequence,\n        'Sequence must be a uint32.');\n      this.sequence = options.sequence;\n    }\n\n    return this;\n  }\n\n  /**\n   * Instantiate an Input from options object.\n   * @param {Object} options\n   * @returns {Input}\n   */\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n\n//   /**\n//    * Clone the input.\n//    * @returns {Input}\n//    */\n\n//   clone() {\n//     const input = new this.constructor();\n//     input.prevout = this.prevout;\n//     input.script.inject(this.script);\n//     input.sequence = this.sequence;\n//     return input;\n//   }\n\n//   /**\n//    * Test equality against another input.\n//    * @param {Input} input\n//    * @returns {Boolean}\n//    */\n\n//   equals(input) {\n//     assert(Input.isInput(input));\n//     return this.prevout.equals(input.prevout);\n//   }\n\n//   /**\n//    * Compare against another input (BIP69).\n//    * @param {Input} input\n//    * @returns {Number}\n//    */\n\n//   compare(input) {\n//     assert(Input.isInput(input));\n//     return this.prevout.compare(input.prevout);\n//   }\n\n//   /**\n//    * Get the previous output script type as a string.\n//    * Will \"guess\" based on the input script and/or\n//    * witness if coin is not available.\n//    * @param {Coin?} coin\n//    * @returns {ScriptType} type\n//    */\n\n//   getType(coin) {\n//     if (this.isCoinbase())\n//       return 'coinbase';\n\n//     if (coin)\n//       return coin.getType();\n\n//     const type = this.script.getInputType();\n\n//     return Script.typesByVal[type].toLowerCase();\n//   }\n\n//   /**\n//    * Get the redeem script.\n//    * @param {Coin?} coin\n//    * @returns {Script?} Redeem script.\n//    */\n\n//   getRedeem(coin) {\n//     if (this.isCoinbase())\n//       return null;\n\n//     if (!coin) {\n//       if (this.script.isScripthashInput())\n//         return this.script.getRedeem();\n\n//       return null;\n//     }\n\n//     let prev = coin.script;\n//     let redeem = null;\n\n//     if (prev.isScripthash()) {\n//       prev = this.script.getRedeem();\n//       redeem = prev;\n//     }\n\n//     return redeem;\n//   }\n\n//   /**\n//    * Get the redeem script type.\n//    * @param {Coin?} coin\n//    * @returns {String} subtype\n//    */\n\n//   getSubtype(coin) {\n//     if (this.isCoinbase())\n//       return null;\n\n//     const redeem = this.getRedeem(coin);\n\n//     if (!redeem)\n//       return null;\n\n//     const type = redeem.getType();\n\n//     return Script.typesByVal[type].toLowerCase();\n//   }\n\n//   /**\n//    * Get the previous output script's address. Will \"guess\"\n//    * based on the input script and/or witness if coin\n//    * is not available.\n//    * @param {Coin?} coin\n//    * @returns {Address?} addr\n//    */\n\n//   getAddress(coin) {\n//     if (this.isCoinbase())\n//       return null;\n\n//     if (coin)\n//       return coin.getAddress();\n\n//     if (this.script.code.length > 0)\n//       return this.script.getInputAddress();\n\n//     return null;\n//   }\n\n//   /**\n//    * Get the address hash.\n//    * @param {Coin?} coin\n//    * @param {String?} enc\n//    * @returns {Hash} hash\n//    */\n\n//   getHash(coin, enc) {\n//     const addr = this.getAddress(coin);\n\n//     if (!addr)\n//       return null;\n\n//     return addr.getHash(enc);\n//   }\n\n//   /**\n//    * Test to see if nSequence is equal to uint32max.\n//    * @returns {Boolean}\n//    */\n\n//   isFinal() {\n//     return this.sequence === 0xffffffff;\n//   }\n\n//   /**\n//    * Test to see if nSequence is less than 0xfffffffe.\n//    * @returns {Boolean}\n//    */\n\n//   isRBF() {\n//     return this.sequence < 0xfffffffe;\n//   }\n\n//   /**\n//    * Test to see if outpoint is null.\n//    * @returns {Boolean}\n//    */\n\n//   isCoinbase() {\n//     return this.prevout.isNull();\n//   }\n\n//   /**\n//    * Convert the input to a more user-friendly object.\n//    * @returns {Object}\n//    */\n\n//   [inspectSymbol]() {\n//     return this.format();\n//   }\n\n//   /**\n//    * Convert the input to a more user-friendly object.\n//    * @param {Coin?} coin\n//    * @returns {Object}\n//    */\n\n//   format(coin) {\n//     return {\n//       type: this.getType(coin),\n//       subtype: this.getSubtype(coin),\n//       address: this.getAddress(coin),\n//       script: this.script,\n//       redeem: this.getRedeem(coin),\n//       sequence: this.sequence,\n//       prevout: this.prevout,\n//       coin: coin || null\n//     };\n//   }\n\n//   /**\n//    * Convert the input to an object suitable\n//    * for JSON serialization.\n//    * @returns {Object}\n//    */\n\n//   toJSON(network, coin) {\n//     return this.getJSON();\n//   }\n\n//   /**\n//    * Convert the input to an object suitable\n//    * for JSON serialization. Note that the hashes\n//    * will be reversed to abide by bitcoind's legacy\n//    * of little-endian uint256s.\n//    * @param {Network} network\n//    * @param {Coin} coin\n//    * @returns {Object}\n//    */\n\n//   getJSON(network, coin) {\n//     network = Network.get(network);\n\n//     let addr;\n//     if (!coin) {\n//       addr = this.getAddress();\n//       if (addr)\n//         addr = addr.toString(network);\n//     }\n\n//     return {\n//       prevout: this.prevout.toJSON(),\n//       script: this.script.toJSON(),\n//       sequence: this.sequence,\n//       address: addr,\n//       coin: coin ? coin.getJSON(network, true) : undefined\n//     };\n//   }\n\n//   /**\n//    * Inject properties from a JSON object.\n//    * @private\n//    * @param {Object} json\n//    */\n\n//   fromJSON(json) {\n//     assert(json, 'Input data is required.');\n//     assert((json.sequence >>> 0) === json.sequence,\n//       'Sequence must be a uint32.');\n//     this.prevout.fromJSON(json.prevout);\n//     this.script.fromJSON(json.script);\n//     this.sequence = json.sequence;\n//     return this;\n//   }\n\n//   /**\n//    * Instantiate an Input from a jsonified input object.\n//    * @param {Object} json - The jsonified input object.\n//    * @returns {Input}\n//    */\n\n//   static fromJSON(json) {\n//     return new this().fromJSON(json);\n//   }\n\n//   /**\n//    * Calculate size of serialized input.\n//    * @returns {Number}\n//    */\n\n//   getSize() {\n//     return 40 + this.script.getVarSize();\n//   }\n\n//   /**\n//    * Serialize the input.\n//    * @param {String?} enc - Encoding, can be `'hex'` or null.\n//    * @returns {Buffer|String}\n//    */\n\n//   toRaw() {\n//     const size = this.getSize();\n//     return this.toWriter(bio.write(size)).render();\n//   }\n\n//   /**\n//    * Write the input to a buffer writer.\n//    * @param {BufferWriter} bw\n//    */\n\n//   toWriter(bw) {\n//     this.prevout.toWriter(bw);\n//     bw.writeVarBytes(this.script.toRaw());\n//     bw.writeU32(this.sequence);\n//     return bw;\n//   }\n\n//   /**\n//    * Inject properties from buffer reader.\n//    * @private\n//    * @param {BufferReader} br\n//    */\n\n//   fromReader(br) {\n//     this.prevout.fromReader(br);\n//     this.script.fromRaw(br.readVarBytes());\n//     this.sequence = br.readU32();\n//     return this;\n//   }\n\n//   /**\n//    * Inject properties from serialized data.\n//    * @param {Buffer} data\n//    */\n\n//   fromRaw(data) {\n//     return this.fromReader(bio.read(data));\n//   }\n\n//   /**\n//    * Instantiate an input from a buffer reader.\n//    * @param {BufferReader} br\n//    * @returns {Input}\n//    */\n\n//   static fromReader(br) {\n//     return new this().fromReader(br);\n//   }\n\n//   /**\n//    * Instantiate an input from a serialized Buffer.\n//    * @param {Buffer} data\n//    * @param {String?} enc - Encoding, can be `'hex'` or null.\n//    * @returns {Input}\n//    */\n\n//   static fromRaw(data, enc) {\n//     if (typeof data === 'string')\n//       data = Buffer.from(data, enc);\n//     return new this().fromRaw(data);\n//   }\n\n//   /**\n//    * Inject properties from outpoint.\n//    * @private\n//    * @param {Outpoint} outpoint\n//    */\n\n//   fromOutpoint(outpoint) {\n//     assert(Buffer.isBuffer(outpoint.hash));\n//     assert(typeof outpoint.index === 'number');\n//     this.prevout.hash = outpoint.hash;\n//     this.prevout.index = outpoint.index;\n//     return this;\n//   }\n\n//   /**\n//    * Instantiate input from outpoint.\n//    * @param {Outpoint}\n//    * @returns {Input}\n//    */\n\n//   static fromOutpoint(outpoint) {\n//     return new this().fromOutpoint(outpoint);\n//   }\n\n//   /**\n//    * Inject properties from coin.\n//    * @private\n//    * @param {Coin} coin\n//    */\n\n//   fromCoin(coin) {\n//     assert(Buffer.isBuffer(coin.hash));\n//     assert(typeof coin.index === 'number');\n//     this.prevout.hash = coin.hash;\n//     this.prevout.index = coin.index;\n//     return this;\n//   }\n\n//   /**\n//    * Instantiate input from coin.\n//    * @param {Coin}\n//    * @returns {Input}\n//    */\n\n//   static fromCoin(coin) {\n//     return new this().fromCoin(coin);\n//   }\n\n//   /**\n//    * Inject properties from transaction.\n//    * @private\n//    * @param {TX} tx\n//    * @param {Number} index\n//    */\n\n//   fromTX(tx, index) {\n//     assert(tx);\n//     assert(typeof index === 'number');\n//     assert(index >= 0 && index < tx.outputs.length);\n//     this.prevout.hash = tx.hash();\n//     this.prevout.index = index;\n//     return this;\n//   }\n\n//   /**\n//    * Instantiate input from tx.\n//    * @param {TX} tx\n//    * @param {Number} index\n//    * @returns {Input}\n//    */\n\n//   static fromTX(tx, index) {\n//     return new this().fromTX(tx, index);\n//   }\n\n//   /**\n//    * Test an object to see if it is an Input.\n//    * @param {Object} obj\n//    * @returns {Boolean}\n//    */\n\n//   static isInput(obj) {\n//     return obj instanceof Input;\n//   }\n}\n\n/*\n * Expose\n */\n\nmodule.exports = Input;\n"]},"metadata":{},"sourceType":"module"}