{"ast":null,"code":"/*!\n * hmac-drbg.js - hmac-drbg implementation for bcrypto\n * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on indutny/hmac-drbg:\n *   Copyright Fedor Indutny, 2017.\n *   https://github.com/indutny/hmac-drbg\n *\n * Resources:\n *   https://tools.ietf.org/html/rfc6979\n *   https://csrc.nist.gov/publications/detail/sp/800-90a/archive/2012-01-23\n *   https://github.com/indutny/hmac-drbg/blob/master/lib/hmac-drbg.js\n */\n'use strict';\n\nconst assert = require('./internal/assert');\n/*\n * Constants\n */\n\n\nconst RESEED_INTERVAL = 0x1000000000000;\nconst ZERO = Buffer.from([0x00]);\nconst ONE = Buffer.from([0x01]);\n/**\n * HmacDRBG\n */\n\nclass HmacDRBG {\n  constructor(hash, entropy, nonce, pers) {\n    assert(hash && typeof hash.id === 'string');\n    this.hash = hash;\n    this.minEntropy = hash.id === 'SHA1' ? 10 : 24;\n    this.K = Buffer.allocUnsafe(hash.size);\n    this.V = Buffer.allocUnsafe(hash.size);\n    this.rounds = 0;\n    if (entropy) this.init(entropy, nonce, pers);\n  }\n\n  init(entropy) {\n    let nonce = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let pers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    assert(Buffer.isBuffer(entropy));\n    assert(!nonce || Buffer.isBuffer(nonce));\n    assert(!pers || Buffer.isBuffer(pers));\n\n    for (let i = 0; i < this.V.length; i++) {\n      this.K[i] = 0x00;\n      this.V[i] = 0x01;\n    }\n\n    const seed = concat(entropy, nonce, pers);\n    if (seed.length < this.minEntropy) throw new Error('Not enough entropy.');\n    this.update(seed);\n    this.rounds = 1;\n    return this;\n  }\n\n  reseed(entropy) {\n    let add = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    assert(Buffer.isBuffer(entropy));\n    assert(!add || Buffer.isBuffer(add));\n    if (this.rounds === 0) throw new Error('DRBG not initialized.');\n    const seed = concat(entropy, add);\n    if (seed.length < this.minEntropy) throw new Error('Not enough entropy.');\n    this.update(seed);\n    this.rounds = 1;\n    return this;\n  }\n\n  generate(len) {\n    let add = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    assert(len >>> 0 === len);\n    assert(!add || Buffer.isBuffer(add));\n    if (this.rounds === 0) throw new Error('DRBG not initialized.');\n    if (this.rounds > RESEED_INTERVAL) throw new Error('Reseed is required.');\n    if (add && add.length === 0) add = null;\n    if (add) this.update(add);\n    const blocks = Math.ceil(len / this.hash.size);\n    const out = Buffer.allocUnsafe(blocks * this.hash.size);\n\n    for (let i = 0; i < blocks; i++) {\n      this.V = this.mac(this.V);\n      this.V.copy(out, i * this.hash.size);\n    }\n\n    this.update(add);\n    this.rounds += 1;\n    return out.slice(0, len);\n  }\n\n  randomBytes(size) {\n    return this.generate(size);\n  }\n  /*\n   * Helpers\n   */\n\n\n  mac(data) {\n    return this.hash.mac(data, this.K);\n  }\n\n  hmac() {\n    return this.hash.hmac().init(this.K);\n  }\n\n  update() {\n    let seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    assert(!seed || Buffer.isBuffer(seed));\n    const kmac = this.hmac();\n    kmac.update(this.V);\n    kmac.update(ZERO);\n    if (seed) kmac.update(seed);\n    this.K = kmac.final();\n    this.V = this.mac(this.V);\n\n    if (seed) {\n      const kmac = this.hmac();\n      kmac.update(this.V);\n      kmac.update(ONE);\n      kmac.update(seed);\n      this.K = kmac.final();\n      this.V = this.mac(this.V);\n    }\n\n    return this;\n  }\n\n}\n/*\n * Static\n */\n\n\nHmacDRBG.native = 0;\n/*\n * Helpers\n */\n\nfunction concat(a) {\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (!b && !c) return a;\n  let s = a.length;\n  let p = 0;\n  if (b) s += b.length;\n  if (c) s += c.length;\n  const d = Buffer.allocUnsafe(s);\n  p += a.copy(d, p);\n  if (b) p += b.copy(d, p);\n  if (c) c.copy(d, p);\n  return d;\n}\n/*\n * Expose\n */\n\n\nmodule.exports = HmacDRBG;","map":null,"metadata":{},"sourceType":"script"}