{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BitMatrix_1 = require(\"../../common/BitMatrix\");\n\nvar GenericGF_1 = require(\"../../common/reedsolomon/GenericGF\");\n\nvar ReedSolomonDecoder_1 = require(\"../../common/reedsolomon/ReedSolomonDecoder\");\n\nvar BitMatrixParser_1 = require(\"./BitMatrixParser\");\n\nvar QRCodeDecoderMetaData_1 = require(\"./QRCodeDecoderMetaData\");\n\nvar DataBlock_1 = require(\"./DataBlock\");\n\nvar DecodedBitStreamParser_1 = require(\"./DecodedBitStreamParser\");\n\nvar ChecksumException_1 = require(\"../../ChecksumException\");\n/*import java.util.Map;*/\n\n/**\r\n * <p>The main class which implements QR Code decoding -- as opposed to locating and extracting\r\n * the QR Code from an image.</p>\r\n *\r\n * @author Sean Owen\r\n */\n\n\nvar Decoder =\n/** @class */\nfunction () {\n  function Decoder() {\n    this.rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.QR_CODE_FIELD_256);\n  } // public decode(image: boolean[][]): DecoderResult /*throws ChecksumException, FormatException*/ {\n  //   return decode(image, null)\n  // }\n\n  /**\r\n   * <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.\r\n   * \"true\" is taken to mean a black module.</p>\r\n   *\r\n   * @param image booleans representing white/black QR Code modules\r\n   * @param hints decoding hints that should be used to influence decoding\r\n   * @return text and bytes encoded within the QR Code\r\n   * @throws FormatException if the QR Code cannot be decoded\r\n   * @throws ChecksumException if error correction fails\r\n   */\n\n\n  Decoder.prototype.decodeBooleanArray = function (image, hints) {\n    return this.decodeBitMatrix(BitMatrix_1.default.parseFromBooleanArray(image), hints);\n  }; // public decodeBitMatrix(bits: BitMatrix): DecoderResult /*throws ChecksumException, FormatException*/ {\n  //   return decode(bits, null)\n  // }\n\n  /**\r\n   * <p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or \"true\" is taken to mean a black module.</p>\r\n   *\r\n   * @param bits booleans representing white/black QR Code modules\r\n   * @param hints decoding hints that should be used to influence decoding\r\n   * @return text and bytes encoded within the QR Code\r\n   * @throws FormatException if the QR Code cannot be decoded\r\n   * @throws ChecksumException if error correction fails\r\n   */\n\n\n  Decoder.prototype.decodeBitMatrix = function (bits, hints) {\n    // Construct a parser and read version, error-correction level\n    var parser = new BitMatrixParser_1.default(bits);\n    var ex = null;\n\n    try {\n      return this.decodeBitMatrixParser(parser, hints);\n    } catch (e\n    /*: FormatException, ChecksumException*/\n    ) {\n      ex = e;\n    }\n\n    try {\n      // Revert the bit matrix\n      parser.remask(); // Will be attempting a mirrored reading of the version and format info.\n\n      parser.setMirror(true); // Preemptively read the version.\n\n      parser.readVersion(); // Preemptively read the format information.\n\n      parser.readFormatInformation();\n      /*\r\n       * Since we're here, this means we have successfully detected some kind\r\n       * of version and format information when mirrored. This is a good sign,\r\n       * that the QR code may be mirrored, and we should try once more with a\r\n       * mirrored content.\r\n       */\n      // Prepare for a mirrored reading.\n\n      parser.mirror();\n      var result = this.decodeBitMatrixParser(parser, hints); // Success! Notify the caller that the code was mirrored.\n\n      result.setOther(new QRCodeDecoderMetaData_1.default(true));\n      return result;\n    } catch (e\n    /*FormatException | ChecksumException*/\n    ) {\n      // Throw the exception from the original reading\n      if (ex !== null) {\n        throw ex;\n      }\n\n      throw e;\n    }\n  };\n\n  Decoder.prototype.decodeBitMatrixParser = function (parser, hints) {\n    var version = parser.readVersion();\n    var ecLevel = parser.readFormatInformation().getErrorCorrectionLevel(); // Read codewords\n\n    var codewords = parser.readCodewords(); // Separate into data blocks\n\n    var dataBlocks = DataBlock_1.default.getDataBlocks(codewords, version, ecLevel); // Count total number of data bytes\n\n    var totalBytes = 0;\n\n    for (var _i = 0, dataBlocks_1 = dataBlocks; _i < dataBlocks_1.length; _i++) {\n      var dataBlock = dataBlocks_1[_i];\n      totalBytes += dataBlock.getNumDataCodewords();\n    }\n\n    var resultBytes = new Uint8Array(totalBytes);\n    var resultOffset = 0; // Error-correct and copy data blocks together into a stream of bytes\n\n    for (var _a = 0, dataBlocks_2 = dataBlocks; _a < dataBlocks_2.length; _a++) {\n      var dataBlock = dataBlocks_2[_a];\n      var codewordBytes = dataBlock.getCodewords();\n      var numDataCodewords = dataBlock.getNumDataCodewords();\n      this.correctErrors(codewordBytes, numDataCodewords);\n\n      for (var i = 0; i < numDataCodewords; i++) {\n        resultBytes[resultOffset++] = codewordBytes[i];\n      }\n    } // Decode the contents of that stream of bytes\n\n\n    return DecodedBitStreamParser_1.default.decode(resultBytes, version, ecLevel, hints);\n  };\n  /**\r\n   * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\r\n   * correct the errors in-place using Reed-Solomon error correction.</p>\r\n   *\r\n   * @param codewordBytes data and error correction codewords\r\n   * @param numDataCodewords number of codewords that are data bytes\r\n   * @throws ChecksumException if error correction fails\r\n   */\n\n\n  Decoder.prototype.correctErrors = function (codewordBytes, numDataCodewords\n  /*int*/\n  ) {\n    var numCodewords = codewordBytes.length; // First read into an array of ints\n\n    var codewordsInts = new Int32Array(codewordBytes); // TYPESCRIPTPORT: not realy necessary to transform to ints? could redesign everything to work with unsigned bytes?\n    // const codewordsInts = new Int32Array(numCodewords)\n    // for (let i = 0; i < numCodewords; i++) {\n    //   codewordsInts[i] = codewordBytes[i] & 0xFF\n    // }\n\n    try {\n      this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);\n    } catch (ignored\n    /*: ReedSolomonException*/\n    ) {\n      throw new ChecksumException_1.default();\n    } // Copy back into array of bytes -- only need to worry about the bytes that were data\n    // We don't care about errors in the error-correction codewords\n\n\n    for (var i = 0; i < numDataCodewords; i++) {\n      codewordBytes[i] =\n      /*(byte) */\n      codewordsInts[i];\n    }\n  };\n\n  return Decoder;\n}();\n\nexports.default = Decoder;","map":null,"metadata":{},"sourceType":"script"}