{"ast":null,"code":"/*!\n * salsa20.js - salsa20 for bcrypto\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources\n *   https://en.wikipedia.org/wiki/Salsa20\n *   https://cr.yp.to/snuffle.html\n *   https://cr.yp.to/snuffle/spec.pdf\n *   https://cr.yp.to/snuffle/812.pdf\n *   http://www.ecrypt.eu.org/stream/salsa20pf.html\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n/*\n * Constants\n */\n\n\nconst BIG_ENDIAN = new Int8Array(new Int16Array([1]).buffer)[0] === 0;\n/**\n * Salsa20\n */\n\nclass Salsa20 {\n  /**\n   * Create a Salsa20 context.\n   * @constructor\n   */\n  constructor() {\n    this.state = new Uint32Array(16);\n    this.stream = new Uint32Array(16);\n    this.bytes = new Uint8Array(this.stream.buffer);\n    this.pos = -1;\n    if (BIG_ENDIAN) this.bytes = Buffer.alloc(64);\n  }\n  /**\n   * Initialize salsa20 with a key, nonce, and counter.\n   * @param {Buffer} key\n   * @param {Buffer} nonce\n   * @param {Number} counter\n   */\n\n\n  init(key, nonce, counter) {\n    if (counter == null) counter = 0;\n    assert(Buffer.isBuffer(key));\n    assert(Buffer.isBuffer(nonce));\n    assert(Number.isSafeInteger(counter));\n    if (key.length !== 16 && key.length !== 32) throw new RangeError('Invalid key size.');\n\n    if (nonce.length >= 24) {\n      key = Salsa20.derive(key, nonce.slice(0, 16));\n      nonce = nonce.slice(16);\n    }\n\n    this.state[0] = 0x61707865;\n    this.state[1] = readU32(key, 0);\n    this.state[2] = readU32(key, 4);\n    this.state[3] = readU32(key, 8);\n    this.state[4] = readU32(key, 12);\n    this.state[5] = key.length < 32 ? 0x3120646e : 0x3320646e;\n\n    if (nonce.length === 8) {\n      this.state[6] = readU32(nonce, 0);\n      this.state[7] = readU32(nonce, 4);\n      this.state[8] = counter >>> 0;\n      this.state[9] = counter / 0x100000000 >>> 0;\n    } else if (nonce.length === 12) {\n      this.state[6] = readU32(nonce, 0);\n      this.state[7] = readU32(nonce, 4);\n      this.state[8] = readU32(nonce, 8);\n      this.state[9] = counter >>> 0;\n    } else if (nonce.length === 16) {\n      this.state[6] = readU32(nonce, 0);\n      this.state[7] = readU32(nonce, 4);\n      this.state[8] = readU32(nonce, 8);\n      this.state[9] = readU32(nonce, 12);\n    } else {\n      throw new RangeError('Invalid nonce size.');\n    }\n\n    this.state[10] = key.length < 32 ? 0x79622d36 : 0x79622d32;\n    this.state[11] = readU32(key, 16 % key.length);\n    this.state[12] = readU32(key, 20 % key.length);\n    this.state[13] = readU32(key, 24 % key.length);\n    this.state[14] = readU32(key, 28 % key.length);\n    this.state[15] = 0x6b206574;\n    this.pos = 0;\n    return this;\n  }\n  /**\n   * Encrypt/decrypt data.\n   * @param {Buffer} data - Will be mutated.\n   * @returns {Buffer}\n   */\n\n\n  encrypt(data) {\n    assert(Buffer.isBuffer(data));\n    if (this.pos === -1) throw new Error('Context is not initialized.');\n\n    for (let i = 0; i < data.length; i++) {\n      if ((this.pos & 63) === 0) {\n        this._block();\n\n        this.pos = 0;\n      }\n\n      data[i] ^= this.bytes[this.pos++];\n    }\n\n    return data;\n  }\n  /**\n   * Stir the stream.\n   */\n\n\n  _block() {\n    for (let i = 0; i < 16; i++) this.stream[i] = this.state[i];\n\n    for (let i = 0; i < 10; i++) {\n      qround(this.stream, 0, 4, 8, 12);\n      qround(this.stream, 5, 9, 13, 1);\n      qround(this.stream, 10, 14, 2, 6);\n      qround(this.stream, 15, 3, 7, 11);\n      qround(this.stream, 0, 1, 2, 3);\n      qround(this.stream, 5, 6, 7, 4);\n      qround(this.stream, 10, 11, 8, 9);\n      qround(this.stream, 15, 12, 13, 14);\n    }\n\n    for (let i = 0; i < 16; i++) this.stream[i] += this.state[i];\n\n    if (BIG_ENDIAN) {\n      for (let i = 0; i < 16; i++) writeU32(this.bytes, this.stream[i], i * 4);\n    }\n\n    this.state[8] += 1;\n    if (this.state[8] === 0) this.state[9] += 1;\n  }\n  /**\n   * Destroy context.\n   */\n\n\n  destroy() {\n    for (let i = 0; i < 16; i++) {\n      this.state[i] = 0;\n      this.stream[i] = 0;\n    }\n\n    if (BIG_ENDIAN) {\n      for (let i = 0; i < 64; i++) this.bytes[i] = 0;\n    }\n\n    this.pos = -1;\n    return this;\n  }\n  /**\n   * Derive key with XSalsa20.\n   * @param {Buffer} key\n   * @param {Buffer} nonce\n   * @returns {Buffer}\n   */\n\n\n  static derive(key, nonce) {\n    assert(Buffer.isBuffer(key));\n    assert(Buffer.isBuffer(nonce));\n    if (key.length !== 16 && key.length !== 32) throw new RangeError('Invalid key size.');\n    if (nonce.length !== 16) throw new RangeError('Invalid nonce size.');\n    const state = new Uint32Array(16);\n    state[0] = 0x61707865;\n    state[1] = readU32(key, 0);\n    state[2] = readU32(key, 4);\n    state[3] = readU32(key, 8);\n    state[4] = readU32(key, 12);\n    state[5] = key.length < 32 ? 0x3120646e : 0x3320646e;\n    state[6] = readU32(nonce, 0);\n    state[7] = readU32(nonce, 4);\n    state[8] = readU32(nonce, 8);\n    state[9] = readU32(nonce, 12);\n    state[10] = key.length < 32 ? 0x79622d36 : 0x79622d32;\n    state[11] = readU32(key, 16 % key.length);\n    state[12] = readU32(key, 20 % key.length);\n    state[13] = readU32(key, 24 % key.length);\n    state[14] = readU32(key, 28 % key.length);\n    state[15] = 0x6b206574;\n\n    for (let j = 0; j < 10; j++) {\n      qround(state, 0, 4, 8, 12);\n      qround(state, 5, 9, 13, 1);\n      qround(state, 10, 14, 2, 6);\n      qround(state, 15, 3, 7, 11);\n      qround(state, 0, 1, 2, 3);\n      qround(state, 5, 6, 7, 4);\n      qround(state, 10, 11, 8, 9);\n      qround(state, 15, 12, 13, 14);\n    }\n\n    const out = Buffer.alloc(32);\n    writeU32(out, state[0], 0);\n    writeU32(out, state[5], 4);\n    writeU32(out, state[10], 8);\n    writeU32(out, state[15], 12);\n    writeU32(out, state[6], 16);\n    writeU32(out, state[7], 20);\n    writeU32(out, state[8], 24);\n    writeU32(out, state[9], 28);\n    return out;\n  }\n\n}\n/*\n * Static\n */\n\n\nSalsa20.native = 0;\n/*\n * Helpers\n */\n\nfunction qround(x, a, b, c, d) {\n  x[b] ^= rotl32(x[a] + x[d], 7);\n  x[c] ^= rotl32(x[b] + x[a], 9);\n  x[d] ^= rotl32(x[c] + x[b], 13);\n  x[a] ^= rotl32(x[d] + x[c], 18);\n}\n\nfunction rotl32(w, b) {\n  return w << b | w >>> 32 - b;\n}\n\nfunction readU32(data, off) {\n  return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;\n}\n\nfunction writeU32(dst, num, off) {\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  return off;\n}\n/*\n * Expose\n */\n\n\nmodule.exports = Salsa20;","map":null,"metadata":{},"sourceType":"script"}