{"ast":null,"code":"/*!\n * md4.js - MD4 implementation for bcrypto\n * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on RustCrypto/hashes:\n *   Copyright (c) 2016-2018, The RustCrypto Authors (MIT License).\n *   https://github.com/RustCrypto/hashes\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/MD4\n *   https://tools.ietf.org/html/rfc1320\n *   https://github.com/RustCrypto/hashes/blob/master/md4/src/lib.rs\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst HMAC = require('../internal/hmac');\n/*\n * Constants\n */\n\n\nconst FINALIZED = -1;\nconst DESC = Buffer.alloc(8, 0x00);\nconst PADDING = Buffer.alloc(64, 0x00);\nPADDING[0] = 0x80;\nconst K = new Uint32Array([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]);\n/**\n * MD4\n */\n\nclass MD4 {\n  constructor() {\n    this.state = new Uint32Array(4);\n    this.msg = new Uint32Array(16);\n    this.block = Buffer.allocUnsafe(64);\n    this.size = FINALIZED;\n  }\n\n  init() {\n    this.state[0] = K[0];\n    this.state[1] = K[1];\n    this.state[2] = K[2];\n    this.state[3] = K[3];\n    this.size = 0;\n    return this;\n  }\n\n  update(data) {\n    assert(Buffer.isBuffer(data));\n\n    this._update(data, data.length);\n\n    return this;\n  }\n\n  final() {\n    return this._final(Buffer.allocUnsafe(16));\n  }\n\n  _update(data, len) {\n    assert(this.size !== FINALIZED, 'Context is not initialized.');\n    let pos = this.size & 63;\n    let off = 0;\n    this.size += len;\n\n    if (pos > 0) {\n      let want = 64 - pos;\n      if (want > len) want = len;\n      data.copy(this.block, pos, off, off + want);\n      pos += want;\n      len -= want;\n      off += want;\n      if (pos < 64) return;\n\n      this._transform(this.block, 0);\n    }\n\n    while (len >= 64) {\n      this._transform(data, off);\n\n      off += 64;\n      len -= 64;\n    }\n\n    if (len > 0) data.copy(this.block, 0, off, off + len);\n  }\n  /**\n   * Finalize MD4 context.\n   * @private\n   * @param {Buffer} out\n   * @returns {Buffer}\n   */\n\n\n  _final(out) {\n    assert(this.size !== FINALIZED, 'Context is not initialized.');\n    const pos = this.size & 63;\n    const len = this.size * 8;\n    writeU32(DESC, len >>> 0, 0);\n    writeU32(DESC, len * (1 / 0x100000000) >>> 0, 4);\n\n    this._update(PADDING, 1 + (119 - pos & 63));\n\n    this._update(DESC, 8);\n\n    for (let i = 0; i < 4; i++) {\n      writeU32(out, this.state[i], i * 4);\n      this.state[i] = 0;\n    }\n\n    for (let i = 0; i < 16; i++) this.msg[i] = 0;\n\n    for (let i = 0; i < 64; i++) this.block[i] = 0;\n\n    this.size = FINALIZED;\n    return out;\n  }\n\n  _transform(chunk, pos) {\n    const W = this.msg;\n    let a = this.state[0];\n    let b = this.state[1];\n    let c = this.state[2];\n    let d = this.state[3];\n\n    for (let i = 0; i < 16; i++) W[i] = readU32(chunk, pos + i * 4); // round 1\n\n\n    for (const i of [0, 4, 8, 12]) {\n      a = op1(a, b, c, d, W[i], 3);\n      d = op1(d, a, b, c, W[i + 1], 7);\n      c = op1(c, d, a, b, W[i + 2], 11);\n      b = op1(b, c, d, a, W[i + 3], 19);\n    } // round 2\n\n\n    for (let i = 0; i < 4; i++) {\n      a = op2(a, b, c, d, W[i], 3);\n      d = op2(d, a, b, c, W[i + 4], 5);\n      c = op2(c, d, a, b, W[i + 8], 9);\n      b = op2(b, c, d, a, W[i + 12], 13);\n    } // round 3\n\n\n    for (const i of [0, 2, 1, 3]) {\n      a = op3(a, b, c, d, W[i], 3);\n      d = op3(d, a, b, c, W[i + 8], 9);\n      c = op3(c, d, a, b, W[i + 4], 11);\n      b = op3(b, c, d, a, W[i + 12], 15);\n    }\n\n    this.state[0] += a;\n    this.state[1] += b;\n    this.state[2] += c;\n    this.state[3] += d;\n  }\n\n  static hash() {\n    return new MD4();\n  }\n\n  static hmac() {\n    return new HMAC(MD4, 64);\n  }\n\n  static digest(data) {\n    return MD4.ctx.init().update(data).final();\n  }\n\n  static root(left, right) {\n    assert(Buffer.isBuffer(left) && left.length === 16);\n    assert(Buffer.isBuffer(right) && right.length === 16);\n    return MD4.ctx.init().update(left).update(right).final();\n  }\n\n  static multi(x, y, z) {\n    const {\n      ctx\n    } = MD4;\n    ctx.init();\n    ctx.update(x);\n    ctx.update(y);\n    if (z) ctx.update(z);\n    return ctx.final();\n  }\n\n  static mac(data, key) {\n    return MD4.hmac().init(key).update(data).final();\n  }\n\n}\n/*\n * Static\n */\n\n\nMD4.native = 0;\nMD4.id = 'MD4';\nMD4.size = 16;\nMD4.bits = 128;\nMD4.blockSize = 64;\nMD4.zero = Buffer.alloc(16, 0x00);\nMD4.ctx = new MD4();\n/*\n * Helpers\n */\n\nfunction f(x, y, z) {\n  return x & y | ~x & z;\n}\n\nfunction g(x, y, z) {\n  return x & y | x & z | y & z;\n}\n\nfunction h(x, y, z) {\n  return x ^ y ^ z;\n}\n\nfunction op1(a, b, c, d, k, s) {\n  return rotl32(a + f(b, c, d) + k, s);\n}\n\nfunction op2(a, b, c, d, k, s) {\n  return rotl32(a + g(b, c, d) + k + 0x5a827999, s);\n}\n\nfunction op3(a, b, c, d, k, s) {\n  return rotl32(a + h(b, c, d) + k + 0x6ed9eba1, s);\n}\n\nfunction rotl32(w, b) {\n  return w << b | w >>> 32 - b;\n}\n\nfunction readU32(data, off) {\n  return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;\n}\n\nfunction writeU32(dst, num, off) {\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  return off;\n}\n/*\n * Expose\n */\n\n\nmodule.exports = MD4;","map":null,"metadata":{},"sourceType":"script"}