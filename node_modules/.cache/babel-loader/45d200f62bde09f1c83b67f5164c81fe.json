{"ast":null,"code":"import BigNumber from 'bignumber.js';\nimport { currency, isCashtabOutput, extractCashtabMessage, extractExternalMessage } from '@components/Common/Ticker';\nimport { toSmallestDenomination, fromSmallestDenomination, isValidStoredWallet, convertToEcashPrefix } from '@utils/cashMethods';\nimport { postPayment } from '@utils/bip70';\nimport { TXUtil, authPubKeys, buildOutScript } from '@utils/selfMint';\nimport cashaddr from 'ecashaddrjs';\nimport { U64 } from 'n64';\n\nconst Input = require('@utils/bcash/primitives/input');\n\nconst Output = require('@utils/bcash/primitives/output');\n\nconst Outpoint = require('@utils/bcash/primitives/outpoint');\n\nconst Coin = require('@utils/bcash/primitives/coin');\n\nconst MTX = require('@utils/bcash/primitives/mtx');\n\nconst TX = require('@utils/bcash/primitives/tx');\n\nconst KeyRing = require('@utils/bcash/primitives/keyring');\n\nconst Script = require('@utils/bcash/script/script');\n\nconst Opcode = require('@utils/bcash/script/opcode');\n\nconst utils = require('@utils/bcash/utils/index'); // import { \n//     Input,\n//     Output,\n//     Outpoint,\n//     Coin, \n//     MTX,\n//     TX,\n//     KeyRing,\n//     Script,\n//     Opcode,\n//     utils,\n//     script\n// } from '@utils/bcash/bcoin';\n\n\nimport { Hash160 } from 'bcrypto';\nimport { read } from 'bufio';\nimport { PaymentDetails } from 'b70';\n\nconst SLP = require('@utils/bcash/script/slp');\n\nconst common = require('@utils/bcash/script/common');\n\nconst opcodes = common.opcodes; // const { \n//     SLP,\n//     common: { opcodes }\n// } = script;\n\nexport default function useBCH() {\n  const SEND_BCH_ERRORS = {\n    INSUFFICIENT_FUNDS: 0,\n    NETWORK_ERROR: 1,\n    INSUFFICIENT_PRIORITY: 66,\n    // ~insufficient fee\n    DOUBLE_SPENDING: 18,\n    MAX_UNCONFIRMED_TXS: 64\n  };\n  const POSTAGE_URL = `${currency.postageUrl}?currency=${currency.tokenPrefixes[0]}`;\n\n  const getPostage = async tokenId => {\n    try {\n      const res = await fetch(POSTAGE_URL);\n      const postageObj = await res.json();\n      const stamp = postageObj.stamps.find(s => s.tokenId === tokenId);\n\n      if (stamp) {\n        return {\n          address: postageObj.address,\n          weight: postageObj.weight,\n          stamp\n        };\n      }\n    } catch (err) {\n      console.error(err);\n    }\n\n    return null;\n  };\n\n  const calculatePostage = (inputCount, tokenRecipientCount, postageObj) => {\n    const sendAmountArray = ['1', '1']; // Begin with stamp output and change\n\n    for (let i = 0; i < tokenRecipientCount; i++) {\n      sendAmountArray.push('1');\n    }\n\n    const sendOpReturn = buildSendOpReturn(Buffer.alloc(32).toString('hex'), sendAmountArray);\n    let byteCount = getByteCount({\n      P2PKH: inputCount\n    }, {\n      P2PKH: sendAmountArray.length\n    });\n    byteCount += 8 + 1 + sendOpReturn.length; // Account for difference in inputs and outputs\n\n    byteCount += 546 * (sendAmountArray.length - inputCount);\n    let stampsNeeded = Math.ceil(byteCount / postageObj.weight); // console.log('byteCount', byteCount);\n    // console.log('stampsNeeded', stampsNeeded);\n\n    if (stampsNeeded < 1) stampsNeeded = 1;\n    return postageObj.stamp.rate * stampsNeeded;\n  };\n\n  const getBcashRestUrl = () => {\n    return process.env.REACT_APP_BCASH_API;\n  };\n\n  const parseTxData = (wallet, txData) => {\n    /*\n    Desired output\n    [\n    {\n    txid: '',\n    type: send, receive\n    receivingAddress: '',\n    quantity: amount bcha\n    token: true/false\n    tokenInfo: {\n        tokenId:\n        tokenQty:\n        txType: mint, send, other\n    }\n    opReturnMessage: 'message extracted from asm' or ''\n    }\n    ]\n    */\n    const ownAddressArray = [wallet.Path245.cashAddress, wallet.Path145.cashAddress, wallet.Path1899.cashAddress];\n    const parsedTxHistory = [];\n\n    for (let i = 0; i < txData.length; i += 1) {\n      const tx = txData[i];\n      const parsedTx = {}; // Move over info that does not need to be calculated\n\n      parsedTx.txid = tx.hash;\n      parsedTx.height = tx.height;\n      const destinationOutput = tx.outputs.find(output => output.address);\n      const destinationAddress = destinationOutput === null || destinationOutput === void 0 ? void 0 : destinationOutput.address; // If this tx had too many inputs to be parsed skip it\n      // When this occurs, the tx will only have txid and height\n      // So, it will not have 'vin'\n\n      if (!Object.keys(tx).includes('inputs')) {\n        // Populate as a limited-info tx that can be expanded in a block explorer\n        parsedTxHistory.push(parsedTx);\n        continue;\n      }\n\n      parsedTx.confirmations = tx.confirmations;\n      parsedTx.blocktime = tx.time;\n      let amountSent = 0;\n      let amountReceived = 0;\n      let opReturnMessage = '';\n      let isCashtabMessage = false; // Assume an incoming transaction\n\n      let outgoingTx = false;\n      let tokenTx = false;\n      let substring = ''; // get the address of the sender for this tx and encode into eCash address\n\n      let senderAddress = tx.inputs[0].coin.address; // If input includes tx address, this is an outgoing tx\n      // Note that with bch-input data, we do not have input amounts\n\n      for (let j = 0; j < tx.inputs.length; j += 1) {\n        const thisInput = tx.inputs[j];\n\n        if (ownAddressArray.includes(thisInput.coin.address)) {\n          // This is an outgoing transaction\n          outgoingTx = true;\n        }\n      } // Iterate over vout to find how much was sent or received\n\n\n      for (let j = 0; j < tx.outputs.length; j += 1) {\n        const thisOutput = tx.outputs[j]; // If there is no addresses object in the output, it's either an OP_RETURN msg or token tx\n\n        if (!thisOutput.address) {\n          let hex = thisOutput.script;\n\n          if (tx.slpToken) {\n            // this is an eToken transaction\n            tokenTx = true;\n            parsedTx.tokenInfo = parseTokenInfoForTxHistory(tx, ownAddressArray);\n          } else if (isCashtabOutput(hex)) {\n            // this is a cashtab.com generated message\n            try {\n              substring = extractCashtabMessage(hex);\n              opReturnMessage = Buffer.from(substring, 'hex');\n              isCashtabMessage = true;\n            } catch (err) {\n              // soft error if an unexpected or invalid cashtab hex is encountered\n              opReturnMessage = '';\n              console.log('useBCH.parsedTxHistory() error: invalid cashtab msg hex: ' + substring);\n            }\n          } else {\n            // this is an externally generated message\n            try {\n              substring = extractExternalMessage(hex);\n              opReturnMessage = Buffer.from(substring, 'hex');\n            } catch (err) {\n              // soft error if an unexpected or invalid cashtab hex is encountered\n              opReturnMessage = '';\n              console.log('useBCH.parsedTxHistory() error: invalid external msg hex: ' + substring);\n            }\n          }\n\n          continue; // skipping the remainder of tx data parsing logic in both token and OP_RETURN tx cases\n        }\n\n        if (thisOutput.address && ownAddressArray.includes(thisOutput.address)) {\n          if (outgoingTx) {\n            // This amount is change\n            continue;\n          }\n\n          amountReceived += fromSmallestDenomination(thisOutput.value);\n        } else if (outgoingTx) {\n          amountSent += fromSmallestDenomination(thisOutput.value);\n        }\n      } // Construct parsedTx\n\n\n      parsedTx.amountSent = amountSent;\n      parsedTx.amountReceived = amountReceived;\n      parsedTx.tokenTx = tokenTx;\n      parsedTx.outgoingTx = outgoingTx;\n      parsedTx.replyAddress = senderAddress;\n      parsedTx.destinationAddress = destinationAddress;\n      parsedTx.opReturnMessage = opReturnMessage;\n      parsedTx.isCashtabMessage = isCashtabMessage; // Add token info\n\n      parsedTxHistory.push(parsedTx);\n    }\n\n    return parsedTxHistory;\n  };\n\n  const getTxHistoryBcash = async function (addresses) {\n    let limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 30;\n    let reverse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const result = [];\n    const utxoPromises = addresses.map(address => {\n      const addr = convertToEcashPrefix(address);\n      result.push({\n        address: addr\n      });\n      return fetch(`${getBcashRestUrl()}/tx/address/${addr}?slp=true&limit=${limit}&reverse=${reverse}`).then(res => res.json());\n    });\n    const txs = await Promise.all(utxoPromises);\n    let allTxs = [];\n\n    for (let i = 0; i < txs.length; i++) {\n      allTxs = [...allTxs, ...txs[i]];\n    }\n\n    return allTxs;\n  };\n\n  const parseTokenInfoForTxHistory = (unparsedTx, ownAddressArray) => {\n    // Get transaction type by finding first\n    const transactionType = unparsedTx.outputs.find(output => output.slp).slp.type;\n    let qtyReceived = new BigNumber(0);\n    let qtySent = new BigNumber(0); // Scan over tx to find out how much was sent and received\n\n    const totalSent = unparsedTx.inputs.filter(input => input.coin.slp && ownAddressArray.includes(input.coin.address) && transactionType != 'MINT').reduce((prev, curr) => prev.plus(curr.coin.slp.value), new BigNumber(0));\n    const totalReceived = unparsedTx.outputs.filter(output => output.slp && ownAddressArray.includes(output.address) && output.slp.type != 'BATON').reduce((prev, curr) => prev.plus(curr.slp.value), new BigNumber(0)); // Check to see if this is either a sent or received transaction\n\n    const divisor = 10 ** parseInt(unparsedTx.slpToken.decimals);\n\n    if (totalSent.gte(totalReceived)) {\n      qtySent = totalSent.minus(totalReceived).div(divisor);\n    } else {\n      qtyReceived = totalReceived.minus(totalSent).div(divisor);\n    }\n\n    const cashtabTokenInfo = {};\n    cashtabTokenInfo.qtySent = qtySent.toString();\n    cashtabTokenInfo.qtyReceived = qtyReceived.toString();\n    cashtabTokenInfo.tokenId = unparsedTx.slpToken.tokenId;\n    cashtabTokenInfo.tokenName = unparsedTx.slpToken.name;\n    cashtabTokenInfo.tokenTicker = unparsedTx.slpToken.ticker;\n    cashtabTokenInfo.transactionType = transactionType;\n    return cashtabTokenInfo;\n  };\n\n  const getUtxoBcash = async (hash, index) => {\n    return fetch(`${getBcashRestUrl()}/coin/${hash}/${index}?slp=true`).then(res => res.json()).catch(err => null);\n  };\n\n  const getUtxosBcash = async addresses => {\n    const result = [];\n    const utxoPromises = addresses.map(address => {\n      const addr = convertToEcashPrefix(address);\n      result.push({\n        address: addr\n      });\n      return fetch(`${getBcashRestUrl()}/coin/address/${addr}?slp=true`).then(res => res.json());\n    });\n    const utxos = await Promise.all(utxoPromises);\n    let allUtxos = [];\n\n    for (let i = 0; i < utxos.length; i++) {\n      allUtxos = [...allUtxos, ...utxos[i]];\n    }\n\n    return allUtxos;\n  };\n\n  const getSlpBalancesAndUtxosBcash = async utxos => {\n    // Prevent app from treating slpUtxos as nonSlpUtxos\n    // Do not classify any utxos that include token information as nonSlpUtxos\n    const nonSlpUtxos = utxos.filter(utxo => !utxo.slp || utxo.slp && utxo.slp.value == '0'); // To be included in slpUtxos, the utxo must\n    // have utxo.isValid = true\n    // If utxo has a utxo.tokenQty field, i.e. not a minting baton, then utxo.value !== '0'\n\n    const slpUtxos = utxos.filter(utxo => utxo.slp && (utxo.slp.value != '0' || utxo.slp.type == 'MINT'));\n    let tokensById = {};\n\n    for (let i = 0; i < slpUtxos.length; i++) {\n      const slpUtxo = slpUtxos[i];\n      let token = tokensById[slpUtxo.slp.tokenId];\n\n      if (token) {\n        // Minting baton does nto have a slpUtxo.tokenQty type\n        token.hasBaton = slpUtxo.slp.type === 'BATON';\n\n        if (!token.hasBaton) {\n          token.balance = new BigNumber(token.balance).plus(new BigNumber(slpUtxo.slp.value));\n        }\n      } else {\n        token = {};\n        token.info = await fetch(`${getBcashRestUrl()}/token/${slpUtxo.slp.tokenId}`).then(res => res.json());\n        token.tokenId = slpUtxo.slp.tokenId;\n        token.hasBaton = slpUtxo.slp.type === 'BATON';\n\n        if (!token.hasBaton) {\n          token.balance = new BigNumber(slpUtxo.slp.value);\n        } else {\n          token.balance = new BigNumber(0);\n        }\n\n        tokensById[slpUtxo.slp.tokenId] = token;\n      }\n    }\n\n    const tokens = Object.values(tokensById); // console.log(`tokens`, tokens);\n\n    return {\n      tokens,\n      nonSlpUtxos,\n      slpUtxos\n    };\n  };\n\n  const getMintTxHistory = async minterPublicKey => {\n    return await fetch(`https://ecash.badger.cash:8332/tx/0c3817fbbd945277035d8adcab70f3c5b1eeb37ae08caf6cf78bd62e3535f81e?slp=true`).then(res => res.json()); // return await fetch(\n    //     `https://stats.bux.digital/tx/address/${wallet.Path1889}`\n    // ).then(res => res.json());\n  };\n\n  const parseMintTxData = txData => {\n    const parsedTxHistory = [];\n\n    for (let i = 0; i < txData.length; i += 1) {\n      const tx = txData[i];\n      const parsedTx = {}; // Move over info that does not need to be calculated\n\n      parsedTx.txid = tx.hash;\n      parsedTx.height = tx.height;\n      console.log(\"tx.outputs\", tx.outputs);\n      const destinationOutput = tx.outputs.find(output => output.address);\n      const destinationAddress = destinationOutput === null || destinationOutput === void 0 ? void 0 : destinationOutput.address; // If this tx had too many inputs to be parsed skip it\n      // When this occurs, the tx will only have txid and height\n      // So, it will not have 'vin'\n\n      if (!Object.keys(tx).includes('inputs')) {\n        // Populate as a limited-info tx that can be expanded in a block explorer\n        parsedTxHistory.push(parsedTx);\n        continue;\n      }\n\n      parsedTx.confirmations = tx.confirmations;\n      parsedTx.blocktime = tx.time;\n      let opReturnMessage = ''; // Assume an incoming transaction\n\n      let substring = '';\n      const divisor = 10 ** tx.slpToken.decimals;\n      const amountMinted = tx.outputs.filter(output => {\n        var _output$slp;\n\n        return ((_output$slp = output.slp) === null || _output$slp === void 0 ? void 0 : _output$slp.type) === 'MINT';\n      }).reduce((prev, curr) => prev.plus(curr.slp.value), new BigNumber(0)).div(divisor);\n      parsedTx.tokenInfo = {\n        qtySent: amountMinted.toString(),\n        // qtyMinted?,\n        qtyReceived: 0,\n        // replace for edge case self mint \n        tokenId: tx.slpToken.tokenId,\n        tokenName: tx.slpToken.name,\n        tokenTicker: tx.slpToken.ticker,\n        transactionType: 'MINT'\n      }; // Construct parsedTx\n\n      parsedTx.tokenTx = true; // always true\n\n      parsedTx.outgoingTx = true; // always true\n\n      parsedTx.destinationAddress = destinationAddress; // does that still make sense? yes\n\n      parsedTx.opReturnMessage = opReturnMessage;\n      parsedTx.isCashtabMessage = false; // always false\n      // Add token info\n\n      parsedTxHistory.push(parsedTx);\n    }\n\n    return parsedTxHistory;\n  };\n\n  const broadcastTx = async hex => {\n    return fetch(`${getBcashRestUrl()}/broadcast`, {\n      method: 'POST',\n      body: JSON.stringify({\n        tx: hex\n      })\n    }).then(res => res.json());\n  };\n\n  const getByteCount = (inputs, outputs) => {\n    // from https://github.com/bitcoinjs/bitcoinjs-lib/issues/921#issuecomment-354394004\n    let totalWeight = 0;\n    let hasWitness = false; // assumes compressed pubkeys in all cases.\n\n    const types = {\n      inputs: {\n        \"MULTISIG-P2SH\": 49 * 4,\n        \"MULTISIG-P2WSH\": 6 + 41 * 4,\n        \"MULTISIG-P2SH-P2WSH\": 6 + 76 * 4,\n        P2PKH: 148 * 4,\n        P2WPKH: 108 + 41 * 4,\n        \"P2SH-P2WPKH\": 108 + 64 * 4\n      },\n      outputs: {\n        P2SH: 32 * 4,\n        P2PKH: 34 * 4,\n        P2WPKH: 31 * 4,\n        P2WSH: 43 * 4\n      }\n    };\n    Object.keys(inputs).forEach(function (key) {\n      if (key.slice(0, 8) === \"MULTISIG\") {\n        // ex. \"MULTISIG-P2SH:2-3\" would mean 2 of 3 P2SH MULTISIG\n        const keyParts = key.split(\":\");\n        if (keyParts.length !== 2) throw new Error(`invalid input: ${key}`);\n        const newKey = keyParts[0];\n        const mAndN = keyParts[1].split(\"-\").map(function (item) {\n          return parseInt(item);\n        });\n        totalWeight += types.inputs[newKey] * inputs[key];\n        const multiplyer = newKey === \"MULTISIG-P2SH\" ? 4 : 1;\n        totalWeight += (73 * mAndN[0] + 34 * mAndN[1]) * multiplyer;\n      } else {\n        totalWeight += types.inputs[key] * inputs[key];\n      }\n\n      if (key.indexOf(\"W\") >= 0) hasWitness = true;\n    });\n    Object.keys(outputs).forEach(function (key) {\n      totalWeight += types.outputs[key] * outputs[key];\n    });\n    if (hasWitness) totalWeight += 2;\n    totalWeight += 10 * 4;\n    return Math.ceil(totalWeight / 4);\n  };\n\n  const calcFee = function (utxos) {\n    let p2pkhOutputNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    let satoshisPerByte = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : currency.defaultFee;\n    const byteCount = getByteCount({\n      P2PKH: utxos.length\n    }, {\n      P2PKH: p2pkhOutputNumber\n    });\n    const txFee = Math.ceil(satoshisPerByte * byteCount);\n    return txFee;\n  };\n\n  const buildGenesisOpReturn = configObj => {\n    const stringsArray = ['ticker', 'name', 'documentUrl'];\n    const pushEmptyOp = new Opcode(opcodes.OP_PUSHDATA1, Buffer.alloc(0));\n    const genesisOpReturn = new Script().pushSym('return').pushData(Buffer.concat([Buffer.from('SLP', 'ascii'), Buffer.alloc(1)])).pushPush(Buffer.alloc(1, 1)).pushData(Buffer.from('GENESIS', 'ascii')); // Push metadata strings\n\n    for (let i = 0; i < stringsArray.length; i++) {\n      const item = configObj[stringsArray[i]];\n      if (item && typeof item === 'string' && item.length > 0) genesisOpReturn.pushString(item);else genesisOpReturn.push(pushEmptyOp);\n    } // Document Hash\n\n\n    if (configObj.documentHash) {\n      const documentHash = typeof configObj.documentHash === 'string' ? Buffer.from(configObj.documentHash, 'hex') : configObj.documentHash;\n      if (!Buffer.isBuffer(documentHash) || documentHash.length != 0 && documentHash.length != 32) throw new Error('documentHash must be hex string or buffer of 32 bytes or less');\n      if (documentHash.length === 0) genesisOpReturn.push(pushEmptyOp);else genesisOpReturn.pushPush(documentHash);\n    } else genesisOpReturn.push(pushEmptyOp); // Decimals\n\n\n    const decimalInt = parseInt(configObj.decimals);\n    if (decimalInt > 9 || decimalInt < 0) throw new Error('decimal value must be a number between 0 and 9');\n    genesisOpReturn.pushPush(Buffer.alloc(1, decimalInt)); // Mint baton\n\n    if (configObj.mintBatonVout) {\n      const batonInt = parseInt(configObj.mintBatonVout);\n      if (batonInt != 2) throw new Error('mintBaton must equal 2');\n      genesisOpReturn.pushPush(Buffer.alloc(1, batonInt));\n    } else genesisOpReturn.push(pushEmptyOp); // Quantity\n\n\n    genesisOpReturn.pushData(U64.fromString(configObj.initialQty).muln(10 ** decimalInt).toBE(Buffer)).compile();\n    return genesisOpReturn;\n  };\n\n  const buildMintOpReturn = (tokenId, mintQuantityBufBE) => {\n    const mintOpReturn = new Script().pushSym('return').pushData(Buffer.concat([Buffer.from('SLP', 'ascii'), Buffer.alloc(1)])).pushPush(Buffer.alloc(1, 1)).pushData(Buffer.from('MINT', 'ascii')).pushData(tokenId).pushPush(Buffer.alloc(1, 2)).pushData(mintQuantityBufBE).compile();\n    return mintOpReturn;\n  };\n\n  const buildSendOpReturn = function (tokenId, sendQuantityArray) {\n    let version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const sendOpReturn = new Script().pushSym('return').pushData(Buffer.concat([Buffer.from('SLP', 'ascii'), Buffer.alloc(1)])).pushPush(Buffer.alloc(1, version)).pushData(Buffer.from('SEND', 'ascii')).pushData(Buffer.from(tokenId, 'hex'));\n\n    for (let i = 0; i < sendQuantityArray.length; i++) {\n      const sendQuantity = sendQuantityArray[i];\n      sendOpReturn.pushData(U64.fromString(sendQuantity).toBE(Buffer));\n    }\n\n    return sendOpReturn.compile();\n  };\n\n  const createToken = async function (wallet, feeInSatsPerByte, configObj) {\n    let testOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    try {\n      // Throw error if wallet does not have utxo set in state\n      if (!isValidStoredWallet(wallet)) {\n        const walletError = new Error(`Invalid wallet`);\n        throw walletError;\n      }\n\n      const utxos = wallet.state.slpBalancesAndUtxos.nonSlpUtxos;\n      const CREATION_ADDR = wallet.Path1899.cashAddress;\n      const coins = utxos.map(utxo => Coin.fromJSON(utxo));\n      const tx = new MTX(); // Generate the OP_RETURN entry for an SLP GENESIS transaction.\n\n      const genesisOpReturn = buildGenesisOpReturn(configObj); // OP_RETURN needs to be the first output in the transaction.\n\n      tx.addOutput(genesisOpReturn, 0); // add output w/ address and amount to send\n\n      tx.addOutput(CREATION_ADDR, currency.etokenSats); // Add mint baton output\n\n      if (configObj.mintBatonVout) tx.addOutput(CREATION_ADDR, currency.etokenSats);\n      await tx.fund(coins, {\n        changeAddress: CREATION_ADDR,\n        rate: feeInSatsPerByte * 1000 // 1000 sats per kb = 1 sat/b\n\n      });\n      const keyRingArray = [KeyRing.fromSecret(wallet.Path245.fundingWif), KeyRing.fromSecret(wallet.Path145.fundingWif), KeyRing.fromSecret(wallet.Path1899.fundingWif)];\n      tx.sign(keyRingArray); // output rawhex\n\n      const hex = tx.toRaw().toString('hex'); // Broadcast transaction to the network\n\n      let broadcast = {\n        success: true\n      };\n      if (!testOnly) broadcast = await broadcastTx(hex);\n      const txidStr = tx.txid().toString('hex');\n\n      if (broadcast.success) {\n        console.log(`${currency.ticker} txid`, txidStr);\n      }\n\n      let link;\n\n      if (process.env.REACT_APP_NETWORK === `mainnet`) {\n        link = `${currency.tokenExplorerUrl}/tx/${txidStr}`;\n      } else {\n        link = `${currency.blockExplorerUrlTestnet}/tx/${txidStr}`;\n      } //console.log(`link`, link);\n\n\n      return link;\n    } catch (err) {\n      if (err.error === 'insufficient priority (code 66)') {\n        err.code = SEND_BCH_ERRORS.INSUFFICIENT_PRIORITY;\n      } else if (err.error === 'txn-mempool-conflict (code 18)') {\n        err.code = SEND_BCH_ERRORS.DOUBLE_SPENDING;\n      } else if (err.error === 'Network Error') {\n        err.code = SEND_BCH_ERRORS.NETWORK_ERROR;\n      } else if (err.error === 'too-long-mempool-chain, too many unconfirmed ancestors [limit: 25] (code 64)') {\n        err.code = SEND_BCH_ERRORS.MAX_UNCONFIRMED_TXS;\n      }\n\n      console.log(`error: `, err);\n      throw err;\n    }\n  };\n\n  const sendToken = async function (wallet, _ref, feeInSatsPerByte) {\n    let {\n      tokenId,\n      amount,\n      tokenReceiverAddress,\n      postageData\n    } = _ref;\n    let testOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    // Get change address from sending utxos\n    // fall back to what is stored in wallet\n    const REMAINDER_ADDR = wallet.Path1899.cashAddress;\n    const slpBalancesAndUtxos = wallet.state.slpBalancesAndUtxos; // Handle error of user having no BCH and not using post office\n\n    if (slpBalancesAndUtxos.nonSlpUtxos.length === 0 && !postageData) {\n      throw new Error(`You need some ${currency.ticker} to send ${currency.tokenTicker}`);\n    }\n\n    const nonSlpCoins = slpBalancesAndUtxos.nonSlpUtxos.map(utxo => Coin.fromJSON(utxo));\n    const tokenUtxos = slpBalancesAndUtxos.slpUtxos.filter(utxo => {\n      if (utxo && // UTXO is associated with a token.\n      utxo.slp.tokenId === tokenId && // UTXO matches the token ID.\n      utxo.slp.type !== 'BATON' // UTXO is not a minting baton.\n      ) {\n        return true;\n      }\n\n      return false;\n    });\n\n    if (tokenUtxos.length === 0) {\n      throw new Error('No token UTXOs for the specified token could be found.');\n    } // Get Info for token being sent\n\n\n    const tokenInfo = slpBalancesAndUtxos.tokens.find(token => token.tokenId == tokenId).info;\n    console.log(\"tokenInfo\", tokenInfo); // BEGIN transaction construction.\n\n    const tx = new MTX();\n    let finalTokenAmountSent = new BigNumber(0); // TODO: Handle multiple token outputs\n\n    let postageAmount = new BigNumber(0);\n    let tokenAmountBeingSentToAddress = new BigNumber(amount).times(10 ** tokenInfo.decimals);\n    let totalTokenOutputAmount = tokenAmountBeingSentToAddress;\n    const tokenCoins = [];\n\n    for (let i = 0; i < tokenUtxos.length; i++) {\n      const tokenCoin = Coin.fromJSON(tokenUtxos[i]);\n      tokenCoins.push(tokenCoin);\n      finalTokenAmountSent = finalTokenAmountSent.plus(new BigNumber(tokenUtxos[i].slp.value)); // Handle postage\n\n      if (postageData) {\n        const postageBaseAmount = calculatePostage(tokenCoins.length, 1, postageData);\n        postageAmount = new BigNumber(postageBaseAmount);\n      }\n\n      totalTokenOutputAmount = tokenAmountBeingSentToAddress.plus(postageAmount);\n\n      if (totalTokenOutputAmount.lte(finalTokenAmountSent)) {\n        break;\n      }\n    }\n\n    const tokenAmountArray = [tokenAmountBeingSentToAddress.toString()]; // Add postage to output array if exists\n\n    if (postageAmount.gt(0)) tokenAmountArray.push(postageAmount.toString()); // Add change if any\n\n    const tokenChangeAmount = finalTokenAmountSent.minus(totalTokenOutputAmount);\n    if (tokenChangeAmount.gt(0)) tokenAmountArray.push(tokenChangeAmount.toString());\n    const sendOpReturn = buildSendOpReturn(tokenId, tokenAmountArray, tokenInfo.version); // Add OP_RETURN as first output.\n\n    tx.addOutput(sendOpReturn, 0); // Send dust representing tokens being sent.\n\n    const decodedTokenReceiverAddress = cashaddr.decode(tokenReceiverAddress);\n    const cleanTokenReceiverAddress = cashaddr.encode('ecash', decodedTokenReceiverAddress.type, decodedTokenReceiverAddress.hash); // Add destination output\n\n    tx.addOutput(cleanTokenReceiverAddress, currency.etokenSats); // Add postage output is any\n\n    if (postageAmount.gt(0)) {\n      const decodedPostageAddress = cashaddr.decode(postageData.address);\n      const cleanPostageAddress = cashaddr.encode('ecash', decodedPostageAddress.type, decodedPostageAddress.hash);\n      tx.addOutput(cleanPostageAddress, currency.etokenSats);\n    } // Send token change if there is any\n\n\n    if (tokenChangeAmount.gt(0)) {\n      tx.addOutput(REMAINDER_ADDR, currency.etokenSats);\n    } // If post office is selected\n\n\n    if (postageData) {\n      for (let i = 0; i < tokenCoins.length; i++) {\n        tx.addCoin(tokenCoins[i]);\n      }\n    } else {\n      // If post office not being used, add native tokens as gas\n      await tx.fund([...tokenCoins, ...nonSlpCoins], {\n        inputs: tokenCoins.map(coin => Input.fromCoin(coin).prevout),\n        changeAddress: REMAINDER_ADDR,\n        rate: feeInSatsPerByte * 1000 // 1000 sats per kb = 1 sat/b\n\n      });\n    }\n\n    const keyRingArray = [KeyRing.fromSecret(wallet.Path245.fundingWif), KeyRing.fromSecret(wallet.Path145.fundingWif), KeyRing.fromSecret(wallet.Path1899.fundingWif)]; // Set Sighash type\n\n    const hashTypes = Script.hashType;\n    const sighashType = postageData ? hashTypes.ALL | hashTypes.ANYONECANPAY | hashTypes.SIGHASH_FORKID : hashTypes.ALL | hashTypes.SIGHASH_FORKID; // Sign transaction\n\n    tx.sign(keyRingArray, sighashType); // output rawhex\n\n    let txidStr;\n    const rawTx = tx.toRaw();\n    const hex = rawTx.toString('hex');\n    console.log('hex', hex);\n    const paymentObj = {\n      merchantData: Buffer.alloc(0),\n      transactions: [rawTx],\n      refundTo: [{\n        script: Script.fromAddress(REMAINDER_ADDR).toRaw(),\n        value: 0\n      }],\n      memo: ''\n    }; // Broadcast if postage enabled\n\n    if (postageData) {\n      let paymentAck;\n\n      if (!testOnly) {\n        paymentAck = await postPayment(POSTAGE_URL, paymentObj, currency.tokenPrefixes[0]);\n      }\n\n      if (paymentAck.payment) {\n        const transactionIds = paymentAck.payment.transactions.map(t => TX.fromRaw(t).txid());\n        txidStr = transactionIds[0];\n        console.log(`${currency.tokenTicker} txid`, txidStr);\n      }\n    } else {\n      // Broadcast transaction to the network\n      let broadcast = {\n        success: true\n      };\n      if (!testOnly) broadcast = await broadcastTx(hex);\n      txidStr = tx.txid().toString('hex');\n\n      if (broadcast.success) {\n        console.log(`${currency.tokenTicker} txid`, txidStr);\n      }\n    }\n\n    let link;\n\n    if (process.env.REACT_APP_NETWORK === `mainnet`) {\n      link = `${currency.tokenExplorerUrl}/tx/${txidStr}`;\n    } else {\n      link = `${currency.blockExplorerUrlTestnet}/tx/${txidStr}`;\n    } //console.log(`link`, link);\n\n\n    return link;\n  };\n\n  const signPkMessage = async (pk, message) => {\n    try {\n      const keyring = KeyRing.fromSecret(pk);\n      const sig = utils.message.sign(message, keyring);\n      return sig.toString('base64');\n    } catch (err) {\n      console.log(`useBCH.signPkMessage() error: `, err);\n      throw err;\n    }\n  };\n\n  const sendXec = async function (wallet, feeInSatsPerByte, optionalOpReturnMsg, isOneToMany, destinationAddressAndValueArray, destinationAddress, sendAmount) {\n    let testOnly = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n\n    try {\n      let value = new BigNumber(0);\n      const tx = new MTX();\n\n      if (isOneToMany) {\n        // this is a one to many XEC transaction\n        if (!destinationAddressAndValueArray || !destinationAddressAndValueArray.length) {\n          throw new Error('Invalid destinationAddressAndValueArray');\n        }\n\n        const arrayLength = destinationAddressAndValueArray.length;\n\n        for (let i = 0; i < arrayLength; i++) {\n          // add the total value being sent in this array of recipients\n          value = BigNumber.sum(value, new BigNumber(destinationAddressAndValueArray[i].split(',')[1]));\n        } // If user is attempting to send an aggregate value that is less than minimum accepted by the backend\n\n\n        if (value.lt(new BigNumber(fromSmallestDenomination(currency.dustSats).toString()))) {\n          // Throw the same error given by the backend attempting to broadcast such a tx\n          throw new Error('dust');\n        }\n      } else {\n        // this is a one to one XEC transaction then check sendAmount\n        // note: one to many transactions won't be sending a single sendAmount\n        if (!sendAmount) {\n          return null;\n        }\n\n        value = new BigNumber(sendAmount); // If user is attempting to send less than minimum accepted by the backend\n\n        if (value.lt(new BigNumber(fromSmallestDenomination(currency.dustSats).toString()))) {\n          // Throw the same error given by the backend attempting to broadcast such a tx\n          throw new Error('dust');\n        }\n      }\n\n      const satoshisToSend = toSmallestDenomination(value); // Throw validation error if toSmallestDenomination returns false\n\n      if (!satoshisToSend) {\n        const error = new Error(`Invalid decimal places for send amount`);\n        throw error;\n      } // Start of building the OP_RETURN output.\n      // only build the OP_RETURN output if the user supplied it\n\n\n      if (typeof optionalOpReturnMsg !== 'undefined' && optionalOpReturnMsg.trim() !== '') {\n        const script = new Script().pushSym('return').pushData(Buffer.from(currency.opReturn.appPrefixesHex.cashtab, 'hex')).pushString(optionalOpReturnMsg).compile();\n        tx.addOutput(script, 0);\n      } // End of building the OP_RETURN output.\n\n\n      const utxos = wallet.state.slpBalancesAndUtxos.nonSlpUtxos;\n      let coins = [];\n\n      for (let i = 0; i < utxos.length; i++) {\n        const utxo = utxos[i];\n        coins.push(Coin.fromJSON(utxo));\n      } // Get change address from sending utxos\n      // fall back to what is stored in wallet\n\n\n      const REMAINDER_ADDR = wallet.Path1899.cashAddress;\n\n      if (isOneToMany) {\n        // for one to many mode, add the multiple outputs from the array\n        let arrayLength = destinationAddressAndValueArray.length;\n\n        for (let i = 0; i < arrayLength; i++) {\n          // add each send tx from the array as an output\n          let outputAddress = destinationAddressAndValueArray[i].split(',')[0];\n          let outputValue = new BigNumber(destinationAddressAndValueArray[i].split(',')[1]);\n          tx.addOutput(outputAddress, parseInt(toSmallestDenomination(outputValue)));\n        }\n      } else {\n        // for one to one mode, add output w/ single address and amount to send\n        tx.addOutput(destinationAddress, parseInt(toSmallestDenomination(value)));\n      }\n\n      await tx.fund(coins, {\n        changeAddress: REMAINDER_ADDR,\n        rate: feeInSatsPerByte * 1000 // 1000 sats per kb = 1 sat/b\n\n      });\n      const keyRingArray = [KeyRing.fromSecret(wallet.Path245.fundingWif), KeyRing.fromSecret(wallet.Path145.fundingWif), KeyRing.fromSecret(wallet.Path1899.fundingWif)];\n      tx.sign(keyRingArray); // output rawhex\n\n      const hex = tx.toRaw().toString('hex'); // Broadcast transaction to the network\n\n      let broadcast = {\n        success: true\n      };\n      if (!testOnly) broadcast = await broadcastTx(hex);\n      const txidStr = tx.txid().toString('hex');\n\n      if (broadcast.success) {\n        console.log(`${currency.ticker} txid`, txidStr);\n      }\n\n      let link;\n\n      if (process.env.REACT_APP_NETWORK === `mainnet`) {\n        link = `${currency.blockExplorerUrl}/tx/${txidStr}`;\n      } else {\n        link = `${currency.blockExplorerUrlTestnet}/tx/${txidStr}`;\n      } //console.log(`link`, link);\n\n\n      return link;\n    } catch (err) {\n      if (err.error === 'insufficient priority (code 66)') {\n        err.code = SEND_BCH_ERRORS.INSUFFICIENT_PRIORITY;\n      } else if (err.error === 'txn-mempool-conflict (code 18)') {\n        err.code = SEND_BCH_ERRORS.DOUBLE_SPENDING;\n      } else if (err.error === 'Network Error') {\n        err.code = SEND_BCH_ERRORS.NETWORK_ERROR;\n      } else if (err.error === 'too-long-mempool-chain, too many unconfirmed ancestors [limit: 25] (code 64)') {\n        err.code = SEND_BCH_ERRORS.MAX_UNCONFIRMED_TXS;\n      }\n\n      console.log(`error: `, err);\n      throw err;\n    }\n  };\n\n  const sendBip70 = async function (wallet, paymentDetails, // b70.PaymentDetails\n  feeInSatsPerByte) {\n    let testOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let isPreburn = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    let rawChainTxs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n    // Get change address from sending utxos\n    // fall back to what is stored in wallet\n    const REMAINDER_ADDR = wallet.Path1899.cashAddress;\n    const refundOutput = new Output({\n      address: REMAINDER_ADDR\n    });\n    const slpBalancesAndUtxos = wallet.state.slpBalancesAndUtxos;\n    let nonSlpCoins = slpBalancesAndUtxos.nonSlpUtxos.map(utxo => Coin.fromJSON(utxo)); // Check to see if this is an SLP/eToken transaction\n\n    const firstOutput = paymentDetails.outputs[0];\n    console.log('paymentDetails', paymentDetails); // console.log('paymentDetails.outputs', paymentDetails.outputs);\n\n    const slpScript = SLP.fromRaw(Buffer.from(firstOutput.script));\n    const isSlp = slpScript.isValidSlp();\n    let postagePaid = false;\n    const tokenCoins = []; // If is SLP\n\n    if (isSlp) {\n      const tokenIdBuf = slpScript.getData(4);\n      const tokenId = tokenIdBuf.toString('hex'); // Is Postage Paid by Merchant?\n\n      const merchantData = paymentDetails.getData('json'); // console.log('merchantData', merchantData)\n      // console.log('typeof merchantData', typeof merchantData)\n\n      if (typeof merchantData === \"object\" && merchantData.postage) {\n        const stamps = merchantData.postage.stamps;\n        const listing = stamps.find(stamp => stamp.tokenId == tokenId); // If postage is paid don't use native token funding\n\n        if (listing && listing.rate == 0) {\n          postagePaid = true;\n        }\n      }\n\n      console.log('postagePaid', postagePaid); // Throw error if transaction type is not SEND\n\n      const slpType = slpScript.getType();\n      if (slpType !== 'SEND' && slpType !== 'BURN') throw new Error(`Token ${slpType} transactions not supported`); // Get required UTXOs\n\n      const sendRecords = slpScript.getRecords(tokenIdBuf);\n      const totalBase = sendRecords.reduce((total, record) => {\n        return total.add(U64.fromBE(Buffer.from(record.value)));\n      }, U64.fromInt(0));\n      let totalTokenBalance = U64.fromInt(0);\n      const token = wallet.state.tokens.find(token => token.tokenId === tokenId);\n\n      if (token) {\n        totalTokenBalance = U64.fromString(token.balance.toString());\n      }\n\n      if (totalTokenBalance.lt(totalBase) && rawChainTxs.length === 0) throw new Error('Insufficient token balance to complete transaction');\n      const tokenUtxos = []; // Add utxos from chained parent if present\n\n      if (rawChainTxs.length > 0) {\n        // If a chain TX is provided, use it for the input coins\n        const parentTx = TX.fromRaw(rawChainTxs[rawChainTxs.length - 1]); // Parse SLP script\n\n        const slpScript = script.SLP.fromRaw(parentTx.outputs[0].script.toRaw());\n        const records = slpScript.getRecords(Buffer.alloc(32)); // Iterate through parentTx outputs\n\n        for (let i = 0; i < parentTx.outputs.length; i++) {\n          var _parentTx$outputs$i$g;\n\n          const address = (_parentTx$outputs$i$g = parentTx.outputs[i].getAddress()) === null || _parentTx$outputs$i$g === void 0 ? void 0 : _parentTx$outputs$i$g.toString();\n\n          if (address === REMAINDER_ADDR) {\n            const record = records.find(r => r.type !== 'BATON' && r.vout === i);\n\n            if (record) {\n              // convert to coin first for compatibility\n              const coin = Coin.fromTX(parentTx, i, -1);\n              coin.slp = record;\n              const utxo = coin.toJSON(); // Add UTXO\n\n              tokenUtxos.push(utxo);\n            }\n          }\n        }\n      }\n\n      if (slpType === 'BURN' && !isPreburn) {\n        // Send up preburn split transaction\n        // Postage will be added and it will be cached on server\n        // Use UTXO from response as input UTXO for burn\n        // Clear utxo array in case rawChainTxs is present\n        tokenUtxos.length = 0; // First clone payment details to use with split tx\n\n        const splitDetails = PaymentDetails.fromOptions(paymentDetails); // Replace with split tx outputs\n\n        const sendTotalString = totalBase.toString();\n        const sendOpReturn = buildSendOpReturn(tokenId, [sendTotalString]);\n        const opReturnOut = {\n          script: sendOpReturn.toRaw(),\n          value: 0\n        };\n        const preburnOut = new Output({\n          address: REMAINDER_ADDR,\n          value: 546\n        });\n        splitDetails.outputs = [opReturnOut, {\n          script: preburnOut.script.toRaw(),\n          value: preburnOut.value\n        }]; // Send split tx and get Payment object back if successful\n\n        const splitPayment = await sendBip70(wallet, splitDetails, feeInSatsPerByte, false, true);\n        const merchantData = splitPayment.getData('json');\n        if (!merchantData.preburn) throw new Error('Burn failed: Preburn tx hash not returned from payment server'); // Use split UTXO as sole input UTXO\n\n        tokenUtxos.push({\n          version: 1,\n          height: -1,\n          coinbase: false,\n          script: preburnOut.script.toJSON(),\n          value: preburnOut.value,\n          hash: merchantData.preburn,\n          index: 1,\n          slp: {\n            vout: 1,\n            tokenId,\n            value: sendTotalString,\n            type: \"SEND\"\n          }\n        });\n      } else {\n        // Use available UTXOS in wallet\n        const availableTokenUtxos = slpBalancesAndUtxos.slpUtxos.filter(utxo => {\n          if (utxo && // UTXO is associated with a token.\n          utxo.slp.tokenId === tokenId && // UTXO matches the token ID.\n          utxo.slp.type !== 'BATON' // UTXO is not a minting baton.\n          ) {\n            return true;\n          }\n\n          return false;\n        });\n        tokenUtxos.push(...availableTokenUtxos);\n      }\n\n      if (tokenUtxos.length === 0) {\n        throw new Error('No token UTXOs for the specified token could be found.');\n      }\n\n      let finalTokenAmountSent = U64.fromInt(0);\n\n      for (let i = 0; i < tokenUtxos.length; i++) {\n        console.log('tokenUtxos', tokenUtxos);\n        const tokenCoin = Coin.fromJSON(tokenUtxos[i]);\n        tokenCoins.push(tokenCoin);\n        finalTokenAmountSent = finalTokenAmountSent.add(U64.fromString(tokenUtxos[i].slp.value));\n\n        if (totalBase.lte(finalTokenAmountSent)) {\n          // Add token change amount to SLP OP_RETURN\n          const tokenChangeAmount = finalTokenAmountSent.sub(totalBase); // Skip if change amount is zero\n\n          if (tokenChangeAmount.toInt() != 0) {\n            slpScript.pushData(tokenChangeAmount.toBE(Buffer)).compile(); // add additional output for change\n\n            paymentDetails.outputs[0].script = slpScript.toRaw();\n            paymentDetails.outputs.splice(sendRecords.length + 1, // Must skip OP_RETURN\n            0, {\n              script: refundOutput.script.toRaw(),\n              value: 546\n            });\n          }\n\n          break;\n        }\n      } // Handle error of user having no BCH and postage not paid\n\n\n      if (!postagePaid && slpBalancesAndUtxos.nonSlpUtxos.length === 0) {\n        throw new Error(`You need some ${currency.ticker} to send ${currency.tokenTicker}`);\n      }\n    } // Build Transaction\n\n\n    const tx = new MTX(); // Set SigHashType\n\n    let sigHashType = Script.hashType.ALL | Script.hashType.SIGHASH_FORKID; // Add required outputs\n\n    for (let i = 0; i < paymentDetails.outputs.length; i++) {\n      tx.addOutput(paymentDetails.outputs[i]);\n    }\n\n    if (postagePaid) {\n      // Postage Protocol requires ANYONECANPAY\n      sigHashType = Script.hashType.ANYONECANPAY | sigHashType;\n\n      for (let i = 0; i < tokenCoins.length; i++) {\n        tx.addCoin(tokenCoins[i]);\n      }\n    } else {\n      await tx.fund([...tokenCoins, ...nonSlpCoins], {\n        inputs: tokenCoins.map(coin => Input.fromCoin(coin).prevout),\n        changeAddress: REMAINDER_ADDR,\n        rate: feeInSatsPerByte * 1000 // 1000 sats per kb = 1 sat/b\n\n      });\n    }\n\n    const keyRingArray = [KeyRing.fromSecret(wallet.Path245.fundingWif), KeyRing.fromSecret(wallet.Path145.fundingWif), KeyRing.fromSecret(wallet.Path1899.fundingWif)];\n    tx.sign(keyRingArray, sigHashType); // output rawhex\n\n    const rawTx = tx.toRaw();\n    const hex = rawTx.toString('hex');\n    console.log('hex', hex); // Add on any \n\n    const rawTxs = [...rawChainTxs, rawTx];\n    const paymentObj = {\n      merchantData: Buffer.alloc(0),\n      transactions: rawTxs,\n      refundTo: [{\n        script: refundOutput.script.toRaw(),\n        value: 0\n      }],\n      memo: paymentDetails.memo\n    };\n    let txidStr = tx.txid().toString('hex'); // Broadcast transaction to the network\n\n    let paymentAck;\n\n    if (!testOnly) {\n      paymentAck = await postPayment(paymentDetails.paymentUrl, paymentObj, isSlp ? currency.tokenPrefixes[0] : currency.prefixes[0]);\n    }\n\n    if (paymentAck.payment) {\n      // Return the payment object from the ACK if is preburn\n      if (isPreburn) return paymentAck.payment;\n      const transactionIds = paymentAck.payment.transactions.map(t => TX.fromRaw(t).txid());\n      txidStr = transactionIds[0];\n      console.log(`${currency.tokenTicker} txid`, txidStr);\n    }\n\n    let link;\n\n    if (process.env.REACT_APP_NETWORK === `mainnet`) {\n      link = `${currency.tokenExplorerUrl}/tx/${txidStr}`;\n    } else {\n      link = `${currency.blockExplorerUrlTestnet}/tx/${txidStr}`;\n    } //console.log(`link`, link);\n\n\n    return link;\n  };\n\n  const readAuthCode = authCode => {\n    const authReader = read(Buffer.from(authCode, 'base64'));\n    const mintQuantity = authReader.readBytes(8);\n    const stampRawOutpoint = authReader.readBytes(36);\n    const stampOutpoint = Outpoint.fromRaw(stampRawOutpoint); // Auth signature is remaining bytes\n\n    const txAuthSig = authReader.readBytes(authReader.getSize() - authReader.offset);\n    return {\n      mintQuantity,\n      stampOutpoint,\n      txAuthSig\n    };\n  };\n\n  const sendSelfMint = async function (wallet, tokenId, // Buffer\n  authCode) {\n    let testOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let returnRawTx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n    try {\n      const tokenIdString = tokenId.toString('hex'); // Process entered Auth Code string\n\n      const {\n        mintQuantity,\n        stampOutpoint,\n        txAuthSig\n      } = readAuthCode(authCode); // console.log('stampRawoutpoint', stampRawOutpoint);\n      // console.log('txAuthSig', txAuthSig);\n      // Get authPubKey for token\n\n      const {\n        pubkey: authPubKey\n      } = authPubKeys.find(authObj => authObj.tokenId == tokenIdString); // console.log('authKeyBuf', Buffer.from(authPubKey, 'hex'));\n\n      if (!authPubKey) throw new Error(`Unsupported self-mint token ID: ${tokenIdString}`); // Build Baton Outscript\n\n      const outscript = buildOutScript(Buffer.from(authPubKey, 'hex'), false);\n      const outScriptHash = Hash160.digest(outscript.toRaw());\n      const p2shPubKeyScript = Script.fromScripthash(outScriptHash);\n      const p2shAddress = p2shPubKeyScript.getAddress(); // Find Baton\n\n      const batonAddrUtxos = await getUtxosBcash([p2shAddress.toCashAddr()]);\n      const batonUtxo = batonAddrUtxos.find(u => {\n        var _u$slp;\n\n        return ((_u$slp = u.slp) === null || _u$slp === void 0 ? void 0 : _u$slp.tokenId) == tokenIdString && u.slp.type == 'BATON';\n      }); // Stub coin/utxo for \"stamp\" and baton\n\n      const batonCoin = Coin.fromJSON(batonUtxo); // Build Stamp Outscript\n\n      const stampOutscript = buildOutScript(Buffer.from(authPubKey, 'hex'), true);\n      const stampOutScriptHash = Hash160.digest(stampOutscript.toRaw());\n      const stampP2shPubKeyScript = Script.fromScripthash(stampOutScriptHash);\n      const stampUtxo = await getUtxoBcash(stampOutpoint.txid().toString('hex'), stampOutpoint.index);\n      if (!stampUtxo) throw new Error('Stamp UTXO in auth code is spent or invalid');\n      const stampCoin = Coin.fromJSON(stampUtxo);\n      const keyring = KeyRing.fromSecret(wallet.Path1899.fundingWif); // Construct transaction\n\n      const tx = new TXUtil(); // Build MINT OP_RETURN\n\n      const mintOpReturn = buildMintOpReturn(tokenId, mintQuantity); // Add outputs\n\n      tx.addOutput(mintOpReturn, 0); // SLP mint OP_RETURN\n\n      tx.addOutput(keyring.getAddress(), 546); // Minted tokens\n\n      tx.addOutput(p2shAddress, 546); // Mint baton return\n      // Add inputs (must be in this order)\n\n      tx.addCoin(stampCoin); // Input index 0: \"stamp\"\n\n      tx.addCoin(batonCoin); // Input index 1: existing mint baton\n\n      const sigHashType = Script.hashType.ALL | Script.hashType.SIGHASH_FORKID;\n      const flags = Script.flags.STANDARD_VERIFY_FLAGS; // Sign TX\n\n      tx.template(keyring); // prepares the template\n      // Get the prevout and outputs sequences as they appear in the preimage\n\n      const rawOutputs = tx.outputs.map(output => output.toRaw());\n      const outputSeq = Buffer.concat(rawOutputs);\n      const rawPrevouts = tx.inputs.map(input => input.prevout.toRaw());\n      const prevoutSeq = Buffer.concat(rawPrevouts); // Sign The Stamp and Baton\n\n      for (let i = 0; i < 2; i++) {\n        const {\n          prevout\n        } = tx.inputs[i];\n        const p2shCoin = tx.view.getOutput(prevout);\n        const subscript = i == 0 ? stampOutscript : outscript;\n        const sig = tx.signature(i, subscript, p2shCoin.value, keyring.privateKey, sigHashType, flags);\n        const preimage = tx.getPreimage(i, subscript, p2shCoin.value, sigHashType, false);\n        const items = [sig, keyring.getPublicKey(), Buffer.from(preimage.toString('hex'), 'hex'), txAuthSig, outputSeq, prevoutSeq, subscript.toRaw()];\n        tx.inputs[i].script.fromItems(items);\n      }\n\n      const rawTx = tx.toRaw();\n      const hex = rawTx.toString('hex'); // Verify\n      // const mintMsgBuf = Buffer.concat([\n      //     stampRawOutpoint,\n      //     tx.outputs[0].toRaw(),\n      //     tx.outputs[1].toRaw(),\n      //     tx.outputs[2].toRaw(),\n      // ])\n      // console.log('mintMsgBuf', mintMsgBuf);\n      // console.log('mintMsgBufHash', SHA256.digest(mintMsgBuf));\n      // console.log('checking index 0');\n      // const checkBaton = tx.checkInput(0, stampCoin);\n      // console.log('checking index 1');\n      // const checkStamp = tx.checkInput(1, batonCoin);\n\n      const verified = tx.verify(tx.view);\n      console.log('verified', verified);\n      console.log('tx size', tx.getSize());\n      console.log('fee', tx.getFee());\n      console.log('tx hex', hex);\n      if (!verified) throw new Error('Transaction verification failed');\n      if (returnRawTx) return rawTx; // Broadcast transaction to the network\n\n      let broadcast = {\n        success: true\n      };\n\n      if (!testOnly) {\n        broadcast = await broadcastTx(hex);\n        if (broadcast.error) throw broadcast.error;\n      }\n\n      const txidStr = tx.txid().toString('hex');\n\n      if (broadcast.success) {\n        console.log(`${currency.tokenTicker} txid`, txidStr);\n      }\n\n      let link;\n\n      if (process.env.REACT_APP_NETWORK === `mainnet`) {\n        link = `${currency.tokenExplorerUrl}/tx/${txidStr}`;\n      } else {\n        link = `${currency.blockExplorerUrlTestnet}/tx/${txidStr}`;\n      } //console.log(`link`, link);\n\n\n      return link;\n    } catch (err) {\n      if (err.error === 'insufficient priority (code 66)') {\n        err.code = SEND_BCH_ERRORS.INSUFFICIENT_PRIORITY;\n      } else if (err.error === 'txn-mempool-conflict (code 18)') {\n        err.code = SEND_BCH_ERRORS.DOUBLE_SPENDING;\n      } else if (err.error === 'Network Error') {\n        err.code = SEND_BCH_ERRORS.NETWORK_ERROR;\n      } else if (err.error === 'too-long-mempool-chain, too many unconfirmed ancestors [limit: 25] (code 64)') {\n        err.code = SEND_BCH_ERRORS.MAX_UNCONFIRMED_TXS;\n      }\n\n      console.log(`error: `, err);\n      throw err;\n    }\n  };\n\n  return {\n    calcFee,\n    getPostage,\n    // check\n    calculatePostage,\n    // check\n    getUtxoBcash,\n    // check\n    getUtxosBcash,\n    // check\n    getSlpBalancesAndUtxosBcash,\n    // rmv\n    getTxHistoryBcash,\n    // rmv\n    parseTxData,\n    // rmv\n    parseTokenInfoForTxHistory,\n    // rmv ?\n    getBcashRestUrl,\n    // getMintTxHistory,\n    // parseMintTxData,\n    // signPkMessage,\n    // sendXec,\n    // sendToken,\n    sendBip70,\n    readAuthCode,\n    sendSelfMint // createToken,\n\n  };\n}","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/hooks/useBCH.js"],"names":["BigNumber","currency","isCashtabOutput","extractCashtabMessage","extractExternalMessage","toSmallestDenomination","fromSmallestDenomination","isValidStoredWallet","convertToEcashPrefix","postPayment","TXUtil","authPubKeys","buildOutScript","cashaddr","U64","Input","require","Output","Outpoint","Coin","MTX","TX","KeyRing","Script","Opcode","utils","Hash160","read","PaymentDetails","SLP","common","opcodes","useBCH","SEND_BCH_ERRORS","INSUFFICIENT_FUNDS","NETWORK_ERROR","INSUFFICIENT_PRIORITY","DOUBLE_SPENDING","MAX_UNCONFIRMED_TXS","POSTAGE_URL","postageUrl","tokenPrefixes","getPostage","tokenId","res","fetch","postageObj","json","stamp","stamps","find","s","address","weight","err","console","error","calculatePostage","inputCount","tokenRecipientCount","sendAmountArray","i","push","sendOpReturn","buildSendOpReturn","Buffer","alloc","toString","byteCount","getByteCount","P2PKH","length","stampsNeeded","Math","ceil","rate","getBcashRestUrl","process","env","REACT_APP_BCASH_API","parseTxData","wallet","txData","ownAddressArray","Path245","cashAddress","Path145","Path1899","parsedTxHistory","tx","parsedTx","txid","hash","height","destinationOutput","outputs","output","destinationAddress","Object","keys","includes","confirmations","blocktime","time","amountSent","amountReceived","opReturnMessage","isCashtabMessage","outgoingTx","tokenTx","substring","senderAddress","inputs","coin","j","thisInput","thisOutput","hex","script","slpToken","tokenInfo","parseTokenInfoForTxHistory","from","log","value","replyAddress","getTxHistoryBcash","addresses","limit","reverse","result","utxoPromises","map","addr","then","txs","Promise","all","allTxs","unparsedTx","transactionType","slp","type","qtyReceived","qtySent","totalSent","filter","input","reduce","prev","curr","plus","totalReceived","divisor","parseInt","decimals","gte","minus","div","cashtabTokenInfo","tokenName","name","tokenTicker","ticker","getUtxoBcash","index","catch","getUtxosBcash","utxos","allUtxos","getSlpBalancesAndUtxosBcash","nonSlpUtxos","utxo","slpUtxos","tokensById","slpUtxo","token","hasBaton","balance","info","tokens","values","getMintTxHistory","minterPublicKey","parseMintTxData","amountMinted","broadcastTx","method","body","JSON","stringify","totalWeight","hasWitness","types","P2WPKH","P2SH","P2WSH","forEach","key","slice","keyParts","split","Error","newKey","mAndN","item","multiplyer","indexOf","calcFee","p2pkhOutputNumber","satoshisPerByte","defaultFee","txFee","buildGenesisOpReturn","configObj","stringsArray","pushEmptyOp","OP_PUSHDATA1","genesisOpReturn","pushSym","pushData","concat","pushPush","pushString","documentHash","isBuffer","decimalInt","mintBatonVout","batonInt","fromString","initialQty","muln","toBE","compile","buildMintOpReturn","mintQuantityBufBE","mintOpReturn","sendQuantityArray","version","sendQuantity","createToken","feeInSatsPerByte","testOnly","walletError","state","slpBalancesAndUtxos","CREATION_ADDR","coins","fromJSON","addOutput","etokenSats","fund","changeAddress","keyRingArray","fromSecret","fundingWif","sign","toRaw","broadcast","success","txidStr","link","REACT_APP_NETWORK","tokenExplorerUrl","blockExplorerUrlTestnet","code","sendToken","amount","tokenReceiverAddress","postageData","REMAINDER_ADDR","nonSlpCoins","tokenUtxos","finalTokenAmountSent","postageAmount","tokenAmountBeingSentToAddress","times","totalTokenOutputAmount","tokenCoins","tokenCoin","postageBaseAmount","lte","tokenAmountArray","gt","tokenChangeAmount","decodedTokenReceiverAddress","decode","cleanTokenReceiverAddress","encode","decodedPostageAddress","cleanPostageAddress","addCoin","fromCoin","prevout","hashTypes","hashType","sighashType","ALL","ANYONECANPAY","SIGHASH_FORKID","rawTx","paymentObj","merchantData","transactions","refundTo","fromAddress","memo","paymentAck","payment","transactionIds","t","fromRaw","signPkMessage","pk","message","keyring","sig","sendXec","optionalOpReturnMsg","isOneToMany","destinationAddressAndValueArray","sendAmount","arrayLength","sum","lt","dustSats","satoshisToSend","trim","opReturn","appPrefixesHex","cashtab","outputAddress","outputValue","blockExplorerUrl","sendBip70","paymentDetails","isPreburn","rawChainTxs","refundOutput","firstOutput","slpScript","isSlp","isValidSlp","postagePaid","tokenIdBuf","getData","postage","listing","slpType","getType","sendRecords","getRecords","totalBase","total","record","add","fromBE","fromInt","totalTokenBalance","parentTx","records","getAddress","r","vout","fromTX","toJSON","splitDetails","fromOptions","sendTotalString","opReturnOut","preburnOut","splitPayment","preburn","coinbase","availableTokenUtxos","sub","toInt","splice","sigHashType","rawTxs","paymentUrl","prefixes","readAuthCode","authCode","authReader","mintQuantity","readBytes","stampRawOutpoint","stampOutpoint","txAuthSig","getSize","offset","sendSelfMint","returnRawTx","tokenIdString","pubkey","authPubKey","authObj","outscript","outScriptHash","digest","p2shPubKeyScript","fromScripthash","p2shAddress","batonAddrUtxos","toCashAddr","batonUtxo","u","batonCoin","stampOutscript","stampOutScriptHash","stampP2shPubKeyScript","stampUtxo","stampCoin","flags","STANDARD_VERIFY_FLAGS","template","rawOutputs","outputSeq","rawPrevouts","prevoutSeq","p2shCoin","view","getOutput","subscript","signature","privateKey","preimage","getPreimage","items","getPublicKey","fromItems","verified","verify","getFee"],"mappings":"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","sourcesContent":["import BigNumber from 'bignumber.js';\nimport {\n    currency,\n    isCashtabOutput,\n    extractCashtabMessage,\n    extractExternalMessage,\n} from '@components/Common/Ticker';\nimport {\n    toSmallestDenomination,\n    fromSmallestDenomination,\n    isValidStoredWallet,\n    convertToEcashPrefix,\n} from '@utils/cashMethods';\nimport { postPayment } from '@utils/bip70';\nimport { \n    TXUtil,\n    authPubKeys,\n    buildOutScript\n} from '@utils/selfMint';\nimport cashaddr from 'ecashaddrjs';\nimport { U64 } from 'n64';\nconst Input = require('@utils/bcash/primitives/input');\nconst Output = require('@utils/bcash/primitives/output');\nconst Outpoint = require('@utils/bcash/primitives/outpoint');\nconst Coin = require('@utils/bcash/primitives/coin');\nconst MTX = require('@utils/bcash/primitives/mtx');\nconst TX = require('@utils/bcash/primitives/tx');\nconst KeyRing = require('@utils/bcash/primitives/keyring');\nconst Script = require('@utils/bcash/script/script');\nconst Opcode = require('@utils/bcash/script/opcode');\nconst utils = require('@utils/bcash/utils/index');\n\n// import { \n//     Input,\n//     Output,\n//     Outpoint,\n//     Coin, \n//     MTX,\n//     TX,\n//     KeyRing,\n//     Script,\n//     Opcode,\n//     utils,\n//     script\n// } from '@utils/bcash/bcoin';\nimport {\n    Hash160\n} from 'bcrypto';\nimport { read } from 'bufio';\nimport { PaymentDetails } from 'b70';\n\nconst SLP = require('@utils/bcash/script/slp');\nconst common = require('@utils/bcash/script/common');\nconst opcodes = common.opcodes;\n// const { \n//     SLP,\n//     common: { opcodes }\n// } = script;\n\nexport default function useBCH() {\n    const SEND_BCH_ERRORS = {\n        INSUFFICIENT_FUNDS: 0,\n        NETWORK_ERROR: 1,\n        INSUFFICIENT_PRIORITY: 66, // ~insufficient fee\n        DOUBLE_SPENDING: 18,\n        MAX_UNCONFIRMED_TXS: 64,\n    };\n\n    const POSTAGE_URL = `${currency.postageUrl}?currency=${currency.tokenPrefixes[0]}`;\n\n    const getPostage = async (tokenId) => {\n        try {\n            const res = await fetch(POSTAGE_URL);\n            const postageObj = await res.json();\n            const stamp = postageObj.stamps.find(\n                s => s.tokenId === tokenId\n            );\n            if (stamp) {\n                return {\n                    address: postageObj.address,\n                    weight: postageObj.weight,\n                    stamp\n                };\n            }\n        } catch (err) {\n            console.error(err);\n        }\n        return null;\n    };\n\n    const calculatePostage = (\n        inputCount, \n        tokenRecipientCount, \n        postageObj\n    ) => {\n        const sendAmountArray = ['1', '1']; // Begin with stamp output and change\n        for (let i = 0; i < tokenRecipientCount; i++) {\n            sendAmountArray.push('1');\n        }\n\n        const sendOpReturn = buildSendOpReturn(\n            Buffer.alloc(32).toString('hex'),\n            sendAmountArray\n        )\n        let byteCount = getByteCount(\n            { P2PKH: inputCount },\n            { P2PKH: sendAmountArray.length }\n        );\n\n        byteCount += 8 + 1 + sendOpReturn.length;\n        // Account for difference in inputs and outputs\n        byteCount += 546 * (sendAmountArray.length - inputCount);\n  \n        let stampsNeeded = Math.ceil(byteCount / postageObj.weight);\n        // console.log('byteCount', byteCount);\n        // console.log('stampsNeeded', stampsNeeded);\n        if (stampsNeeded < 1) stampsNeeded = 1;\n        return postageObj.stamp.rate * stampsNeeded;\n    }\n\n    const getBcashRestUrl = () => {\n        return process.env.REACT_APP_BCASH_API;\n    }\n\n    const parseTxData = (wallet, txData) => {\n        /*\n        Desired output\n        [\n        {\n        txid: '',\n        type: send, receive\n        receivingAddress: '',\n        quantity: amount bcha\n        token: true/false\n        tokenInfo: {\n            tokenId:\n            tokenQty:\n            txType: mint, send, other\n        }\n        opReturnMessage: 'message extracted from asm' or ''\n        }\n        ]\n        */\n        const ownAddressArray = [\n            wallet.Path245.cashAddress,\n            wallet.Path145.cashAddress,\n            wallet.Path1899.cashAddress\n        ];\n\n        const parsedTxHistory = [];\n        for (let i = 0; i < txData.length; i += 1) {\n            const tx = txData[i];\n\n            const parsedTx = {};\n\n            // Move over info that does not need to be calculated\n            parsedTx.txid = tx.hash;\n            parsedTx.height = tx.height;\n            const destinationOutput = tx.outputs.find(output => output.address)\n            const destinationAddress = destinationOutput?.address;\n\n            // If this tx had too many inputs to be parsed skip it\n            // When this occurs, the tx will only have txid and height\n            // So, it will not have 'vin'\n            if (!Object.keys(tx).includes('inputs')) {\n                // Populate as a limited-info tx that can be expanded in a block explorer\n                parsedTxHistory.push(parsedTx);\n                continue;\n            }\n\n            parsedTx.confirmations = tx.confirmations;\n            parsedTx.blocktime = tx.time;\n            let amountSent = 0;\n            let amountReceived = 0;\n            let opReturnMessage = '';\n            let isCashtabMessage = false;\n            // Assume an incoming transaction\n            let outgoingTx = false;\n            let tokenTx = false;\n            let substring = '';\n\n            // get the address of the sender for this tx and encode into eCash address\n            let senderAddress = tx.inputs[0].coin.address;\n\n            // If input includes tx address, this is an outgoing tx\n            // Note that with bch-input data, we do not have input amounts\n            for (let j = 0; j < tx.inputs.length; j += 1) {\n                const thisInput = tx.inputs[j];\n                if (ownAddressArray.includes(thisInput.coin.address)) {\n                    // This is an outgoing transaction\n                    outgoingTx = true;\n                }\n            }\n            // Iterate over vout to find how much was sent or received\n            for (let j = 0; j < tx.outputs.length; j += 1) {\n                const thisOutput = tx.outputs[j];\n\n                // If there is no addresses object in the output, it's either an OP_RETURN msg or token tx\n                if (!thisOutput.address) {\n                    let hex = thisOutput.script;\n\n                    if (tx.slpToken) {\n                        // this is an eToken transaction\n                        tokenTx = true;\n                        parsedTx.tokenInfo = parseTokenInfoForTxHistory(tx, ownAddressArray);\n                    } else if (isCashtabOutput(hex)) {\n                        // this is a cashtab.com generated message\n                        try {\n                            substring = extractCashtabMessage(hex);\n                            opReturnMessage = Buffer.from(substring, 'hex');\n                            isCashtabMessage = true;\n                        } catch (err) {\n                            // soft error if an unexpected or invalid cashtab hex is encountered\n                            opReturnMessage = '';\n                            console.log(\n                                'useBCH.parsedTxHistory() error: invalid cashtab msg hex: ' +\n                                    substring,\n                            );\n                        }\n                    } else {\n                        // this is an externally generated message\n                        try {\n                            substring = extractExternalMessage(hex);\n                            opReturnMessage = Buffer.from(substring, 'hex');\n                        } catch (err) {\n                            // soft error if an unexpected or invalid cashtab hex is encountered\n                            opReturnMessage = '';\n                            console.log(\n                                'useBCH.parsedTxHistory() error: invalid external msg hex: ' +\n                                    substring,\n                            );\n                        }\n                    }\n                    continue; // skipping the remainder of tx data parsing logic in both token and OP_RETURN tx cases\n                }\n                if (thisOutput.address && \n                    ownAddressArray.includes(thisOutput.address)\n                ) {\n                    if (outgoingTx) {\n                        // This amount is change\n                        continue;\n                    }\n                    amountReceived += fromSmallestDenomination(thisOutput.value);\n                } else if (outgoingTx) {\n                    amountSent += fromSmallestDenomination(thisOutput.value);\n                }\n            }\n            // Construct parsedTx\n            parsedTx.amountSent = amountSent;\n            parsedTx.amountReceived = amountReceived;\n            parsedTx.tokenTx = tokenTx;\n            parsedTx.outgoingTx = outgoingTx;\n            parsedTx.replyAddress = senderAddress;\n            parsedTx.destinationAddress = destinationAddress;\n            parsedTx.opReturnMessage = opReturnMessage;\n            parsedTx.isCashtabMessage = isCashtabMessage;\n\n            // Add token info\n            parsedTxHistory.push(parsedTx);\n        }\n        return parsedTxHistory;\n    };\n\n    const getTxHistoryBcash = async (\n        addresses,\n        limit = 30,\n        reverse = true\n    ) => {\n        const result = []\n        const utxoPromises = addresses.map(address => {\n            const addr = convertToEcashPrefix(address);\n            result.push({\n                address: addr\n            });\n            return fetch(`${getBcashRestUrl()}/tx/address/${addr}?slp=true&limit=${limit}&reverse=${reverse}`)\n                .then(res => res.json());\n        });\n        const txs = await Promise.all(utxoPromises);\n        let allTxs = [];\n        for (let i = 0; i < txs.length; i++) {\n            allTxs = [\n                ...allTxs,\n                ...txs[i]\n            ]\n        }\n        return allTxs;\n    };\n\n    const parseTokenInfoForTxHistory = (unparsedTx, ownAddressArray) => {\n        // Get transaction type by finding first\n        const transactionType = unparsedTx.outputs.find(\n            output => output.slp\n        ).slp.type;\n\n        let qtyReceived = new BigNumber(0);\n        let qtySent = new BigNumber(0);\n        // Scan over tx to find out how much was sent and received\n        const totalSent = unparsedTx.inputs.filter(input => \n                input.coin.slp && \n                ownAddressArray.includes(input.coin.address) &&\n                transactionType != 'MINT'\n            )\n            .reduce((prev, curr) => prev.plus(curr.coin.slp.value), \n                new BigNumber(0));\n\n        const totalReceived = unparsedTx.outputs.filter(output => \n                output.slp && \n                ownAddressArray.includes(output.address) &&\n                output.slp.type != 'BATON'\n            )\n            .reduce((prev, curr) => prev.plus(curr.slp.value), \n                new BigNumber(0));\n        // Check to see if this is either a sent or received transaction\n        const divisor = 10 ** parseInt(unparsedTx.slpToken.decimals);\n\n        if (totalSent.gte(totalReceived)) {\n            qtySent = totalSent.minus(totalReceived)\n                .div(divisor);\n        } else {\n            qtyReceived = totalReceived.minus(totalSent)\n                .div(divisor);\n        }\n\n        const cashtabTokenInfo = {};\n        cashtabTokenInfo.qtySent = qtySent.toString();\n        cashtabTokenInfo.qtyReceived = qtyReceived.toString();\n        cashtabTokenInfo.tokenId = unparsedTx.slpToken.tokenId;\n        cashtabTokenInfo.tokenName = unparsedTx.slpToken.name;\n        cashtabTokenInfo.tokenTicker = unparsedTx.slpToken.ticker;\n        cashtabTokenInfo.transactionType = transactionType;\n\n        return cashtabTokenInfo;\n    };\n\n    const getUtxoBcash = async (hash, index) => {\n        return fetch(`${getBcashRestUrl()}/coin/${hash}/${index}?slp=true`)\n            .then(res => res.json())\n            .catch(err => null);\n    };\n\n    const getUtxosBcash = async (addresses) => {\n        const result = []\n        const utxoPromises = addresses.map(address => {\n            const addr = convertToEcashPrefix(address);\n            result.push({\n                address: addr\n            });\n            return fetch(`${getBcashRestUrl()}/coin/address/${addr}?slp=true`)\n                .then(res => res.json());\n        });\n        const utxos = await Promise.all(utxoPromises);\n        let allUtxos = [];\n        for (let i = 0; i < utxos.length; i++) {\n            allUtxos = [\n                ...allUtxos,\n                ...utxos[i]\n            ]\n        }\n        return allUtxos;\n    };\n\n    const getSlpBalancesAndUtxosBcash = async (utxos) => {\n        // Prevent app from treating slpUtxos as nonSlpUtxos\n        // Do not classify any utxos that include token information as nonSlpUtxos\n        const nonSlpUtxos = utxos.filter(utxo => \n            !utxo.slp || (utxo.slp && utxo.slp.value == '0')\n        );\n\n        // To be included in slpUtxos, the utxo must\n        // have utxo.isValid = true\n        // If utxo has a utxo.tokenQty field, i.e. not a minting baton, then utxo.value !== '0'\n        const slpUtxos = utxos.filter(utxo => \n            utxo.slp && ( utxo.slp.value != '0' || utxo.slp.type == 'MINT')\n        );\n\n        let tokensById = {};\n\n        for (let i = 0; i < slpUtxos.length; i++) {\n            const slpUtxo = slpUtxos[i];\n            let token = tokensById[slpUtxo.slp.tokenId];\n\n            if (token) {\n                // Minting baton does nto have a slpUtxo.tokenQty type\n                token.hasBaton = slpUtxo.slp.type === 'BATON';\n\n                if (!token.hasBaton) {\n                    token.balance = new BigNumber(token.balance).plus(\n                        new BigNumber(slpUtxo.slp.value)\n                    );\n                }\n\n            } else {\n                token = {};\n                token.info = await fetch(`${getBcashRestUrl()}/token/${slpUtxo.slp.tokenId}`)\n                    .then(res => res.json());\n                token.tokenId = slpUtxo.slp.tokenId;\n                token.hasBaton = slpUtxo.slp.type === 'BATON';\n                if (!token.hasBaton) {\n                    token.balance = new BigNumber(slpUtxo.slp.value);\n                } else {\n                    token.balance = new BigNumber(0);\n                }\n\n                tokensById[slpUtxo.slp.tokenId] = token;\n            }\n        }\n\n        const tokens = Object.values(tokensById);\n        // console.log(`tokens`, tokens);\n        return {\n            tokens,\n            nonSlpUtxos,\n            slpUtxos,\n        };\n    };\n\n    const getMintTxHistory = async (minterPublicKey) => {\n        return await fetch(\n            `https://ecash.badger.cash:8332/tx/0c3817fbbd945277035d8adcab70f3c5b1eeb37ae08caf6cf78bd62e3535f81e?slp=true`\n        ).then(res => res.json());\n        // return await fetch(\n        //     `https://stats.bux.digital/tx/address/${wallet.Path1889}`\n        // ).then(res => res.json());\n    };\n\n    const parseMintTxData = (txData) => {\n        const parsedTxHistory = [];\n        for (let i = 0; i < txData.length; i += 1) {\n            const tx = txData[i];\n    \n            const parsedTx = {};\n    \n            // Move over info that does not need to be calculated\n            parsedTx.txid = tx.hash;\n            parsedTx.height = tx.height;\n            console.log(\"tx.outputs\", tx.outputs)\n            const destinationOutput = tx.outputs.find(output => output.address)\n            const destinationAddress = destinationOutput?.address;\n    \n            // If this tx had too many inputs to be parsed skip it\n            // When this occurs, the tx will only have txid and height\n            // So, it will not have 'vin'\n            if (!Object.keys(tx).includes('inputs')) {\n                // Populate as a limited-info tx that can be expanded in a block explorer\n                parsedTxHistory.push(parsedTx);\n                continue;\n            }\n    \n            parsedTx.confirmations = tx.confirmations;\n            parsedTx.blocktime = tx.time;\n            let opReturnMessage = '';\n            // Assume an incoming transaction\n            let substring = '';\n\n            const divisor = 10 ** tx.slpToken.decimals;    \n            const amountMinted = tx.outputs.filter(output => output.slp?.type === 'MINT')   \n                .reduce((prev, curr) => prev.plus(curr.slp.value), new BigNumber(0))\n                .div(divisor);\n            \n            parsedTx.tokenInfo = {\n                qtySent: amountMinted.toString(), // qtyMinted?,\n                qtyReceived: 0, // replace for edge case self mint \n                tokenId: tx.slpToken.tokenId,\n                tokenName: tx.slpToken.name,\n                tokenTicker: tx.slpToken.ticker,\n                transactionType: 'MINT'\n            };\n\n            // Construct parsedTx\n            parsedTx.tokenTx = true; // always true\n            parsedTx.outgoingTx = true; // always true\n            parsedTx.destinationAddress = destinationAddress; // does that still make sense? yes\n            parsedTx.opReturnMessage = opReturnMessage;\n            parsedTx.isCashtabMessage = false; // always false\n    \n            // Add token info\n            parsedTxHistory.push(parsedTx);\n        }\n        \n        return parsedTxHistory;\n    };\n\n    const broadcastTx = async (hex) => {\n        return fetch(`${getBcashRestUrl()}/broadcast`, {\n            method: 'POST',\n            body: JSON.stringify({tx: hex})\n        }).then(res => res.json());\n    }\n\n    const getByteCount = (inputs, outputs) => {\n        // from https://github.com/bitcoinjs/bitcoinjs-lib/issues/921#issuecomment-354394004\n        let totalWeight = 0\n        let hasWitness = false\n        // assumes compressed pubkeys in all cases.\n        const types = {\n          inputs: {\n            \"MULTISIG-P2SH\": 49 * 4,\n            \"MULTISIG-P2WSH\": 6 + 41 * 4,\n            \"MULTISIG-P2SH-P2WSH\": 6 + 76 * 4,\n            P2PKH: 148 * 4,\n            P2WPKH: 108 + 41 * 4,\n            \"P2SH-P2WPKH\": 108 + 64 * 4\n          },\n          outputs: {\n            P2SH: 32 * 4,\n            P2PKH: 34 * 4,\n            P2WPKH: 31 * 4,\n            P2WSH: 43 * 4\n          }\n        }\n    \n        Object.keys(inputs).forEach(function(key) {\n          if (key.slice(0, 8) === \"MULTISIG\") {\n            // ex. \"MULTISIG-P2SH:2-3\" would mean 2 of 3 P2SH MULTISIG\n            const keyParts = key.split(\":\")\n            if (keyParts.length !== 2) throw new Error(`invalid input: ${key}`)\n            const newKey = keyParts[0]\n            const mAndN = keyParts[1].split(\"-\").map(function(item) {\n              return parseInt(item)\n            })\n    \n            totalWeight += types.inputs[newKey] * inputs[key]\n            const multiplyer = newKey === \"MULTISIG-P2SH\" ? 4 : 1\n            totalWeight += (73 * mAndN[0] + 34 * mAndN[1]) * multiplyer\n          } else {\n            totalWeight += types.inputs[key] * inputs[key]\n          }\n          if (key.indexOf(\"W\") >= 0) hasWitness = true\n        })\n    \n        Object.keys(outputs).forEach(function(key) {\n          totalWeight += types.outputs[key] * outputs[key]\n        })\n    \n        if (hasWitness) totalWeight += 2\n    \n        totalWeight += 10 * 4\n    \n        return Math.ceil(totalWeight / 4)\n    }\n\n    const calcFee = (\n        utxos,\n        p2pkhOutputNumber = 2,\n        satoshisPerByte = currency.defaultFee,\n    ) => {\n        const byteCount = getByteCount(\n            { P2PKH: utxos.length },\n            { P2PKH: p2pkhOutputNumber },\n        );\n        const txFee = Math.ceil(satoshisPerByte * byteCount);\n        return txFee;\n    };\n\n    const buildGenesisOpReturn = (configObj) => {\n        const stringsArray = [\n            'ticker',\n            'name',\n            'documentUrl'\n        ];\n        const pushEmptyOp = new Opcode(\n            opcodes.OP_PUSHDATA1,\n            Buffer.alloc(0)\n        );\n        const genesisOpReturn = new Script()\n                .pushSym('return')\n                .pushData(Buffer.concat([\n                    Buffer.from('SLP', 'ascii'),\n                    Buffer.alloc(1)\n                ]))\n                .pushPush(Buffer.alloc(1, 1))\n                .pushData(Buffer.from('GENESIS', 'ascii'));\n                // Push metadata strings\n                for (let i = 0; i < stringsArray.length; i++) {\n                    const item = configObj[stringsArray[i]];\n                    if (item && typeof item === 'string' && item.length > 0)\n                        genesisOpReturn.pushString(item);\n                    else\n                        genesisOpReturn.push(pushEmptyOp);\n                }\n                // Document Hash\n                if (configObj.documentHash) {\n                    const documentHash = typeof configObj.documentHash === 'string'\n                        ? Buffer.from(configObj.documentHash, 'hex')\n                        : configObj.documentHash;\n                    if (!Buffer.isBuffer(documentHash) || (documentHash.length != 0 && documentHash.length != 32))\n                        throw new Error ('documentHash must be hex string or buffer of 32 bytes or less');\n                    if (documentHash.length === 0)\n                        genesisOpReturn.push(pushEmptyOp);\n                    else\n                        genesisOpReturn.pushPush(documentHash);\n                } else\n                    genesisOpReturn.push(pushEmptyOp);\n                // Decimals\n                const decimalInt = parseInt(configObj.decimals);\n                if (decimalInt > 9 || decimalInt < 0)\n                    throw new Error ('decimal value must be a number between 0 and 9');\n                genesisOpReturn.pushPush(Buffer.alloc(1, decimalInt));\n\n                // Mint baton\n                if (configObj.mintBatonVout) {\n                    const batonInt = parseInt(configObj.mintBatonVout)\n                    if (batonInt != 2)\n                        throw new Error ('mintBaton must equal 2')\n                    genesisOpReturn.pushPush(Buffer.alloc(1, batonInt));\n                } else \n                    genesisOpReturn.push(pushEmptyOp);\n                // Quantity\n                genesisOpReturn.pushData(U64\n                    .fromString(configObj.initialQty)\n                    .muln(10 ** decimalInt)\n                    .toBE(Buffer)\n                )\n                .compile();\n\n        return genesisOpReturn;\n    };\n\n    const buildMintOpReturn = (tokenId, mintQuantityBufBE) => {\n        const mintOpReturn = new Script()\n                .pushSym('return')\n                .pushData(Buffer.concat([\n                    Buffer.from('SLP', 'ascii'),\n                    Buffer.alloc(1)\n                ]))\n                .pushPush(Buffer.alloc(1, 1))\n                .pushData(Buffer.from('MINT', 'ascii'))\n                .pushData(tokenId)\n                .pushPush(Buffer.alloc(1, 2))\n                .pushData(mintQuantityBufBE)\n                .compile();\n        return mintOpReturn\n    };\n\n    const buildSendOpReturn = (tokenId, sendQuantityArray, version = 1) => {\n        const sendOpReturn = new Script()\n                .pushSym('return')\n                .pushData(Buffer.concat([\n                    Buffer.from('SLP', 'ascii'),\n                    Buffer.alloc(1)\n                ]))\n                .pushPush(Buffer.alloc(1, version))\n                .pushData(Buffer.from('SEND', 'ascii'))\n                .pushData(Buffer.from(tokenId, 'hex'))\n                for (let i = 0; i < sendQuantityArray.length; i++) {\n                    const sendQuantity = sendQuantityArray[i]\n                    sendOpReturn.pushData(U64.fromString(sendQuantity).toBE(Buffer))\n                }\n        return sendOpReturn.compile();\n    };\n\n    const createToken = async (\n        wallet, \n        feeInSatsPerByte, \n        configObj,\n        testOnly = false\n    ) => {\n        try {\n            // Throw error if wallet does not have utxo set in state\n            if (!isValidStoredWallet(wallet)) {\n                const walletError = new Error(`Invalid wallet`);\n                throw walletError;\n            }\n            const utxos = wallet.state.slpBalancesAndUtxos.nonSlpUtxos;\n\n            const CREATION_ADDR = wallet.Path1899.cashAddress;\n\n            const coins = utxos.map(utxo => Coin.fromJSON(utxo));\n\n            const tx = new MTX()\n\n            // Generate the OP_RETURN entry for an SLP GENESIS transaction.\n            const genesisOpReturn = buildGenesisOpReturn(configObj);\n            // OP_RETURN needs to be the first output in the transaction.\n            tx.addOutput(genesisOpReturn, 0);\n\n            // add output w/ address and amount to send\n            tx.addOutput(CREATION_ADDR, currency.etokenSats);\n            // Add mint baton output\n            if (configObj.mintBatonVout)\n                tx.addOutput(CREATION_ADDR, currency.etokenSats); \n\n            await tx.fund(coins, {\n                changeAddress: CREATION_ADDR,\n                rate: feeInSatsPerByte * 1000 // 1000 sats per kb = 1 sat/b\n            });\n\n            const keyRingArray = [\n                KeyRing.fromSecret(wallet.Path245.fundingWif),\n                KeyRing.fromSecret(wallet.Path145.fundingWif),\n                KeyRing.fromSecret(wallet.Path1899.fundingWif)\n            ];\n\n            tx.sign(keyRingArray);\n\n            // output rawhex\n            const hex = tx.toRaw().toString('hex');\n\n            // Broadcast transaction to the network\n            let broadcast = { success: true };\n            if (!testOnly)\n                broadcast = await broadcastTx(hex);\n            const txidStr = tx.txid().toString('hex')\n\n            if (broadcast.success) {\n                console.log(`${currency.ticker} txid`, txidStr);\n            }\n            let link;\n            if (process.env.REACT_APP_NETWORK === `mainnet`) {\n                link = `${currency.tokenExplorerUrl}/tx/${txidStr}`;\n            } else {\n                link = `${currency.blockExplorerUrlTestnet}/tx/${txidStr}`;\n            }\n            //console.log(`link`, link);\n\n            return link;\n        } catch (err) {\n            if (err.error === 'insufficient priority (code 66)') {\n                err.code = SEND_BCH_ERRORS.INSUFFICIENT_PRIORITY;\n            } else if (err.error === 'txn-mempool-conflict (code 18)') {\n                err.code = SEND_BCH_ERRORS.DOUBLE_SPENDING;\n            } else if (err.error === 'Network Error') {\n                err.code = SEND_BCH_ERRORS.NETWORK_ERROR;\n            } else if (\n                err.error ===\n                'too-long-mempool-chain, too many unconfirmed ancestors [limit: 25] (code 64)'\n            ) {\n                err.code = SEND_BCH_ERRORS.MAX_UNCONFIRMED_TXS;\n            }\n            console.log(`error: `, err);\n            throw err;\n        }\n    };\n\n    const sendToken = async (\n        wallet,\n        { \n            tokenId, \n            amount, \n            tokenReceiverAddress,\n            postageData\n        },\n        feeInSatsPerByte,\n        testOnly = false\n    ) => {\n\n        // Get change address from sending utxos\n        // fall back to what is stored in wallet\n        const REMAINDER_ADDR = wallet.Path1899.cashAddress;\n\n        const slpBalancesAndUtxos = wallet.state.slpBalancesAndUtxos\n        // Handle error of user having no BCH and not using post office\n        if (slpBalancesAndUtxos.nonSlpUtxos.length === 0 &&\n            !postageData\n        ) {\n            throw new Error(\n                `You need some ${currency.ticker} to send ${currency.tokenTicker}`,\n            );\n        }\n\n        const nonSlpCoins = slpBalancesAndUtxos.nonSlpUtxos.map( utxo => \n            Coin.fromJSON(utxo)\n        );\n\n        const tokenUtxos = slpBalancesAndUtxos.slpUtxos.filter(\n            utxo => {\n                if (\n                    utxo && // UTXO is associated with a token.\n                    utxo.slp.tokenId === tokenId && // UTXO matches the token ID.\n                    utxo.slp.type !== 'BATON' // UTXO is not a minting baton.\n                ) {\n                    return true;\n                }\n                return false;\n            },\n        );\n\n        if (tokenUtxos.length === 0) {\n            throw new Error(\n                'No token UTXOs for the specified token could be found.',\n            );\n        }\n\n        // Get Info for token being sent\n        const tokenInfo = slpBalancesAndUtxos.tokens.find(token => \n            token.tokenId == tokenId\n        ).info;\n        console.log(\"tokenInfo\", tokenInfo);\n        // BEGIN transaction construction.\n\n        const tx = new MTX();\n\n        let finalTokenAmountSent = new BigNumber(0);\n        // TODO: Handle multiple token outputs\n        let postageAmount = new BigNumber(0)\n        let tokenAmountBeingSentToAddress = new BigNumber(amount)\n            .times(10 ** tokenInfo.decimals);\n        let totalTokenOutputAmount = tokenAmountBeingSentToAddress;\n\n        const tokenCoins = [];\n        for (let i = 0; i < tokenUtxos.length; i++) {\n            const tokenCoin = Coin.fromJSON(tokenUtxos[i]);\n            tokenCoins.push(tokenCoin);\n\n            finalTokenAmountSent = finalTokenAmountSent.plus(\n                new BigNumber(tokenUtxos[i].slp.value),\n            );\n\n            // Handle postage\n            if (postageData) {\n                const postageBaseAmount = calculatePostage(\n                    tokenCoins.length,\n                    1,\n                    postageData\n                );\n                postageAmount = new BigNumber(postageBaseAmount);\n            }\n\n            totalTokenOutputAmount = tokenAmountBeingSentToAddress\n                .plus(postageAmount);\n\n            if (totalTokenOutputAmount.lte(finalTokenAmountSent)) {\n                break;\n            }\n        }\n\n        const tokenAmountArray = [ tokenAmountBeingSentToAddress.toString() ];\n        // Add postage to output array if exists\n        if (postageAmount.gt(0))\n            tokenAmountArray.push(postageAmount.toString());\n        // Add change if any\n        const tokenChangeAmount = finalTokenAmountSent.minus(totalTokenOutputAmount);\n        if (tokenChangeAmount.gt(0))\n            tokenAmountArray.push(tokenChangeAmount.toString());\n\n        const sendOpReturn = buildSendOpReturn(\n            tokenId,\n            tokenAmountArray,\n            tokenInfo.version,\n        );\n\n        // Add OP_RETURN as first output.\n        tx.addOutput(sendOpReturn, 0);\n\n        // Send dust representing tokens being sent.\n        const decodedTokenReceiverAddress = cashaddr.decode(tokenReceiverAddress);\n        const cleanTokenReceiverAddress = cashaddr.encode(\n            'ecash',\n            decodedTokenReceiverAddress.type,\n            decodedTokenReceiverAddress.hash\n        );\n        // Add destination output\n        tx.addOutput(\n            cleanTokenReceiverAddress,\n            currency.etokenSats,\n        );\n\n        // Add postage output is any\n        if (postageAmount.gt(0)) {\n            const decodedPostageAddress = cashaddr.decode(postageData.address);\n            const cleanPostageAddress = cashaddr.encode(\n                'ecash',\n                decodedPostageAddress.type,\n                decodedPostageAddress.hash\n            );\n            tx.addOutput(\n                cleanPostageAddress,\n                currency.etokenSats,\n            );\n        }\n\n        // Send token change if there is any\n        if (tokenChangeAmount.gt(0)) {\n            tx.addOutput(\n                REMAINDER_ADDR,\n                currency.etokenSats,\n            );\n        }\n\n        // If post office is selected\n        if (postageData) {\n            for (let i =0; i < tokenCoins.length; i++) {\n                tx.addCoin(tokenCoins[i]);\n            }\n        } else {\n            // If post office not being used, add native tokens as gas\n            await tx.fund([\n                    ...tokenCoins,\n                    ...nonSlpCoins\n                ], {\n                inputs: tokenCoins.map(coin => Input.fromCoin(coin).prevout),\n                changeAddress: REMAINDER_ADDR,\n                rate: feeInSatsPerByte * 1000 // 1000 sats per kb = 1 sat/b\n            });\n        }\n\n        const keyRingArray = [\n            KeyRing.fromSecret(wallet.Path245.fundingWif),\n            KeyRing.fromSecret(wallet.Path145.fundingWif),\n            KeyRing.fromSecret(wallet.Path1899.fundingWif)\n        ];\n\n        // Set Sighash type\n        const hashTypes = Script.hashType;\n        const sighashType = postageData\n            ? hashTypes.ALL | hashTypes.ANYONECANPAY | hashTypes.SIGHASH_FORKID\n            : hashTypes.ALL | hashTypes.SIGHASH_FORKID;\n\n        // Sign transaction\n        tx.sign(keyRingArray, sighashType);\n\n        // output rawhex\n        let txidStr\n        const rawTx = tx.toRaw()\n        const hex = rawTx.toString('hex');\n        console.log('hex', hex);\n        \n        const paymentObj = {\n            merchantData: Buffer.alloc(0),\n            transactions: [rawTx],\n            refundTo:[{\n                script: Script.fromAddress(REMAINDER_ADDR).toRaw(),\n                value: 0\n            }],\n            memo: ''\n        }\n        // Broadcast if postage enabled\n        if (postageData) {\n            let paymentAck;\n            if (!testOnly) {\n                paymentAck = await postPayment(\n                    POSTAGE_URL,\n                    paymentObj,\n                    currency.tokenPrefixes[0]\n                );\n            }\n\n            if (paymentAck.payment) {\n                const transactionIds = paymentAck.payment.transactions.map(t =>\n                    TX.fromRaw(t).txid()\n                );\n                txidStr = transactionIds[0];\n                console.log(`${currency.tokenTicker} txid`, txidStr);\n            }\n\n        } else {\n            // Broadcast transaction to the network\n            let broadcast = { success: true };\n            if (!testOnly)\n                broadcast = await broadcastTx(hex);\n            txidStr = tx.txid().toString('hex')\n\n            if (broadcast.success) {\n                console.log(`${currency.tokenTicker} txid`, txidStr);\n            }\n        }\n\n        let link;\n        if (process.env.REACT_APP_NETWORK === `mainnet`) {\n            link = `${currency.tokenExplorerUrl}/tx/${txidStr}`;\n        } else {\n            link = `${currency.blockExplorerUrlTestnet}/tx/${txidStr}`;\n        }\n\n        //console.log(`link`, link);\n\n        return link;\n    };\n\n    const signPkMessage = async (pk, message) => {\n        try {\n            const keyring = KeyRing.fromSecret(pk);\n            const sig = utils.message.sign(message, keyring);\n            return sig.toString('base64');\n        } catch (err) {\n            console.log(`useBCH.signPkMessage() error: `, err);\n            throw err;\n        }\n    };\n\n    const sendXec = async (\n        wallet,\n        feeInSatsPerByte,\n        optionalOpReturnMsg,\n        isOneToMany,\n        destinationAddressAndValueArray,\n        destinationAddress,\n        sendAmount,\n        testOnly = false\n    ) => {\n        try {\n            let value = new BigNumber(0);\n\n            const tx = new MTX();\n\n            if (isOneToMany) {\n                // this is a one to many XEC transaction\n                if (\n                    !destinationAddressAndValueArray ||\n                    !destinationAddressAndValueArray.length\n                ) {\n                    throw new Error('Invalid destinationAddressAndValueArray');\n                }\n                const arrayLength = destinationAddressAndValueArray.length;\n                for (let i = 0; i < arrayLength; i++) {\n                    // add the total value being sent in this array of recipients\n                    value = BigNumber.sum(\n                        value,\n                        new BigNumber(\n                            destinationAddressAndValueArray[i].split(',')[1],\n                        ),\n                    );\n                }\n\n                // If user is attempting to send an aggregate value that is less than minimum accepted by the backend\n                if (\n                    value.lt(\n                        new BigNumber(\n                            fromSmallestDenomination(\n                                currency.dustSats,\n                            ).toString(),\n                        ),\n                    )\n                ) {\n                    // Throw the same error given by the backend attempting to broadcast such a tx\n                    throw new Error('dust');\n                }\n            } else {\n                // this is a one to one XEC transaction then check sendAmount\n                // note: one to many transactions won't be sending a single sendAmount\n\n                if (!sendAmount) {\n                    return null;\n                }\n\n                value = new BigNumber(sendAmount);\n\n                // If user is attempting to send less than minimum accepted by the backend\n                if (\n                    value.lt(\n                        new BigNumber(\n                            fromSmallestDenomination(\n                                currency.dustSats,\n                            ).toString(),\n                        ),\n                    )\n                ) {\n                    // Throw the same error given by the backend attempting to broadcast such a tx\n                    throw new Error('dust');\n                }\n            }\n\n            const satoshisToSend = toSmallestDenomination(value);\n\n            // Throw validation error if toSmallestDenomination returns false\n            if (!satoshisToSend) {\n                const error = new Error(\n                    `Invalid decimal places for send amount`,\n                );\n                throw error;\n            }\n\n            // Start of building the OP_RETURN output.\n            // only build the OP_RETURN output if the user supplied it\n            if (\n                typeof optionalOpReturnMsg !== 'undefined' &&\n                optionalOpReturnMsg.trim() !== ''\n            ) {\n                const script = new Script()\n                    .pushSym('return')\n                    .pushData(Buffer.from(\n                        currency.opReturn.appPrefixesHex.cashtab,\n                        'hex',\n                    ))\n                    .pushString(optionalOpReturnMsg)\n                    .compile();\n\n                tx.addOutput(script, 0);\n            }\n            // End of building the OP_RETURN output.\n            const utxos = wallet.state.slpBalancesAndUtxos.nonSlpUtxos\n            let coins = [];\n            for (let i = 0; i < utxos.length; i++) {\n                const utxo = utxos[i];\n                coins.push(Coin.fromJSON(utxo));\n            }\n\n            // Get change address from sending utxos\n            // fall back to what is stored in wallet\n            const REMAINDER_ADDR = wallet.Path1899.cashAddress;\n\n            if (isOneToMany) {\n                // for one to many mode, add the multiple outputs from the array\n                let arrayLength = destinationAddressAndValueArray.length;\n                for (let i = 0; i < arrayLength; i++) {\n                    // add each send tx from the array as an output\n                    let outputAddress =\n                        destinationAddressAndValueArray[i].split(',')[0];\n                    let outputValue = new BigNumber(\n                        destinationAddressAndValueArray[i].split(',')[1],\n                    );\n\n                    tx.addOutput(\n                        outputAddress, \n                        parseInt(toSmallestDenomination(outputValue))\n                    );\n                }\n            } else {\n                // for one to one mode, add output w/ single address and amount to send\n                tx.addOutput(\n                    destinationAddress, \n                    parseInt(toSmallestDenomination(value))\n                );\n            }\n\n            await tx.fund(coins, {\n                changeAddress: REMAINDER_ADDR,\n                rate: feeInSatsPerByte * 1000 // 1000 sats per kb = 1 sat/b\n            });\n\n            const keyRingArray = [\n                KeyRing.fromSecret(wallet.Path245.fundingWif),\n                KeyRing.fromSecret(wallet.Path145.fundingWif),\n                KeyRing.fromSecret(wallet.Path1899.fundingWif)\n            ];\n\n            tx.sign(keyRingArray);\n\n            // output rawhex\n            const hex = tx.toRaw().toString('hex');\n\n            // Broadcast transaction to the network\n            let broadcast = {success: true};\n            if (!testOnly)\n                broadcast = await broadcastTx(hex);\n            const txidStr = tx.txid().toString('hex')\n\n            if (broadcast.success) {\n                console.log(`${currency.ticker} txid`, txidStr);\n            }\n            let link;\n            if (process.env.REACT_APP_NETWORK === `mainnet`) {\n                link = `${currency.blockExplorerUrl}/tx/${txidStr}`;\n            } else {\n                link = `${currency.blockExplorerUrlTestnet}/tx/${txidStr}`;\n            }\n            //console.log(`link`, link);\n\n            return link;\n        } catch (err) {\n            if (err.error === 'insufficient priority (code 66)') {\n                err.code = SEND_BCH_ERRORS.INSUFFICIENT_PRIORITY;\n            } else if (err.error === 'txn-mempool-conflict (code 18)') {\n                err.code = SEND_BCH_ERRORS.DOUBLE_SPENDING;\n            } else if (err.error === 'Network Error') {\n                err.code = SEND_BCH_ERRORS.NETWORK_ERROR;\n            } else if (\n                err.error ===\n                'too-long-mempool-chain, too many unconfirmed ancestors [limit: 25] (code 64)'\n            ) {\n                err.code = SEND_BCH_ERRORS.MAX_UNCONFIRMED_TXS;\n            }\n            console.log(`error: `, err);\n            throw err;\n        }\n    };\n\n    const sendBip70 = async (\n        wallet,\n        paymentDetails, // b70.PaymentDetails\n        feeInSatsPerByte,\n        testOnly = false,\n        isPreburn = false,\n        rawChainTxs = [] // All outputs for this wallet address in last TX will be used\n    ) => {\n        // Get change address from sending utxos\n        // fall back to what is stored in wallet\n        const REMAINDER_ADDR = wallet.Path1899.cashAddress;\n        const refundOutput = new Output({\n            address: REMAINDER_ADDR\n        });\n\n        const slpBalancesAndUtxos = wallet.state.slpBalancesAndUtxos;\n        let nonSlpCoins = slpBalancesAndUtxos.nonSlpUtxos.map( utxo => \n            Coin.fromJSON(utxo)\n        );\n\n        // Check to see if this is an SLP/eToken transaction\n        const firstOutput = paymentDetails.outputs[0]\n        console.log('paymentDetails', paymentDetails);\n        // console.log('paymentDetails.outputs', paymentDetails.outputs);\n        const slpScript = SLP.fromRaw(Buffer.from(firstOutput.script));\n        const isSlp = slpScript.isValidSlp();\n        let postagePaid = false;\n        const tokenCoins = [];\n        // If is SLP\n        if (isSlp) {\n\n            const tokenIdBuf = slpScript.getData(4);\n            const tokenId = tokenIdBuf.toString('hex');\n\n            // Is Postage Paid by Merchant?\n            const merchantData = paymentDetails.getData('json');\n            // console.log('merchantData', merchantData)\n            // console.log('typeof merchantData', typeof merchantData)\n            if (typeof merchantData === \"object\" && merchantData.postage) {\n                const stamps = merchantData.postage.stamps;\n                const listing = stamps.find(stamp => stamp.tokenId == tokenId);\n                // If postage is paid don't use native token funding\n                if (listing && listing.rate == 0) {\n                    postagePaid = true;\n                }\n            }\n            console.log('postagePaid', postagePaid);\n\n            // Throw error if transaction type is not SEND\n            const slpType = slpScript.getType();\n            if (slpType !== 'SEND' && slpType !== 'BURN')\n                throw new Error(`Token ${slpType} transactions not supported`);\n\n            // Get required UTXOs\n            const sendRecords = slpScript.getRecords(tokenIdBuf);\n            const totalBase = sendRecords.reduce((total, record) => {\n                return total.add(U64.fromBE(Buffer.from(record.value)));\n            }, U64.fromInt(0));\n            let totalTokenBalance = U64.fromInt(0);\n            const token = wallet.state.tokens.find(token => \n                token.tokenId === tokenId\n            );\n            if (token) {\n                totalTokenBalance = U64.fromString(\n                    token.balance.toString()\n                );\n            }\n            if (totalTokenBalance.lt(totalBase) && rawChainTxs.length === 0)\n                throw new Error ('Insufficient token balance to complete transaction');\n\n            const tokenUtxos = [];\n            \n            // Add utxos from chained parent if present\n            if (rawChainTxs.length > 0) {\n                // If a chain TX is provided, use it for the input coins\n                const parentTx = TX.fromRaw(rawChainTxs[rawChainTxs.length -1]);\n                // Parse SLP script\n                const slpScript = script.SLP.fromRaw(parentTx.outputs[0].script.toRaw())\n                const records = slpScript.getRecords(Buffer.alloc(32))\n                // Iterate through parentTx outputs\n                for (let i = 0; i < parentTx.outputs.length; i++) {\n                    const address = parentTx.outputs[i].getAddress()?.toString()\n                    if (address === REMAINDER_ADDR) {\n                        const record = records.find(r => r.type !== 'BATON' && r.vout === i)\n                        if (record) {\n                            // convert to coin first for compatibility\n                            const coin = Coin.fromTX(parentTx, i, -1);\n                            coin.slp = record;\n                            const utxo = coin.toJSON();\n                            // Add UTXO\n                            tokenUtxos.push(utxo)\n                        }\n                    }\n                }\n            \n            }\n\n            if (slpType === 'BURN' && !isPreburn) {\n                // Send up preburn split transaction\n                // Postage will be added and it will be cached on server\n                // Use UTXO from response as input UTXO for burn\n\n                // Clear utxo array in case rawChainTxs is present\n                tokenUtxos.length = 0;\n\n                // First clone payment details to use with split tx\n                const splitDetails = PaymentDetails.fromOptions(\n                    paymentDetails\n                );\n                // Replace with split tx outputs\n                const sendTotalString = totalBase.toString();\n                const sendOpReturn = buildSendOpReturn(\n                    tokenId,\n                    [sendTotalString]\n                );\n                const opReturnOut = {\n                    script: sendOpReturn.toRaw(),\n                    value: 0\n                };\n                const preburnOut = new Output({\n                    address: REMAINDER_ADDR,\n                    value: 546\n                });\n                splitDetails.outputs = [\n                    opReturnOut, \n                    {\n                        script: preburnOut.script.toRaw(),\n                        value: preburnOut.value\n                    }\n                ]\n                // Send split tx and get Payment object back if successful\n                const splitPayment = await sendBip70(\n                    wallet,\n                    splitDetails,\n                    feeInSatsPerByte,\n                    false,\n                    true\n                );\n                const merchantData = splitPayment.getData('json');\n                if (!merchantData.preburn)\n                    throw new Error('Burn failed: Preburn tx hash not returned from payment server');\n\n                // Use split UTXO as sole input UTXO\n                tokenUtxos.push({\n                    version: 1,\n                    height: -1,\n                    coinbase: false,\n                    script: preburnOut.script.toJSON(),\n                    value: preburnOut.value,\n                    hash: merchantData.preburn,\n                    index: 1,\n                    slp: {\n                        vout: 1,\n                        tokenId,\n                        value: sendTotalString,\n                        type: \"SEND\"\n                      }\n                });\n\n            } else {\n                // Use available UTXOS in wallet\n                const availableTokenUtxos = slpBalancesAndUtxos.slpUtxos.filter(\n                    utxo => {\n                        if (\n                            utxo && // UTXO is associated with a token.\n                            utxo.slp.tokenId === tokenId && // UTXO matches the token ID.\n                            utxo.slp.type !== 'BATON' // UTXO is not a minting baton.\n                        ) {\n                            return true;\n                        }\n                        return false;\n                    },\n                );\n\n                tokenUtxos.push(...availableTokenUtxos);\n            }\n\n            if (tokenUtxos.length === 0) {\n                throw new Error(\n                    'No token UTXOs for the specified token could be found.',\n                );\n            }\n\n            let finalTokenAmountSent = U64.fromInt(0);\n            for (let i = 0; i < tokenUtxos.length; i++) {\n                console.log('tokenUtxos', tokenUtxos);\n                const tokenCoin = Coin.fromJSON(tokenUtxos[i]);\n                tokenCoins.push(tokenCoin);\n\n                finalTokenAmountSent = finalTokenAmountSent.add(\n                    U64.fromString(tokenUtxos[i].slp.value),\n                );\n\n                if (totalBase.lte(finalTokenAmountSent)) {\n                    // Add token change amount to SLP OP_RETURN\n                    const tokenChangeAmount = finalTokenAmountSent.sub(totalBase);\n                    // Skip if change amount is zero\n                    if (tokenChangeAmount.toInt() != 0) {\n                        slpScript.pushData(tokenChangeAmount.toBE(Buffer)).compile();\n                        // add additional output for change\n                        paymentDetails.outputs[0].script = slpScript.toRaw()\n                        paymentDetails.outputs.splice(\n                            sendRecords.length + 1, // Must skip OP_RETURN\n                            0,\n                            {\n                                script: refundOutput.script.toRaw(),\n                                value: 546\n                            }\n                        );\n                    }\n                    break;\n                }\n            }\n\n            // Handle error of user having no BCH and postage not paid\n            if (!postagePaid && slpBalancesAndUtxos.nonSlpUtxos.length === 0) {\n                throw new Error(\n                    `You need some ${currency.ticker} to send ${currency.tokenTicker}`,\n                );\n            }\n        }\n\n        // Build Transaction\n        const tx = new MTX();\n        // Set SigHashType\n        let sigHashType = Script.hashType.ALL | Script.hashType.SIGHASH_FORKID;\n\n        // Add required outputs\n        for (let i = 0; i < paymentDetails.outputs.length; i++) {\n            tx.addOutput(paymentDetails.outputs[i]);\n        }\n\n        if (postagePaid) {\n            // Postage Protocol requires ANYONECANPAY\n            sigHashType = Script.hashType.ANYONECANPAY | sigHashType;\n\n            for (let i = 0; i < tokenCoins.length; i++) {\n                tx.addCoin(tokenCoins[i]);\n            }\n        } else {\n            await tx.fund([\n                    ...tokenCoins,\n                    ...nonSlpCoins\n                ], {\n                inputs: tokenCoins.map(coin => Input.fromCoin(coin).prevout),\n                changeAddress: REMAINDER_ADDR,\n                rate: feeInSatsPerByte * 1000 // 1000 sats per kb = 1 sat/b\n            });\n        }\n\n        const keyRingArray = [\n            KeyRing.fromSecret(wallet.Path245.fundingWif),\n            KeyRing.fromSecret(wallet.Path145.fundingWif),\n            KeyRing.fromSecret(wallet.Path1899.fundingWif)\n        ];\n\n        tx.sign(keyRingArray, sigHashType);\n\n        // output rawhex\n        const rawTx = tx.toRaw()\n        const hex = rawTx.toString('hex');\n        console.log('hex', hex);\n\n        // Add on any \n        const rawTxs = [\n            ...rawChainTxs,\n            rawTx\n        ]\n\n        const paymentObj = {\n            merchantData: Buffer.alloc(0),\n            transactions: rawTxs,\n            refundTo:[{\n                script: refundOutput.script.toRaw(),\n                value: 0\n            }],\n            memo: paymentDetails.memo\n        }\n\n        let txidStr = tx.txid().toString('hex');\n\n        // Broadcast transaction to the network\n        let paymentAck;\n        if (!testOnly) {\n            paymentAck = await postPayment(\n                paymentDetails.paymentUrl,\n                paymentObj,\n                isSlp ? currency.tokenPrefixes[0] : currency.prefixes[0]\n            );\n        }\n\n        if (paymentAck.payment) {\n            // Return the payment object from the ACK if is preburn\n            if (isPreburn)\n                return paymentAck.payment\n\n            const transactionIds = paymentAck.payment.transactions.map(t =>\n                TX.fromRaw(t).txid()\n            );\n            txidStr = transactionIds[0];\n\n            console.log(`${currency.tokenTicker} txid`, txidStr);\n        }\n\n        let link;\n        if (process.env.REACT_APP_NETWORK === `mainnet`) {\n            link = `${currency.tokenExplorerUrl}/tx/${txidStr}`;\n        } else {\n            link = `${currency.blockExplorerUrlTestnet}/tx/${txidStr}`;\n        }\n\n        //console.log(`link`, link);\n\n        return link;\n    };\n\n    const readAuthCode = (authCode) => {\n        const authReader = read(Buffer.from(authCode, 'base64'));\n        const mintQuantity = authReader.readBytes(8);\n        const stampRawOutpoint = authReader.readBytes(36);\n        const stampOutpoint = Outpoint.fromRaw(stampRawOutpoint);\n        // Auth signature is remaining bytes\n        const txAuthSig = authReader.readBytes(authReader.getSize() - authReader.offset);\n\n        return {\n            mintQuantity,\n            stampOutpoint,\n            txAuthSig\n        }\n    }\n\n    const sendSelfMint = async (\n        wallet,\n        tokenId, // Buffer\n        authCode,\n        testOnly = false,\n        returnRawTx = false\n    ) => {\n        try {\n            const tokenIdString = tokenId.toString('hex');\n            // Process entered Auth Code string\n            const {\n                mintQuantity,\n                stampOutpoint,\n                txAuthSig\n            } = readAuthCode(authCode);\n            // console.log('stampRawoutpoint', stampRawOutpoint);\n            // console.log('txAuthSig', txAuthSig);\n\n            // Get authPubKey for token\n            const { pubkey: authPubKey } = authPubKeys.find(authObj => \n                authObj.tokenId == tokenIdString\n            );\n            // console.log('authKeyBuf', Buffer.from(authPubKey, 'hex'));\n            if (!authPubKey)\n                throw new Error(`Unsupported self-mint token ID: ${tokenIdString}`);\n\n            // Build Baton Outscript\n            const outscript = buildOutScript(\n                Buffer.from(authPubKey, 'hex'),\n                false\n            );\n            const outScriptHash = Hash160.digest(outscript.toRaw());\n            const p2shPubKeyScript = Script.fromScripthash(outScriptHash);\n            const p2shAddress = p2shPubKeyScript.getAddress();\n\n            // Find Baton\n            const batonAddrUtxos = await getUtxosBcash([\n                p2shAddress.toCashAddr()\n            ]);\n            const batonUtxo = batonAddrUtxos.find(u => \n                u.slp?.tokenId == tokenIdString && u.slp.type == 'BATON'\n            );\n\n            // Stub coin/utxo for \"stamp\" and baton\n            const batonCoin = Coin.fromJSON(batonUtxo);\n\n            // Build Stamp Outscript\n            const stampOutscript = buildOutScript(\n                Buffer.from(authPubKey, 'hex'), \n                true\n            );\n            const stampOutScriptHash = Hash160.digest(stampOutscript.toRaw());\n            const stampP2shPubKeyScript = Script.fromScripthash(stampOutScriptHash);\n            const stampUtxo = await getUtxoBcash(\n                stampOutpoint.txid().toString('hex'),\n                stampOutpoint.index\n            )\n\n            if (!stampUtxo)\n                throw new Error('Stamp UTXO in auth code is spent or invalid');\n\n            const stampCoin = Coin.fromJSON(stampUtxo);\n\n            const keyring = KeyRing.fromSecret(wallet.Path1899.fundingWif);\n            // Construct transaction\n            const tx = new TXUtil()\n            // Build MINT OP_RETURN\n            const mintOpReturn = buildMintOpReturn(tokenId, mintQuantity);\n            // Add outputs\n            tx.addOutput(mintOpReturn, 0) // SLP mint OP_RETURN\n            tx.addOutput(keyring.getAddress(), 546) // Minted tokens\n            tx.addOutput(p2shAddress, 546) // Mint baton return\n            // Add inputs (must be in this order)\n            tx.addCoin(stampCoin) // Input index 0: \"stamp\"\n            tx.addCoin(batonCoin); // Input index 1: existing mint baton\n\n            const sigHashType = Script.hashType.ALL | Script.hashType.SIGHASH_FORKID;\n            const flags = Script.flags.STANDARD_VERIFY_FLAGS;\n\n            // Sign TX\n            tx.template(keyring); // prepares the template\n            // Get the prevout and outputs sequences as they appear in the preimage\n            const rawOutputs= tx.outputs.map(output => output.toRaw());\n            const outputSeq = Buffer.concat(rawOutputs);\n            const rawPrevouts= tx.inputs.map(input => input.prevout.toRaw());\n            const prevoutSeq = Buffer.concat(rawPrevouts);\n            // Sign The Stamp and Baton\n            for (let i = 0; i < 2; i++) {\n                const {prevout} = tx.inputs[i];\n                const p2shCoin = tx.view.getOutput(prevout);\n                const subscript = i == 0 ? stampOutscript : outscript;\n                const sig = tx.signature(i, subscript, p2shCoin.value, keyring.privateKey, sigHashType, flags);\n                const preimage = tx.getPreimage(i, subscript, p2shCoin.value, sigHashType, false);\n                const items = [\n                    sig,\n                    keyring.getPublicKey(),\n                    Buffer.from(preimage.toString('hex'), 'hex'),  \n                    txAuthSig,\n                    outputSeq,\n                    prevoutSeq,\n                    subscript.toRaw()\n                ];\n                tx.inputs[i].script.fromItems(items);\n            }\n\n            const rawTx = tx.toRaw()\n            const hex = rawTx.toString('hex')\n\n            // Verify\n            // const mintMsgBuf = Buffer.concat([\n            //     stampRawOutpoint,\n            //     tx.outputs[0].toRaw(),\n            //     tx.outputs[1].toRaw(),\n            //     tx.outputs[2].toRaw(),\n            // ])\n            // console.log('mintMsgBuf', mintMsgBuf);\n            // console.log('mintMsgBufHash', SHA256.digest(mintMsgBuf));\n            // console.log('checking index 0');\n            // const checkBaton = tx.checkInput(0, stampCoin);\n            // console.log('checking index 1');\n            // const checkStamp = tx.checkInput(1, batonCoin);\n            const verified = tx.verify(tx.view);\n            \n            console.log('verified', verified);\n            console.log('tx size', tx.getSize());\n            console.log('fee', tx.getFee());\n            console.log('tx hex', hex);\n\n            if (!verified)\n                throw new Error('Transaction verification failed');\n\n            if (returnRawTx)\n                return rawTx;\n        \n            // Broadcast transaction to the network\n            let broadcast = {success: true};\n            if (!testOnly) {\n                broadcast = await broadcastTx(hex);\n                if (broadcast.error)\n                    throw broadcast.error\n            }\n\n            const txidStr = tx.txid().toString('hex')\n\n            if (broadcast.success) {\n                console.log(`${currency.tokenTicker} txid`, txidStr);\n            }\n            let link;\n            if (process.env.REACT_APP_NETWORK === `mainnet`) {\n                link = `${currency.tokenExplorerUrl}/tx/${txidStr}`;\n            } else {\n                link = `${currency.blockExplorerUrlTestnet}/tx/${txidStr}`;\n            }\n            //console.log(`link`, link);\n\n            return link;\n        } catch (err) {\n            if (err.error === 'insufficient priority (code 66)') {\n                err.code = SEND_BCH_ERRORS.INSUFFICIENT_PRIORITY;\n            } else if (err.error === 'txn-mempool-conflict (code 18)') {\n                err.code = SEND_BCH_ERRORS.DOUBLE_SPENDING;\n            } else if (err.error === 'Network Error') {\n                err.code = SEND_BCH_ERRORS.NETWORK_ERROR;\n            } else if (\n                err.error ===\n                'too-long-mempool-chain, too many unconfirmed ancestors [limit: 25] (code 64)'\n            ) {\n                err.code = SEND_BCH_ERRORS.MAX_UNCONFIRMED_TXS;\n            }\n            console.log(`error: `, err);\n            throw err;\n        }\n    }\n\n    return {\n        calcFee,\n        getPostage, // check\n        calculatePostage, // check\n        getUtxoBcash, // check\n        getUtxosBcash, // check\n        getSlpBalancesAndUtxosBcash, // rmv\n        getTxHistoryBcash, // rmv\n        parseTxData, // rmv\n        parseTokenInfoForTxHistory, // rmv ?\n        getBcashRestUrl,\n        // getMintTxHistory,\n        // parseMintTxData,\n        // signPkMessage,\n        // sendXec,\n        // sendToken,\n        sendBip70,\n        readAuthCode,\n        sendSelfMint,\n        // createToken,\n    };\n}\n"]},"metadata":{},"sourceType":"module"}