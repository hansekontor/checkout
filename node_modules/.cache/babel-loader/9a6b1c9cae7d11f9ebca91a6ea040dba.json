{"ast":null,"code":"/*!\n * tx.js - transaction object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bio = require('bufio');\n\nconst hash256 = require('bcrypto/lib/hash256');\n\nconst secp256k1 = require('bcrypto/lib/secp256k1');\n\nconst {\n  BufferSet\n} = require('buffer-map');\n\nconst util = require('../utils/util');\n\nconst Amount = require('../btc/amount');\n\nconst Network = require('../protocol/network');\n\nconst Script = require('../script/script');\n\nconst SLP = require('../script/slp');\n\nconst Input = require('./input');\n\nconst Output = require('./output');\n\nconst Outpoint = require('./outpoint');\n\nconst InvItem = require('./invitem');\n\nconst consensus = require('../protocol/consensus');\n\nconst policy = require('../protocol/policy');\n\nconst ScriptError = require('../script/scripterror');\n\nconst {\n  encoding\n} = bio;\nconst {\n  hashType\n} = Script;\n\nconst common = require('../script/common');\n\nconst {\n  inspectSymbol\n} = require('../utils');\n/**\n * TX\n * A static transaction object.\n * @alias module:primitives.TX\n * @property {Number} version\n * @property {Input[]} inputs\n * @property {Output[]} outputs\n * @property {Number} locktime\n * @property {SlpTokenRecord?} slpToken\n */\n\n\nclass TX {\n  /**\n   * Create a transaction.\n   * @constructor\n   * @param {Object?} options\n   */\n  constructor(options) {\n    this.version = 1;\n    this.inputs = [];\n    this.outputs = [];\n    this.locktime = 0;\n    this.mutable = false;\n    this._hash = null;\n    this._hhash = null;\n    this._raw = null;\n    this._offset = -1;\n    this._block = false;\n    this._size = -1;\n    this._sigops = -1;\n    this._hashPrevouts = null;\n    this._hashSequence = null;\n    this._hashOutputs = null;\n    if (options) this.fromOptions(options);\n  }\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n\n  fromOptions(options) {\n    assert(options, 'TX data is required.');\n\n    if (options.version != null) {\n      assert(options.version >>> 0 === options.version, 'Version must be a uint32.');\n      this.version = options.version;\n    }\n\n    if (options.inputs) {\n      assert(Array.isArray(options.inputs), 'Inputs must be an array.');\n\n      for (const input of options.inputs) this.inputs.push(new Input(input));\n    }\n\n    if (options.outputs) {\n      assert(Array.isArray(options.outputs), 'Outputs must be an array.');\n\n      for (const output of options.outputs) this.outputs.push(new Output(output));\n    }\n\n    if (options.locktime != null) {\n      assert(options.locktime >>> 0 === options.locktime, 'Locktime must be a uint32.');\n      this.locktime = options.locktime;\n    }\n\n    if (options.slpToken.constructor === SLP.TokenRecord().constructor) {\n      this.slpToken = options.slpToken;\n    }\n\n    return this;\n  }\n  /**\n   * Instantiate TX from options object.\n   * @param {Object} options\n   * @returns {TX}\n   */\n\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  } //   /**\n  //    * Clone the transaction.\n  //    * @returns {TX}\n  //    */\n  //   clone() {\n  //     return new this.constructor().inject(this);\n  //   }\n  //   /**\n  //    * Inject properties from tx.\n  //    * Used for cloning.\n  //    * @private\n  //    * @param {TX} tx\n  //    * @returns {TX}\n  //    */\n  //   inject(tx) {\n  //     this.version = tx.version;\n  //     for (const input of tx.inputs)\n  //       this.inputs.push(input.clone());\n  //     for (const output of tx.outputs)\n  //       this.outputs.push(output.clone());\n  //     this.locktime = tx.locktime;\n  //     return this;\n  //   }\n  //   /**\n  //    * Clear any cached values.\n  //    */\n  //   refresh() {\n  //     this._hash = null;\n  //     this._hhash = null;\n  //     this._raw = null;\n  //     this._size = -1;\n  //     this._offset = -1;\n  //     this._block = false;\n  //     this._sigops = -1;\n  //     this._hashPrevouts = null;\n  //     this._hashSequence = null;\n  //     this._hashOutputs = null;\n  //   }\n  //   /**\n  //    * Hash the transaction with the non-witness serialization.\n  //    * @param {String?} enc - Can be `'hex'` or `null`.\n  //    * @returns {Hash|Buffer} hash\n  //    */\n  //   hash(enc) {\n  //     let h = this._hash;\n  //     if (!h) {\n  //       h = hash256.digest(this.toRaw());\n  //       if (!this.mutable)\n  //         this._hash = h;\n  //     }\n  //     if (enc === 'hex') {\n  //       let hex = this._hhash;\n  //       if (!hex) {\n  //         hex = h.toString('hex');\n  //         if (!this.mutable)\n  //           this._hhash = hex;\n  //       }\n  //       h = hex;\n  //     }\n  //     return h;\n  //   }\n  //   /**\n  //    * Serialize the transaction. Note\n  //    * that this is cached.\n  //    * @returns {Buffer} Serialized transaction.\n  //    */\n  //   toRaw() {\n  //     return this.frame().data;\n  //   }\n  //   /**\n  //    * Write the transaction to a buffer writer.\n  //    * @param {BufferWriter} bw\n  //    * @param {Boolean} block\n  //    */\n  //   toWriter(bw, block) {\n  //     if (this.mutable)\n  //       return this.writeNormal(bw);\n  //     if (block) {\n  //       this._offset = bw.offset;\n  //       this._block = true;\n  //     }\n  //     bw.writeBytes(this.toRaw());\n  //     return bw;\n  //   }\n  //   /**\n  //    * Serialize the transaction. Note\n  //    * that this is cached.\n  //    * @private\n  //    * @returns {RawTX}\n  //    */\n  //   frame() {\n  //     if (this.mutable) {\n  //       assert(!this._raw);\n  //       return this.frameNormal();\n  //     }\n  //     if (this._raw) {\n  //       assert(this._size >= 0);\n  //       const raw = new RawTX(this._size);\n  //       raw.data = this._raw;\n  //       return raw;\n  //     }\n  //     const raw = this.frameNormal();\n  //     this._raw = raw.data;\n  //     this._size = raw.size;\n  //     return raw;\n  //   }\n  //   /**\n  //    * Return the offset and size of the transaction. Useful\n  //    * when the transaction is deserialized within a block.\n  //    * @returns {Object} contains `size` and `offset`.\n  //    */\n  //   getPosition() {\n  //     if (!(this._block && this._offset > 80))\n  //       console.log(this);\n  //     assert(this._block && this._offset > 80, 'Position not available.');\n  //     return {\n  //       offset: this._offset,\n  //       size: this._size\n  //     };\n  //   }\n  //   /**\n  //    * Calculate the real size of the transaction.\n  //    * @returns {Number} size\n  //    */\n  //   getSize() {\n  //     if (this.mutable)\n  //       return this.getNormalSizes().size;\n  //     return this.frame().size;\n  //   }\n  //   /**\n  //    * Get the signature hash of the transaction for signing verifying.\n  //    * @param {Number} index - Index of input being signed/verified.\n  //    * @param {Script} prev - Previous output script or redeem script.\n  //    * @param {Amount} value - Previous output value.\n  //    * @param {SighashType} type - Sighash type.\n  //    * @param {Number} flags - Script flags.\n  //    * @returns {Buffer} Signature hash.\n  //    */\n  //   signatureHash(index, prev, value, type, flags) {\n  //     assert(index >= 0 && index < this.inputs.length);\n  //     assert(prev instanceof Script);\n  //     assert(typeof value === 'number');\n  //     assert(typeof type === 'number');\n  //     if (flags == null)\n  //       flags = Script.flags.STANDARD_VERIFY_FLAGS;\n  //     if (flags & Script.flags.VERIFY_REPLAY_PROTECTION) {\n  //       const newForkValue = (common.getHashTypeForkValue(type) ^ 0xdead);\n  //       type = common.hashTypeWithForkValue(type, newForkValue | 0xff0000);\n  //     }\n  //     if ((type & Script.hashType.SIGHASH_FORKID)\n  //         && (flags & Script.flags.VERIFY_SIGHASH_FORKID)) {\n  //       return this.signatureHashV1(index, prev, value, type);\n  //     }\n  //     return this.signatureHashV0(index, prev, type);\n  //   }\n  //   /**\n  //    * Legacy sighashing -- O(n^2).\n  //    * @private\n  //    * @param {Number} index\n  //    * @param {Script} prev\n  //    * @param {SighashType} type\n  //    * @returns {Buffer}\n  //    */\n  //   signatureHashV0(index, prev, type) {\n  //     if ((type & 0x1f) === hashType.SINGLE) {\n  //       // Bitcoind used to return 1 as an error code:\n  //       // it ended up being treated like a hash.\n  //       if (index >= this.outputs.length) {\n  //         const hash = Buffer.alloc(32, 0x00);\n  //         hash[0] = 0x01;\n  //         return hash;\n  //       }\n  //     }\n  //     // Remove all code separators.\n  //     prev = prev.removeSeparators();\n  //     // Calculate buffer size.\n  //     const size = this.hashSize(index, prev, type);\n  //     const bw = bio.pool(size);\n  //     bw.writeU32(this.version);\n  //     // Serialize inputs.\n  //     if (type & hashType.ANYONECANPAY) {\n  //       // Serialize only the current\n  //       // input if ANYONECANPAY.\n  //       const input = this.inputs[index];\n  //       // Count.\n  //       bw.writeVarint(1);\n  //       // Outpoint.\n  //       input.prevout.toWriter(bw);\n  //       // Replace script with previous\n  //       // output script if current index.\n  //       bw.writeVarBytes(prev.toRaw());\n  //       bw.writeU32(input.sequence);\n  //     } else {\n  //       bw.writeVarint(this.inputs.length);\n  //       for (let i = 0; i < this.inputs.length; i++) {\n  //         const input = this.inputs[i];\n  //         // Outpoint.\n  //         input.prevout.toWriter(bw);\n  //         // Replace script with previous\n  //         // output script if current index.\n  //         if (i === index) {\n  //           bw.writeVarBytes(prev.toRaw());\n  //           bw.writeU32(input.sequence);\n  //           continue;\n  //         }\n  //         // Script is null.\n  //         bw.writeVarint(0);\n  //         // Sequences are 0 if NONE or SINGLE.\n  //         switch (type & 0x1f) {\n  //           case hashType.NONE:\n  //           case hashType.SINGLE:\n  //             bw.writeU32(0);\n  //             break;\n  //           default:\n  //             bw.writeU32(input.sequence);\n  //             break;\n  //         }\n  //       }\n  //     }\n  //     // Serialize outputs.\n  //     switch (type & 0x1f) {\n  //       case hashType.NONE: {\n  //         // No outputs if NONE.\n  //         bw.writeVarint(0);\n  //         break;\n  //       }\n  //       case hashType.SINGLE: {\n  //         const output = this.outputs[index];\n  //         // Drop all outputs after the\n  //         // current input index if SINGLE.\n  //         bw.writeVarint(index + 1);\n  //         for (let i = 0; i < index; i++) {\n  //           // Null all outputs not at\n  //           // current input index.\n  //           bw.writeI64(-1);\n  //           bw.writeVarint(0);\n  //         }\n  //         // Regular serialization\n  //         // at current input index.\n  //         output.toWriter(bw);\n  //         break;\n  //       }\n  //       default: {\n  //         // Regular output serialization if ALL.\n  //         bw.writeVarint(this.outputs.length);\n  //         for (const output of this.outputs)\n  //           output.toWriter(bw);\n  //         break;\n  //       }\n  //     }\n  //     bw.writeU32(this.locktime);\n  //     // Append the hash type.\n  //     bw.writeU32(type);\n  //     return hash256.digest(bw.render());\n  //   }\n  //   /**\n  //    * Calculate sighash size.\n  //    * @private\n  //    * @param {Number} index\n  //    * @param {Script} prev\n  //    * @param {Number} type\n  //    * @returns {Number}\n  //    */\n  //   hashSize(index, prev, type) {\n  //     let size = 0;\n  //     size += 4;\n  //     if (type & hashType.ANYONECANPAY) {\n  //       size += 1;\n  //       size += 36;\n  //       size += prev.getVarSize();\n  //       size += 4;\n  //     } else {\n  //       size += encoding.sizeVarint(this.inputs.length);\n  //       size += 41 * (this.inputs.length - 1);\n  //       size += 36;\n  //       size += prev.getVarSize();\n  //       size += 4;\n  //     }\n  //     switch (type & 0x1f) {\n  //       case hashType.NONE:\n  //         size += 1;\n  //         break;\n  //       case hashType.SINGLE:\n  //         size += encoding.sizeVarint(index + 1);\n  //         size += 9 * index;\n  //         size += this.outputs[index].getSize();\n  //         break;\n  //       default:\n  //         size += encoding.sizeVarint(this.outputs.length);\n  //         for (const output of this.outputs)\n  //           size += output.getSize();\n  //         break;\n  //     }\n  //     size += 8;\n  //     return size;\n  //   }\n  //   /**\n  //    * Witness sighashing -- O(n).\n  //    * @private\n  //    * @param {Number} index\n  //    * @param {Script} prev\n  //    * @param {Amount} value\n  //    * @param {SighashType} type\n  //    * @returns {Buffer}\n  //    */\n  //   signatureHashV1(index, prev, value, type) {\n  //     const input = this.inputs[index];\n  //     let prevouts = consensus.ZERO_HASH;\n  //     let sequences = consensus.ZERO_HASH;\n  //     let outputs = consensus.ZERO_HASH;\n  //     if (!(type & hashType.ANYONECANPAY)) {\n  //       if (this._hashPrevouts) {\n  //         prevouts = this._hashPrevouts;\n  //       } else {\n  //         const bw = bio.pool(this.inputs.length * 36);\n  //         for (const input of this.inputs)\n  //           input.prevout.toWriter(bw);\n  //         prevouts = hash256.digest(bw.render());\n  //         if (!this.mutable)\n  //           this._hashPrevouts = prevouts;\n  //       }\n  //     }\n  //     if (!(type & hashType.ANYONECANPAY)\n  //         && (type & 0x1f) !== hashType.SINGLE\n  //         && (type & 0x1f) !== hashType.NONE) {\n  //       if (this._hashSequence) {\n  //         sequences = this._hashSequence;\n  //       } else {\n  //         const bw = bio.pool(this.inputs.length * 4);\n  //         for (const input of this.inputs)\n  //           bw.writeU32(input.sequence);\n  //         sequences = hash256.digest(bw.render());\n  //         if (!this.mutable)\n  //           this._hashSequence = sequences;\n  //       }\n  //     }\n  //     if ((type & 0x1f) !== hashType.SINGLE\n  //         && (type & 0x1f) !== hashType.NONE) {\n  //       if (this._hashOutputs) {\n  //         outputs = this._hashOutputs;\n  //       } else {\n  //         let size = 0;\n  //         for (const output of this.outputs)\n  //           size += output.getSize();\n  //         const bw = bio.pool(size);\n  //         for (const output of this.outputs)\n  //           output.toWriter(bw);\n  //         outputs = hash256.digest(bw.render());\n  //         if (!this.mutable)\n  //           this._hashOutputs = outputs;\n  //       }\n  //     } else if ((type & 0x1f) === hashType.SINGLE) {\n  //       if (index < this.outputs.length) {\n  //         const output = this.outputs[index];\n  //         outputs = hash256.digest(output.toRaw());\n  //       }\n  //     }\n  //     const size = 156 + prev.getVarSize();\n  //     const bw = bio.pool(size);\n  //     bw.writeU32(this.version);\n  //     bw.writeBytes(prevouts);\n  //     bw.writeBytes(sequences);\n  //     bw.writeHash(input.prevout.hash);\n  //     bw.writeU32(input.prevout.index);\n  //     bw.writeVarBytes(prev.toRaw());\n  //     bw.writeI64(value);\n  //     bw.writeU32(input.sequence);\n  //     bw.writeBytes(outputs);\n  //     bw.writeU32(this.locktime);\n  //     bw.writeU32(type);\n  //     return hash256.digest(bw.render());\n  //   }\n  //   /**\n  //    * Verify signature.\n  //    * @param {Number} index\n  //    * @param {Script} prev\n  //    * @param {Amount} value\n  //    * @param {Buffer} sig\n  //    * @param {Buffer} key\n  //    * @param {Number} flags\n  //    * @returns {Boolean}\n  //    */\n  //   checksig(index, prev, value, sig, key, flags) {\n  //     if (sig.length === 0)\n  //       return false;\n  //     const type = sig[sig.length - 1];\n  //     const hash = this.signatureHash(index, prev, value, type, flags);\n  //     let res;\n  //     if (common.isSchnorr(sig)) {\n  //       res = secp256k1.schnorrVerify(hash, sig.slice(0, -1), key)\n  //     } else {\n  //       res = secp256k1.verifyDER(hash, sig.slice(0, -1), key);\n  //     }\n  //     return res;\n  //   }\n  //   /**\n  //    * Create a signature suitable for inserting into scriptSigs.\n  //    * @param {Number} index - Index of input being signed.\n  //    * @param {Script} prev - Previous output script or redeem script.\n  //    * @param {Amount} value - Previous output value.\n  //    * @param {Buffer} key\n  //    * @param {SighashType} type\n  //    * @param {Number} flags - Script flags.\n  //    * @returns {Buffer} Signature in SCHNORR / DER format.\n  //    */\n  //   signature(index, prev, value, key, type, flags) {\n  //     let sig;\n  //     if (type == null)\n  //       type = hashType.ALL;\n  //     if (flags == null)\n  //       flags = Script.flags.VERIFY_SIGHASH_FORKID;\n  //     const hash = this.signatureHash(index, prev, value, type, flags);\n  //     const DER = secp256k1.signDER(hash, key);\n  //     const SCHNORR = secp256k1.schnorrSign(hash, key);\n  //     if (common.isSchnorr(SCHNORR)) {\n  //       sig = SCHNORR;\n  //     } else {\n  //       sig = DER;\n  //     }\n  //     const bw = bio.write(sig.length + 1);\n  //     bw.writeBytes(sig);\n  //     bw.writeU8(type);\n  //     return bw.render();\n  //   }\n  //   /**\n  //    * Create a signature suitable for inserting into scriptSigs.\n  //    * @param {Number} index - Index of input being signed.\n  //    * @param {Script} prev - Previous output script or redeem script.\n  //    * @param {Amount} value - Previous output value.\n  //    * @param {Buffer} key\n  //    * @param {SighashType} type\n  //    * @param {Number} flags - Script flags.\n  //    * @returns {Buffer} Signature in Schnorr format.\n  //    */\n  //   schnorrSignature(index, prev, value, key, type, flags) {\n  //     if (type == null)\n  //       type = hashType.ALL;\n  //     if (flags == null)\n  //       flags = Script.flags.VERIFY_SIGHASH_FORKID;\n  //     const hash = this.signatureHash(index, prev, value, type, flags);\n  //     const sig = secp256k1.schnorrSign(hash, key);\n  //     const bw = bio.write(sig.length + 1);\n  //     bw.writeBytes(sig);\n  //     bw.writeU8(type);\n  //     return bw.render();\n  //   }\n  //   /**\n  //    * Verify all transaction inputs.\n  //    * @param {CoinView} view\n  //    * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n  //    * @throws {ScriptError} on invalid inputs\n  //    */\n  //   check(view, flags) {\n  //     if (this.inputs.length === 0)\n  //       throw new ScriptError('UNKNOWN_ERROR', 'No inputs.');\n  //     if (this.isCoinbase())\n  //       return;\n  //     for (let i = 0; i < this.inputs.length; i++) {\n  //       const {prevout} = this.inputs[i];\n  //       const coin = view.getOutput(prevout);\n  //       if (!coin)\n  //         throw new ScriptError('UNKNOWN_ERROR', 'No coin available.');\n  //       this.checkInput(i, coin, flags);\n  //     }\n  //   }\n  //   /**\n  //    * Verify a transaction input.\n  //    * @param {Number} index - Index of output being\n  //    * verified.\n  //    * @param {Coin|Output} coin - Previous output.\n  //    * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n  //    * @throws {ScriptError} on invalid input\n  //    */\n  //   checkInput(index, coin, flags) {\n  //     const input = this.inputs[index];\n  //     assert(input, 'Input does not exist.');\n  //     assert(coin, 'No coin passed.');\n  //     Script.verify(\n  //       input.script,\n  //       null,\n  //       coin.script,\n  //       this,\n  //       index,\n  //       coin.value,\n  //       flags\n  //     );\n  //   }\n  //   /**\n  //    * Verify the transaction inputs on the worker pool\n  //    * (if workers are enabled).\n  //    * @param {CoinView} view\n  //    * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n  //    * @param {WorkerPool?} pool\n  //    * @returns {Promise}\n  //    */\n  //   async checkAsync(view, flags, pool) {\n  //     if (this.inputs.length === 0)\n  //       throw new ScriptError('UNKNOWN_ERROR', 'No inputs.');\n  //     if (this.isCoinbase())\n  //       return;\n  //     if (!pool) {\n  //       this.check(view, flags);\n  //       return;\n  //     }\n  //     await pool.check(this, view, flags);\n  //   }\n  //   /**\n  //    * Verify a transaction input asynchronously.\n  //    * @param {Number} index - Index of output being\n  //    * verified.\n  //    * @param {Coin|Output} coin - Previous output.\n  //    * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n  //    * @param {WorkerPool?} pool\n  //    * @returns {Promise}\n  //    */\n  //   async checkInputAsync(index, coin, flags, pool) {\n  //     const input = this.inputs[index];\n  //     assert(input, 'Input does not exist.');\n  //     assert(coin, 'No coin passed.');\n  //     if (!pool) {\n  //       this.checkInput(index, coin, flags);\n  //       return;\n  //     }\n  //     await pool.checkInput(this, index, coin, flags);\n  //   }\n  //   /**\n  //    * Verify all transaction inputs.\n  //    * @param {CoinView} view\n  //    * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n  //    * @returns {Boolean} Whether the inputs are valid.\n  //    */\n  //   verify(view, flags) {\n  //     try {\n  //       this.check(view, flags);\n  //     } catch (e) {\n  //       if (e.type === 'ScriptError')\n  //         return false;\n  //       throw e;\n  //     }\n  //     return true;\n  //   }\n  //   /**\n  //    * Verify a transaction input.\n  //    * @param {Number} index - Index of output being\n  //    * verified.\n  //    * @param {Coin|Output} coin - Previous output.\n  //    * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n  //    * @returns {Boolean} Whether the input is valid.\n  //    */\n  //   verifyInput(index, coin, flags) {\n  //     try {\n  //       this.checkInput(index, coin, flags);\n  //     } catch (e) {\n  //       if (e.type === 'ScriptError')\n  //         return false;\n  //       throw e;\n  //     }\n  //     return true;\n  //   }\n  //   /**\n  //    * Verify the transaction inputs on the worker pool\n  //    * (if workers are enabled).\n  //    * @param {CoinView} view\n  //    * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n  //    * @param {WorkerPool?} pool\n  //    * @returns {Promise}\n  //    */\n  //   async verifyAsync(view, flags, pool) {\n  //     try {\n  //       await this.checkAsync(view, flags, pool);\n  //     } catch (e) {\n  //       if (e.type === 'ScriptError')\n  //         return false;\n  //       throw e;\n  //     }\n  //     return true;\n  //   }\n  //   /**\n  //    * Verify a transaction input asynchronously.\n  //    * @param {Number} index - Index of output being\n  //    * verified.\n  //    * @param {Coin|Output} coin - Previous output.\n  //    * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n  //    * @param {WorkerPool?} pool\n  //    * @returns {Promise}\n  //    */\n  //   async verifyInputAsync(index, coin, flags, pool) {\n  //     try {\n  //       await this.checkInput(index, coin, flags, pool);\n  //     } catch (e) {\n  //       if (e.type === 'ScriptError')\n  //         return false;\n  //       throw e;\n  //     }\n  //     return true;\n  //   }\n  //   /**\n  //    * Test whether the transaction is a coinbase\n  //    * by examining the inputs.\n  //    * @returns {Boolean}\n  //    */\n  //   isCoinbase() {\n  //     return this.inputs.length === 1 && this.inputs[0].prevout.isNull();\n  //   }\n  //   /**\n  //    * Test whether the transaction is replaceable.\n  //    * @returns {Boolean}\n  //    */\n  //   isRBF() {\n  //     // Core doesn't do this, but it should:\n  //     if (this.version === 2)\n  //       return false;\n  //     for (const input of this.inputs) {\n  //       if (input.isRBF())\n  //         return true;\n  //     }\n  //     return false;\n  //   }\n  //   /**\n  //    * Calculate the fee for the transaction.\n  //    * @param {CoinView} view\n  //    * @returns {Amount} fee (zero if not all coins are available).\n  //    */\n  //   getFee(view) {\n  //     if (!this.hasCoins(view))\n  //       return 0;\n  //     return this.getInputValue(view) - this.getOutputValue();\n  //   }\n  //   /**\n  //    * Calculate the total input value.\n  //    * @param {CoinView} view\n  //    * @returns {Amount} value\n  //    */\n  //   getInputValue(view) {\n  //     let total = 0;\n  //     for (const {prevout} of this.inputs) {\n  //       const coin = view.getOutput(prevout);\n  //       if (!coin)\n  //         return 0;\n  //       total += coin.value;\n  //     }\n  //     return total;\n  //   }\n  //   /**\n  //    * Calculate the total output value.\n  //    * @returns {Amount} value\n  //    */\n  //   getOutputValue() {\n  //     let total = 0;\n  //     for (const output of this.outputs)\n  //       total += output.value;\n  //     return total;\n  //   }\n  //   /**\n  //    * Get all input addresses.\n  //    * @private\n  //    * @param {CoinView} view\n  //    * @returns {Array} [addrs, table]\n  //    */\n  //   _getInputAddresses(view) {\n  //     const table = new BufferSet();\n  //     const addrs = [];\n  //     if (this.isCoinbase())\n  //       return [addrs, table];\n  //     for (const input of this.inputs) {\n  //       const coin = view ? view.getOutputFor(input) : null;\n  //       const addr = input.getAddress(coin);\n  //       if (!addr)\n  //         continue;\n  //       const hash = addr.getHash();\n  //       if (!table.has(hash)) {\n  //         table.add(hash);\n  //         addrs.push(addr);\n  //       }\n  //     }\n  //     return [addrs, table];\n  //   }\n  //   /**\n  //    * Get all output addresses.\n  //    * @private\n  //    * @returns {Array} [addrs, table]\n  //    */\n  //   _getOutputAddresses() {\n  //     const table = new BufferSet();\n  //     const addrs = [];\n  //     for (const output of this.outputs) {\n  //       const addr = output.getAddress();\n  //       if (!addr)\n  //         continue;\n  //       const hash = addr.getHash();\n  //       if (!table.has(hash)) {\n  //         table.add(hash);\n  //         addrs.push(addr);\n  //       }\n  //     }\n  //     return [addrs, table];\n  //   }\n  //   /**\n  //    * Get all addresses.\n  //    * @private\n  //    * @param {CoinView} view\n  //    * @returns {Array} [addrs, table]\n  //    */\n  //   _getAddresses(view) {\n  //     const [addrs, table] = this._getInputAddresses(view);\n  //     const output = this.getOutputAddresses();\n  //     for (const addr of output) {\n  //       const hash = addr.getHash();\n  //       if (!table.has(hash)) {\n  //         table.add(hash);\n  //         addrs.push(addr);\n  //       }\n  //     }\n  //     return [addrs, table];\n  //   }\n  //   /**\n  //    * Get all input addresses.\n  //    * @param {CoinView|null} view\n  //    * @returns {Address[]} addresses\n  //    */\n  //   getInputAddresses(view) {\n  //     const [addrs] = this._getInputAddresses(view);\n  //     return addrs;\n  //   }\n  //   /**\n  //    * Get all output addresses.\n  //    * @returns {Address[]} addresses\n  //    */\n  //   getOutputAddresses() {\n  //     const [addrs] = this._getOutputAddresses();\n  //     return addrs;\n  //   }\n  //   /**\n  //    * Get all addresses.\n  //    * @param {CoinView|null} view\n  //    * @returns {Address[]} addresses\n  //    */\n  //   getAddresses(view) {\n  //     const [addrs] = this._getAddresses(view);\n  //     return addrs;\n  //   }\n  //   /**\n  //    * Get all input address hashes.\n  //    * @param {CoinView|null} view\n  //    * @returns {Hash[]} hashes\n  //    */\n  //   getInputHashes(view, enc) {\n  //     const [, table] = this._getInputAddresses(view);\n  //     if (enc !== 'hex')\n  //       return table.toArray();\n  //     return table.toArray().map(h => h.toString('hex'));\n  //   }\n  //   /**\n  //    * Get all output address hashes.\n  //    * @returns {Hash[]} hashes\n  //    */\n  //   getOutputHashes(enc) {\n  //     const [, table] = this._getOutputAddresses();\n  //     if (enc !== 'hex')\n  //       return table.toArray();\n  //     return table.toArray().map(h => h.toString('hex'));\n  //   }\n  //   /**\n  //    * Get all address hashes.\n  //    * @param {CoinView|null} view\n  //    * @returns {Hash[]} hashes\n  //    */\n  //   getHashes(view, enc) {\n  //     const [, table] = this._getAddresses(view);\n  //     if (enc !== 'hex')\n  //       return table.toArray();\n  //     return table.toArray().map(h => h.toString('hex'));\n  //   }\n  //   /**\n  //    * Test whether the transaction has\n  //    * all coins available.\n  //    * @param {CoinView} view\n  //    * @returns {Boolean}\n  //    */\n  //   hasCoins(view) {\n  //     if (this.inputs.length === 0)\n  //       return false;\n  //     for (const {prevout} of this.inputs) {\n  //       if (!view.hasEntry(prevout))\n  //         return false;\n  //     }\n  //     return true;\n  //   }\n  //   /**\n  //    * Check finality of transaction by examining\n  //    * nLocktime and nSequence values.\n  //    * @example\n  //    * tx.isFinal(chain.height + 1, network.now());\n  //    * @param {Number} height - Height at which to test. This\n  //    * is usually the chain height, or the chain height + 1\n  //    * when the transaction entered the mempool.\n  //    * @param {Number} time - Time at which to test. This is\n  //    * usually the chain tip's parent's median time, or the\n  //    * time at which the transaction entered the mempool. If\n  //    * MEDIAN_TIME_PAST is enabled this will be the median\n  //    * time of the chain tip's previous entry's median time.\n  //    * @returns {Boolean}\n  //    */\n  //   isFinal(height, time) {\n  //     const THRESHOLD = consensus.LOCKTIME_THRESHOLD;\n  //     if (this.locktime === 0)\n  //       return true;\n  //     if (this.locktime < (this.locktime < THRESHOLD ? height : time))\n  //       return true;\n  //     for (const input of this.inputs) {\n  //       if (input.sequence !== 0xffffffff)\n  //         return false;\n  //     }\n  //     return true;\n  //   }\n  //   /**\n  //    * Verify the absolute locktime of a transaction.\n  //    * Called by OP_CHECKLOCKTIMEVERIFY.\n  //    * @param {Number} index - Index of input being verified.\n  //    * @param {Number} predicate - Locktime to verify against.\n  //    * @returns {Boolean}\n  //    */\n  //   verifyLocktime(index, predicate) {\n  //     const THRESHOLD = consensus.LOCKTIME_THRESHOLD;\n  //     const input = this.inputs[index];\n  //     assert(input, 'Input does not exist.');\n  //     assert(predicate >= 0, 'Locktime must be non-negative.');\n  //     // Locktimes must be of the same type (blocks or seconds).\n  //     if ((this.locktime < THRESHOLD) !== (predicate < THRESHOLD))\n  //       return false;\n  //     if (predicate > this.locktime)\n  //       return false;\n  //     if (input.sequence === 0xffffffff)\n  //       return false;\n  //     return true;\n  //   }\n  //   /**\n  //    * Verify the relative locktime of an input.\n  //    * Called by OP_CHECKSEQUENCEVERIFY.\n  //    * @param {Number} index - Index of input being verified.\n  //    * @param {Number} predicate - Relative locktime to verify against.\n  //    * @returns {Boolean}\n  //    */\n  //   verifySequence(index, predicate) {\n  //     const DISABLE_FLAG = consensus.SEQUENCE_DISABLE_FLAG;\n  //     const TYPE_FLAG = consensus.SEQUENCE_TYPE_FLAG;\n  //     const MASK = consensus.SEQUENCE_MASK;\n  //     const input = this.inputs[index];\n  //     assert(input, 'Input does not exist.');\n  //     assert(predicate >= 0, 'Locktime must be non-negative.');\n  //     // For future softfork capability.\n  //     if (predicate & DISABLE_FLAG)\n  //       return true;\n  //     // Version must be >=2.\n  //     if (this.version < 2)\n  //       return false;\n  //     // Cannot use the disable flag without\n  //     // the predicate also having the disable\n  //     // flag (for future softfork capability).\n  //     if (input.sequence & DISABLE_FLAG)\n  //       return false;\n  //     // Locktimes must be of the same type (blocks or seconds).\n  //     if ((input.sequence & TYPE_FLAG) !== (predicate & TYPE_FLAG))\n  //       return false;\n  //     if ((predicate & MASK) > (input.sequence & MASK))\n  //       return false;\n  //     return true;\n  //   }\n  //   /**\n  //    * Calculate legacy (inaccurate) sigop count.\n  //    * @returns {Number} sigop count\n  //    */\n  //   getLegacySigops() {\n  //     if (this._sigops !== -1)\n  //       return this._sigops;\n  //     let total = 0;\n  //     for (const input of this.inputs)\n  //       total += input.script.getSigops(false);\n  //     for (const output of this.outputs)\n  //       total += output.script.getSigops(false);\n  //     if (!this.mutable)\n  //       this._sigops = total;\n  //     return total;\n  //   }\n  //   /**\n  //    * Calculate accurate sigop count, taking into account redeem scripts.\n  //    * @param {CoinView} view\n  //    * @param {VerifyFlags} flags\n  //    * @returns {Number} sigop count\n  //    */\n  //   getScripthashSigops(view, flags) {\n  //     if (this.isCoinbase())\n  //       return 0;\n  //     let total = 0;\n  //     for (const input of this.inputs) {\n  //       const coin = view.getOutputFor(input);\n  //       if (!coin)\n  //         continue;\n  //       if (!coin.script.isScripthash())\n  //         continue;\n  //       total += coin.script.getScripthashSigops(input.script, flags);\n  //     }\n  //     return total;\n  //   }\n  //   /**\n  //    * Calculate sigops count.\n  //    * @param {CoinView} view\n  //    * @param {VerifyFlags?} flags\n  //    * @returns {Number} sigop count\n  //    */\n  //   getSigopsCount(view, flags) {\n  //     if (flags === null)\n  //       flags = Script.flags.STANDARD_VERIFY_FLAGS;\n  //     let cost = this.getLegacySigops();\n  //     if (flags & Script.flags.VERIFY_P2SH)\n  //       cost += this.getScripthashSigops(view, flags);\n  //     return cost;\n  //   }\n  //   /**\n  //    * Calculate sigop count.\n  //    * @param {CoinView} view\n  //    * @param {VerifyFlags?} flags\n  //    * @returns {Number} sigop count\n  //    */\n  //   getSigops(view, flags) {\n  //     return this.getSigopsCount(view, flags);\n  //   }\n  //   /**\n  //    * Non-contextual sanity checks for the transaction.\n  //    * Will mostly verify coin and output values.\n  //    * @see CheckTransaction()\n  //    * @returns {Array} [result, reason, score]\n  //    */\n  //   isSane() {\n  //     const [valid] = this.checkSanity();\n  //     return valid;\n  //   }\n  //   /**\n  //    * Non-contextual sanity checks for the transaction.\n  //    * Will mostly verify coin and output values.\n  //    * @see CheckTransaction()\n  //    * @returns {Array} [valid, reason, score]\n  //    */\n  //   checkSanity() {\n  //     if (this.inputs.length === 0)\n  //       return [false, 'bad-txns-vin-empty', 100];\n  //     if (this.outputs.length === 0)\n  //       return [false, 'bad-txns-vout-empty', 100];\n  //     if (this.getSize() > consensus.MAX_TX_SIZE)\n  //       return [false, 'bad-txns-oversize', 100];\n  //     let total = 0;\n  //     for (const output of this.outputs) {\n  //       if (output.value < 0)\n  //         return [false, 'bad-txns-vout-negative', 100];\n  //       if (output.value > consensus.MAX_MONEY)\n  //         return [false, 'bad-txns-vout-toolarge', 100];\n  //       total += output.value;\n  //       if (total < 0 || total > consensus.MAX_MONEY)\n  //         return [false, 'bad-txns-txouttotal-toolarge', 100];\n  //     }\n  //     const prevout = new BufferSet();\n  //     for (const input of this.inputs) {\n  //       const key = input.prevout.toKey();\n  //       if (prevout.has(key))\n  //         return [false, 'bad-txns-inputs-duplicate', 100];\n  //       prevout.add(key);\n  //     }\n  //     if (this.isCoinbase()) {\n  //       const size = this.inputs[0].script.getSize();\n  //       if (size < 2 || size > consensus.MAX_COINBASE_SCRIPTSIG_SIZE)\n  //         return [false, 'bad-cb-length', 100];\n  //     } else {\n  //       for (const input of this.inputs) {\n  //         if (input.prevout.isNull())\n  //           return [false, 'bad-txns-prevout-null', 10];\n  //       }\n  //     }\n  //     return [true, 'valid', 0];\n  //   }\n  //   /**\n  //    * Non-contextual checks to determine whether the\n  //    * transaction has all standard output script\n  //    * types and standard input script size with only\n  //    * pushdatas in the code.\n  //    * Will mostly verify coin and output values.\n  //    * @see IsStandardTx()\n  //    * @returns {Array} [valid, reason, score]\n  //    */\n  //   isStandard() {\n  //     const [valid] = this.checkStandard();\n  //     return valid;\n  //   }\n  //   /**\n  //    * Non-contextual checks to determine whether the\n  //    * transaction has all standard output script\n  //    * types and standard input script size with only\n  //    * pushdatas in the code.\n  //    * Will mostly verify coin and output values.\n  //    * @see IsStandardTx()\n  //    * @returns {Array} [valid, reason, score]\n  //    */\n  //   checkStandard() {\n  //     if (this.version < 1 || this.version > policy.MAX_TX_VERSION)\n  //       return [false, 'version', 0];\n  //     // MAX_STANDARD_TX_SIZE\n  //     if (this.getSize() >= policy.MAX_TX_SIZE)\n  //       return [false, 'tx-size', 0];\n  //     for (const input of this.inputs) {\n  //       if (input.script.getSize() > 1650)\n  //         return [false, 'scriptsig-size', 0];\n  //       if (!input.script.isPushOnly())\n  //         return [false, 'scriptsig-not-pushonly', 0];\n  //     }\n  //     let nulldata = 0;\n  //     for (const output of this.outputs) {\n  //       if (!output.script.isStandard())\n  //         return [false, 'scriptpubkey', 0];\n  //       if (output.script.isNulldata()) {\n  //         nulldata++;\n  //         continue;\n  //       }\n  //       if (output.script.isMultisig() && !policy.BARE_MULTISIG)\n  //         return [false, 'bare-multisig', 0];\n  //       if (output.isDust(policy.MIN_RELAY))\n  //         return [false, 'dust', 0];\n  //     }\n  //     if (nulldata > 1)\n  //       return [false, 'multi-op-return', 0];\n  //     return [true, 'valid', 0];\n  //   }\n  //   /**\n  //    * Perform contextual checks to verify coin and input\n  //    * script standardness (including the redeem script).\n  //    * @see AreInputsStandard()\n  //    * @param {CoinView} view\n  //    * @param {VerifyFlags?} flags\n  //    * @returns {Boolean}\n  //    */\n  //   hasStandardInputs(view) {\n  //     if (this.isCoinbase())\n  //       return true;\n  //     for (const input of this.inputs) {\n  //       const coin = view.getOutputFor(input);\n  //       if (!coin)\n  //         return false;\n  //       if (coin.script.isPubkeyhash())\n  //         continue;\n  //       if (coin.script.isScripthash()) {\n  //         const redeem = input.script.getRedeem();\n  //         if (!redeem)\n  //           return false;\n  //         if (redeem.getSigops(true) > policy.MAX_P2SH_SIGOPS)\n  //           return false;\n  //         continue;\n  //       }\n  //       if (coin.script.isUnknown())\n  //         return false;\n  //     }\n  //     return true;\n  //   }\n  //   /**\n  //    * Perform contextual checks to verify input, output,\n  //    * and fee values, as well as coinbase spend maturity\n  //    * (coinbases can only be spent 100 blocks or more\n  //    * after they're created). Note that this function is\n  //    * consensus critical.\n  //    * @param {CoinView} view\n  //    * @param {Number} height - Height at which the\n  //    * transaction is being spent. In the mempool this is\n  //    * the chain height plus one at the time it entered the pool.\n  //    * @returns {Boolean}\n  //    */\n  //   verifyInputs(view, height) {\n  //     const [fee] = this.checkInputs(view, height);\n  //     return fee !== -1;\n  //   }\n  //   /**\n  //    * Perform contextual checks to verify input, output,\n  //    * and fee values, as well as coinbase spend maturity\n  //    * (coinbases can only be spent 100 blocks or more\n  //    * after they're created). Note that this function is\n  //    * consensus critical.\n  //    * @param {CoinView} view\n  //    * @param {Number} height - Height at which the\n  //    * transaction is being spent. In the mempool this is\n  //    * the chain height plus one at the time it entered the pool.\n  //    * @returns {Array} [fee, reason, score]\n  //    */\n  //   checkInputs(view, height) {\n  //     assert(typeof height === 'number');\n  //     let total = 0;\n  //     for (const {prevout} of this.inputs) {\n  //       const entry = view.getEntry(prevout);\n  //       if (!entry)\n  //         return [-1, 'bad-txns-inputs-missingorspent', 0];\n  //       if (entry.coinbase) {\n  //         if (height - entry.height < consensus.COINBASE_MATURITY)\n  //           return [-1, 'bad-txns-premature-spend-of-coinbase', 0];\n  //       }\n  //       const coin = view.getOutput(prevout);\n  //       assert(coin);\n  //       if (coin.value < 0 || coin.value > consensus.MAX_MONEY)\n  //         return [-1, 'bad-txns-inputvalues-outofrange', 100];\n  //       total += coin.value;\n  //       if (total < 0 || total > consensus.MAX_MONEY)\n  //         return [-1, 'bad-txns-inputvalues-outofrange', 100];\n  //     }\n  //     // Overflows already checked in `isSane()`.\n  //     const value = this.getOutputValue();\n  //     if (total < value)\n  //       return [-1, 'bad-txns-in-belowout', 100];\n  //     const fee = total - value;\n  //     if (fee < 0)\n  //       return [-1, 'bad-txns-fee-negative', 100];\n  //     if (fee > consensus.MAX_MONEY)\n  //       return [-1, 'bad-txns-fee-outofrange', 100];\n  //     return [fee, 'valid', 0];\n  //   }\n  //   /**\n  //    * Calculate the modified size of the transaction. This\n  //    * is used in the mempool for calculating priority.\n  //    * @param {Number?} size - The size to modify. If not present,\n  //    * virtual size will be used.\n  //    * @returns {Number} Modified size.\n  //    */\n  //   getModifiedSize(size) {\n  //     if (size == null)\n  //       size = this.getSize();\n  //     for (const input of this.inputs) {\n  //       const offset = 41 + Math.min(110, input.script.getSize());\n  //       if (size > offset)\n  //         size -= offset;\n  //     }\n  //     return size;\n  //   }\n  //   /**\n  //    * Calculate the transaction priority.\n  //    * @param {CoinView} view\n  //    * @param {Number} height\n  //    * @param {Number?} size - Size to calculate priority\n  //    * based on. If not present, virtual size will be used.\n  //    * @returns {Number}\n  //    */\n  //   getPriority(view, height, size) {\n  //     assert(typeof height === 'number', 'Must pass in height.');\n  //     if (this.isCoinbase())\n  //       return 0;\n  //     if (size == null)\n  //       size = this.getSize();\n  //     let sum = 0;\n  //     for (const {prevout} of this.inputs) {\n  //       const coin = view.getOutput(prevout);\n  //       if (!coin)\n  //         continue;\n  //       const coinHeight = view.getHeight(prevout);\n  //       if (coinHeight === -1)\n  //         continue;\n  //       if (coinHeight <= height) {\n  //         const age = height - coinHeight;\n  //         sum += coin.value * age;\n  //       }\n  //     }\n  //     return Math.floor(sum / size);\n  //   }\n  //   /**\n  //    * Calculate the transaction's on-chain value.\n  //    * @param {CoinView} view\n  //    * @returns {Number}\n  //    */\n  //   getChainValue(view) {\n  //     if (this.isCoinbase())\n  //       return 0;\n  //     let value = 0;\n  //     for (const {prevout} of this.inputs) {\n  //       const coin = view.getOutput(prevout);\n  //       if (!coin)\n  //         continue;\n  //       const height = view.getHeight(prevout);\n  //       if (height === -1)\n  //         continue;\n  //       value += coin.value;\n  //     }\n  //     return value;\n  //   }\n  //   /**\n  //    * Determine whether the transaction is above the\n  //    * free threshold in priority. A transaction which\n  //    * passed this test is most likely relayable\n  //    * without a fee.\n  //    * @param {CoinView} view\n  //    * @param {Number?} height - If not present, tx\n  //    * height or network height will be used.\n  //    * @param {Number?} size - If not present, modified\n  //    * size will be calculated and used.\n  //    * @returns {Boolean}\n  //    */\n  //   isFree(view, height, size) {\n  //     const priority = this.getPriority(view, height, size);\n  //     return priority > policy.FREE_THRESHOLD;\n  //   }\n  //   /**\n  //    * Calculate minimum fee in order for the transaction\n  //    * to be relayable (not the constant min relay fee).\n  //    * @param {Number?} size - If not present, max size\n  //    * estimation will be calculated and used.\n  //    * @param {Rate?} rate - Rate of satoshi per kB.\n  //    * @returns {Amount} fee\n  //    */\n  //   getMinFee(size, rate) {\n  //     if (size == null)\n  //       size = this.getSize();\n  //     return policy.getMinFee(size, rate);\n  //   }\n  //   /**\n  //    * Calculate the minimum fee in order for the transaction\n  //    * to be relayable, but _round to the nearest kilobyte\n  //    * when taking into account size.\n  //    * @param {Number?} size - If not present, max size\n  //    * estimation will be calculated and used.\n  //    * @param {Rate?} rate - Rate of satoshi per kB.\n  //    * @returns {Amount} fee\n  //    */\n  //   getRoundFee(size, rate) {\n  //     if (size == null)\n  //       size = this.getSize();\n  //     return policy.getRoundFee(size, rate);\n  //   }\n  //   /**\n  //    * Calculate the transaction's rate based on size\n  //    * and fees. Size will be calculated if not present.\n  //    * @param {CoinView} view\n  //    * @param {Number?} size\n  //    * @returns {Rate}\n  //    */\n  //   getRate(view, size) {\n  //     const fee = this.getFee(view);\n  //     if (fee < 0)\n  //       return 0;\n  //     if (size == null)\n  //       size = this.getSize();\n  //     return policy.getRate(size, fee);\n  //   }\n  //   /**\n  //    * Get all unique outpoint hashes.\n  //    * @returns {Hash[]} Outpoint hashes.\n  //    */\n  //   getPrevout() {\n  //     if (this.isCoinbase())\n  //       return [];\n  //     const prevout = new BufferSet();\n  //     for (const input of this.inputs)\n  //       prevout.add(input.prevout.hash);\n  //     return prevout.toArray();\n  //   }\n  //   /**\n  //    * Test a transaction against a bloom filter using\n  //    * the BIP37 matching algorithm. Note that this may\n  //    * update the filter depending on what the `update`\n  //    * value is.\n  //    * @see \"Filter matching algorithm\":\n  //    * @see https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki\n  //    * @param {BloomFilter} filter\n  //    * @returns {Boolean} True if the transaction matched.\n  //    */\n  //   isWatched(filter) {\n  //     let found = false;\n  //     // 1. Test the tx hash\n  //     if (filter.test(this.hash()))\n  //       found = true;\n  //     // 2. Test data elements in output scripts\n  //     //    (may need to update filter on match)\n  //     for (let i = 0; i < this.outputs.length; i++) {\n  //       const output = this.outputs[i];\n  //       // Test the output script\n  //       if (output.script.test(filter)) {\n  //         if (filter.update === 1 /* ALL */) {\n  //           const prevout = Outpoint.fromTX(this, i);\n  //           filter.add(prevout.toRaw());\n  //         } else if (filter.update === 2 /* PUBKEY_ONLY */) {\n  //           if (output.script.isPubkey() || output.script.isMultisig()) {\n  //             const prevout = Outpoint.fromTX(this, i);\n  //             filter.add(prevout.toRaw());\n  //           }\n  //         }\n  //         found = true;\n  //       }\n  //     }\n  //     if (found)\n  //       return found;\n  //     // 3. Test prev_out structure\n  //     // 4. Test data elements in input scripts\n  //     for (const input of this.inputs) {\n  //       const prevout = input.prevout;\n  //       // Test the COutPoint structure\n  //       if (filter.test(prevout.toRaw()))\n  //         return true;\n  //       // Test the input script\n  //       if (input.script.test(filter))\n  //         return true;\n  //     }\n  //     // 5. No match\n  //     return false;\n  //   }\n  //   /**\n  //    * Get little-endian tx hash.\n  //    * @returns {Hash}\n  //    */\n  //   rhash() {\n  //     return util.revHex(this.hash());\n  //   }\n  //   /**\n  //    * Get little-endian tx hash.\n  //    * @returns {Hash}\n  //    */\n  //   txid() {\n  //     return this.rhash();\n  //   }\n  //   /**\n  //    * Convert the tx to an inv item.\n  //    * @returns {InvItem}\n  //    */\n  //   toInv() {\n  //     return new InvItem(InvItem.types.TX, this.hash());\n  //   }\n  //   /**\n  //    * Inspect the transaction and return a more\n  //    * user-friendly representation of the data.\n  //    * @returns {Object}\n  //    */\n  //   [inspectSymbol]() {\n  //     return this.format();\n  //   }\n  //   /**\n  //    * Inspect the transaction and return a more\n  //    * user-friendly representation of the data.\n  //    * @param {CoinView} view\n  //    * @param {ChainEntry} entry\n  //    * @param {Number} index\n  //    * @returns {Object}\n  //    */\n  //   format(view, entry, index) {\n  //     let rate = 0;\n  //     let fee = 0;\n  //     let height = -1;\n  //     let block = null;\n  //     let time = 0;\n  //     let date = null;\n  //     if (view) {\n  //       fee = this.getFee(view);\n  //       rate = this.getRate(view);\n  //       // Rate can exceed 53 bits in testing.\n  //       if (!Number.isSafeInteger(rate))\n  //         rate = 0;\n  //     }\n  //     if (entry) {\n  //       height = entry.height;\n  //       block = util.revHex(entry.hash);\n  //       time = entry.time;\n  //       date = util.date(time);\n  //     }\n  //     if (index == null)\n  //       index = -1;\n  //     const hr = {\n  //       hash: this.txid(),\n  //       size: this.getSize(),\n  //       value: Amount.btc(this.getOutputValue()),\n  //       fee: Amount.btc(fee),\n  //       rate: Amount.btc(rate),\n  //       minFee: Amount.btc(this.getMinFee()),\n  //       height: height,\n  //       block: block,\n  //       time: time,\n  //       date: date,\n  //       index: index,\n  //       version: this.version,\n  //       inputs: this.inputs.map((input) => {\n  //         const coin = view ? view.getOutputFor(input) : null;\n  //         return input.format(coin);\n  //       }),\n  //       outputs: this.outputs,\n  //       locktime: this.locktime\n  //     };\n  //     if (this.slpToken) {\n  //       return {\n  //         ...hr,\n  //         slpToken: this.slpToken\n  //       };\n  //     }\n  //     return hr;\n  //   }\n  //   /**\n  //    * Convert the transaction to an object suitable\n  //    * for JSON serialization.\n  //    * @returns {Object}\n  //    */\n  //   toJSON() {\n  //     return this.getJSON();\n  //   }\n  //   /**\n  //    * Convert the transaction to an object suitable\n  //    * for JSON serialization. Note that the hashes\n  //    * will be reversed to abide by bitcoind's legacy\n  //    * of little-endian uint256s.\n  //    * @param {Network} network\n  //    * @param {CoinView} view\n  //    * @param {ChainEntry} entry\n  //    * @param {Number} index\n  //    * @returns {Object}\n  //    */\n  //   getJSON(network, view, entry, index) {\n  //     let rate, fee, height, block, time, date;\n  //     if (view) {\n  //       fee = this.getFee(view);\n  //       rate = this.getRate(view);\n  //       // Rate can exceed 53 bits in testing.\n  //       if (!Number.isSafeInteger(rate))\n  //         rate = 0;\n  //     }\n  //     if (entry) {\n  //       height = entry.height;\n  //       block = util.revHex(entry.hash);\n  //       time = entry.time;\n  //       date = util.date(time);\n  //     }\n  //     network = Network.get(network);\n  //     const json = {\n  //       hash: this.txid(),\n  //       fee: fee,\n  //       rate: rate,\n  //       mtime: util.now(),\n  //       height: height,\n  //       block: block,\n  //       time: time,\n  //       date: date,\n  //       index: index,\n  //       version: this.version,\n  //       inputs: this.inputs.map((input) => {\n  //         const coin = view ? view.getCoinFor(input) : null;\n  //         return input.getJSON(network, coin);\n  //       }),\n  //       outputs: this.outputs.map((output) => {\n  //         return output.getJSON(network);\n  //       }),\n  //       locktime: this.locktime,\n  //       hex: this.toRaw().toString('hex')\n  //     };\n  //     if (this.slpToken) {\n  //       return {\n  //         ...json,\n  //         slpToken: this.slpToken.getJSON()\n  //       };\n  //     }\n  //     return json;\n  //   }\n  //   /**\n  //    * Inject properties from a json object.\n  //    * @private\n  //    * @param {Object} json\n  //    */\n  //   fromJSON(json) {\n  //     assert(json, 'TX data is required.');\n  //     assert((json.version >>> 0) === json.version, 'Version must be a uint32.');\n  //     assert(Array.isArray(json.inputs), 'Inputs must be an array.');\n  //     assert(Array.isArray(json.outputs), 'Outputs must be an array.');\n  //     assert((json.locktime >>> 0) === json.locktime,\n  //       'Locktime must be a uint32.');\n  //     this.version = json.version;\n  //     for (const input of json.inputs)\n  //       this.inputs.push(Input.fromJSON(input));\n  //     for (const output of json.outputs)\n  //       this.outputs.push(Output.fromJSON(output));\n  //     this.locktime = json.locktime;\n  //     if (json.slpToken)\n  //       this.slpToken = SLP.TokenRecord().fromJSON(json.slpToken)\n  //     return this;\n  //   }\n  //   /**\n  //    * Instantiate a transaction from a\n  //    * jsonified transaction object.\n  //    * @param {Object} json - The jsonified transaction object.\n  //    * @returns {TX}\n  //    */\n  //   static fromJSON(json) {\n  //     return new this().fromJSON(json);\n  //   }\n  //   /**\n  //    * Instantiate a transaction from a serialized Buffer.\n  //    * @param {Buffer} data\n  //    * @param {String?} enc - Encoding, can be `'hex'` or null.\n  //    * @returns {TX}\n  //    */\n  //   static fromRaw(data, enc) {\n  //     if (typeof data === 'string')\n  //       data = Buffer.from(data, enc);\n  //     return new this().fromRaw(data);\n  //   }\n  //   /**\n  //    * Instantiate a transaction from a buffer reader.\n  //    * @param {BufferReader} br\n  //    * @param {Boolean} block\n  //    * @returns {TX}\n  //    */\n  //   static fromReader(br, block) {\n  //     return new this().fromReader(br, block);\n  //   }\n  //   /**\n  //    * Inject properties from serialized data.\n  //    * @private\n  //    * @param {Buffer} data\n  //    */\n  //   fromRaw(data) {\n  //     return this.fromReader(bio.read(data));\n  //   }\n  //   /**\n  //    * Inject properties from buffer reader.\n  //    * @private\n  //    * @param {BufferReader} br\n  //    * @param {Boolean} block\n  //    */\n  //   fromReader(br, block) {\n  //     const start = br.start();\n  //     this.version = br.readU32();\n  //     const inCount = br.readVarint();\n  //     for (let i = 0; i < inCount; i++)\n  //       this.inputs.push(Input.fromReader(br));\n  //     const outCount = br.readVarint();\n  //     for (let i = 0; i < outCount; i++)\n  //       this.outputs.push(Output.fromReader(br));\n  //     this.locktime = br.readU32();\n  //     if (block) {\n  //       this._offset = start;\n  //       this._block = true;\n  //     }\n  //     if (!this.mutable) {\n  //       this._raw = br.endData();\n  //       this._size = this._raw.length;\n  //     } else {\n  //       br.end();\n  //     }\n  //     return this;\n  //   }\n  //   /**\n  //    * Serialize transaction without witness.\n  //    * @private\n  //    * @returns {RawTX}\n  //    */\n  //   frameNormal() {\n  //     const raw = this.getNormalSizes();\n  //     const bw = bio.write(raw.size);\n  //     this.writeNormal(bw);\n  //     raw.data = bw.render();\n  //     return raw;\n  //   }\n  //   /**\n  //    * Serialize transaction without witness.\n  //    * @private\n  //    * @param {BufferWriter} bw\n  //    * @returns {RawTX}\n  //    */\n  //   writeNormal(bw) {\n  //     if (this.inputs.length === 0 && this.outputs.length !== 0)\n  //       throw new Error('Cannot serialize zero-input tx.');\n  //     bw.writeU32(this.version);\n  //     bw.writeVarint(this.inputs.length);\n  //     for (const input of this.inputs)\n  //       input.toWriter(bw);\n  //     bw.writeVarint(this.outputs.length);\n  //     for (const output of this.outputs)\n  //       output.toWriter(bw);\n  //     bw.writeU32(this.locktime);\n  //     return bw;\n  //   }\n  //   /**\n  //    * Calculate the real size of the transaction\n  //    * without the witness vector.\n  //    * @returns {RawTX}\n  //    */\n  //   getNormalSizes() {\n  //     let base = 0;\n  //     base += 4;\n  //     base += encoding.sizeVarint(this.inputs.length);\n  //     for (const input of this.inputs)\n  //       base += input.getSize();\n  //     base += encoding.sizeVarint(this.outputs.length);\n  //     for (const output of this.outputs)\n  //       base += output.getSize();\n  //     base += 4;\n  //     return new RawTX(base, 0);\n  //   }\n  //   /**\n  //    * Test whether an object is a TX.\n  //    * @param {Object} obj\n  //    * @returns {Boolean}\n  //    */\n  //   static isTX(obj) {\n  //     return obj instanceof TX;\n  //   }\n\n\n} // /*\n//  * Helpers\n//  */\n// class RawTX {\n//   constructor(size) {\n//     this.data = null;\n//     this.size = size;\n//   }\n// }\n\n/*\n * Expose\n */\n\n\nmodule.exports = TX;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/primitives/tx.js"],"names":["assert","require","bio","hash256","secp256k1","BufferSet","util","Amount","Network","Script","SLP","Input","Output","Outpoint","InvItem","consensus","policy","ScriptError","encoding","hashType","common","inspectSymbol","TX","constructor","options","version","inputs","outputs","locktime","mutable","_hash","_hhash","_raw","_offset","_block","_size","_sigops","_hashPrevouts","_hashSequence","_hashOutputs","fromOptions","Array","isArray","input","push","output","slpToken","TokenRecord","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,OAAD,CAAtB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,uBAAD,CAAzB;;AACA,MAAM;AAACI,EAAAA;AAAD,IAAcJ,OAAO,CAAC,YAAD,CAA3B;;AACA,MAAMK,IAAI,GAAGL,OAAO,CAAC,eAAD,CAApB;;AACA,MAAMM,MAAM,GAAGN,OAAO,CAAC,eAAD,CAAtB;;AACA,MAAMO,OAAO,GAAGP,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMQ,MAAM,GAAGR,OAAO,CAAC,kBAAD,CAAtB;;AACA,MAAMS,GAAG,GAAGT,OAAO,CAAC,eAAD,CAAnB;;AACA,MAAMU,KAAK,GAAGV,OAAO,CAAC,SAAD,CAArB;;AACA,MAAMW,MAAM,GAAGX,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMY,QAAQ,GAAGZ,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAMa,OAAO,GAAGb,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAMc,SAAS,GAAGd,OAAO,CAAC,uBAAD,CAAzB;;AACA,MAAMe,MAAM,GAAGf,OAAO,CAAC,oBAAD,CAAtB;;AACA,MAAMgB,WAAW,GAAGhB,OAAO,CAAC,uBAAD,CAA3B;;AACA,MAAM;AAACiB,EAAAA;AAAD,IAAahB,GAAnB;AACA,MAAM;AAACiB,EAAAA;AAAD,IAAaV,MAAnB;;AACA,MAAMW,MAAM,GAAGnB,OAAO,CAAC,kBAAD,CAAtB;;AACA,MAAM;AAACoB,EAAAA;AAAD,IAAkBpB,OAAO,CAAC,UAAD,CAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMqB,EAAN,CAAS;AACP;AACF;AACA;AACA;AACA;AAEEC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB,SAAKC,OAAL,GAAe,CAAf;AACA,SAAKC,MAAL,GAAc,EAAd;AACA,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,QAAL,GAAgB,CAAhB;AAEA,SAAKC,OAAL,GAAe,KAAf;AAEA,SAAKC,KAAL,GAAa,IAAb;AACA,SAAKC,MAAL,GAAc,IAAd;AAEA,SAAKC,IAAL,GAAY,IAAZ;AACA,SAAKC,OAAL,GAAe,CAAC,CAAhB;AACA,SAAKC,MAAL,GAAc,KAAd;AACA,SAAKC,KAAL,GAAa,CAAC,CAAd;AACA,SAAKC,OAAL,GAAe,CAAC,CAAhB;AAEA,SAAKC,aAAL,GAAqB,IAArB;AACA,SAAKC,aAAL,GAAqB,IAArB;AACA,SAAKC,YAAL,GAAoB,IAApB;AAEA,QAAIf,OAAJ,EACE,KAAKgB,WAAL,CAAiBhB,OAAjB;AACH;AAED;AACF;AACA;AACA;AACA;;;AAEEgB,EAAAA,WAAW,CAAChB,OAAD,EAAU;AACnBxB,IAAAA,MAAM,CAACwB,OAAD,EAAU,sBAAV,CAAN;;AAEA,QAAIA,OAAO,CAACC,OAAR,IAAmB,IAAvB,EAA6B;AAC3BzB,MAAAA,MAAM,CAAEwB,OAAO,CAACC,OAAR,KAAoB,CAArB,KAA4BD,OAAO,CAACC,OAArC,EACJ,2BADI,CAAN;AAEA,WAAKA,OAAL,GAAeD,OAAO,CAACC,OAAvB;AACD;;AAED,QAAID,OAAO,CAACE,MAAZ,EAAoB;AAClB1B,MAAAA,MAAM,CAACyC,KAAK,CAACC,OAAN,CAAclB,OAAO,CAACE,MAAtB,CAAD,EAAgC,0BAAhC,CAAN;;AACA,WAAK,MAAMiB,KAAX,IAAoBnB,OAAO,CAACE,MAA5B,EACE,KAAKA,MAAL,CAAYkB,IAAZ,CAAiB,IAAIjC,KAAJ,CAAUgC,KAAV,CAAjB;AACH;;AAED,QAAInB,OAAO,CAACG,OAAZ,EAAqB;AACnB3B,MAAAA,MAAM,CAACyC,KAAK,CAACC,OAAN,CAAclB,OAAO,CAACG,OAAtB,CAAD,EAAiC,2BAAjC,CAAN;;AACA,WAAK,MAAMkB,MAAX,IAAqBrB,OAAO,CAACG,OAA7B,EACE,KAAKA,OAAL,CAAaiB,IAAb,CAAkB,IAAIhC,MAAJ,CAAWiC,MAAX,CAAlB;AACH;;AAED,QAAIrB,OAAO,CAACI,QAAR,IAAoB,IAAxB,EAA8B;AAC5B5B,MAAAA,MAAM,CAAEwB,OAAO,CAACI,QAAR,KAAqB,CAAtB,KAA6BJ,OAAO,CAACI,QAAtC,EACJ,4BADI,CAAN;AAEA,WAAKA,QAAL,GAAgBJ,OAAO,CAACI,QAAxB;AACD;;AAED,QAAIJ,OAAO,CAACsB,QAAR,CAAiBvB,WAAjB,KAAiCb,GAAG,CAACqC,WAAJ,GAAkBxB,WAAvD,EAAoE;AAClE,WAAKuB,QAAL,GAAgBtB,OAAO,CAACsB,QAAxB;AACD;;AAED,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEoB,SAAXN,WAAW,CAAChB,OAAD,EAAU;AAC1B,WAAO,IAAI,IAAJ,GAAWgB,WAAX,CAAuBhB,OAAvB,CAAP;AACD,GAhFM,CAkFT;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAzjES,C,CA4jET;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAEAwB,MAAM,CAACC,OAAP,GAAiB3B,EAAjB","sourcesContent":["/*!\n * tx.js - transaction object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bio = require('bufio');\nconst hash256 = require('bcrypto/lib/hash256');\nconst secp256k1 = require('bcrypto/lib/secp256k1');\nconst {BufferSet} = require('buffer-map');\nconst util = require('../utils/util');\nconst Amount = require('../btc/amount');\nconst Network = require('../protocol/network');\nconst Script = require('../script/script');\nconst SLP = require('../script/slp');\nconst Input = require('./input');\nconst Output = require('./output');\nconst Outpoint = require('./outpoint');\nconst InvItem = require('./invitem');\nconst consensus = require('../protocol/consensus');\nconst policy = require('../protocol/policy');\nconst ScriptError = require('../script/scripterror');\nconst {encoding} = bio;\nconst {hashType} = Script;\nconst common = require('../script/common');\nconst {inspectSymbol} = require('../utils');\n\n/**\n * TX\n * A static transaction object.\n * @alias module:primitives.TX\n * @property {Number} version\n * @property {Input[]} inputs\n * @property {Output[]} outputs\n * @property {Number} locktime\n * @property {SlpTokenRecord?} slpToken\n */\n\nclass TX {\n  /**\n   * Create a transaction.\n   * @constructor\n   * @param {Object?} options\n   */\n\n  constructor(options) {\n    this.version = 1;\n    this.inputs = [];\n    this.outputs = [];\n    this.locktime = 0;\n\n    this.mutable = false;\n\n    this._hash = null;\n    this._hhash = null;\n\n    this._raw = null;\n    this._offset = -1;\n    this._block = false;\n    this._size = -1;\n    this._sigops = -1;\n\n    this._hashPrevouts = null;\n    this._hashSequence = null;\n    this._hashOutputs = null;\n\n    if (options)\n      this.fromOptions(options);\n  }\n\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n  fromOptions(options) {\n    assert(options, 'TX data is required.');\n\n    if (options.version != null) {\n      assert((options.version >>> 0) === options.version,\n        'Version must be a uint32.');\n      this.version = options.version;\n    }\n\n    if (options.inputs) {\n      assert(Array.isArray(options.inputs), 'Inputs must be an array.');\n      for (const input of options.inputs)\n        this.inputs.push(new Input(input));\n    }\n\n    if (options.outputs) {\n      assert(Array.isArray(options.outputs), 'Outputs must be an array.');\n      for (const output of options.outputs)\n        this.outputs.push(new Output(output));\n    }\n\n    if (options.locktime != null) {\n      assert((options.locktime >>> 0) === options.locktime,\n        'Locktime must be a uint32.');\n      this.locktime = options.locktime;\n    }\n\n    if (options.slpToken.constructor === SLP.TokenRecord().constructor) {\n      this.slpToken = options.slpToken;\n    }\n\n    return this;\n  }\n\n  /**\n   * Instantiate TX from options object.\n   * @param {Object} options\n   * @returns {TX}\n   */\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n\n//   /**\n//    * Clone the transaction.\n//    * @returns {TX}\n//    */\n\n//   clone() {\n//     return new this.constructor().inject(this);\n//   }\n\n//   /**\n//    * Inject properties from tx.\n//    * Used for cloning.\n//    * @private\n//    * @param {TX} tx\n//    * @returns {TX}\n//    */\n\n//   inject(tx) {\n//     this.version = tx.version;\n\n//     for (const input of tx.inputs)\n//       this.inputs.push(input.clone());\n\n//     for (const output of tx.outputs)\n//       this.outputs.push(output.clone());\n\n//     this.locktime = tx.locktime;\n\n//     return this;\n//   }\n\n//   /**\n//    * Clear any cached values.\n//    */\n\n//   refresh() {\n//     this._hash = null;\n//     this._hhash = null;\n\n//     this._raw = null;\n//     this._size = -1;\n//     this._offset = -1;\n//     this._block = false;\n//     this._sigops = -1;\n\n//     this._hashPrevouts = null;\n//     this._hashSequence = null;\n//     this._hashOutputs = null;\n//   }\n\n//   /**\n//    * Hash the transaction with the non-witness serialization.\n//    * @param {String?} enc - Can be `'hex'` or `null`.\n//    * @returns {Hash|Buffer} hash\n//    */\n\n//   hash(enc) {\n//     let h = this._hash;\n\n//     if (!h) {\n//       h = hash256.digest(this.toRaw());\n//       if (!this.mutable)\n//         this._hash = h;\n//     }\n\n//     if (enc === 'hex') {\n//       let hex = this._hhash;\n//       if (!hex) {\n//         hex = h.toString('hex');\n//         if (!this.mutable)\n//           this._hhash = hex;\n//       }\n//       h = hex;\n//     }\n\n//     return h;\n//   }\n\n//   /**\n//    * Serialize the transaction. Note\n//    * that this is cached.\n//    * @returns {Buffer} Serialized transaction.\n//    */\n\n//   toRaw() {\n//     return this.frame().data;\n//   }\n\n//   /**\n//    * Write the transaction to a buffer writer.\n//    * @param {BufferWriter} bw\n//    * @param {Boolean} block\n//    */\n\n//   toWriter(bw, block) {\n//     if (this.mutable)\n//       return this.writeNormal(bw);\n\n//     if (block) {\n//       this._offset = bw.offset;\n//       this._block = true;\n//     }\n\n//     bw.writeBytes(this.toRaw());\n\n//     return bw;\n//   }\n\n//   /**\n//    * Serialize the transaction. Note\n//    * that this is cached.\n//    * @private\n//    * @returns {RawTX}\n//    */\n\n//   frame() {\n//     if (this.mutable) {\n//       assert(!this._raw);\n//       return this.frameNormal();\n//     }\n\n//     if (this._raw) {\n//       assert(this._size >= 0);\n//       const raw = new RawTX(this._size);\n//       raw.data = this._raw;\n//       return raw;\n//     }\n\n//     const raw = this.frameNormal();\n\n//     this._raw = raw.data;\n//     this._size = raw.size;\n\n//     return raw;\n//   }\n\n//   /**\n//    * Return the offset and size of the transaction. Useful\n//    * when the transaction is deserialized within a block.\n//    * @returns {Object} contains `size` and `offset`.\n//    */\n\n//   getPosition() {\n//     if (!(this._block && this._offset > 80))\n//       console.log(this);\n//     assert(this._block && this._offset > 80, 'Position not available.');\n\n//     return {\n//       offset: this._offset,\n//       size: this._size\n//     };\n//   }\n\n//   /**\n//    * Calculate the real size of the transaction.\n//    * @returns {Number} size\n//    */\n\n//   getSize() {\n//     if (this.mutable)\n//       return this.getNormalSizes().size;\n//     return this.frame().size;\n//   }\n\n//   /**\n//    * Get the signature hash of the transaction for signing verifying.\n//    * @param {Number} index - Index of input being signed/verified.\n//    * @param {Script} prev - Previous output script or redeem script.\n//    * @param {Amount} value - Previous output value.\n//    * @param {SighashType} type - Sighash type.\n//    * @param {Number} flags - Script flags.\n//    * @returns {Buffer} Signature hash.\n//    */\n\n//   signatureHash(index, prev, value, type, flags) {\n//     assert(index >= 0 && index < this.inputs.length);\n//     assert(prev instanceof Script);\n//     assert(typeof value === 'number');\n//     assert(typeof type === 'number');\n\n//     if (flags == null)\n//       flags = Script.flags.STANDARD_VERIFY_FLAGS;\n\n//     if (flags & Script.flags.VERIFY_REPLAY_PROTECTION) {\n//       const newForkValue = (common.getHashTypeForkValue(type) ^ 0xdead);\n//       type = common.hashTypeWithForkValue(type, newForkValue | 0xff0000);\n//     }\n\n//     if ((type & Script.hashType.SIGHASH_FORKID)\n//         && (flags & Script.flags.VERIFY_SIGHASH_FORKID)) {\n//       return this.signatureHashV1(index, prev, value, type);\n//     }\n\n//     return this.signatureHashV0(index, prev, type);\n//   }\n\n//   /**\n//    * Legacy sighashing -- O(n^2).\n//    * @private\n//    * @param {Number} index\n//    * @param {Script} prev\n//    * @param {SighashType} type\n//    * @returns {Buffer}\n//    */\n\n//   signatureHashV0(index, prev, type) {\n//     if ((type & 0x1f) === hashType.SINGLE) {\n//       // Bitcoind used to return 1 as an error code:\n//       // it ended up being treated like a hash.\n//       if (index >= this.outputs.length) {\n//         const hash = Buffer.alloc(32, 0x00);\n//         hash[0] = 0x01;\n//         return hash;\n//       }\n//     }\n\n//     // Remove all code separators.\n//     prev = prev.removeSeparators();\n\n//     // Calculate buffer size.\n//     const size = this.hashSize(index, prev, type);\n//     const bw = bio.pool(size);\n\n//     bw.writeU32(this.version);\n\n//     // Serialize inputs.\n//     if (type & hashType.ANYONECANPAY) {\n//       // Serialize only the current\n//       // input if ANYONECANPAY.\n//       const input = this.inputs[index];\n\n//       // Count.\n//       bw.writeVarint(1);\n\n//       // Outpoint.\n//       input.prevout.toWriter(bw);\n\n//       // Replace script with previous\n//       // output script if current index.\n//       bw.writeVarBytes(prev.toRaw());\n//       bw.writeU32(input.sequence);\n//     } else {\n//       bw.writeVarint(this.inputs.length);\n//       for (let i = 0; i < this.inputs.length; i++) {\n//         const input = this.inputs[i];\n\n//         // Outpoint.\n//         input.prevout.toWriter(bw);\n\n//         // Replace script with previous\n//         // output script if current index.\n//         if (i === index) {\n//           bw.writeVarBytes(prev.toRaw());\n//           bw.writeU32(input.sequence);\n//           continue;\n//         }\n\n//         // Script is null.\n//         bw.writeVarint(0);\n\n//         // Sequences are 0 if NONE or SINGLE.\n//         switch (type & 0x1f) {\n//           case hashType.NONE:\n//           case hashType.SINGLE:\n//             bw.writeU32(0);\n//             break;\n//           default:\n//             bw.writeU32(input.sequence);\n//             break;\n//         }\n//       }\n//     }\n\n//     // Serialize outputs.\n//     switch (type & 0x1f) {\n//       case hashType.NONE: {\n//         // No outputs if NONE.\n//         bw.writeVarint(0);\n//         break;\n//       }\n//       case hashType.SINGLE: {\n//         const output = this.outputs[index];\n\n//         // Drop all outputs after the\n//         // current input index if SINGLE.\n//         bw.writeVarint(index + 1);\n\n//         for (let i = 0; i < index; i++) {\n//           // Null all outputs not at\n//           // current input index.\n//           bw.writeI64(-1);\n//           bw.writeVarint(0);\n//         }\n\n//         // Regular serialization\n//         // at current input index.\n//         output.toWriter(bw);\n\n//         break;\n//       }\n//       default: {\n//         // Regular output serialization if ALL.\n//         bw.writeVarint(this.outputs.length);\n//         for (const output of this.outputs)\n//           output.toWriter(bw);\n//         break;\n//       }\n//     }\n\n//     bw.writeU32(this.locktime);\n\n//     // Append the hash type.\n//     bw.writeU32(type);\n\n//     return hash256.digest(bw.render());\n//   }\n\n//   /**\n//    * Calculate sighash size.\n//    * @private\n//    * @param {Number} index\n//    * @param {Script} prev\n//    * @param {Number} type\n//    * @returns {Number}\n//    */\n\n//   hashSize(index, prev, type) {\n//     let size = 0;\n\n//     size += 4;\n\n//     if (type & hashType.ANYONECANPAY) {\n//       size += 1;\n//       size += 36;\n//       size += prev.getVarSize();\n//       size += 4;\n//     } else {\n//       size += encoding.sizeVarint(this.inputs.length);\n//       size += 41 * (this.inputs.length - 1);\n//       size += 36;\n//       size += prev.getVarSize();\n//       size += 4;\n//     }\n\n//     switch (type & 0x1f) {\n//       case hashType.NONE:\n//         size += 1;\n//         break;\n//       case hashType.SINGLE:\n//         size += encoding.sizeVarint(index + 1);\n//         size += 9 * index;\n//         size += this.outputs[index].getSize();\n//         break;\n//       default:\n//         size += encoding.sizeVarint(this.outputs.length);\n//         for (const output of this.outputs)\n//           size += output.getSize();\n//         break;\n//     }\n\n//     size += 8;\n\n//     return size;\n//   }\n\n//   /**\n//    * Witness sighashing -- O(n).\n//    * @private\n//    * @param {Number} index\n//    * @param {Script} prev\n//    * @param {Amount} value\n//    * @param {SighashType} type\n//    * @returns {Buffer}\n//    */\n\n//   signatureHashV1(index, prev, value, type) {\n//     const input = this.inputs[index];\n//     let prevouts = consensus.ZERO_HASH;\n//     let sequences = consensus.ZERO_HASH;\n//     let outputs = consensus.ZERO_HASH;\n\n//     if (!(type & hashType.ANYONECANPAY)) {\n//       if (this._hashPrevouts) {\n//         prevouts = this._hashPrevouts;\n//       } else {\n//         const bw = bio.pool(this.inputs.length * 36);\n\n//         for (const input of this.inputs)\n//           input.prevout.toWriter(bw);\n\n//         prevouts = hash256.digest(bw.render());\n\n//         if (!this.mutable)\n//           this._hashPrevouts = prevouts;\n//       }\n//     }\n\n//     if (!(type & hashType.ANYONECANPAY)\n//         && (type & 0x1f) !== hashType.SINGLE\n//         && (type & 0x1f) !== hashType.NONE) {\n//       if (this._hashSequence) {\n//         sequences = this._hashSequence;\n//       } else {\n//         const bw = bio.pool(this.inputs.length * 4);\n\n//         for (const input of this.inputs)\n//           bw.writeU32(input.sequence);\n\n//         sequences = hash256.digest(bw.render());\n\n//         if (!this.mutable)\n//           this._hashSequence = sequences;\n//       }\n//     }\n\n//     if ((type & 0x1f) !== hashType.SINGLE\n//         && (type & 0x1f) !== hashType.NONE) {\n//       if (this._hashOutputs) {\n//         outputs = this._hashOutputs;\n//       } else {\n//         let size = 0;\n\n//         for (const output of this.outputs)\n//           size += output.getSize();\n\n//         const bw = bio.pool(size);\n\n//         for (const output of this.outputs)\n//           output.toWriter(bw);\n\n//         outputs = hash256.digest(bw.render());\n\n//         if (!this.mutable)\n//           this._hashOutputs = outputs;\n//       }\n//     } else if ((type & 0x1f) === hashType.SINGLE) {\n//       if (index < this.outputs.length) {\n//         const output = this.outputs[index];\n//         outputs = hash256.digest(output.toRaw());\n//       }\n//     }\n\n//     const size = 156 + prev.getVarSize();\n//     const bw = bio.pool(size);\n\n//     bw.writeU32(this.version);\n//     bw.writeBytes(prevouts);\n//     bw.writeBytes(sequences);\n//     bw.writeHash(input.prevout.hash);\n//     bw.writeU32(input.prevout.index);\n//     bw.writeVarBytes(prev.toRaw());\n//     bw.writeI64(value);\n//     bw.writeU32(input.sequence);\n//     bw.writeBytes(outputs);\n//     bw.writeU32(this.locktime);\n//     bw.writeU32(type);\n\n//     return hash256.digest(bw.render());\n//   }\n\n//   /**\n//    * Verify signature.\n//    * @param {Number} index\n//    * @param {Script} prev\n//    * @param {Amount} value\n//    * @param {Buffer} sig\n//    * @param {Buffer} key\n//    * @param {Number} flags\n//    * @returns {Boolean}\n//    */\n\n//   checksig(index, prev, value, sig, key, flags) {\n//     if (sig.length === 0)\n//       return false;\n\n//     const type = sig[sig.length - 1];\n//     const hash = this.signatureHash(index, prev, value, type, flags);\n\n//     let res;\n\n//     if (common.isSchnorr(sig)) {\n//       res = secp256k1.schnorrVerify(hash, sig.slice(0, -1), key)\n//     } else {\n//       res = secp256k1.verifyDER(hash, sig.slice(0, -1), key);\n//     }\n\n//     return res;\n//   }\n\n//   /**\n//    * Create a signature suitable for inserting into scriptSigs.\n//    * @param {Number} index - Index of input being signed.\n//    * @param {Script} prev - Previous output script or redeem script.\n//    * @param {Amount} value - Previous output value.\n//    * @param {Buffer} key\n//    * @param {SighashType} type\n//    * @param {Number} flags - Script flags.\n//    * @returns {Buffer} Signature in SCHNORR / DER format.\n//    */\n\n//   signature(index, prev, value, key, type, flags) {\n//     let sig;\n\n//     if (type == null)\n//       type = hashType.ALL;\n\n//     if (flags == null)\n//       flags = Script.flags.VERIFY_SIGHASH_FORKID;\n\n//     const hash = this.signatureHash(index, prev, value, type, flags);\n\n//     const DER = secp256k1.signDER(hash, key);\n//     const SCHNORR = secp256k1.schnorrSign(hash, key);\n\n//     if (common.isSchnorr(SCHNORR)) {\n//       sig = SCHNORR;\n//     } else {\n//       sig = DER;\n//     }\n//     const bw = bio.write(sig.length + 1);\n\n//     bw.writeBytes(sig);\n//     bw.writeU8(type);\n\n//     return bw.render();\n//   }\n\n//   /**\n//    * Create a signature suitable for inserting into scriptSigs.\n//    * @param {Number} index - Index of input being signed.\n//    * @param {Script} prev - Previous output script or redeem script.\n//    * @param {Amount} value - Previous output value.\n//    * @param {Buffer} key\n//    * @param {SighashType} type\n//    * @param {Number} flags - Script flags.\n//    * @returns {Buffer} Signature in Schnorr format.\n//    */\n\n//   schnorrSignature(index, prev, value, key, type, flags) {\n//     if (type == null)\n//       type = hashType.ALL;\n\n//     if (flags == null)\n//       flags = Script.flags.VERIFY_SIGHASH_FORKID;\n\n//     const hash = this.signatureHash(index, prev, value, type, flags);\n//     const sig = secp256k1.schnorrSign(hash, key);\n//     const bw = bio.write(sig.length + 1);\n\n//     bw.writeBytes(sig);\n//     bw.writeU8(type);\n\n//     return bw.render();\n//   }\n\n//   /**\n//    * Verify all transaction inputs.\n//    * @param {CoinView} view\n//    * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n//    * @throws {ScriptError} on invalid inputs\n//    */\n\n//   check(view, flags) {\n//     if (this.inputs.length === 0)\n//       throw new ScriptError('UNKNOWN_ERROR', 'No inputs.');\n\n//     if (this.isCoinbase())\n//       return;\n\n//     for (let i = 0; i < this.inputs.length; i++) {\n//       const {prevout} = this.inputs[i];\n//       const coin = view.getOutput(prevout);\n\n//       if (!coin)\n//         throw new ScriptError('UNKNOWN_ERROR', 'No coin available.');\n\n//       this.checkInput(i, coin, flags);\n//     }\n//   }\n\n//   /**\n//    * Verify a transaction input.\n//    * @param {Number} index - Index of output being\n//    * verified.\n//    * @param {Coin|Output} coin - Previous output.\n//    * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n//    * @throws {ScriptError} on invalid input\n//    */\n\n//   checkInput(index, coin, flags) {\n//     const input = this.inputs[index];\n\n//     assert(input, 'Input does not exist.');\n//     assert(coin, 'No coin passed.');\n\n//     Script.verify(\n//       input.script,\n//       null,\n//       coin.script,\n//       this,\n//       index,\n//       coin.value,\n//       flags\n//     );\n//   }\n\n//   /**\n//    * Verify the transaction inputs on the worker pool\n//    * (if workers are enabled).\n//    * @param {CoinView} view\n//    * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n//    * @param {WorkerPool?} pool\n//    * @returns {Promise}\n//    */\n\n//   async checkAsync(view, flags, pool) {\n//     if (this.inputs.length === 0)\n//       throw new ScriptError('UNKNOWN_ERROR', 'No inputs.');\n\n//     if (this.isCoinbase())\n//       return;\n\n//     if (!pool) {\n//       this.check(view, flags);\n//       return;\n//     }\n\n//     await pool.check(this, view, flags);\n//   }\n\n//   /**\n//    * Verify a transaction input asynchronously.\n//    * @param {Number} index - Index of output being\n//    * verified.\n//    * @param {Coin|Output} coin - Previous output.\n//    * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n//    * @param {WorkerPool?} pool\n//    * @returns {Promise}\n//    */\n\n//   async checkInputAsync(index, coin, flags, pool) {\n//     const input = this.inputs[index];\n\n//     assert(input, 'Input does not exist.');\n//     assert(coin, 'No coin passed.');\n\n//     if (!pool) {\n//       this.checkInput(index, coin, flags);\n//       return;\n//     }\n\n//     await pool.checkInput(this, index, coin, flags);\n//   }\n\n//   /**\n//    * Verify all transaction inputs.\n//    * @param {CoinView} view\n//    * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n//    * @returns {Boolean} Whether the inputs are valid.\n//    */\n\n//   verify(view, flags) {\n//     try {\n//       this.check(view, flags);\n//     } catch (e) {\n//       if (e.type === 'ScriptError')\n//         return false;\n//       throw e;\n//     }\n//     return true;\n//   }\n\n//   /**\n//    * Verify a transaction input.\n//    * @param {Number} index - Index of output being\n//    * verified.\n//    * @param {Coin|Output} coin - Previous output.\n//    * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n//    * @returns {Boolean} Whether the input is valid.\n//    */\n\n//   verifyInput(index, coin, flags) {\n//     try {\n//       this.checkInput(index, coin, flags);\n//     } catch (e) {\n//       if (e.type === 'ScriptError')\n//         return false;\n//       throw e;\n//     }\n//     return true;\n//   }\n\n//   /**\n//    * Verify the transaction inputs on the worker pool\n//    * (if workers are enabled).\n//    * @param {CoinView} view\n//    * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n//    * @param {WorkerPool?} pool\n//    * @returns {Promise}\n//    */\n\n//   async verifyAsync(view, flags, pool) {\n//     try {\n//       await this.checkAsync(view, flags, pool);\n//     } catch (e) {\n//       if (e.type === 'ScriptError')\n//         return false;\n//       throw e;\n//     }\n//     return true;\n//   }\n\n//   /**\n//    * Verify a transaction input asynchronously.\n//    * @param {Number} index - Index of output being\n//    * verified.\n//    * @param {Coin|Output} coin - Previous output.\n//    * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n//    * @param {WorkerPool?} pool\n//    * @returns {Promise}\n//    */\n\n//   async verifyInputAsync(index, coin, flags, pool) {\n//     try {\n//       await this.checkInput(index, coin, flags, pool);\n//     } catch (e) {\n//       if (e.type === 'ScriptError')\n//         return false;\n//       throw e;\n//     }\n//     return true;\n//   }\n\n//   /**\n//    * Test whether the transaction is a coinbase\n//    * by examining the inputs.\n//    * @returns {Boolean}\n//    */\n\n//   isCoinbase() {\n//     return this.inputs.length === 1 && this.inputs[0].prevout.isNull();\n//   }\n\n//   /**\n//    * Test whether the transaction is replaceable.\n//    * @returns {Boolean}\n//    */\n\n//   isRBF() {\n//     // Core doesn't do this, but it should:\n//     if (this.version === 2)\n//       return false;\n\n//     for (const input of this.inputs) {\n//       if (input.isRBF())\n//         return true;\n//     }\n\n//     return false;\n//   }\n\n//   /**\n//    * Calculate the fee for the transaction.\n//    * @param {CoinView} view\n//    * @returns {Amount} fee (zero if not all coins are available).\n//    */\n\n//   getFee(view) {\n//     if (!this.hasCoins(view))\n//       return 0;\n\n//     return this.getInputValue(view) - this.getOutputValue();\n//   }\n\n//   /**\n//    * Calculate the total input value.\n//    * @param {CoinView} view\n//    * @returns {Amount} value\n//    */\n\n//   getInputValue(view) {\n//     let total = 0;\n\n//     for (const {prevout} of this.inputs) {\n//       const coin = view.getOutput(prevout);\n\n//       if (!coin)\n//         return 0;\n\n//       total += coin.value;\n//     }\n\n//     return total;\n//   }\n\n//   /**\n//    * Calculate the total output value.\n//    * @returns {Amount} value\n//    */\n\n//   getOutputValue() {\n//     let total = 0;\n\n//     for (const output of this.outputs)\n//       total += output.value;\n\n//     return total;\n//   }\n\n//   /**\n//    * Get all input addresses.\n//    * @private\n//    * @param {CoinView} view\n//    * @returns {Array} [addrs, table]\n//    */\n\n//   _getInputAddresses(view) {\n//     const table = new BufferSet();\n//     const addrs = [];\n\n//     if (this.isCoinbase())\n//       return [addrs, table];\n\n//     for (const input of this.inputs) {\n//       const coin = view ? view.getOutputFor(input) : null;\n//       const addr = input.getAddress(coin);\n\n//       if (!addr)\n//         continue;\n\n//       const hash = addr.getHash();\n\n//       if (!table.has(hash)) {\n//         table.add(hash);\n//         addrs.push(addr);\n//       }\n//     }\n\n//     return [addrs, table];\n//   }\n\n//   /**\n//    * Get all output addresses.\n//    * @private\n//    * @returns {Array} [addrs, table]\n//    */\n\n//   _getOutputAddresses() {\n//     const table = new BufferSet();\n//     const addrs = [];\n\n//     for (const output of this.outputs) {\n//       const addr = output.getAddress();\n\n//       if (!addr)\n//         continue;\n\n//       const hash = addr.getHash();\n\n//       if (!table.has(hash)) {\n//         table.add(hash);\n//         addrs.push(addr);\n//       }\n//     }\n\n//     return [addrs, table];\n//   }\n\n//   /**\n//    * Get all addresses.\n//    * @private\n//    * @param {CoinView} view\n//    * @returns {Array} [addrs, table]\n//    */\n\n//   _getAddresses(view) {\n//     const [addrs, table] = this._getInputAddresses(view);\n//     const output = this.getOutputAddresses();\n\n//     for (const addr of output) {\n//       const hash = addr.getHash();\n\n//       if (!table.has(hash)) {\n//         table.add(hash);\n//         addrs.push(addr);\n//       }\n//     }\n\n//     return [addrs, table];\n//   }\n\n//   /**\n//    * Get all input addresses.\n//    * @param {CoinView|null} view\n//    * @returns {Address[]} addresses\n//    */\n\n//   getInputAddresses(view) {\n//     const [addrs] = this._getInputAddresses(view);\n//     return addrs;\n//   }\n\n//   /**\n//    * Get all output addresses.\n//    * @returns {Address[]} addresses\n//    */\n\n//   getOutputAddresses() {\n//     const [addrs] = this._getOutputAddresses();\n//     return addrs;\n//   }\n\n//   /**\n//    * Get all addresses.\n//    * @param {CoinView|null} view\n//    * @returns {Address[]} addresses\n//    */\n\n//   getAddresses(view) {\n//     const [addrs] = this._getAddresses(view);\n//     return addrs;\n//   }\n\n//   /**\n//    * Get all input address hashes.\n//    * @param {CoinView|null} view\n//    * @returns {Hash[]} hashes\n//    */\n\n//   getInputHashes(view, enc) {\n//     const [, table] = this._getInputAddresses(view);\n\n//     if (enc !== 'hex')\n//       return table.toArray();\n\n//     return table.toArray().map(h => h.toString('hex'));\n//   }\n\n//   /**\n//    * Get all output address hashes.\n//    * @returns {Hash[]} hashes\n//    */\n\n//   getOutputHashes(enc) {\n//     const [, table] = this._getOutputAddresses();\n\n//     if (enc !== 'hex')\n//       return table.toArray();\n\n//     return table.toArray().map(h => h.toString('hex'));\n//   }\n\n//   /**\n//    * Get all address hashes.\n//    * @param {CoinView|null} view\n//    * @returns {Hash[]} hashes\n//    */\n\n//   getHashes(view, enc) {\n//     const [, table] = this._getAddresses(view);\n\n//     if (enc !== 'hex')\n//       return table.toArray();\n\n//     return table.toArray().map(h => h.toString('hex'));\n//   }\n\n//   /**\n//    * Test whether the transaction has\n//    * all coins available.\n//    * @param {CoinView} view\n//    * @returns {Boolean}\n//    */\n\n//   hasCoins(view) {\n//     if (this.inputs.length === 0)\n//       return false;\n\n//     for (const {prevout} of this.inputs) {\n//       if (!view.hasEntry(prevout))\n//         return false;\n//     }\n\n//     return true;\n//   }\n\n//   /**\n//    * Check finality of transaction by examining\n//    * nLocktime and nSequence values.\n//    * @example\n//    * tx.isFinal(chain.height + 1, network.now());\n//    * @param {Number} height - Height at which to test. This\n//    * is usually the chain height, or the chain height + 1\n//    * when the transaction entered the mempool.\n//    * @param {Number} time - Time at which to test. This is\n//    * usually the chain tip's parent's median time, or the\n//    * time at which the transaction entered the mempool. If\n//    * MEDIAN_TIME_PAST is enabled this will be the median\n//    * time of the chain tip's previous entry's median time.\n//    * @returns {Boolean}\n//    */\n\n//   isFinal(height, time) {\n//     const THRESHOLD = consensus.LOCKTIME_THRESHOLD;\n\n//     if (this.locktime === 0)\n//       return true;\n\n//     if (this.locktime < (this.locktime < THRESHOLD ? height : time))\n//       return true;\n\n//     for (const input of this.inputs) {\n//       if (input.sequence !== 0xffffffff)\n//         return false;\n//     }\n\n//     return true;\n//   }\n\n//   /**\n//    * Verify the absolute locktime of a transaction.\n//    * Called by OP_CHECKLOCKTIMEVERIFY.\n//    * @param {Number} index - Index of input being verified.\n//    * @param {Number} predicate - Locktime to verify against.\n//    * @returns {Boolean}\n//    */\n\n//   verifyLocktime(index, predicate) {\n//     const THRESHOLD = consensus.LOCKTIME_THRESHOLD;\n//     const input = this.inputs[index];\n\n//     assert(input, 'Input does not exist.');\n//     assert(predicate >= 0, 'Locktime must be non-negative.');\n\n//     // Locktimes must be of the same type (blocks or seconds).\n//     if ((this.locktime < THRESHOLD) !== (predicate < THRESHOLD))\n//       return false;\n\n//     if (predicate > this.locktime)\n//       return false;\n\n//     if (input.sequence === 0xffffffff)\n//       return false;\n\n//     return true;\n//   }\n\n//   /**\n//    * Verify the relative locktime of an input.\n//    * Called by OP_CHECKSEQUENCEVERIFY.\n//    * @param {Number} index - Index of input being verified.\n//    * @param {Number} predicate - Relative locktime to verify against.\n//    * @returns {Boolean}\n//    */\n\n//   verifySequence(index, predicate) {\n//     const DISABLE_FLAG = consensus.SEQUENCE_DISABLE_FLAG;\n//     const TYPE_FLAG = consensus.SEQUENCE_TYPE_FLAG;\n//     const MASK = consensus.SEQUENCE_MASK;\n//     const input = this.inputs[index];\n\n//     assert(input, 'Input does not exist.');\n//     assert(predicate >= 0, 'Locktime must be non-negative.');\n\n//     // For future softfork capability.\n//     if (predicate & DISABLE_FLAG)\n//       return true;\n\n//     // Version must be >=2.\n//     if (this.version < 2)\n//       return false;\n\n//     // Cannot use the disable flag without\n//     // the predicate also having the disable\n//     // flag (for future softfork capability).\n//     if (input.sequence & DISABLE_FLAG)\n//       return false;\n\n//     // Locktimes must be of the same type (blocks or seconds).\n//     if ((input.sequence & TYPE_FLAG) !== (predicate & TYPE_FLAG))\n//       return false;\n\n//     if ((predicate & MASK) > (input.sequence & MASK))\n//       return false;\n\n//     return true;\n//   }\n\n//   /**\n//    * Calculate legacy (inaccurate) sigop count.\n//    * @returns {Number} sigop count\n//    */\n\n//   getLegacySigops() {\n//     if (this._sigops !== -1)\n//       return this._sigops;\n\n//     let total = 0;\n\n//     for (const input of this.inputs)\n//       total += input.script.getSigops(false);\n\n//     for (const output of this.outputs)\n//       total += output.script.getSigops(false);\n\n//     if (!this.mutable)\n//       this._sigops = total;\n\n//     return total;\n//   }\n\n//   /**\n//    * Calculate accurate sigop count, taking into account redeem scripts.\n//    * @param {CoinView} view\n//    * @param {VerifyFlags} flags\n//    * @returns {Number} sigop count\n//    */\n\n//   getScripthashSigops(view, flags) {\n//     if (this.isCoinbase())\n//       return 0;\n\n//     let total = 0;\n\n//     for (const input of this.inputs) {\n//       const coin = view.getOutputFor(input);\n\n//       if (!coin)\n//         continue;\n\n//       if (!coin.script.isScripthash())\n//         continue;\n\n//       total += coin.script.getScripthashSigops(input.script, flags);\n//     }\n\n//     return total;\n//   }\n\n//   /**\n//    * Calculate sigops count.\n//    * @param {CoinView} view\n//    * @param {VerifyFlags?} flags\n//    * @returns {Number} sigop count\n//    */\n\n//   getSigopsCount(view, flags) {\n//     if (flags === null)\n//       flags = Script.flags.STANDARD_VERIFY_FLAGS;\n\n//     let cost = this.getLegacySigops();\n\n//     if (flags & Script.flags.VERIFY_P2SH)\n//       cost += this.getScripthashSigops(view, flags);\n\n//     return cost;\n//   }\n\n//   /**\n//    * Calculate sigop count.\n//    * @param {CoinView} view\n//    * @param {VerifyFlags?} flags\n//    * @returns {Number} sigop count\n//    */\n\n//   getSigops(view, flags) {\n//     return this.getSigopsCount(view, flags);\n//   }\n\n//   /**\n//    * Non-contextual sanity checks for the transaction.\n//    * Will mostly verify coin and output values.\n//    * @see CheckTransaction()\n//    * @returns {Array} [result, reason, score]\n//    */\n\n//   isSane() {\n//     const [valid] = this.checkSanity();\n//     return valid;\n//   }\n\n//   /**\n//    * Non-contextual sanity checks for the transaction.\n//    * Will mostly verify coin and output values.\n//    * @see CheckTransaction()\n//    * @returns {Array} [valid, reason, score]\n//    */\n\n//   checkSanity() {\n//     if (this.inputs.length === 0)\n//       return [false, 'bad-txns-vin-empty', 100];\n\n//     if (this.outputs.length === 0)\n//       return [false, 'bad-txns-vout-empty', 100];\n\n//     if (this.getSize() > consensus.MAX_TX_SIZE)\n//       return [false, 'bad-txns-oversize', 100];\n\n//     let total = 0;\n\n//     for (const output of this.outputs) {\n//       if (output.value < 0)\n//         return [false, 'bad-txns-vout-negative', 100];\n\n//       if (output.value > consensus.MAX_MONEY)\n//         return [false, 'bad-txns-vout-toolarge', 100];\n\n//       total += output.value;\n\n//       if (total < 0 || total > consensus.MAX_MONEY)\n//         return [false, 'bad-txns-txouttotal-toolarge', 100];\n//     }\n\n//     const prevout = new BufferSet();\n\n//     for (const input of this.inputs) {\n//       const key = input.prevout.toKey();\n\n//       if (prevout.has(key))\n//         return [false, 'bad-txns-inputs-duplicate', 100];\n\n//       prevout.add(key);\n//     }\n\n//     if (this.isCoinbase()) {\n//       const size = this.inputs[0].script.getSize();\n//       if (size < 2 || size > consensus.MAX_COINBASE_SCRIPTSIG_SIZE)\n//         return [false, 'bad-cb-length', 100];\n//     } else {\n//       for (const input of this.inputs) {\n//         if (input.prevout.isNull())\n//           return [false, 'bad-txns-prevout-null', 10];\n//       }\n//     }\n\n//     return [true, 'valid', 0];\n//   }\n\n//   /**\n//    * Non-contextual checks to determine whether the\n//    * transaction has all standard output script\n//    * types and standard input script size with only\n//    * pushdatas in the code.\n//    * Will mostly verify coin and output values.\n//    * @see IsStandardTx()\n//    * @returns {Array} [valid, reason, score]\n//    */\n\n//   isStandard() {\n//     const [valid] = this.checkStandard();\n//     return valid;\n//   }\n\n//   /**\n//    * Non-contextual checks to determine whether the\n//    * transaction has all standard output script\n//    * types and standard input script size with only\n//    * pushdatas in the code.\n//    * Will mostly verify coin and output values.\n//    * @see IsStandardTx()\n//    * @returns {Array} [valid, reason, score]\n//    */\n\n//   checkStandard() {\n//     if (this.version < 1 || this.version > policy.MAX_TX_VERSION)\n//       return [false, 'version', 0];\n\n//     // MAX_STANDARD_TX_SIZE\n//     if (this.getSize() >= policy.MAX_TX_SIZE)\n//       return [false, 'tx-size', 0];\n\n//     for (const input of this.inputs) {\n//       if (input.script.getSize() > 1650)\n//         return [false, 'scriptsig-size', 0];\n\n//       if (!input.script.isPushOnly())\n//         return [false, 'scriptsig-not-pushonly', 0];\n//     }\n\n//     let nulldata = 0;\n\n//     for (const output of this.outputs) {\n//       if (!output.script.isStandard())\n//         return [false, 'scriptpubkey', 0];\n\n//       if (output.script.isNulldata()) {\n//         nulldata++;\n//         continue;\n//       }\n\n//       if (output.script.isMultisig() && !policy.BARE_MULTISIG)\n//         return [false, 'bare-multisig', 0];\n\n//       if (output.isDust(policy.MIN_RELAY))\n//         return [false, 'dust', 0];\n//     }\n\n//     if (nulldata > 1)\n//       return [false, 'multi-op-return', 0];\n\n//     return [true, 'valid', 0];\n//   }\n\n//   /**\n//    * Perform contextual checks to verify coin and input\n//    * script standardness (including the redeem script).\n//    * @see AreInputsStandard()\n//    * @param {CoinView} view\n//    * @param {VerifyFlags?} flags\n//    * @returns {Boolean}\n//    */\n\n//   hasStandardInputs(view) {\n//     if (this.isCoinbase())\n//       return true;\n\n//     for (const input of this.inputs) {\n//       const coin = view.getOutputFor(input);\n\n//       if (!coin)\n//         return false;\n\n//       if (coin.script.isPubkeyhash())\n//         continue;\n\n//       if (coin.script.isScripthash()) {\n//         const redeem = input.script.getRedeem();\n\n//         if (!redeem)\n//           return false;\n\n//         if (redeem.getSigops(true) > policy.MAX_P2SH_SIGOPS)\n//           return false;\n\n//         continue;\n//       }\n\n//       if (coin.script.isUnknown())\n//         return false;\n//     }\n\n//     return true;\n//   }\n\n//   /**\n//    * Perform contextual checks to verify input, output,\n//    * and fee values, as well as coinbase spend maturity\n//    * (coinbases can only be spent 100 blocks or more\n//    * after they're created). Note that this function is\n//    * consensus critical.\n//    * @param {CoinView} view\n//    * @param {Number} height - Height at which the\n//    * transaction is being spent. In the mempool this is\n//    * the chain height plus one at the time it entered the pool.\n//    * @returns {Boolean}\n//    */\n\n//   verifyInputs(view, height) {\n//     const [fee] = this.checkInputs(view, height);\n//     return fee !== -1;\n//   }\n\n//   /**\n//    * Perform contextual checks to verify input, output,\n//    * and fee values, as well as coinbase spend maturity\n//    * (coinbases can only be spent 100 blocks or more\n//    * after they're created). Note that this function is\n//    * consensus critical.\n//    * @param {CoinView} view\n//    * @param {Number} height - Height at which the\n//    * transaction is being spent. In the mempool this is\n//    * the chain height plus one at the time it entered the pool.\n//    * @returns {Array} [fee, reason, score]\n//    */\n\n//   checkInputs(view, height) {\n//     assert(typeof height === 'number');\n\n//     let total = 0;\n\n//     for (const {prevout} of this.inputs) {\n//       const entry = view.getEntry(prevout);\n\n//       if (!entry)\n//         return [-1, 'bad-txns-inputs-missingorspent', 0];\n\n//       if (entry.coinbase) {\n//         if (height - entry.height < consensus.COINBASE_MATURITY)\n//           return [-1, 'bad-txns-premature-spend-of-coinbase', 0];\n//       }\n\n//       const coin = view.getOutput(prevout);\n//       assert(coin);\n\n//       if (coin.value < 0 || coin.value > consensus.MAX_MONEY)\n//         return [-1, 'bad-txns-inputvalues-outofrange', 100];\n\n//       total += coin.value;\n\n//       if (total < 0 || total > consensus.MAX_MONEY)\n//         return [-1, 'bad-txns-inputvalues-outofrange', 100];\n//     }\n\n//     // Overflows already checked in `isSane()`.\n//     const value = this.getOutputValue();\n\n//     if (total < value)\n//       return [-1, 'bad-txns-in-belowout', 100];\n\n//     const fee = total - value;\n\n//     if (fee < 0)\n//       return [-1, 'bad-txns-fee-negative', 100];\n\n//     if (fee > consensus.MAX_MONEY)\n//       return [-1, 'bad-txns-fee-outofrange', 100];\n\n//     return [fee, 'valid', 0];\n//   }\n\n//   /**\n//    * Calculate the modified size of the transaction. This\n//    * is used in the mempool for calculating priority.\n//    * @param {Number?} size - The size to modify. If not present,\n//    * virtual size will be used.\n//    * @returns {Number} Modified size.\n//    */\n\n//   getModifiedSize(size) {\n//     if (size == null)\n//       size = this.getSize();\n\n//     for (const input of this.inputs) {\n//       const offset = 41 + Math.min(110, input.script.getSize());\n//       if (size > offset)\n//         size -= offset;\n//     }\n\n//     return size;\n//   }\n\n//   /**\n//    * Calculate the transaction priority.\n//    * @param {CoinView} view\n//    * @param {Number} height\n//    * @param {Number?} size - Size to calculate priority\n//    * based on. If not present, virtual size will be used.\n//    * @returns {Number}\n//    */\n\n//   getPriority(view, height, size) {\n//     assert(typeof height === 'number', 'Must pass in height.');\n\n//     if (this.isCoinbase())\n//       return 0;\n\n//     if (size == null)\n//       size = this.getSize();\n\n//     let sum = 0;\n\n//     for (const {prevout} of this.inputs) {\n//       const coin = view.getOutput(prevout);\n\n//       if (!coin)\n//         continue;\n\n//       const coinHeight = view.getHeight(prevout);\n\n//       if (coinHeight === -1)\n//         continue;\n\n//       if (coinHeight <= height) {\n//         const age = height - coinHeight;\n//         sum += coin.value * age;\n//       }\n//     }\n\n//     return Math.floor(sum / size);\n//   }\n\n//   /**\n//    * Calculate the transaction's on-chain value.\n//    * @param {CoinView} view\n//    * @returns {Number}\n//    */\n\n//   getChainValue(view) {\n//     if (this.isCoinbase())\n//       return 0;\n\n//     let value = 0;\n\n//     for (const {prevout} of this.inputs) {\n//       const coin = view.getOutput(prevout);\n\n//       if (!coin)\n//         continue;\n\n//       const height = view.getHeight(prevout);\n\n//       if (height === -1)\n//         continue;\n\n//       value += coin.value;\n//     }\n\n//     return value;\n//   }\n\n//   /**\n//    * Determine whether the transaction is above the\n//    * free threshold in priority. A transaction which\n//    * passed this test is most likely relayable\n//    * without a fee.\n//    * @param {CoinView} view\n//    * @param {Number?} height - If not present, tx\n//    * height or network height will be used.\n//    * @param {Number?} size - If not present, modified\n//    * size will be calculated and used.\n//    * @returns {Boolean}\n//    */\n\n//   isFree(view, height, size) {\n//     const priority = this.getPriority(view, height, size);\n//     return priority > policy.FREE_THRESHOLD;\n//   }\n\n//   /**\n//    * Calculate minimum fee in order for the transaction\n//    * to be relayable (not the constant min relay fee).\n//    * @param {Number?} size - If not present, max size\n//    * estimation will be calculated and used.\n//    * @param {Rate?} rate - Rate of satoshi per kB.\n//    * @returns {Amount} fee\n//    */\n\n//   getMinFee(size, rate) {\n//     if (size == null)\n//       size = this.getSize();\n\n//     return policy.getMinFee(size, rate);\n//   }\n\n//   /**\n//    * Calculate the minimum fee in order for the transaction\n//    * to be relayable, but _round to the nearest kilobyte\n//    * when taking into account size.\n//    * @param {Number?} size - If not present, max size\n//    * estimation will be calculated and used.\n//    * @param {Rate?} rate - Rate of satoshi per kB.\n//    * @returns {Amount} fee\n//    */\n\n//   getRoundFee(size, rate) {\n//     if (size == null)\n//       size = this.getSize();\n\n//     return policy.getRoundFee(size, rate);\n//   }\n\n//   /**\n//    * Calculate the transaction's rate based on size\n//    * and fees. Size will be calculated if not present.\n//    * @param {CoinView} view\n//    * @param {Number?} size\n//    * @returns {Rate}\n//    */\n\n//   getRate(view, size) {\n//     const fee = this.getFee(view);\n\n//     if (fee < 0)\n//       return 0;\n\n//     if (size == null)\n//       size = this.getSize();\n\n//     return policy.getRate(size, fee);\n//   }\n\n//   /**\n//    * Get all unique outpoint hashes.\n//    * @returns {Hash[]} Outpoint hashes.\n//    */\n\n//   getPrevout() {\n//     if (this.isCoinbase())\n//       return [];\n\n//     const prevout = new BufferSet();\n\n//     for (const input of this.inputs)\n//       prevout.add(input.prevout.hash);\n\n//     return prevout.toArray();\n//   }\n\n//   /**\n//    * Test a transaction against a bloom filter using\n//    * the BIP37 matching algorithm. Note that this may\n//    * update the filter depending on what the `update`\n//    * value is.\n//    * @see \"Filter matching algorithm\":\n//    * @see https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki\n//    * @param {BloomFilter} filter\n//    * @returns {Boolean} True if the transaction matched.\n//    */\n\n//   isWatched(filter) {\n//     let found = false;\n\n//     // 1. Test the tx hash\n//     if (filter.test(this.hash()))\n//       found = true;\n\n//     // 2. Test data elements in output scripts\n//     //    (may need to update filter on match)\n//     for (let i = 0; i < this.outputs.length; i++) {\n//       const output = this.outputs[i];\n//       // Test the output script\n//       if (output.script.test(filter)) {\n//         if (filter.update === 1 /* ALL */) {\n//           const prevout = Outpoint.fromTX(this, i);\n//           filter.add(prevout.toRaw());\n//         } else if (filter.update === 2 /* PUBKEY_ONLY */) {\n//           if (output.script.isPubkey() || output.script.isMultisig()) {\n//             const prevout = Outpoint.fromTX(this, i);\n//             filter.add(prevout.toRaw());\n//           }\n//         }\n//         found = true;\n//       }\n//     }\n\n//     if (found)\n//       return found;\n\n//     // 3. Test prev_out structure\n//     // 4. Test data elements in input scripts\n//     for (const input of this.inputs) {\n//       const prevout = input.prevout;\n\n//       // Test the COutPoint structure\n//       if (filter.test(prevout.toRaw()))\n//         return true;\n\n//       // Test the input script\n//       if (input.script.test(filter))\n//         return true;\n//     }\n\n//     // 5. No match\n//     return false;\n//   }\n\n//   /**\n//    * Get little-endian tx hash.\n//    * @returns {Hash}\n//    */\n\n//   rhash() {\n//     return util.revHex(this.hash());\n//   }\n\n//   /**\n//    * Get little-endian tx hash.\n//    * @returns {Hash}\n//    */\n\n//   txid() {\n//     return this.rhash();\n//   }\n\n//   /**\n//    * Convert the tx to an inv item.\n//    * @returns {InvItem}\n//    */\n\n//   toInv() {\n//     return new InvItem(InvItem.types.TX, this.hash());\n//   }\n\n//   /**\n//    * Inspect the transaction and return a more\n//    * user-friendly representation of the data.\n//    * @returns {Object}\n//    */\n\n//   [inspectSymbol]() {\n//     return this.format();\n//   }\n\n//   /**\n//    * Inspect the transaction and return a more\n//    * user-friendly representation of the data.\n//    * @param {CoinView} view\n//    * @param {ChainEntry} entry\n//    * @param {Number} index\n//    * @returns {Object}\n//    */\n\n//   format(view, entry, index) {\n//     let rate = 0;\n//     let fee = 0;\n//     let height = -1;\n//     let block = null;\n//     let time = 0;\n//     let date = null;\n\n//     if (view) {\n//       fee = this.getFee(view);\n//       rate = this.getRate(view);\n\n//       // Rate can exceed 53 bits in testing.\n//       if (!Number.isSafeInteger(rate))\n//         rate = 0;\n//     }\n\n//     if (entry) {\n//       height = entry.height;\n//       block = util.revHex(entry.hash);\n//       time = entry.time;\n//       date = util.date(time);\n//     }\n\n//     if (index == null)\n//       index = -1;\n\n//     const hr = {\n//       hash: this.txid(),\n//       size: this.getSize(),\n//       value: Amount.btc(this.getOutputValue()),\n//       fee: Amount.btc(fee),\n//       rate: Amount.btc(rate),\n//       minFee: Amount.btc(this.getMinFee()),\n//       height: height,\n//       block: block,\n//       time: time,\n//       date: date,\n//       index: index,\n//       version: this.version,\n//       inputs: this.inputs.map((input) => {\n//         const coin = view ? view.getOutputFor(input) : null;\n//         return input.format(coin);\n//       }),\n//       outputs: this.outputs,\n//       locktime: this.locktime\n//     };\n\n//     if (this.slpToken) {\n//       return {\n//         ...hr,\n//         slpToken: this.slpToken\n//       };\n//     }\n//     return hr;\n//   }\n\n//   /**\n//    * Convert the transaction to an object suitable\n//    * for JSON serialization.\n//    * @returns {Object}\n//    */\n\n//   toJSON() {\n//     return this.getJSON();\n//   }\n\n//   /**\n//    * Convert the transaction to an object suitable\n//    * for JSON serialization. Note that the hashes\n//    * will be reversed to abide by bitcoind's legacy\n//    * of little-endian uint256s.\n//    * @param {Network} network\n//    * @param {CoinView} view\n//    * @param {ChainEntry} entry\n//    * @param {Number} index\n//    * @returns {Object}\n//    */\n\n//   getJSON(network, view, entry, index) {\n//     let rate, fee, height, block, time, date;\n\n//     if (view) {\n//       fee = this.getFee(view);\n//       rate = this.getRate(view);\n\n//       // Rate can exceed 53 bits in testing.\n//       if (!Number.isSafeInteger(rate))\n//         rate = 0;\n//     }\n\n//     if (entry) {\n//       height = entry.height;\n//       block = util.revHex(entry.hash);\n//       time = entry.time;\n//       date = util.date(time);\n//     }\n\n//     network = Network.get(network);\n\n//     const json = {\n//       hash: this.txid(),\n//       fee: fee,\n//       rate: rate,\n//       mtime: util.now(),\n//       height: height,\n//       block: block,\n//       time: time,\n//       date: date,\n//       index: index,\n//       version: this.version,\n//       inputs: this.inputs.map((input) => {\n//         const coin = view ? view.getCoinFor(input) : null;\n//         return input.getJSON(network, coin);\n//       }),\n//       outputs: this.outputs.map((output) => {\n//         return output.getJSON(network);\n//       }),\n//       locktime: this.locktime,\n//       hex: this.toRaw().toString('hex')\n//     };\n\n//     if (this.slpToken) {\n//       return {\n//         ...json,\n//         slpToken: this.slpToken.getJSON()\n//       };\n//     }\n//     return json;\n//   }\n\n//   /**\n//    * Inject properties from a json object.\n//    * @private\n//    * @param {Object} json\n//    */\n\n//   fromJSON(json) {\n//     assert(json, 'TX data is required.');\n//     assert((json.version >>> 0) === json.version, 'Version must be a uint32.');\n//     assert(Array.isArray(json.inputs), 'Inputs must be an array.');\n//     assert(Array.isArray(json.outputs), 'Outputs must be an array.');\n//     assert((json.locktime >>> 0) === json.locktime,\n//       'Locktime must be a uint32.');\n\n//     this.version = json.version;\n\n//     for (const input of json.inputs)\n//       this.inputs.push(Input.fromJSON(input));\n\n//     for (const output of json.outputs)\n//       this.outputs.push(Output.fromJSON(output));\n\n//     this.locktime = json.locktime;\n\n//     if (json.slpToken)\n//       this.slpToken = SLP.TokenRecord().fromJSON(json.slpToken)\n\n//     return this;\n//   }\n\n//   /**\n//    * Instantiate a transaction from a\n//    * jsonified transaction object.\n//    * @param {Object} json - The jsonified transaction object.\n//    * @returns {TX}\n//    */\n\n//   static fromJSON(json) {\n//     return new this().fromJSON(json);\n//   }\n\n//   /**\n//    * Instantiate a transaction from a serialized Buffer.\n//    * @param {Buffer} data\n//    * @param {String?} enc - Encoding, can be `'hex'` or null.\n//    * @returns {TX}\n//    */\n\n//   static fromRaw(data, enc) {\n//     if (typeof data === 'string')\n//       data = Buffer.from(data, enc);\n//     return new this().fromRaw(data);\n//   }\n\n//   /**\n//    * Instantiate a transaction from a buffer reader.\n//    * @param {BufferReader} br\n//    * @param {Boolean} block\n//    * @returns {TX}\n//    */\n\n//   static fromReader(br, block) {\n//     return new this().fromReader(br, block);\n//   }\n\n//   /**\n//    * Inject properties from serialized data.\n//    * @private\n//    * @param {Buffer} data\n//    */\n\n//   fromRaw(data) {\n//     return this.fromReader(bio.read(data));\n//   }\n\n//   /**\n//    * Inject properties from buffer reader.\n//    * @private\n//    * @param {BufferReader} br\n//    * @param {Boolean} block\n//    */\n\n//   fromReader(br, block) {\n//     const start = br.start();\n\n//     this.version = br.readU32();\n\n//     const inCount = br.readVarint();\n\n//     for (let i = 0; i < inCount; i++)\n//       this.inputs.push(Input.fromReader(br));\n\n//     const outCount = br.readVarint();\n\n//     for (let i = 0; i < outCount; i++)\n//       this.outputs.push(Output.fromReader(br));\n\n//     this.locktime = br.readU32();\n\n//     if (block) {\n//       this._offset = start;\n//       this._block = true;\n//     }\n\n//     if (!this.mutable) {\n//       this._raw = br.endData();\n//       this._size = this._raw.length;\n//     } else {\n//       br.end();\n//     }\n\n//     return this;\n//   }\n\n//   /**\n//    * Serialize transaction without witness.\n//    * @private\n//    * @returns {RawTX}\n//    */\n\n//   frameNormal() {\n//     const raw = this.getNormalSizes();\n//     const bw = bio.write(raw.size);\n//     this.writeNormal(bw);\n//     raw.data = bw.render();\n//     return raw;\n//   }\n\n//   /**\n//    * Serialize transaction without witness.\n//    * @private\n//    * @param {BufferWriter} bw\n//    * @returns {RawTX}\n//    */\n\n//   writeNormal(bw) {\n//     if (this.inputs.length === 0 && this.outputs.length !== 0)\n//       throw new Error('Cannot serialize zero-input tx.');\n\n//     bw.writeU32(this.version);\n\n//     bw.writeVarint(this.inputs.length);\n\n//     for (const input of this.inputs)\n//       input.toWriter(bw);\n\n//     bw.writeVarint(this.outputs.length);\n\n//     for (const output of this.outputs)\n//       output.toWriter(bw);\n\n//     bw.writeU32(this.locktime);\n\n//     return bw;\n//   }\n\n//   /**\n//    * Calculate the real size of the transaction\n//    * without the witness vector.\n//    * @returns {RawTX}\n//    */\n\n//   getNormalSizes() {\n//     let base = 0;\n\n//     base += 4;\n\n//     base += encoding.sizeVarint(this.inputs.length);\n\n//     for (const input of this.inputs)\n//       base += input.getSize();\n\n//     base += encoding.sizeVarint(this.outputs.length);\n\n//     for (const output of this.outputs)\n//       base += output.getSize();\n\n//     base += 4;\n\n//     return new RawTX(base, 0);\n//   }\n\n//   /**\n//    * Test whether an object is a TX.\n//    * @param {Object} obj\n//    * @returns {Boolean}\n//    */\n\n//   static isTX(obj) {\n//     return obj instanceof TX;\n//   }\n}\n\n// /*\n//  * Helpers\n//  */\n\n// class RawTX {\n//   constructor(size) {\n//     this.data = null;\n//     this.size = size;\n//   }\n// }\n\n/*\n * Expose\n */\n\nmodule.exports = TX;\n"]},"metadata":{},"sourceType":"module"}