{"ast":null,"code":"/*!\n * scrypt.js - scrypt for bcrypto\n * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on Tarsnap/scrypt:\n *   Copyright (c) 2005-2016, Colin Percival. All rights reserved.\n *   Copyright (c) 2005-2016, Tarsnap Backup Inc. All rights reserved.\n *   Copyright (c) 2014, Sean Kelly. All rights reserved.\n *   https://github.com/Tarsnap/scrypt\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/Scrypt\n *   http://www.tarsnap.com/scrypt.html\n *   http://www.tarsnap.com/scrypt/scrypt.pdf\n *   https://github.com/Tarsnap/scrypt/blob/master/lib/crypto/crypto_scrypt-ref.c\n */\n\n/* eslint camelcase: \"off\" */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst pbkdf2 = require('../pbkdf2');\n\nconst SHA256 = require('../sha256');\n/*\n * Constants\n */\n\n\nconst SLAB1 = Buffer.alloc(64);\nconst SLAB2 = new Uint32Array(16);\nconst SLAB3 = new Uint32Array(16);\n/**\n * Perform scrypt key derivation.\n * @param {Buffer} passwd\n * @param {Buffer} salt\n * @param {Number} N\n * @param {Number} r\n * @param {Number} p\n * @param {Number} len\n * @returns {Buffer}\n */\n\nfunction derive(passwd, salt, N, r, p, len) {\n  if (typeof passwd === 'string') passwd = Buffer.from(passwd, 'utf8');\n  if (typeof salt === 'string') salt = Buffer.from(salt, 'utf8');\n  if (salt == null) salt = Buffer.alloc(0);\n  assert(Buffer.isBuffer(passwd));\n  assert(Buffer.isBuffer(salt));\n  assert(N >>> 0 === N);\n  assert(r >>> 0 === r);\n  assert(p >>> 0 === p);\n  assert(len >>> 0 === len);\n  if (r * p >= 1 << 30) throw new Error('EFBIG');\n  if ((N & N - 1) !== 0 || N === 0) throw new Error('EINVAL');\n  if (N > 0xffffffff) throw new Error('EINVAL');\n  const XY = Buffer.allocUnsafe(256 * r);\n  const V = Buffer.allocUnsafe(128 * r * N);\n  const B = pbkdf2.derive(SHA256, passwd, salt, 1, p * 128 * r);\n\n  for (let i = 0; i < p; i++) smix(B, i * 128 * r, r, N, V, XY);\n\n  clear();\n  return pbkdf2.derive(SHA256, passwd, B, 1, len);\n}\n/**\n * Perform scrypt key derivation (async).\n * @param {Buffer} passwd\n * @param {Buffer} salt\n * @param {Number} N\n * @param {Number} r\n * @param {Number} p\n * @param {Number} len\n * @returns {Promise}\n */\n\n\nasync function deriveAsync(passwd, salt, N, r, p, len) {\n  if (typeof passwd === 'string') passwd = Buffer.from(passwd, 'utf8');\n  if (typeof salt === 'string') salt = Buffer.from(salt, 'utf8');\n  if (salt == null) salt = Buffer.alloc(0);\n  assert(Buffer.isBuffer(passwd));\n  assert(Buffer.isBuffer(salt));\n  assert(N >>> 0 === N);\n  assert(r >>> 0 === r);\n  assert(p >>> 0 === p);\n  assert(len >>> 0 === len);\n  if (r * p >= 1 << 30) throw new Error('EFBIG');\n  if ((N & N - 1) !== 0 || N === 0) throw new Error('EINVAL');\n  if (N > 0xffffffff) throw new Error('EINVAL');\n  const XY = Buffer.allocUnsafe(256 * r);\n  const V = Buffer.allocUnsafe(128 * r * N);\n  const B = await pbkdf2.deriveAsync(SHA256, passwd, salt, 1, p * 128 * r);\n\n  for (let i = 0; i < p; i++) await smixAsync(B, i * 128 * r, r, N, V, XY);\n\n  clear();\n  return pbkdf2.deriveAsync(SHA256, passwd, B, 1, len);\n}\n/*\n * Helpers\n */\n\n\nfunction salsa20_8(B) {\n  const B32 = SLAB2;\n  const X = SLAB3;\n\n  for (let i = 0; i < 16; i++) B32[i] = readU32(B, i * 4);\n\n  for (let i = 0; i < 16; i++) X[i] = B32[i];\n\n  for (let i = 0; i < 8; i += 2) {\n    X[4] ^= R(X[0] + X[12], 7);\n    X[8] ^= R(X[4] + X[0], 9);\n    X[12] ^= R(X[8] + X[4], 13);\n    X[0] ^= R(X[12] + X[8], 18);\n    X[9] ^= R(X[5] + X[1], 7);\n    X[13] ^= R(X[9] + X[5], 9);\n    X[1] ^= R(X[13] + X[9], 13);\n    X[5] ^= R(X[1] + X[13], 18);\n    X[14] ^= R(X[10] + X[6], 7);\n    X[2] ^= R(X[14] + X[10], 9);\n    X[6] ^= R(X[2] + X[14], 13);\n    X[10] ^= R(X[6] + X[2], 18);\n    X[3] ^= R(X[15] + X[11], 7);\n    X[7] ^= R(X[3] + X[15], 9);\n    X[11] ^= R(X[7] + X[3], 13);\n    X[15] ^= R(X[11] + X[7], 18);\n    X[1] ^= R(X[0] + X[3], 7);\n    X[2] ^= R(X[1] + X[0], 9);\n    X[3] ^= R(X[2] + X[1], 13);\n    X[0] ^= R(X[3] + X[2], 18);\n    X[6] ^= R(X[5] + X[4], 7);\n    X[7] ^= R(X[6] + X[5], 9);\n    X[4] ^= R(X[7] + X[6], 13);\n    X[5] ^= R(X[4] + X[7], 18);\n    X[11] ^= R(X[10] + X[9], 7);\n    X[8] ^= R(X[11] + X[10], 9);\n    X[9] ^= R(X[8] + X[11], 13);\n    X[10] ^= R(X[9] + X[8], 18);\n    X[12] ^= R(X[15] + X[14], 7);\n    X[13] ^= R(X[12] + X[15], 9);\n    X[14] ^= R(X[13] + X[12], 13);\n    X[15] ^= R(X[14] + X[13], 18);\n  }\n\n  for (let i = 0; i < 16; i++) B32[i] += X[i];\n\n  for (let i = 0; i < 16; i++) writeU32(B, B32[i], 4 * i);\n}\n\nfunction R(a, b) {\n  return a << b | a >>> 32 - b;\n}\n\nfunction blockmix_salsa8(B, Y, Yo, r) {\n  const X = SLAB1;\n  blkcpy(X, B, 0, (2 * r - 1) * 64, 64);\n\n  for (let i = 0; i < 2 * r; i++) {\n    blkxor(X, B, 0, i * 64, 64);\n    salsa20_8(X);\n    blkcpy(Y, X, Yo + i * 64, 0, 64);\n  }\n\n  for (let i = 0; i < r; i++) blkcpy(B, Y, i * 64, Yo + i * 2 * 64, 64);\n\n  for (let i = 0; i < r; i++) blkcpy(B, Y, (i + r) * 64, Yo + (i * 2 + 1) * 64, 64);\n}\n\nfunction integerify(B, r) {\n  return readU32(B, (2 * r - 1) * 64);\n}\n\nfunction smix(B, Bo, r, N, V, XY) {\n  const X = XY;\n  const Y = XY;\n  blkcpy(X, B, 0, Bo, 128 * r);\n\n  for (let i = 0; i < N; i++) {\n    blkcpy(V, X, i * (128 * r), 0, 128 * r);\n    blockmix_salsa8(X, Y, 128 * r, r);\n  }\n\n  for (let i = 0; i < N; i++) {\n    const j = integerify(X, r) & N - 1;\n    blkxor(X, V, 0, j * (128 * r), 128 * r);\n    blockmix_salsa8(X, Y, 128 * r, r);\n  }\n\n  blkcpy(B, X, Bo, 0, 128 * r);\n}\n\nasync function smixAsync(B, Bo, r, N, V, XY) {\n  const X = XY;\n  const Y = XY;\n  blkcpy(X, B, 0, Bo, 128 * r);\n\n  for (let i = 0; i < N; i++) {\n    blkcpy(V, X, i * (128 * r), 0, 128 * r);\n    blockmix_salsa8(X, Y, 128 * r, r);\n    await wait();\n  }\n\n  for (let i = 0; i < N; i++) {\n    const j = integerify(X, r) & N - 1;\n    blkxor(X, V, 0, j * (128 * r), 128 * r);\n    blockmix_salsa8(X, Y, 128 * r, r);\n    await wait();\n  }\n\n  blkcpy(B, X, Bo, 0, 128 * r);\n}\n\nfunction blkcpy(dst, src, dstOff, srcOff, len) {\n  src.copy(dst, dstOff, srcOff, srcOff + len);\n}\n\nfunction blkxor(dst, src, dstOff, srcOff, len) {\n  for (let i = 0; i < len; i++) dst[dstOff + i] ^= src[srcOff + i];\n}\n\nfunction wait() {\n  return new Promise(r => setImmediate(r));\n}\n\nfunction clear() {\n  for (let i = 0; i < 64; i++) SLAB1[i] = 0;\n\n  for (let i = 0; i < 16; i++) {\n    SLAB2[i] = 0;\n    SLAB3[i] = 0;\n  }\n}\n\nfunction readU32(data, off) {\n  return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;\n}\n\nfunction writeU32(dst, num, off) {\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  return off;\n}\n/*\n * Expose\n */\n\n\nexports.native = 0;\nexports.derive = derive;\nexports.deriveAsync = deriveAsync;","map":null,"metadata":{},"sourceType":"script"}