{"ast":null,"code":"/*!\n * ecdsa.js - ECDSA for bcrypto\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on indutny/elliptic:\n *   Copyright (c) 2014, Fedor Indutny (MIT License).\n *   https://github.com/indutny/elliptic\n *\n * References:\n *\n *   [SEC1] SEC 1: Elliptic Curve Cryptography, Version 2.0\n *     Certicom Research\n *     http://www.secg.org/sec1-v2.pdf\n *\n *   [FIPS186] Suite B Implementer's Guide to FIPS 186-3 (ECDSA)\n *     https://tinyurl.com/fips186-guide\n *\n *   [GECC] Guide to Elliptic Curve Cryptography\n *     D. Hankerson, A. Menezes, and S. Vanstone\n *     https://tinyurl.com/guide-to-ecc\n *\n *   [RFC6979] Deterministic Usage of the Digital Signature\n *             Algorithm (DSA) and Elliptic Curve Digital\n *             Signature Algorithm (ECDSA)\n *     T. Pornin\n *     https://tools.ietf.org/html/rfc6979\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst BN = require('../bn');\n\nconst rng = require('../random');\n\nconst asn1 = require('../internal/asn1');\n\nconst Schnorr = require('./schnorr-legacy');\n\nconst HmacDRBG = require('../hmac-drbg');\n\nconst elliptic = require('./elliptic');\n/**\n * ECDSA\n */\n\n\nclass ECDSA {\n  constructor(name, hash, pre) {\n    assert(typeof name === 'string');\n    assert(hash);\n    this.id = name;\n    this.type = 'ecdsa';\n    this.hash = hash;\n    this.native = 0;\n    this._pre = pre || null;\n    this._curve = null;\n    this._schnorr = null;\n  }\n\n  get curve() {\n    if (!this._curve) {\n      this._curve = elliptic.curve(this.id, this._pre);\n\n      this._curve.precompute(rng);\n\n      this._pre = null;\n    }\n\n    return this._curve;\n  }\n\n  get schnorr() {\n    if (!this._schnorr) this._schnorr = new Schnorr(this.curve, this.hash);\n    return this._schnorr;\n  }\n\n  get size() {\n    return this.curve.fieldSize;\n  }\n\n  get bits() {\n    return this.curve.fieldBits;\n  }\n\n  privateKeyGenerate() {\n    const a = this.curve.randomScalar(rng);\n    return this.curve.encodeScalar(a);\n  }\n\n  privateKeyVerify(key) {\n    assert(Buffer.isBuffer(key));\n    let a;\n\n    try {\n      a = this.curve.decodeScalar(key);\n    } catch (e) {\n      return false;\n    }\n\n    return !a.isZero() && a.cmp(this.curve.n) < 0;\n  }\n\n  privateKeyExport(key) {\n    const pub = this.publicKeyCreate(key, false);\n    const {\n      x,\n      y\n    } = this.publicKeyExport(pub);\n    return {\n      d: Buffer.from(key),\n      x,\n      y\n    };\n  }\n\n  privateKeyImport(json) {\n    assert(json && typeof json === 'object');\n    const a = BN.decode(json.d, this.curve.endian);\n    if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');\n    return this.curve.encodeScalar(a);\n  }\n\n  privateKeyTweakAdd(key, tweak) {\n    const t = this.curve.decodeScalar(tweak);\n    if (t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');\n    const a = this.curve.decodeScalar(key);\n    if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');\n    const k = a.add(t).imod(this.curve.n);\n    if (k.isZero()) throw new Error('Invalid private key.');\n    return this.curve.encodeScalar(k);\n  }\n\n  privateKeyTweakMul(key, tweak) {\n    const t = this.curve.decodeScalar(tweak);\n    if (t.isZero() || t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');\n    const a = this.curve.decodeScalar(key);\n    if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');\n    const k = a.mul(t).imod(this.curve.n);\n    if (k.isZero()) throw new Error('Invalid private key.');\n    return this.curve.encodeScalar(k);\n  }\n\n  privateKeyReduce(key) {\n    assert(Buffer.isBuffer(key));\n    if (key.length > this.curve.scalarSize) key = key.slice(0, this.curve.scalarSize);\n    const a = BN.decode(key, this.curve.endian).imod(this.curve.n);\n    if (a.isZero()) throw new Error('Invalid private key.');\n    return this.curve.encodeScalar(a);\n  }\n\n  privateKeyNegate(key) {\n    const a = this.curve.decodeScalar(key);\n    if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');\n    const k = a.neg().imod(this.curve.n);\n    return this.curve.encodeScalar(k);\n  }\n\n  privateKeyInvert(key) {\n    const a = this.curve.decodeScalar(key);\n    if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');\n    const k = a.invert(this.curve.n);\n    return this.curve.encodeScalar(k);\n  }\n\n  publicKeyCreate(key, compress) {\n    const a = this.curve.decodeScalar(key);\n    if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');\n    const A = this.curve.g.mulBlind(a);\n    return A.encode(compress);\n  }\n\n  publicKeyConvert(key, compress) {\n    const A = this.curve.decodePoint(key);\n    return A.encode(compress);\n  }\n\n  publicKeyFromUniform(bytes, compress) {\n    const u = this.curve.decodeUniform(bytes);\n    const A = this.curve.pointFromUniform(u);\n    return A.encode(compress);\n  }\n\n  publicKeyToUniform(key) {\n    let hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : rng.randomInt();\n    const A = this.curve.decodePoint(key);\n    const u = this.curve.pointToUniform(A, hint);\n    return this.curve.encodeUniform(u, rng);\n  }\n\n  publicKeyFromHash(bytes, compress) {\n    const A = this.curve.pointFromHash(bytes);\n    return A.encode(compress);\n  }\n\n  publicKeyToHash(key) {\n    const A = this.curve.decodePoint(key);\n    return this.curve.pointToHash(A, rng);\n  }\n\n  publicKeyVerify(key) {\n    assert(Buffer.isBuffer(key));\n\n    try {\n      this.curve.decodePoint(key);\n    } catch (e) {\n      return false;\n    }\n\n    return true;\n  }\n\n  publicKeyExport(key) {\n    const {\n      x,\n      y\n    } = this.curve.decodePoint(key);\n    return {\n      x: this.curve.encodeField(x.fromRed()),\n      y: this.curve.encodeField(y.fromRed())\n    };\n  }\n\n  publicKeyImport(json, compress) {\n    assert(json && typeof json === 'object');\n    const x = BN.decode(json.x, this.curve.endian);\n    if (x.cmp(this.curve.p) >= 0) throw new Error('Invalid point.');\n\n    if (json.y != null) {\n      const y = BN.decode(json.y, this.curve.endian);\n      if (y.cmp(this.curve.p) >= 0) throw new Error('Invalid point.');\n      const A = this.curve.point(x, y);\n      if (!A.validate()) throw new Error('Invalid point.');\n      return A.encode(compress);\n    }\n\n    const A = this.curve.pointFromX(x, json.sign);\n    return A.encode(compress);\n  }\n\n  publicKeyTweakAdd(key, tweak, compress) {\n    const t = this.curve.decodeScalar(tweak);\n    if (t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');\n    const A = this.curve.decodePoint(key);\n    const T = this.curve.g.jmul(t);\n    const P = T.add(A);\n    return P.encode(compress);\n  }\n\n  publicKeyTweakMul(key, tweak, compress) {\n    const t = this.curve.decodeScalar(tweak);\n    if (t.isZero() || t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');\n    const A = this.curve.decodePoint(key);\n    const P = A.mul(t);\n    return P.encode(compress);\n  }\n\n  publicKeyCombine(keys, compress) {\n    assert(Array.isArray(keys));\n    let P = this.curve.jpoint();\n\n    for (const key of keys) {\n      const A = this.curve.decodePoint(key);\n      P = P.add(A);\n    }\n\n    return P.encode(compress);\n  }\n\n  publicKeyNegate(key, compress) {\n    const A = this.curve.decodePoint(key);\n    const P = A.neg();\n    return P.encode(compress);\n  }\n\n  signatureNormalize(sig) {\n    const [r, s] = this._decodeCompact(sig);\n\n    if (s.cmp(this.curve.nh) > 0) s.ineg().imod(this.curve.n);\n    return this._encodeCompact(r, s);\n  }\n\n  signatureNormalizeDER(sig) {\n    const [r, s] = this._decodeDER(sig, false);\n\n    if (s.cmp(this.curve.nh) > 0) s.ineg().imod(this.curve.n);\n    return this._encodeDER(r, s);\n  }\n\n  signatureExport(sig) {\n    const [r, s] = this._decodeCompact(sig);\n\n    return this._encodeDER(r, s);\n  }\n\n  signatureImport(sig) {\n    const [r, s] = this._decodeDER(sig, false);\n\n    return this._encodeCompact(r, s);\n  }\n\n  isLowS(sig) {\n    assert(Buffer.isBuffer(sig));\n    let s;\n\n    try {\n      [, s] = this._decodeCompact(sig);\n    } catch (e) {\n      return false;\n    }\n\n    return s.cmp(this.curve.nh) <= 0;\n  }\n\n  isLowDER(sig) {\n    assert(Buffer.isBuffer(sig));\n    let s;\n\n    try {\n      [, s] = this._decodeDER(sig, false);\n    } catch (e) {\n      return false;\n    }\n\n    return s.cmp(this.curve.nh) <= 0;\n  }\n\n  sign(msg, key) {\n    const [r, s] = this._sign(msg, key);\n\n    return this._encodeCompact(r, s);\n  }\n\n  signRecoverable(msg, key) {\n    const [r, s, param] = this._sign(msg, key);\n\n    return [this._encodeCompact(r, s), param];\n  }\n\n  signDER(msg, key) {\n    const [r, s] = this._sign(msg, key);\n\n    return this._encodeDER(r, s);\n  }\n\n  signRecoverableDER(msg, key) {\n    const [r, s, param] = this._sign(msg, key);\n\n    return [this._encodeDER(r, s), param];\n  }\n\n  _sign(msg, key) {\n    // ECDSA Signing.\n    //\n    // [SEC1] Page 44, Section 4.1.3.\n    // [GECC] Algorithm 4.29, Page 184, Section 4.4.1.\n    // [RFC6979] Page 9, Section 2.4.\n    // [RFC6979] Page 10, Section 3.2.\n    //\n    // Assumptions:\n    //\n    //   - Let `m` be an integer reduced from bytes.\n    //   - Let `a` be a secret non-zero scalar.\n    //   - Let `k` be a random non-zero scalar.\n    //   - R != O, r != 0, s != 0.\n    //\n    // Computation:\n    //\n    //   k = random integer in [1,n-1]\n    //   R = G * k\n    //   r = x(R) mod n\n    //   s = (r * a + m) / k mod n\n    //   s = -s mod n, if s > n / 2\n    //   S = (r, s)\n    //\n    // We can blind the scalar arithmetic\n    // with a random integer `b` like so:\n    //\n    //   b = random integer in [1,n-1]\n    //   s = (r * (a * b) + m * b) / (k * b) mod n\n    //\n    // Note that `k` must remain secret,\n    // otherwise an attacker can compute:\n    //\n    //   a = (s * k - m) / r mod n\n    //\n    // This means that if two signatures\n    // share the same `r` value, an attacker\n    // can compute:\n    //\n    //   k = (m1 - m2) / (+-s1 - +-s2) mod n\n    //   a = (s1 * k - m1) / r mod n\n    //\n    // Assuming:\n    //\n    //   s1 = (r * a + m1) / k mod n\n    //   s2 = (r * a + m2) / k mod n\n    //\n    // To mitigate this, `k` can be generated\n    // deterministically using the HMAC-DRBG\n    // construction described in [RFC6979].\n    const {\n      n,\n      nh\n    } = this.curve;\n    const G = this.curve.g;\n    const a = this.curve.decodeScalar(key);\n    if (a.isZero() || a.cmp(n) >= 0) throw new Error('Invalid private key.');\n\n    const m = this._reduce(msg);\n\n    const nonce = this.curve.encodeScalar(m);\n    const drbg = new HmacDRBG(this.hash, key, nonce);\n\n    for (;;) {\n      const bytes = drbg.generate(this.curve.scalarSize);\n\n      const k = this._truncate(bytes);\n\n      if (k.isZero() || k.cmp(n) >= 0) continue;\n      const R = G.mulBlind(k);\n      if (R.isInfinity()) continue;\n      const x = R.getX();\n      const r = x.mod(n);\n      if (r.isZero()) continue;\n      const b = this.curve.randomScalar(rng);\n      const ki = k.mul(b).fermat(n);\n      const ba = a.mul(b).imod(n);\n      const bm = m.mul(b).imod(n);\n      const sk = r.mul(ba).iadd(bm).imod(n);\n      const s = sk.mul(ki).imod(n);\n      if (s.isZero()) continue;\n      let param = R.isOdd() | !x.eq(r) << 1;\n\n      if (s.cmp(nh) > 0) {\n        s.ineg().imod(n);\n        param ^= 1;\n      }\n\n      return [r, s, param];\n    }\n  }\n\n  verify(msg, sig, key) {\n    assert(Buffer.isBuffer(msg));\n    assert(Buffer.isBuffer(sig));\n    assert(Buffer.isBuffer(key));\n    let r, s;\n\n    try {\n      [r, s] = this._decodeCompact(sig);\n    } catch (e) {\n      return false;\n    }\n\n    try {\n      return this._verify(msg, r, s, key);\n    } catch (e) {\n      return false;\n    }\n  }\n\n  verifyDER(msg, sig, key) {\n    assert(Buffer.isBuffer(msg));\n    assert(Buffer.isBuffer(sig));\n    assert(Buffer.isBuffer(key));\n    let r, s;\n\n    try {\n      [r, s] = this._decodeDER(sig, false);\n    } catch (e) {\n      return false;\n    }\n\n    try {\n      return this._verify(msg, r, s, key);\n    } catch (e) {\n      return false;\n    }\n  }\n\n  _verify(msg, r, s, key) {\n    // ECDSA Verification.\n    //\n    // [SEC1] Page 46, Section 4.1.4.\n    // [GECC] Algorithm 4.30, Page 184, Section 4.4.1.\n    //\n    // Assumptions:\n    //\n    //   - Let `m` be an integer reduced from bytes.\n    //   - Let `r` and `s` be signature elements.\n    //   - Let `A` be a valid group element.\n    //   - r != 0, r < n.\n    //   - s != 0, s < n.\n    //   - R != O.\n    //\n    // Computation:\n    //\n    //   u1 = m / s mod n\n    //   u2 = r / s mod n\n    //   R = G * u1 + A * u2\n    //   r == x(R) mod n\n    //\n    // Note that the signer can verify their\n    // own signatures more efficiently with:\n    //\n    //   R = G * ((u1 + u2 * a) mod n)\n    //\n    // Furthermore, we can avoid affinization\n    // of `R` by scaling `r` by `z^2` and\n    // repeatedly adding `n * z^2` to it up\n    // to a certain threshold.\n    const {\n      n\n    } = this.curve;\n    const G = this.curve.g;\n\n    const m = this._reduce(msg);\n\n    const A = this.curve.decodePoint(key);\n    if (r.isZero() || r.cmp(n) >= 0) return false;\n    if (s.isZero() || s.cmp(n) >= 0) return false;\n    const si = s.invert(n);\n    const u1 = m.mul(si).imod(n);\n    const u2 = r.mul(si).imod(n);\n    const R = G.jmulAdd(u1, A, u2);\n    return R.eqXToP(r);\n  }\n\n  recover(msg, sig, param, compress) {\n    assert(Buffer.isBuffer(msg));\n    assert(Buffer.isBuffer(sig));\n    assert(param >>> 0 === param);\n    assert((param & 3) === param, 'The recovery param is more than two bits.');\n    let r, s;\n\n    try {\n      [r, s] = this._decodeCompact(sig);\n    } catch (e) {\n      return null;\n    }\n\n    let A;\n\n    try {\n      A = this._recover(msg, r, s, param);\n    } catch (e) {\n      return null;\n    }\n\n    return A.encode(compress);\n  }\n\n  recoverDER(msg, sig, param, compress) {\n    assert(Buffer.isBuffer(msg));\n    assert(Buffer.isBuffer(sig));\n    assert(param >>> 0 === param);\n    assert((param & 3) === param, 'The recovery param is more than two bits.');\n    let r, s;\n\n    try {\n      [r, s] = this._decodeDER(sig, false);\n    } catch (e) {\n      return null;\n    }\n\n    let A;\n\n    try {\n      A = this._recover(msg, r, s, param);\n    } catch (e) {\n      return null;\n    }\n\n    return A.encode(compress);\n  }\n\n  _recover(msg, r, s, param) {\n    // ECDSA Public Key Recovery.\n    //\n    // [SEC1] Page 47, Section 4.1.6.\n    //\n    // Assumptions:\n    //\n    //   - Let `m` be an integer reduced from bytes.\n    //   - Let `r` and `s` be signature elements.\n    //   - Let `i` be an integer in [0,3].\n    //   - x^3 + a * x + b is square in F(p).\n    //   - If i > 1 then r < (p mod n).\n    //   - r != 0, r < n.\n    //   - s != 0, s < n.\n    //   - A != O.\n    //\n    // Computation:\n    //\n    //   x = r + n, if i > 1\n    //     = r, otherwise\n    //   R' = (x, sqrt(x^3 + a * x + b))\n    //   R = -R', if i mod 2 == 1\n    //     = +R', otherwise\n    //   s1 = m / r mod n\n    //   s2 = s / r mod n\n    //   A = R * s2 - G * s1\n    //\n    // Note that this implementation will have\n    // trouble on curves where `p / n > 1`.\n    const {\n      p,\n      n\n    } = this.curve;\n    const G = this.curve.g;\n\n    const m = this._reduce(msg);\n\n    if (r.isZero() || r.cmp(n) >= 0) throw new Error('Invalid R value.');\n    if (s.isZero() || s.cmp(n) >= 0) throw new Error('Invalid S value.');\n    const sign = (param & 1) !== 0;\n    const high = param >>> 1;\n    let x = r;\n\n    if (high) {\n      if (x.cmp(p.mod(n)) >= 0) throw new Error('Invalid R value.');\n      x = x.add(n);\n    }\n\n    const R = this.curve.pointFromX(x, sign);\n    const ri = r.invert(n);\n    const s1 = m.mul(ri).ineg().imod(n);\n    const s2 = s.mul(ri).imod(n);\n    const A = G.mulAdd(s1, R, s2);\n    if (A.isInfinity()) throw new Error('Invalid point.');\n    return A;\n  }\n\n  derive(pub, priv, compress) {\n    const A = this.curve.decodePoint(pub);\n    const a = this.curve.decodeScalar(priv);\n    if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');\n\n    if (this.curve.h.cmpn(1) > 0) {\n      if (A.isSmall()) throw new Error('Invalid point.');\n    }\n\n    const P = A.mulConst(a, rng);\n    return P.encode(compress);\n  }\n  /*\n   * Schnorr\n   */\n\n\n  schnorrSign(msg, key) {\n    return this.schnorr.sign(msg, key);\n  }\n\n  schnorrVerify(msg, sig, key) {\n    return this.schnorr.verify(msg, sig, key);\n  }\n\n  schnorrVerifyBatch(batch) {\n    return this.schnorr.verifyBatch(batch);\n  }\n  /*\n   * Helpers\n   */\n\n\n  _encodeCompact(r, s) {\n    return Buffer.concat([this.curve.encodeScalar(r), this.curve.encodeScalar(s)]);\n  }\n\n  _decodeCompact(sig) {\n    assert(Buffer.isBuffer(sig));\n    const {\n      n\n    } = this.curve;\n    const size = this.curve.scalarSize;\n    if (sig.length !== size * 2) throw new Error('Invalid signature size.');\n    const Rraw = sig.slice(0, size);\n    const Sraw = sig.slice(size, size * 2);\n    const r = this.curve.decodeScalar(Rraw);\n    const s = this.curve.decodeScalar(Sraw);\n    if (r.cmp(n) >= 0 || s.cmp(n) >= 0) throw new Error('Invalid signature.');\n    return [r, s];\n  }\n\n  _encodeDER(r, s) {\n    const size = asn1.sizeInt(r) + asn1.sizeInt(s);\n    const out = Buffer.alloc(asn1.sizeSeq(size));\n    let pos = 0;\n    pos = asn1.writeSeq(out, pos, size);\n    pos = asn1.writeInt(out, pos, r);\n    pos = asn1.writeInt(out, pos, s);\n    assert(pos === out.length);\n    return out;\n  }\n\n  _decodeDER(sig, strict) {\n    assert(Buffer.isBuffer(sig));\n    assert(typeof strict === 'boolean');\n    const {\n      n\n    } = this.curve;\n    let pos = 0;\n    let r, s;\n    pos = asn1.readSeq(sig, pos, strict);\n    [r, pos] = asn1.readInt(sig, pos, strict);\n    [s, pos] = asn1.readInt(sig, pos, strict);\n    if (strict && pos !== sig.length) throw new Error('Trailing bytes.');\n    if (r.cmp(n) >= 0 || s.cmp(n) >= 0) throw new Error('Invalid signature.');\n    return [r, s];\n  }\n\n  _truncate(msg) {\n    // Byte array to integer conversion.\n    //\n    // [SEC1] Step 5, Page 45, Section 4.1.3.\n    // [FIPS186] Page 25, Section B.2.\n    //\n    // The two sources above disagree on this.\n    //\n    // FIPS186 simply modulos the entire byte\n    // array by the order, whereas SEC1 takes\n    // the left-most ceil(log2(n+1)) bits modulo\n    // the order (and maybe does other stuff).\n    //\n    // Instead of trying to decipher all of\n    // this nonsense, we simply replicate the\n    // OpenSSL behavior (which, in actuality,\n    // is more similar to the SEC1 behavior).\n    assert(Buffer.isBuffer(msg));\n    const bits = this.curve.n.bitLength();\n    const bytes = bits + 7 >>> 3;\n    if (msg.length > bytes) msg = msg.slice(0, bytes);\n    const m = BN.decode(msg, this.curve.endian);\n    const d = msg.length * 8 - bits;\n    if (d > 0) m.iushrn(d);\n    return m;\n  }\n\n  _reduce(msg) {\n    return this._truncate(msg).imod(this.curve.n);\n  }\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = ECDSA;","map":null,"metadata":{},"sourceType":"script"}