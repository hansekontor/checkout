{"ast":null,"code":"/*!\n * kmac.js - KMAC implementation for bcrypto\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf\n *   https://github.com/XKCP/XKCP/blob/8f447eb/lib/high/Keccak/SP800-185/SP800-185.inc\n *   https://github.com/XKCP/XKCP/blob/8f447eb/lib/high/Keccak/SP800-185/SP800-185.c\n *   https://github.com/XKCP/XKCP/blob/8f447eb/tests/UnitTests/testSP800-185.c\n *   https://github.com/emn178/js-sha3/blob/master/src/sha3.js\n */\n'use strict';\n\nconst assert = require('./internal/assert');\n\nconst CSHAKE = require('./cshake');\n\nconst HMAC = require('./internal/hmac');\n/*\n * Constants\n */\n\n\nconst PREFIX = Buffer.from('KMAC', 'binary');\nconst EMPTY = Buffer.alloc(0);\n/*\n * KMAC\n */\n\nclass KMAC extends CSHAKE {\n  constructor() {\n    super();\n  }\n\n  init(bits, key, pers) {\n    if (key == null) key = EMPTY;\n    assert(Buffer.isBuffer(key));\n    super.init(bits, PREFIX, pers);\n    super.bytePad([key], this.rate / 8);\n    return this;\n  }\n\n  final(len) {\n    if (len == null) {\n      const size = this.rate / 8;\n      len = 100 - size / 2;\n    }\n\n    super.rightEncode(len * 8);\n    return super.final(len);\n  }\n\n  static hash() {\n    return new KMAC();\n  }\n\n  static hmac(bits, key, pers, len) {\n    if (bits == null) bits = 256;\n    assert(bits >>> 0 === bits);\n    assert(bits === 128 || bits === 256);\n    const rate = 1600 - bits * 2;\n    return new HMAC(KMAC, rate / 8, [bits, key, pers], [len]);\n  }\n\n  static digest(data, bits, key, pers, len) {\n    return KMAC.ctx.init(bits, key, pers).update(data).final(len);\n  }\n\n  static root(left, right, bits, key, pers, len) {\n    if (bits == null) bits = 256;\n    if (len == null) len = 0;\n\n    if (len === 0) {\n      assert(bits >>> 0 === bits);\n      len = bits >>> 3;\n    }\n\n    assert(len >>> 0 === len);\n    assert(Buffer.isBuffer(left) && left.length === len);\n    assert(Buffer.isBuffer(right) && right.length === len);\n    const {\n      ctx\n    } = KMAC;\n    ctx.init(bits, key, pers);\n    ctx.update(left);\n    ctx.update(right);\n    return ctx.final(len);\n  }\n\n  static multi(x, y, z, bits, key, pers, len) {\n    const {\n      ctx\n    } = KMAC;\n    ctx.init(bits, key, pers);\n    ctx.update(x);\n    ctx.update(y);\n    if (z) ctx.update(z);\n    return ctx.final(len);\n  }\n\n  static mac(data, salt, bits, key, pers, len) {\n    return KMAC.hmac(bits, key, pers, len).init(salt).update(data).final();\n  }\n\n}\n/*\n * Static\n */\n\n\nKMAC.native = CSHAKE.native;\nKMAC.id = 'KMAC256';\nKMAC.size = 32;\nKMAC.bits = 256;\nKMAC.blockSize = 136;\nKMAC.zero = Buffer.alloc(32, 0x00);\nKMAC.ctx = new KMAC();\n/*\n * Expose\n */\n\nmodule.exports = KMAC;","map":null,"metadata":{},"sourceType":"script"}