{"ast":null,"code":"/* eslint-disable react-hooks/exhaustive-deps */\nimport { useState, useEffect } from 'react';\nimport useAsyncTimeout from '@hooks/useAsyncTimeout';\nimport usePrevious from '@hooks/usePrevious';\nimport useBCH from '@hooks/useBCH';\nimport BigNumber from 'bignumber.js';\nimport { fromSmallestDenomination, loadStoredWallet, isValidStoredWallet, isLegacyMigrationRequired } from '@utils/cashMethods';\nimport { isValidCashtabSettings } from '@utils/validation';\nimport localforage from 'localforage';\nimport { currency } from '@components/Common/Ticker';\nimport isEqual from 'lodash.isequal';\nimport { xecReceivedNotification, eTokenReceivedNotification } from '@components/Common/Notifications';\nimport cashaddr from 'ecashaddrjs';\n\nconst Mnemonic = require('@utils/bcash/hd/mnemonic');\n\nimport { HDPrivateKey } from '@utils/bcash/hd/private';\nimport { KeyRing } from '@utils/bcash/primitives/keyring';\n\nconst useWallet = () => {\n  const [wallet, setWallet] = useState(false);\n  const [cashtabSettings, setCashtabSettings] = useState(false);\n  const [fiatPrice, setFiatPrice] = useState(null);\n  const [apiError, setApiError] = useState(false);\n  const [checkFiatInterval, setCheckFiatInterval] = useState(null);\n  const {\n    getUtxosBcash,\n    getSlpBalancesAndUtxosBcash,\n    getTxHistoryBcash,\n    parseTxData\n  } = useBCH();\n  const [loading, setLoading] = useState(true);\n  const {\n    balances,\n    tokens,\n    utxos\n  } = isValidStoredWallet(wallet) ? wallet.state : {\n    balances: {},\n    tokens: [],\n    utxos: null\n  };\n  const previousBalances = usePrevious(balances);\n  const previousTokens = usePrevious(tokens);\n\n  const normalizeBalance = slpBalancesAndUtxos => {\n    const totalBalanceInSatoshis = slpBalancesAndUtxos.nonSlpUtxos.reduce((previousBalance, utxo) => previousBalance + utxo.value, 0);\n    return {\n      totalBalanceInSatoshis,\n      totalBalance: fromSmallestDenomination(totalBalanceInSatoshis)\n    };\n  };\n\n  const deriveAccount = async _ref => {\n    let {\n      masterHDNode,\n      path\n    } = _ref;\n    const node = masterHDNode.derivePath(path);\n    const publicKey = node.toPublic().publicKey.toString('hex');\n    const keyring = KeyRing.fromPrivate(node.privateKey);\n    const cashAddress = keyring.getAddress('string');\n    const decodedAddress = cashaddr.decode(cashAddress);\n    const slpAddress = cashaddr.encode('etoken', decodedAddress.type, decodedAddress.hash);\n    return {\n      publicKey,\n      cashAddress,\n      slpAddress,\n      fundingWif: keyring.toSecret(),\n      fundingAddress: slpAddress,\n      legacyAddress: keyring.getAddress('base58')\n    };\n  };\n\n  const loadWalletFromStorageOnStartup = async setWallet => {\n    // get wallet object from localforage\n    const wallet = await getWallet(); // If wallet object in storage is valid, use it to set state on startup\n\n    if (isValidStoredWallet(wallet)) {\n      // Convert all the token balance figures to big numbers\n      const liveWalletState = loadStoredWallet(wallet.state);\n      wallet.state = liveWalletState;\n      setWallet(wallet);\n      return setLoading(false);\n    } // Loading will remain true until API calls populate this legacy wallet\n\n\n    setWallet(wallet);\n  };\n\n  const update = async function (_ref2) {\n    let {\n      wallet\n    } = _ref2;\n    let forceFullUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    // const ms = new Date().getTime();\n    // console.log(`update.${ms}`);\n    // console.time(`update.${ms}`);\n    try {\n      var _wallet$state;\n\n      if (!wallet) {\n        return;\n      }\n\n      const cashAddresses = [wallet.Path245.cashAddress, wallet.Path145.cashAddress, wallet.Path1899.cashAddress];\n      const utxosBcash = await getUtxosBcash(cashAddresses);\n      const utxosHaveChanged = !isEqual(utxosBcash, wallet === null || wallet === void 0 ? void 0 : (_wallet$state = wallet.state) === null || _wallet$state === void 0 ? void 0 : _wallet$state.utxos); // If the utxo set has not changed,\n\n      if (!utxosHaveChanged && !forceFullUpdate) {\n        // remove api error here; otherwise it will remain if recovering from a rate\n        // limit error with an unchanged utxo set\n        setApiError(false); // then wallet.state has not changed and does not need to be updated\n        // console.log(\"wallet state not updated\")\n        // console.timeEnd(`update.${ms}`);\n\n        return;\n      }\n\n      const slpBalancesAndUtxos = await getSlpBalancesAndUtxosBcash(utxosBcash);\n      const txHistory = await getTxHistoryBcash(cashAddresses);\n      const parsedWithTokens = parseTxData(wallet, txHistory);\n\n      if (typeof slpBalancesAndUtxos === 'undefined') {\n        console.log(`slpBalancesAndUtxos is undefined`);\n        throw new Error('slpBalancesAndUtxos is undefined');\n      }\n\n      const {\n        tokens\n      } = slpBalancesAndUtxos;\n      const newState = {\n        balances: {},\n        tokens: [],\n        slpBalancesAndUtxos: []\n      };\n      newState.slpBalancesAndUtxos = slpBalancesAndUtxos;\n      newState.balances = normalizeBalance(slpBalancesAndUtxos);\n      newState.tokens = tokens;\n      newState.parsedTxHistory = parsedWithTokens;\n      newState.utxos = utxosBcash; // Set wallet with new state field\n\n      wallet.state = newState; // console.log('wallet.state', wallet.state);\n\n      setWallet(wallet); // Write this state to indexedDb using localForage\n\n      writeWalletState(wallet, newState); // If everything executed correctly, remove apiError\n\n      setApiError(false);\n    } catch (error) {\n      console.log(`Error in update({wallet})`);\n      console.log(error); // Set this in state so that transactions are disabled until the issue is resolved\n\n      setApiError(true); // console.timeEnd(`update.${ms}`);\n    } // console.log(\"wallet state updated\")\n    // console.timeEnd(`update.${ms}`);\n\n  };\n\n  const getActiveWalletFromLocalForage = async () => {\n    let wallet;\n\n    try {\n      wallet = await localforage.getItem('wallet');\n    } catch (err) {\n      console.log(`Error in getActiveWalletFromLocalForage`, err);\n      wallet = null;\n    }\n\n    return wallet;\n  };\n  /*\n  const getSavedWalletsFromLocalForage = async () => {\n      let savedWallets;\n      try {\n          savedWallets = await localforage.getItem('savedWallets');\n      } catch (err) {\n          console.log(`Error in getSavedWalletsFromLocalForage`, err);\n          savedWallets = null;\n      }\n      return savedWallets;\n  };\n  */\n\n\n  const getWallet = async () => {\n    let wallet;\n    let existingWallet;\n\n    try {\n      existingWallet = await getActiveWalletFromLocalForage(); // existing wallet will be\n      // 1 - the 'wallet' value from localForage, if it exists\n      // 2 - false if it does not exist in localForage\n      // 3 - null if error\n      // If the wallet does not have Path1899, add it\n      // or each Path1899, Path145, Path245 does not have a public key, add them\n\n      if (existingWallet) {\n        if (isLegacyMigrationRequired(existingWallet)) {\n          console.log(`Wallet does not have Path1899 or does not have public key`);\n          existingWallet = await migrateLegacyWallet(existingWallet);\n        }\n      } // If not in localforage then existingWallet = false, check localstorage\n\n\n      if (!existingWallet) {\n        existingWallet = JSON.parse(window.localStorage.getItem('wallet')); // If you find it here, move it to indexedDb\n\n        if (existingWallet !== null) {\n          wallet = await getWalletDetails(existingWallet);\n          await localforage.setItem('wallet', wallet);\n          return wallet;\n        }\n      }\n    } catch (err) {\n      console.log(`Error in getWallet()`, err);\n      /* \n      Error here implies problem interacting with localForage or localStorage API\n      \n      Have not seen this error in testing\n       In this case, you still want to return 'wallet' using the logic below based on \n      the determination of 'existingWallet' from the logic above\n      */\n    }\n\n    if (existingWallet === null || !existingWallet) {\n      wallet = await getWalletDetails(existingWallet);\n      await localforage.setItem('wallet', wallet);\n    } else {\n      wallet = existingWallet;\n    }\n\n    return wallet;\n  };\n\n  const migrateLegacyWallet = async wallet => {\n    const NETWORK = process.env.REACT_APP_NETWORK;\n    const mnemonic = wallet.mnemonic;\n    const masterHDNode = HDPrivateKey.fromPhrase(mnemonic);\n    const Path245 = await deriveAccount({\n      masterHDNode,\n      path: \"m/44'/245'/0'/0/0\"\n    });\n    const Path145 = await deriveAccount({\n      masterHDNode,\n      path: \"m/44'/145'/0'/0/0\"\n    });\n    const Path1899 = await deriveAccount({\n      masterHDNode,\n      path: \"m/44'/1899'/0'/0/0\"\n    });\n    wallet.Path245 = Path245;\n    wallet.Path145 = Path145;\n    wallet.Path1899 = Path1899;\n\n    try {\n      await localforage.setItem('wallet', wallet);\n    } catch (err) {\n      console.log(`Error setting wallet to wallet indexedDb in migrateLegacyWallet()`);\n      console.log(err);\n    }\n\n    return wallet;\n  };\n\n  const writeWalletState = async (wallet, newState) => {\n    // Add new state as an object on the active wallet\n    wallet.state = newState;\n\n    try {\n      await localforage.setItem('wallet', wallet);\n    } catch (err) {\n      console.log(`Error in writeWalletState()`);\n      console.log(err);\n    }\n  };\n\n  const getWalletDetails = async wallet => {\n    if (!wallet) {\n      return false;\n    } // Since this info is in localforage now, only get the var\n\n\n    const NETWORK = process.env.REACT_APP_NETWORK;\n    const mnemonic = wallet.mnemonic;\n    const masterHDNode = HDPrivateKey.fromPhrase(mnemonic);\n    const Path245 = await deriveAccount({\n      masterHDNode,\n      path: \"m/44'/245'/0'/0/0\"\n    });\n    const Path145 = await deriveAccount({\n      masterHDNode,\n      path: \"m/44'/145'/0'/0/0\"\n    });\n    const Path1899 = await deriveAccount({\n      masterHDNode,\n      path: \"m/44'/1899'/0'/0/0\"\n    });\n    let name = Path1899.cashAddress.slice(12, 17); // Only set the name if it does not currently exist\n\n    if (wallet && wallet.name) {\n      name = wallet.name;\n    }\n\n    return {\n      mnemonic: wallet.mnemonic,\n      name,\n      Path245,\n      Path145,\n      Path1899\n    };\n  };\n\n  const getSavedWallets = async activeWallet => {\n    let savedWallets;\n\n    try {\n      savedWallets = await localforage.getItem('savedWallets');\n\n      if (savedWallets === null) {\n        savedWallets = [];\n      }\n    } catch (err) {\n      console.log(`Error in getSavedWallets`);\n      console.log(err);\n      savedWallets = [];\n    } // Even though the active wallet is still stored in savedWallets, don't return it in this function\n\n\n    for (let i = 0; i < savedWallets.length; i += 1) {\n      if (typeof activeWallet !== 'undefined' && activeWallet.name && savedWallets[i].name === activeWallet.name) {\n        savedWallets.splice(i, 1);\n      }\n    }\n\n    return savedWallets;\n  };\n\n  const activateWallet = async walletToActivate => {\n    /*\n    If the user is migrating from old version to this version, make sure to save the activeWallet\n    1 - check savedWallets for the previously active wallet\n    2 - If not there, add it\n    */\n    let currentlyActiveWallet;\n\n    try {\n      currentlyActiveWallet = await localforage.getItem('wallet');\n    } catch (err) {\n      console.log(`Error in localforage.getItem(\"wallet\") in activateWallet()`);\n      return false;\n    } // Get savedwallets\n\n\n    let savedWallets;\n\n    try {\n      savedWallets = await localforage.getItem('savedWallets');\n    } catch (err) {\n      console.log(`Error in localforage.getItem(\"savedWallets\") in activateWallet()`);\n      return false;\n    }\n    /*\n    When a legacy user runs cashtab.com/, their active wallet will be migrated to Path1899 by \n    the getWallet function. getWallet function also makes sure that each Path has a public key\n     Wallets in savedWallets are migrated when they are activated, in this function\n     Two cases to handle\n     1 - currentlyActiveWallet has Path1899, but its stored keyvalue pair in savedWallets does not\n        > Update savedWallets so that Path1899 is added to currentlyActiveWallet\n    \n    2 - walletToActivate does not have Path1899\n        > Update walletToActivate with Path1899 before activation\n     NOTE: since publicKey property is added later,\n    wallet without public key in Path1899 is also considered legacy and required migration.\n    */\n    // Need to handle a similar situation with state\n    // If you find the activeWallet in savedWallets but without state, resave active wallet with state\n    // Note you do not have the Case 2 described above here, as wallet state is added in the update() function of useWallet.js\n    // Also note, since state can be expected to change frequently (unlike path deriv), you will likely save it every time you activate a new wallet\n    // Check savedWallets for currentlyActiveWallet\n\n\n    let walletInSavedWallets = false;\n\n    for (let i = 0; i < savedWallets.length; i += 1) {\n      if (savedWallets[i].name === currentlyActiveWallet.name) {\n        walletInSavedWallets = true; // Check savedWallets for unmigrated currentlyActiveWallet\n\n        if (isLegacyMigrationRequired(savedWallets[i])) {\n          // Case 1, described above\n          savedWallets[i].Path1899 = currentlyActiveWallet.Path1899;\n          savedWallets[i].Path145 = currentlyActiveWallet.Path145;\n          savedWallets[i].Path245 = currentlyActiveWallet.Path245;\n        }\n        /*\n        Update wallet state\n        Note, this makes previous `walletUnmigrated` variable redundant\n        savedWallets[i] should always be updated, since wallet state can be expected to change most of the time\n        */\n\n\n        savedWallets[i].state = currentlyActiveWallet.state;\n      }\n    } // resave savedWallets\n\n\n    try {\n      // Set walletName as the active wallet\n      await localforage.setItem('savedWallets', savedWallets);\n    } catch (err) {\n      console.log(`Error in localforage.setItem(\"savedWallets\") in activateWallet() for unmigrated wallet`);\n    }\n\n    if (!walletInSavedWallets) {\n      console.log(`Wallet is not in saved Wallets, adding`);\n      savedWallets.push(currentlyActiveWallet); // resave savedWallets\n\n      try {\n        // Set walletName as the active wallet\n        await localforage.setItem('savedWallets', savedWallets);\n      } catch (err) {\n        console.log(`Error in localforage.setItem(\"savedWallets\") in activateWallet()`);\n      }\n    } // If wallet does not have Path1899, add it\n    // or each of the Path1899, Path145, Path245 does not have a public key, add them\n    // by calling migrateLagacyWallet()\n\n\n    if (isLegacyMigrationRequired(walletToActivate)) {\n      // Case 2, described above\n      console.log(`Case 2: Wallet to activate does not have Path1899 or does not have public key in each Path`);\n      console.log(`Wallet to activate from SavedWallets does not have Path1899 or does not have public key in each Path`);\n      console.log(`walletToActivate`, walletToActivate);\n      walletToActivate = await migrateLegacyWallet(walletToActivate);\n    } else {\n      // Otherwise activate it as normal\n      // Now that we have verified the last wallet was saved, we can activate the new wallet\n      try {\n        await localforage.setItem('wallet', walletToActivate);\n      } catch (err) {\n        console.log(`Error in localforage.setItem(\"wallet\", walletToActivate) in activateWallet()`);\n        return false;\n      }\n    } // Make sure stored wallet is in correct format to be used as live wallet\n\n\n    if (isValidStoredWallet(walletToActivate)) {\n      // Convert all the token balance figures to big numbers\n      const liveWalletState = loadStoredWallet(walletToActivate.state);\n      walletToActivate.state = liveWalletState;\n    }\n\n    return walletToActivate;\n  };\n\n  const renameWallet = async (oldName, newName) => {\n    // Load savedWallets\n    let savedWallets;\n\n    try {\n      savedWallets = await localforage.getItem('savedWallets');\n    } catch (err) {\n      console.log(`Error in await localforage.getItem(\"savedWallets\") in renameWallet`);\n      console.log(err);\n      return false;\n    } // Verify that no existing wallet has this name\n\n\n    for (let i = 0; i < savedWallets.length; i += 1) {\n      if (savedWallets[i].name === newName) {\n        // return an error\n        return false;\n      }\n    } // change name of desired wallet\n\n\n    for (let i = 0; i < savedWallets.length; i += 1) {\n      if (savedWallets[i].name === oldName) {\n        // Replace the name of this entry with the new name\n        savedWallets[i].name = newName;\n      }\n    } // resave savedWallets\n\n\n    try {\n      // Set walletName as the active wallet\n      await localforage.setItem('savedWallets', savedWallets);\n    } catch (err) {\n      console.log(`Error in localforage.setItem(\"savedWallets\", savedWallets) in renameWallet()`);\n      return false;\n    }\n\n    return true;\n  };\n\n  const deleteWallet = async walletToBeDeleted => {\n    // delete a wallet\n    // returns true if wallet is successfully deleted\n    // otherwise returns false\n    // Load savedWallets\n    let savedWallets;\n\n    try {\n      savedWallets = await localforage.getItem('savedWallets');\n    } catch (err) {\n      console.log(`Error in await localforage.getItem(\"savedWallets\") in deleteWallet`);\n      console.log(err);\n      return false;\n    } // Iterate over to find the wallet to be deleted\n    // Verify that no existing wallet has this name\n\n\n    let walletFoundAndRemoved = false;\n\n    for (let i = 0; i < savedWallets.length; i += 1) {\n      if (savedWallets[i].name === walletToBeDeleted.name) {\n        // Verify it has the same mnemonic too, that's a better UUID\n        if (savedWallets[i].mnemonic === walletToBeDeleted.mnemonic) {\n          // Delete it\n          savedWallets.splice(i, 1);\n          walletFoundAndRemoved = true;\n        }\n      }\n    } // If you don't find the wallet, return false\n\n\n    if (!walletFoundAndRemoved) {\n      return false;\n    } // Resave savedWallets less the deleted wallet\n\n\n    try {\n      // Set walletName as the active wallet\n      await localforage.setItem('savedWallets', savedWallets);\n    } catch (err) {\n      console.log(`Error in localforage.setItem(\"savedWallets\", savedWallets) in deleteWallet()`);\n      return false;\n    }\n\n    return true;\n  };\n\n  const addNewSavedWallet = async importMnemonic => {\n    // Add a new wallet to savedWallets from importMnemonic or just new wallet\n    const lang = 'english'; // create 128 bit BIP39 mnemonic\n\n    const Bip39128BitMnemonic = importMnemonic ? importMnemonic : new Mnemonic({\n      language: lang\n    });\n    const newSavedWallet = await getWalletDetails({\n      mnemonic: Bip39128BitMnemonic.toString()\n    }); // Get saved wallets\n\n    let savedWallets;\n\n    try {\n      savedWallets = await localforage.getItem('savedWallets'); // If this doesn't exist yet, savedWallets === null\n\n      if (savedWallets === null) {\n        savedWallets = [];\n      }\n    } catch (err) {\n      console.log(`Error in savedWallets = await localforage.getItem(\"savedWallets\") in addNewSavedWallet()`);\n      console.log(err);\n      console.log(`savedWallets in error state`, savedWallets);\n    } // If this wallet is from an imported mnemonic, make sure it does not already exist in savedWallets\n\n\n    if (importMnemonic) {\n      for (let i = 0; i < savedWallets.length; i += 1) {\n        // Check for condition \"importing new wallet that is already in savedWallets\"\n        if (savedWallets[i].mnemonic === importMnemonic) {\n          // set this as the active wallet to keep name history\n          console.log(`Error: this wallet already exists in savedWallets`);\n          console.log(`Wallet not being added.`);\n          return false;\n        }\n      }\n    } // add newSavedWallet\n\n\n    savedWallets.push(newSavedWallet); // update savedWallets\n\n    try {\n      await localforage.setItem('savedWallets', savedWallets);\n    } catch (err) {\n      console.log(`Error in localforage.setItem(\"savedWallets\", activeWallet) called in createWallet with ${importMnemonic}`);\n      console.log(`savedWallets`, savedWallets);\n      console.log(err);\n    }\n\n    return true;\n  };\n\n  const createWallet = async importMnemonic => {\n    const lang = 'english'; // create 128 bit BIP39 mnemonic\n\n    const Bip39128BitMnemonic = importMnemonic ? importMnemonic : new Mnemonic({\n      language: lang\n    });\n    const wallet = await getWalletDetails({\n      mnemonic: Bip39128BitMnemonic.toString()\n    });\n\n    try {\n      await localforage.setItem('wallet', wallet);\n    } catch (err) {\n      console.log(`Error setting wallet to wallet indexedDb in createWallet()`);\n      console.log(err);\n    } // Since this function is only called from OnBoarding.js, also add this to the saved wallet\n\n\n    try {\n      await localforage.setItem('savedWallets', [wallet]);\n    } catch (err) {\n      console.log(`Error setting wallet to savedWallets indexedDb in createWallet()`);\n      console.log(err);\n    }\n\n    return wallet;\n  };\n\n  const validateMnemonic = mnemonic => {\n    let mnemonicTestOutput;\n\n    try {\n      mnemonicTestOutput = Mnemonic.fromPhrase(mnemonic);\n\n      if (mnemonicTestOutput.toString() === mnemonic) {\n        return true;\n      } else {\n        return false;\n      }\n    } catch (err) {\n      console.log(err);\n      return false;\n    }\n  };\n\n  const handleUpdateWallet = async setWallet => {\n    await loadWalletFromStorageOnStartup(setWallet);\n  };\n\n  const loadCashtabSettings = async () => {\n    // get settings object from localforage\n    let localSettings;\n\n    try {\n      localSettings = await localforage.getItem('settings'); // If there is no keyvalue pair in localforage with key 'settings'\n\n      if (localSettings === null) {\n        // Create one with the default settings from Ticker.js\n        localforage.setItem('settings', currency.defaultSettings); // Set state to default settings\n\n        setCashtabSettings(currency.defaultSettings);\n        return currency.defaultSettings;\n      }\n    } catch (err) {\n      console.log(`Error getting cashtabSettings`, err); // TODO If they do not exist, write them\n      // TODO add function to change them\n\n      setCashtabSettings(currency.defaultSettings);\n      return currency.defaultSettings;\n    } // If you found an object in localforage at the settings key, make sure it's valid\n\n\n    if (isValidCashtabSettings(localSettings)) {\n      setCashtabSettings(localSettings);\n      return localSettings;\n    } // if not valid, also set cashtabSettings to default\n\n\n    setCashtabSettings(currency.defaultSettings);\n    return currency.defaultSettings;\n  }; // With different currency selections possible, need unique intervals for price checks\n  // Must be able to end them and set new ones with new currencies\n\n\n  const initializeFiatPriceApi = async selectedFiatCurrency => {\n    // Update fiat price and confirm it is set to make sure ap keeps loading state until this is updated\n    await fetchBchPrice(selectedFiatCurrency); // Set interval for updating the price with given currency\n\n    const thisFiatInterval = setInterval(function () {\n      fetchBchPrice(selectedFiatCurrency);\n    }, 60000); // set interval in state\n\n    setCheckFiatInterval(thisFiatInterval);\n  };\n\n  const clearFiatPriceApi = fiatPriceApi => {\n    // Clear fiat price check interval of previously selected currency\n    clearInterval(fiatPriceApi);\n  };\n\n  const changeCashtabSettings = async (key, newValue) => {\n    // Set loading to true as you do not want to display the fiat price of the last currency\n    // loading = true will lock the UI until the fiat price has updated\n    setLoading(true); // Get settings from localforage\n\n    let currentSettings;\n    let newSettings;\n\n    try {\n      currentSettings = await localforage.getItem('settings');\n    } catch (err) {\n      console.log(`Error in changeCashtabSettings`, err); // Set fiat price to null, which disables fiat sends throughout the app\n\n      setFiatPrice(null); // Unlock the UI\n\n      setLoading(false);\n      return;\n    } // Make sure function was called with valid params\n\n\n    if (Object.keys(currentSettings).includes(key) && currency.settingsValidation[key].includes(newValue)) {\n      // Update settings\n      newSettings = currentSettings;\n      newSettings[key] = newValue;\n    } // Set new settings in state so they are available in context throughout the app\n\n\n    setCashtabSettings(newSettings); // If this settings change adjusted the fiat currency, update fiat price\n\n    if (key === 'fiatCurrency') {\n      clearFiatPriceApi(checkFiatInterval);\n      initializeFiatPriceApi(newValue);\n    } // Write new settings in localforage\n\n\n    try {\n      await localforage.setItem('settings', newSettings);\n    } catch (err) {\n      console.log(`Error writing newSettings object to localforage in changeCashtabSettings`, err);\n      console.log(`newSettings`, newSettings); // do nothing. If this happens, the user will see default currency next time they load the app.\n    }\n\n    setLoading(false);\n  }; // Parse for incoming XEC transactions\n\n\n  if (previousBalances && balances && 'totalBalance' in previousBalances && 'totalBalance' in balances && new BigNumber(balances.totalBalance).minus(previousBalances.totalBalance).gt(0)) {\n    xecReceivedNotification(balances, previousBalances, cashtabSettings, fiatPrice);\n  } // Parse for incoming eToken transactions\n\n\n  if (tokens && tokens[0] && tokens[0].balance && previousTokens && previousTokens[0] && previousTokens[0].balance) {\n    // If tokens length is greater than previousTokens length, a new token has been received\n    // Note, a user could receive a new token, AND more of existing tokens in between app updates\n    // In this case, the app will only notify about the new token\n    // TODO better handling for all possible cases to cover this\n    // TODO handle with websockets for better response time, less complicated calc\n    if (tokens.length > previousTokens.length) {\n      // Find the new token\n      const tokenIds = tokens.map(_ref3 => {\n        let {\n          tokenId\n        } = _ref3;\n        return tokenId;\n      });\n      const previousTokenIds = previousTokens.map(_ref4 => {\n        let {\n          tokenId\n        } = _ref4;\n        return tokenId;\n      }); //console.log(`tokenIds`, tokenIds);\n      //console.log(`previousTokenIds`, previousTokenIds);\n      // An array with the new token Id\n\n      const newTokenIdArr = tokenIds.filter(tokenId => !previousTokenIds.includes(tokenId)); // It's possible that 2 new tokens were received\n      // To do, handle this case\n\n      const newTokenId = newTokenIdArr[0]; //console.log(newTokenId);\n      // How much of this tokenId did you get?\n      // would be at\n      // Find where the newTokenId is\n\n      const receivedTokenObjectIndex = tokens.findIndex(x => x.tokenId === newTokenId); // console.log(`receivedTokenObjectIndex`, receivedTokenObjectIndex);\n      // Calculate amount received\n      // console.log(`receivedTokenObject:`, tokens[receivedTokenObjectIndex]);\n\n      const receivedSlpQty = tokens[receivedTokenObjectIndex].balance.div(tokens[receivedTokenObjectIndex].info.decimals ** 10).toString();\n      const receivedSlpTicker = tokens[receivedTokenObjectIndex].info.ticker;\n      const receivedSlpName = tokens[receivedTokenObjectIndex].info.name; //console.log(`receivedSlpQty`, receivedSlpQty);\n      // Notification if you received SLP\n\n      if (receivedSlpQty > 0) {\n        eTokenReceivedNotification(currency, receivedSlpTicker, receivedSlpQty, receivedSlpName);\n      } //\n\n    } else {\n      // If tokens[i].balance > previousTokens[i].balance, a new SLP tx of an existing token has been received\n      // Note that tokens[i].balance is of type BigNumber\n      for (let i = 0; i < tokens.length; i += 1) {\n        if (tokens[i].balance.gt(previousTokens[i].balance)) {\n          // Received this token\n          // console.log(`previousTokenId`, previousTokens[i].tokenId);\n          // console.log(`currentTokenId`, tokens[i].tokenId);\n          if (previousTokens[i].tokenId !== tokens[i].tokenId) {\n            console.log(`TokenIds do not match, breaking from SLP notifications`); // Then don't send the notification\n            // Also don't 'continue' ; this means you have sent a token, just stop iterating through\n\n            break;\n          }\n\n          console.log('tokens[i]', tokens[i]);\n          const receivedSlpQty = tokens[i].balance.minus(previousTokens[i].balance).div(10 ** tokens[i].info.decimals);\n          const receivedSlpTicker = tokens[i].info.ticker;\n          const receivedSlpName = tokens[i].info.name;\n          eTokenReceivedNotification(currency, receivedSlpTicker, receivedSlpQty, receivedSlpName);\n        }\n      }\n    }\n  }\n\n  const forceWalletUpdate = async function () {\n    let forceFullUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    console.log(\"forcing wallet update\");\n    const wallet = await getWallet();\n    update({\n      wallet\n    }, forceFullUpdate).finally(() => {\n      setLoading(false);\n    });\n  }; // Update wallet every 10s\n\n\n  useAsyncTimeout(async () => {\n    const wallet = await getWallet();\n    update({\n      wallet\n    }).finally(() => {\n      setLoading(false);\n    });\n  }, 10000);\n\n  const fetchBchPrice = async function () {\n    let fiatCode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : cashtabSettings ? cashtabSettings.fiatCurrency : 'usd';\n    // Split this variable out in case coingecko changes\n    const cryptoId = currency.coingeckoId; // Keep this in the code, because different URLs will have different outputs require different parsing\n\n    const priceApiUrl = `https://api.coingecko.com/api/v3/simple/price?ids=${cryptoId}&vs_currencies=${fiatCode}&include_last_updated_at=true`;\n    let bchPrice;\n    let bchPriceJson;\n\n    try {\n      bchPrice = await fetch(priceApiUrl); //console.log(`bchPrice`, bchPrice);\n    } catch (err) {\n      console.log(`Error fetching BCH Price`);\n      console.log(err);\n    }\n\n    try {\n      bchPriceJson = await bchPrice.json(); //console.log(`bchPriceJson`, bchPriceJson);\n\n      let bchPriceInFiat = bchPriceJson[cryptoId][fiatCode];\n      const validEcashPrice = typeof bchPriceInFiat === 'number';\n\n      if (validEcashPrice) {\n        setFiatPrice(bchPriceInFiat);\n      } else {\n        // If API price looks fishy, do not allow app to send using fiat settings\n        setFiatPrice(null);\n      }\n    } catch (err) {\n      console.log(`Error parsing price API response to JSON`);\n      console.log(err);\n    }\n  };\n\n  useEffect(async () => {\n    handleUpdateWallet(setWallet);\n    const initialSettings = await loadCashtabSettings();\n    initializeFiatPriceApi(initialSettings.fiatCurrency);\n  }, []);\n  return {\n    wallet,\n    fiatPrice,\n    loading,\n    apiError,\n    cashtabSettings,\n    changeCashtabSettings,\n    getActiveWalletFromLocalForage,\n    forceWalletUpdate,\n    validateMnemonic,\n    getWalletDetails,\n    getSavedWallets,\n    migrateLegacyWallet,\n    createWallet: async importMnemonic => {\n      setLoading(true);\n      const newWallet = await createWallet(importMnemonic);\n      setWallet(newWallet);\n      update({\n        wallet: newWallet\n      }).finally(() => setLoading(false));\n    },\n    activateWallet: async walletToActivate => {\n      setLoading(true);\n      const newWallet = await activateWallet(walletToActivate);\n      setWallet(newWallet);\n\n      if (isValidStoredWallet(walletToActivate)) {\n        // If you have all state parameters needed in storage, immediately load the wallet\n        setLoading(false);\n      } else {\n        // If the wallet is missing state parameters in storage, wait for API info\n        // This handles case of unmigrated legacy wallet\n        update({\n          wallet: newWallet\n        }).finally(() => setLoading(false));\n      }\n    },\n    addNewSavedWallet,\n    renameWallet,\n    deleteWallet\n  };\n};\n\nexport default useWallet;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/hooks/useWallet.js"],"names":["useState","useEffect","useAsyncTimeout","usePrevious","useBCH","BigNumber","fromSmallestDenomination","loadStoredWallet","isValidStoredWallet","isLegacyMigrationRequired","isValidCashtabSettings","localforage","currency","isEqual","xecReceivedNotification","eTokenReceivedNotification","cashaddr","Mnemonic","require","HDPrivateKey","KeyRing","useWallet","wallet","setWallet","cashtabSettings","setCashtabSettings","fiatPrice","setFiatPrice","apiError","setApiError","checkFiatInterval","setCheckFiatInterval","getUtxosBcash","getSlpBalancesAndUtxosBcash","getTxHistoryBcash","parseTxData","loading","setLoading","balances","tokens","utxos","state","previousBalances","previousTokens","normalizeBalance","slpBalancesAndUtxos","totalBalanceInSatoshis","nonSlpUtxos","reduce","previousBalance","utxo","value","totalBalance","deriveAccount","masterHDNode","path","node","derivePath","publicKey","toPublic","toString","keyring","fromPrivate","privateKey","cashAddress","getAddress","decodedAddress","decode","slpAddress","encode","type","hash","fundingWif","toSecret","fundingAddress","legacyAddress","loadWalletFromStorageOnStartup","getWallet","liveWalletState","update","forceFullUpdate","cashAddresses","Path245","Path145","Path1899","utxosBcash","utxosHaveChanged","txHistory","parsedWithTokens","console","log","Error","newState","parsedTxHistory","writeWalletState","error","getActiveWalletFromLocalForage","getItem","err","existingWallet","migrateLegacyWallet","JSON","parse","window","localStorage","getWalletDetails","setItem","NETWORK","process","env","REACT_APP_NETWORK","mnemonic","fromPhrase","name","slice","getSavedWallets","activeWallet","savedWallets","i","length","splice","activateWallet","walletToActivate","currentlyActiveWallet","walletInSavedWallets","push","renameWallet","oldName","newName","deleteWallet","walletToBeDeleted","walletFoundAndRemoved","addNewSavedWallet","importMnemonic","lang","Bip39128BitMnemonic","language","newSavedWallet","createWallet","validateMnemonic","mnemonicTestOutput","handleUpdateWallet","loadCashtabSettings","localSettings","defaultSettings","initializeFiatPriceApi","selectedFiatCurrency","fetchBchPrice","thisFiatInterval","setInterval","clearFiatPriceApi","fiatPriceApi","clearInterval","changeCashtabSettings","key","newValue","currentSettings","newSettings","Object","keys","includes","settingsValidation","minus","gt","balance","tokenIds","map","tokenId","previousTokenIds","newTokenIdArr","filter","newTokenId","receivedTokenObjectIndex","findIndex","x","receivedSlpQty","div","info","decimals","receivedSlpTicker","ticker","receivedSlpName","forceWalletUpdate","finally","fiatCode","fiatCurrency","cryptoId","coingeckoId","priceApiUrl","bchPrice","bchPriceJson","fetch","json","bchPriceInFiat","validEcashPrice","initialSettings","newWallet"],"mappings":"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","sourcesContent":["/* eslint-disable react-hooks/exhaustive-deps */\n\nimport { useState, useEffect } from 'react';\nimport useAsyncTimeout from '@hooks/useAsyncTimeout';\nimport usePrevious from '@hooks/usePrevious';\nimport useBCH from '@hooks/useBCH';\nimport BigNumber from 'bignumber.js';\nimport {\n    fromSmallestDenomination,\n    loadStoredWallet,\n    isValidStoredWallet,\n    isLegacyMigrationRequired,\n} from '@utils/cashMethods';\nimport { isValidCashtabSettings } from '@utils/validation';\nimport localforage from 'localforage';\nimport { currency } from '@components/Common/Ticker';\nimport isEqual from 'lodash.isequal';\nimport {\n    xecReceivedNotification,\n    eTokenReceivedNotification,\n} from '@components/Common/Notifications';\nimport cashaddr from 'ecashaddrjs';\nconst Mnemonic = require('@utils/bcash/hd/mnemonic');\nimport { HDPrivateKey } from '@utils/bcash/hd/private';\nimport { KeyRing } from '@utils/bcash/primitives/keyring';\n\nconst useWallet = () => {\n    const [wallet, setWallet] = useState(false);\n    const [cashtabSettings, setCashtabSettings] = useState(false);\n    const [fiatPrice, setFiatPrice] = useState(null);\n    const [apiError, setApiError] = useState(false);\n    const [checkFiatInterval, setCheckFiatInterval] = useState(null);\n    const {\n        getUtxosBcash,\n        getSlpBalancesAndUtxosBcash,\n        getTxHistoryBcash,\n        parseTxData\n    } = useBCH();\n    const [loading, setLoading] = useState(true);\n    const { balances, tokens, utxos } = isValidStoredWallet(wallet)\n        ? wallet.state\n        : {\n              balances: {},\n              tokens: [],\n              utxos: null,\n          };\n    const previousBalances = usePrevious(balances);\n    const previousTokens = usePrevious(tokens);\n\n    const normalizeBalance = slpBalancesAndUtxos => {\n        const totalBalanceInSatoshis = slpBalancesAndUtxos.nonSlpUtxos.reduce(\n            (previousBalance, utxo) => previousBalance + utxo.value,\n            0,\n        );\n        return {\n            totalBalanceInSatoshis,\n            totalBalance: fromSmallestDenomination(totalBalanceInSatoshis),\n        };\n    };\n\n    const deriveAccount = async ({ masterHDNode, path }) => {\n        const node = masterHDNode.derivePath(path);\n        const publicKey = node.toPublic().publicKey.toString('hex');\n        const keyring = KeyRing.fromPrivate(node.privateKey);\n        const cashAddress = keyring.getAddress('string');\n        const decodedAddress = cashaddr.decode(cashAddress);\n        const slpAddress = cashaddr.encode(\n            'etoken', \n            decodedAddress.type, \n            decodedAddress.hash\n        );\n\n        return {\n            publicKey,\n            cashAddress,\n            slpAddress,\n            fundingWif: keyring.toSecret(),\n            fundingAddress: slpAddress,\n            legacyAddress: keyring.getAddress('base58'),\n        };\n    };\n\n    const loadWalletFromStorageOnStartup = async setWallet => {\n        // get wallet object from localforage\n        const wallet = await getWallet();\n        // If wallet object in storage is valid, use it to set state on startup\n        if (isValidStoredWallet(wallet)) {\n            // Convert all the token balance figures to big numbers\n            const liveWalletState = loadStoredWallet(wallet.state);\n            wallet.state = liveWalletState;\n\n            setWallet(wallet);\n            return setLoading(false);\n        }\n        // Loading will remain true until API calls populate this legacy wallet\n        setWallet(wallet);\n    };\n\n    const update = async ({ wallet }, forceFullUpdate = false) => {\n        // const ms = new Date().getTime();\n        // console.log(`update.${ms}`);\n        // console.time(`update.${ms}`);\n        try {\n            if (!wallet) {\n                return;\n            }\n            const cashAddresses = [\n                wallet.Path245.cashAddress,\n                wallet.Path145.cashAddress,\n                wallet.Path1899.cashAddress,\n            ];\n\n            const utxosBcash = await getUtxosBcash(cashAddresses);\n\n            const utxosHaveChanged = !isEqual(utxosBcash, wallet?.state?.utxos);\n\n            // If the utxo set has not changed,\n            if (!utxosHaveChanged && !forceFullUpdate) {\n                // remove api error here; otherwise it will remain if recovering from a rate\n                // limit error with an unchanged utxo set\n                setApiError(false);\n                // then wallet.state has not changed and does not need to be updated\n                // console.log(\"wallet state not updated\")\n                // console.timeEnd(`update.${ms}`);\n                return;\n            }\n\n            const slpBalancesAndUtxos = await getSlpBalancesAndUtxosBcash(utxosBcash);\n\n            const txHistory = await getTxHistoryBcash(cashAddresses);\n\n            const parsedWithTokens = parseTxData(wallet, txHistory);\n\n            if (typeof slpBalancesAndUtxos === 'undefined') {\n                console.log(`slpBalancesAndUtxos is undefined`);\n                throw new Error('slpBalancesAndUtxos is undefined');\n            }\n            const { tokens } = slpBalancesAndUtxos;\n\n            const newState = {\n                balances: {},\n                tokens: [],\n                slpBalancesAndUtxos: [],\n            };\n\n            newState.slpBalancesAndUtxos = slpBalancesAndUtxos;\n\n            newState.balances = normalizeBalance(slpBalancesAndUtxos);\n\n            newState.tokens = tokens;\n\n            newState.parsedTxHistory = parsedWithTokens;\n\n            newState.utxos = utxosBcash;\n\n            // Set wallet with new state field\n            wallet.state = newState;\n            // console.log('wallet.state', wallet.state);\n            setWallet(wallet);\n\n            // Write this state to indexedDb using localForage\n            writeWalletState(wallet, newState);\n            // If everything executed correctly, remove apiError\n            setApiError(false);\n        } catch (error) {\n            console.log(`Error in update({wallet})`);\n            console.log(error);\n            // Set this in state so that transactions are disabled until the issue is resolved\n            setApiError(true);\n            // console.timeEnd(`update.${ms}`);\n        }\n        // console.log(\"wallet state updated\")\n        // console.timeEnd(`update.${ms}`);\n    };\n\n    const getActiveWalletFromLocalForage = async () => {\n        let wallet;\n        try {\n            wallet = await localforage.getItem('wallet');\n        } catch (err) {\n            console.log(`Error in getActiveWalletFromLocalForage`, err);\n            wallet = null;\n        }\n        return wallet;\n    };\n\n    /*\n    const getSavedWalletsFromLocalForage = async () => {\n        let savedWallets;\n        try {\n            savedWallets = await localforage.getItem('savedWallets');\n        } catch (err) {\n            console.log(`Error in getSavedWalletsFromLocalForage`, err);\n            savedWallets = null;\n        }\n        return savedWallets;\n    };\n    */\n\n    const getWallet = async () => {\n        let wallet;\n        let existingWallet;\n        try {\n            existingWallet = await getActiveWalletFromLocalForage();\n            // existing wallet will be\n            // 1 - the 'wallet' value from localForage, if it exists\n            // 2 - false if it does not exist in localForage\n            // 3 - null if error\n\n            // If the wallet does not have Path1899, add it\n            // or each Path1899, Path145, Path245 does not have a public key, add them\n            if (existingWallet) {\n                if (isLegacyMigrationRequired(existingWallet)) {\n                    console.log(\n                        `Wallet does not have Path1899 or does not have public key`,\n                    );\n                    existingWallet = await migrateLegacyWallet(\n                        existingWallet,\n                    );\n                }\n            }\n\n            // If not in localforage then existingWallet = false, check localstorage\n            if (!existingWallet) {\n                existingWallet = JSON.parse(\n                    window.localStorage.getItem('wallet'),\n                );\n                // If you find it here, move it to indexedDb\n                if (existingWallet !== null) {\n                    wallet = await getWalletDetails(existingWallet);\n                    await localforage.setItem('wallet', wallet);\n                    return wallet;\n                }\n            }\n        } catch (err) {\n            console.log(`Error in getWallet()`, err);\n            /* \n            Error here implies problem interacting with localForage or localStorage API\n            \n            Have not seen this error in testing\n\n            In this case, you still want to return 'wallet' using the logic below based on \n            the determination of 'existingWallet' from the logic above\n            */\n        }\n\n        if (existingWallet === null || !existingWallet) {\n            wallet = await getWalletDetails(existingWallet);\n            await localforage.setItem('wallet', wallet);\n        } else {\n            wallet = existingWallet;\n        }\n        return wallet;\n    };\n\n    const migrateLegacyWallet = async (wallet) => {\n        const NETWORK = process.env.REACT_APP_NETWORK;\n        const mnemonic = wallet.mnemonic;\n        const masterHDNode = HDPrivateKey.fromPhrase(mnemonic);\n\n        const Path245 = await deriveAccount({\n            masterHDNode,\n            path: \"m/44'/245'/0'/0/0\",\n        });\n        const Path145 = await deriveAccount({\n            masterHDNode,\n            path: \"m/44'/145'/0'/0/0\",\n        });\n        const Path1899 = await deriveAccount({\n            masterHDNode,\n            path: \"m/44'/1899'/0'/0/0\",\n        });\n\n        wallet.Path245 = Path245;\n        wallet.Path145 = Path145;\n        wallet.Path1899 = Path1899;\n\n        try {\n            await localforage.setItem('wallet', wallet);\n        } catch (err) {\n            console.log(\n                `Error setting wallet to wallet indexedDb in migrateLegacyWallet()`,\n            );\n            console.log(err);\n        }\n\n        return wallet;\n    };\n\n    const writeWalletState = async (wallet, newState) => {\n        // Add new state as an object on the active wallet\n        wallet.state = newState;\n        try {\n            await localforage.setItem('wallet', wallet);\n        } catch (err) {\n            console.log(`Error in writeWalletState()`);\n            console.log(err);\n        }\n    };\n\n    const getWalletDetails = async wallet => {\n        if (!wallet) {\n            return false;\n        }\n        // Since this info is in localforage now, only get the var\n        const NETWORK = process.env.REACT_APP_NETWORK;\n        const mnemonic = wallet.mnemonic;\n        const masterHDNode = HDPrivateKey.fromPhrase(mnemonic);\n\n        const Path245 = await deriveAccount({\n            masterHDNode,\n            path: \"m/44'/245'/0'/0/0\",\n        });\n        const Path145 = await deriveAccount({\n            masterHDNode,\n            path: \"m/44'/145'/0'/0/0\",\n        });\n        const Path1899 = await deriveAccount({\n            masterHDNode,\n            path: \"m/44'/1899'/0'/0/0\",\n        });\n\n        let name = Path1899.cashAddress.slice(12, 17);\n        // Only set the name if it does not currently exist\n        if (wallet && wallet.name) {\n            name = wallet.name;\n        }\n\n        return {\n            mnemonic: wallet.mnemonic,\n            name,\n            Path245,\n            Path145,\n            Path1899,\n        };\n    };\n\n    const getSavedWallets = async activeWallet => {\n        let savedWallets;\n        try {\n            savedWallets = await localforage.getItem('savedWallets');\n            if (savedWallets === null) {\n                savedWallets = [];\n            }\n        } catch (err) {\n            console.log(`Error in getSavedWallets`);\n            console.log(err);\n            savedWallets = [];\n        }\n        // Even though the active wallet is still stored in savedWallets, don't return it in this function\n        for (let i = 0; i < savedWallets.length; i += 1) {\n            if (\n                typeof activeWallet !== 'undefined' &&\n                activeWallet.name &&\n                savedWallets[i].name === activeWallet.name\n            ) {\n                savedWallets.splice(i, 1);\n            }\n        }\n        return savedWallets;\n    };\n\n    const activateWallet = async walletToActivate => {\n        /*\n    If the user is migrating from old version to this version, make sure to save the activeWallet\n\n    1 - check savedWallets for the previously active wallet\n    2 - If not there, add it\n    */\n        let currentlyActiveWallet;\n        try {\n            currentlyActiveWallet = await localforage.getItem('wallet');\n        } catch (err) {\n            console.log(\n                `Error in localforage.getItem(\"wallet\") in activateWallet()`,\n            );\n            return false;\n        }\n        // Get savedwallets\n        let savedWallets;\n        try {\n            savedWallets = await localforage.getItem('savedWallets');\n        } catch (err) {\n            console.log(\n                `Error in localforage.getItem(\"savedWallets\") in activateWallet()`,\n            );\n            return false;\n        }\n        /*\n        When a legacy user runs cashtab.com/, their active wallet will be migrated to Path1899 by \n        the getWallet function. getWallet function also makes sure that each Path has a public key\n\n        Wallets in savedWallets are migrated when they are activated, in this function\n\n        Two cases to handle\n\n        1 - currentlyActiveWallet has Path1899, but its stored keyvalue pair in savedWallets does not\n            > Update savedWallets so that Path1899 is added to currentlyActiveWallet\n        \n        2 - walletToActivate does not have Path1899\n            > Update walletToActivate with Path1899 before activation\n\n        NOTE: since publicKey property is added later,\n        wallet without public key in Path1899 is also considered legacy and required migration.\n        */\n\n        // Need to handle a similar situation with state\n        // If you find the activeWallet in savedWallets but without state, resave active wallet with state\n        // Note you do not have the Case 2 described above here, as wallet state is added in the update() function of useWallet.js\n        // Also note, since state can be expected to change frequently (unlike path deriv), you will likely save it every time you activate a new wallet\n        // Check savedWallets for currentlyActiveWallet\n        let walletInSavedWallets = false;\n        for (let i = 0; i < savedWallets.length; i += 1) {\n            if (savedWallets[i].name === currentlyActiveWallet.name) {\n                walletInSavedWallets = true;\n                // Check savedWallets for unmigrated currentlyActiveWallet\n                if (isLegacyMigrationRequired(savedWallets[i])) {\n                    // Case 1, described above\n                    savedWallets[i].Path1899 = currentlyActiveWallet.Path1899;\n                    savedWallets[i].Path145 = currentlyActiveWallet.Path145;\n                    savedWallets[i].Path245 = currentlyActiveWallet.Path245;\n                }\n\n                /*\n                Update wallet state\n                Note, this makes previous `walletUnmigrated` variable redundant\n                savedWallets[i] should always be updated, since wallet state can be expected to change most of the time\n                */\n                savedWallets[i].state = currentlyActiveWallet.state;\n            }\n        }\n\n        // resave savedWallets\n        try {\n            // Set walletName as the active wallet\n            await localforage.setItem('savedWallets', savedWallets);\n        } catch (err) {\n            console.log(\n                `Error in localforage.setItem(\"savedWallets\") in activateWallet() for unmigrated wallet`,\n            );\n        }\n\n        if (!walletInSavedWallets) {\n            console.log(`Wallet is not in saved Wallets, adding`);\n            savedWallets.push(currentlyActiveWallet);\n            // resave savedWallets\n            try {\n                // Set walletName as the active wallet\n                await localforage.setItem('savedWallets', savedWallets);\n            } catch (err) {\n                console.log(\n                    `Error in localforage.setItem(\"savedWallets\") in activateWallet()`,\n                );\n            }\n        }\n        // If wallet does not have Path1899, add it\n        // or each of the Path1899, Path145, Path245 does not have a public key, add them\n        // by calling migrateLagacyWallet()\n        if (isLegacyMigrationRequired(walletToActivate)) {\n            // Case 2, described above\n            console.log(\n                `Case 2: Wallet to activate does not have Path1899 or does not have public key in each Path`,\n            );\n            console.log(\n                `Wallet to activate from SavedWallets does not have Path1899 or does not have public key in each Path`,\n            );\n            console.log(`walletToActivate`, walletToActivate);\n            walletToActivate = await migrateLegacyWallet(walletToActivate);\n        } else {\n            // Otherwise activate it as normal\n            // Now that we have verified the last wallet was saved, we can activate the new wallet\n            try {\n                await localforage.setItem('wallet', walletToActivate);\n            } catch (err) {\n                console.log(\n                    `Error in localforage.setItem(\"wallet\", walletToActivate) in activateWallet()`,\n                );\n                return false;\n            }\n        }\n        // Make sure stored wallet is in correct format to be used as live wallet\n        if (isValidStoredWallet(walletToActivate)) {\n            // Convert all the token balance figures to big numbers\n            const liveWalletState = loadStoredWallet(walletToActivate.state);\n            walletToActivate.state = liveWalletState;\n        }\n\n        return walletToActivate;\n    };\n\n    const renameWallet = async (oldName, newName) => {\n        // Load savedWallets\n        let savedWallets;\n        try {\n            savedWallets = await localforage.getItem('savedWallets');\n        } catch (err) {\n            console.log(\n                `Error in await localforage.getItem(\"savedWallets\") in renameWallet`,\n            );\n            console.log(err);\n            return false;\n        }\n        // Verify that no existing wallet has this name\n        for (let i = 0; i < savedWallets.length; i += 1) {\n            if (savedWallets[i].name === newName) {\n                // return an error\n                return false;\n            }\n        }\n\n        // change name of desired wallet\n        for (let i = 0; i < savedWallets.length; i += 1) {\n            if (savedWallets[i].name === oldName) {\n                // Replace the name of this entry with the new name\n                savedWallets[i].name = newName;\n            }\n        }\n        // resave savedWallets\n        try {\n            // Set walletName as the active wallet\n            await localforage.setItem('savedWallets', savedWallets);\n        } catch (err) {\n            console.log(\n                `Error in localforage.setItem(\"savedWallets\", savedWallets) in renameWallet()`,\n            );\n            return false;\n        }\n        return true;\n    };\n\n    const deleteWallet = async walletToBeDeleted => {\n        // delete a wallet\n        // returns true if wallet is successfully deleted\n        // otherwise returns false\n        // Load savedWallets\n        let savedWallets;\n        try {\n            savedWallets = await localforage.getItem('savedWallets');\n        } catch (err) {\n            console.log(\n                `Error in await localforage.getItem(\"savedWallets\") in deleteWallet`,\n            );\n            console.log(err);\n            return false;\n        }\n        // Iterate over to find the wallet to be deleted\n        // Verify that no existing wallet has this name\n        let walletFoundAndRemoved = false;\n        for (let i = 0; i < savedWallets.length; i += 1) {\n            if (savedWallets[i].name === walletToBeDeleted.name) {\n                // Verify it has the same mnemonic too, that's a better UUID\n                if (savedWallets[i].mnemonic === walletToBeDeleted.mnemonic) {\n                    // Delete it\n                    savedWallets.splice(i, 1);\n                    walletFoundAndRemoved = true;\n                }\n            }\n        }\n        // If you don't find the wallet, return false\n        if (!walletFoundAndRemoved) {\n            return false;\n        }\n\n        // Resave savedWallets less the deleted wallet\n        try {\n            // Set walletName as the active wallet\n            await localforage.setItem('savedWallets', savedWallets);\n        } catch (err) {\n            console.log(\n                `Error in localforage.setItem(\"savedWallets\", savedWallets) in deleteWallet()`,\n            );\n            return false;\n        }\n        return true;\n    };\n\n    const addNewSavedWallet = async importMnemonic => {\n        // Add a new wallet to savedWallets from importMnemonic or just new wallet\n        const lang = 'english';\n        // create 128 bit BIP39 mnemonic\n        const Bip39128BitMnemonic = importMnemonic\n            ? importMnemonic\n            : new Mnemonic( {language:lang} );\n        const newSavedWallet = await getWalletDetails({\n            mnemonic: Bip39128BitMnemonic.toString(),\n        });\n        // Get saved wallets\n        let savedWallets;\n        try {\n            savedWallets = await localforage.getItem('savedWallets');\n            // If this doesn't exist yet, savedWallets === null\n            if (savedWallets === null) {\n                savedWallets = [];\n            }\n        } catch (err) {\n            console.log(\n                `Error in savedWallets = await localforage.getItem(\"savedWallets\") in addNewSavedWallet()`,\n            );\n            console.log(err);\n            console.log(`savedWallets in error state`, savedWallets);\n        }\n        // If this wallet is from an imported mnemonic, make sure it does not already exist in savedWallets\n        if (importMnemonic) {\n            for (let i = 0; i < savedWallets.length; i += 1) {\n                // Check for condition \"importing new wallet that is already in savedWallets\"\n                if (savedWallets[i].mnemonic === importMnemonic) {\n                    // set this as the active wallet to keep name history\n                    console.log(\n                        `Error: this wallet already exists in savedWallets`,\n                    );\n                    console.log(`Wallet not being added.`);\n                    return false;\n                }\n            }\n        }\n        // add newSavedWallet\n        savedWallets.push(newSavedWallet);\n        // update savedWallets\n        try {\n            await localforage.setItem('savedWallets', savedWallets);\n        } catch (err) {\n            console.log(\n                `Error in localforage.setItem(\"savedWallets\", activeWallet) called in createWallet with ${importMnemonic}`,\n            );\n            console.log(`savedWallets`, savedWallets);\n            console.log(err);\n        }\n        return true;\n    };\n\n    const createWallet = async importMnemonic => {\n        const lang = 'english';\n        // create 128 bit BIP39 mnemonic\n        const Bip39128BitMnemonic = importMnemonic\n            ? importMnemonic\n            : new Mnemonic( {language:lang} );\n        const wallet = await getWalletDetails({\n            mnemonic: Bip39128BitMnemonic.toString(),\n        });\n\n        try {\n            await localforage.setItem('wallet', wallet);\n        } catch (err) {\n            console.log(\n                `Error setting wallet to wallet indexedDb in createWallet()`,\n            );\n            console.log(err);\n        }\n        // Since this function is only called from OnBoarding.js, also add this to the saved wallet\n        try {\n            await localforage.setItem('savedWallets', [wallet]);\n        } catch (err) {\n            console.log(\n                `Error setting wallet to savedWallets indexedDb in createWallet()`,\n            );\n            console.log(err);\n        }\n        return wallet;\n    };\n\n    const validateMnemonic = (mnemonic) => {\n        let mnemonicTestOutput;\n\n        try {\n            mnemonicTestOutput = Mnemonic.fromPhrase(mnemonic);\n\n            if (mnemonicTestOutput.toString() === mnemonic) {\n                return true;\n            } else {\n                return false;\n            }\n        } catch (err) {\n            console.log(err);\n            return false;\n        }\n    };\n\n    const handleUpdateWallet = async setWallet => {\n        await loadWalletFromStorageOnStartup(setWallet);\n    };\n\n    const loadCashtabSettings = async () => {\n        // get settings object from localforage\n        let localSettings;\n        try {\n            localSettings = await localforage.getItem('settings');\n            // If there is no keyvalue pair in localforage with key 'settings'\n            if (localSettings === null) {\n                // Create one with the default settings from Ticker.js\n                localforage.setItem('settings', currency.defaultSettings);\n                // Set state to default settings\n                setCashtabSettings(currency.defaultSettings);\n                return currency.defaultSettings;\n            }\n        } catch (err) {\n            console.log(`Error getting cashtabSettings`, err);\n            // TODO If they do not exist, write them\n            // TODO add function to change them\n            setCashtabSettings(currency.defaultSettings);\n            return currency.defaultSettings;\n        }\n        // If you found an object in localforage at the settings key, make sure it's valid\n        if (isValidCashtabSettings(localSettings)) {\n            setCashtabSettings(localSettings);\n            return localSettings;\n        }\n        // if not valid, also set cashtabSettings to default\n        setCashtabSettings(currency.defaultSettings);\n        return currency.defaultSettings;\n    };\n\n    // With different currency selections possible, need unique intervals for price checks\n    // Must be able to end them and set new ones with new currencies\n    const initializeFiatPriceApi = async selectedFiatCurrency => {\n        // Update fiat price and confirm it is set to make sure ap keeps loading state until this is updated\n        await fetchBchPrice(selectedFiatCurrency);\n        // Set interval for updating the price with given currency\n\n        const thisFiatInterval = setInterval(function () {\n            fetchBchPrice(selectedFiatCurrency);\n        }, 60000);\n\n        // set interval in state\n        setCheckFiatInterval(thisFiatInterval);\n    };\n\n    const clearFiatPriceApi = fiatPriceApi => {\n        // Clear fiat price check interval of previously selected currency\n        clearInterval(fiatPriceApi);\n    };\n\n    const changeCashtabSettings = async (key, newValue) => {\n        // Set loading to true as you do not want to display the fiat price of the last currency\n        // loading = true will lock the UI until the fiat price has updated\n        setLoading(true);\n        // Get settings from localforage\n        let currentSettings;\n        let newSettings;\n        try {\n            currentSettings = await localforage.getItem('settings');\n        } catch (err) {\n            console.log(`Error in changeCashtabSettings`, err);\n            // Set fiat price to null, which disables fiat sends throughout the app\n            setFiatPrice(null);\n            // Unlock the UI\n            setLoading(false);\n            return;\n        }\n        // Make sure function was called with valid params\n        if (\n            Object.keys(currentSettings).includes(key) &&\n            currency.settingsValidation[key].includes(newValue)\n        ) {\n            // Update settings\n            newSettings = currentSettings;\n            newSettings[key] = newValue;\n        }\n        // Set new settings in state so they are available in context throughout the app\n        setCashtabSettings(newSettings);\n        // If this settings change adjusted the fiat currency, update fiat price\n        if (key === 'fiatCurrency') {\n            clearFiatPriceApi(checkFiatInterval);\n            initializeFiatPriceApi(newValue);\n        }\n        // Write new settings in localforage\n        try {\n            await localforage.setItem('settings', newSettings);\n        } catch (err) {\n            console.log(\n                `Error writing newSettings object to localforage in changeCashtabSettings`,\n                err,\n            );\n            console.log(`newSettings`, newSettings);\n            // do nothing. If this happens, the user will see default currency next time they load the app.\n        }\n        setLoading(false);\n    };\n\n    // Parse for incoming XEC transactions\n    if (\n        previousBalances &&\n        balances &&\n        'totalBalance' in previousBalances &&\n        'totalBalance' in balances &&\n        new BigNumber(balances.totalBalance)\n            .minus(previousBalances.totalBalance)\n            .gt(0)\n    ) {\n        xecReceivedNotification(\n            balances,\n            previousBalances,\n            cashtabSettings,\n            fiatPrice,\n        );\n    }\n\n    // Parse for incoming eToken transactions\n    if (\n        tokens &&\n        tokens[0] &&\n        tokens[0].balance &&\n        previousTokens &&\n        previousTokens[0] &&\n        previousTokens[0].balance\n    ) {\n        // If tokens length is greater than previousTokens length, a new token has been received\n        // Note, a user could receive a new token, AND more of existing tokens in between app updates\n        // In this case, the app will only notify about the new token\n        // TODO better handling for all possible cases to cover this\n        // TODO handle with websockets for better response time, less complicated calc\n        if (tokens.length > previousTokens.length) {\n            // Find the new token\n            const tokenIds = tokens.map(({ tokenId }) => tokenId);\n            const previousTokenIds = previousTokens.map(\n                ({ tokenId }) => tokenId,\n            );\n            //console.log(`tokenIds`, tokenIds);\n            //console.log(`previousTokenIds`, previousTokenIds);\n\n            // An array with the new token Id\n            const newTokenIdArr = tokenIds.filter(\n                tokenId => !previousTokenIds.includes(tokenId),\n            );\n            // It's possible that 2 new tokens were received\n            // To do, handle this case\n            const newTokenId = newTokenIdArr[0];\n            //console.log(newTokenId);\n\n            // How much of this tokenId did you get?\n            // would be at\n\n            // Find where the newTokenId is\n            const receivedTokenObjectIndex = tokens.findIndex(\n                x => x.tokenId === newTokenId,\n            );\n            // console.log(`receivedTokenObjectIndex`, receivedTokenObjectIndex);\n            // Calculate amount received\n            // console.log(`receivedTokenObject:`, tokens[receivedTokenObjectIndex]);\n\n            const receivedSlpQty =\n                tokens[receivedTokenObjectIndex].balance\n                .div(tokens[receivedTokenObjectIndex].info.decimals ** 10)\n                .toString();\n            const receivedSlpTicker =\n                tokens[receivedTokenObjectIndex].info.ticker;\n            const receivedSlpName =\n                tokens[receivedTokenObjectIndex].info.name;\n            //console.log(`receivedSlpQty`, receivedSlpQty);\n\n            // Notification if you received SLP\n            if (receivedSlpQty > 0) {\n                eTokenReceivedNotification(\n                    currency,\n                    receivedSlpTicker,\n                    receivedSlpQty,\n                    receivedSlpName,\n                );\n            }\n            //\n        } else {\n            // If tokens[i].balance > previousTokens[i].balance, a new SLP tx of an existing token has been received\n            // Note that tokens[i].balance is of type BigNumber\n            for (let i = 0; i < tokens.length; i += 1) {\n                if (tokens[i].balance.gt(previousTokens[i].balance)) {\n                    // Received this token\n                    // console.log(`previousTokenId`, previousTokens[i].tokenId);\n                    // console.log(`currentTokenId`, tokens[i].tokenId);\n\n                    if (previousTokens[i].tokenId !== tokens[i].tokenId) {\n                        console.log(\n                            `TokenIds do not match, breaking from SLP notifications`,\n                        );\n                        // Then don't send the notification\n                        // Also don't 'continue' ; this means you have sent a token, just stop iterating through\n                        break;\n                    }\n                    console.log('tokens[i]', tokens[i]);\n                    const receivedSlpQty = tokens[i].balance.minus(\n                        previousTokens[i].balance,\n                    ).div(10 ** tokens[i].info.decimals);\n\n                    const receivedSlpTicker = tokens[i].info.ticker;\n                    const receivedSlpName = tokens[i].info.name;\n\n                    eTokenReceivedNotification(\n                        currency,\n                        receivedSlpTicker,\n                        receivedSlpQty,\n                        receivedSlpName,\n                    );\n                }\n            }\n        }\n    }\n\n    const forceWalletUpdate = async (forceFullUpdate = false) => {\n        console.log(\"forcing wallet update\");\n        const wallet = await getWallet();\n        update({\n            wallet,\n        }, forceFullUpdate).finally(() => {\n            setLoading(false);\n        });\n    }\n\n    // Update wallet every 10s\n    useAsyncTimeout(async () => {\n        const wallet = await getWallet();\n        update({\n            wallet,\n        }).finally(() => {\n            setLoading(false);\n        });\n    }, 10000);\n\n    const fetchBchPrice = async (\n        fiatCode = cashtabSettings ? cashtabSettings.fiatCurrency : 'usd',\n    ) => {\n        // Split this variable out in case coingecko changes\n        const cryptoId = currency.coingeckoId;\n        // Keep this in the code, because different URLs will have different outputs require different parsing\n        const priceApiUrl = `https://api.coingecko.com/api/v3/simple/price?ids=${cryptoId}&vs_currencies=${fiatCode}&include_last_updated_at=true`;\n        let bchPrice;\n        let bchPriceJson;\n        try {\n            bchPrice = await fetch(priceApiUrl);\n            //console.log(`bchPrice`, bchPrice);\n        } catch (err) {\n            console.log(`Error fetching BCH Price`);\n            console.log(err);\n        }\n        try {\n            bchPriceJson = await bchPrice.json();\n            //console.log(`bchPriceJson`, bchPriceJson);\n            let bchPriceInFiat = bchPriceJson[cryptoId][fiatCode];\n\n            const validEcashPrice = typeof bchPriceInFiat === 'number';\n\n            if (validEcashPrice) {\n                setFiatPrice(bchPriceInFiat);\n            } else {\n                // If API price looks fishy, do not allow app to send using fiat settings\n                setFiatPrice(null);\n            }\n        } catch (err) {\n            console.log(`Error parsing price API response to JSON`);\n            console.log(err);\n        }\n    };\n\n    useEffect(async () => {\n        handleUpdateWallet(setWallet);\n        const initialSettings = await loadCashtabSettings();\n        initializeFiatPriceApi(initialSettings.fiatCurrency);\n    }, []);\n\n    return {\n        wallet,\n        fiatPrice,\n        loading,\n        apiError,\n        cashtabSettings,\n        changeCashtabSettings,\n        getActiveWalletFromLocalForage,\n        forceWalletUpdate,\n        validateMnemonic,\n        getWalletDetails,\n        getSavedWallets,\n        migrateLegacyWallet,\n        createWallet: async importMnemonic => {\n            setLoading(true);\n            const newWallet = await createWallet(importMnemonic);\n            setWallet(newWallet);\n            update({\n                wallet: newWallet,\n            }).finally(() => setLoading(false));\n        },\n        activateWallet: async walletToActivate => {\n            setLoading(true);\n            const newWallet = await activateWallet(walletToActivate);\n            setWallet(newWallet);\n            if (isValidStoredWallet(walletToActivate)) {\n                // If you have all state parameters needed in storage, immediately load the wallet\n                setLoading(false);\n            } else {\n                // If the wallet is missing state parameters in storage, wait for API info\n                // This handles case of unmigrated legacy wallet\n                update({\n                    wallet: newWallet,\n                }).finally(() => setLoading(false));\n            }\n        },\n        addNewSavedWallet,\n        renameWallet,\n        deleteWallet,\n    };\n};\n\nexport default useWallet;\n"]},"metadata":{},"sourceType":"module"}