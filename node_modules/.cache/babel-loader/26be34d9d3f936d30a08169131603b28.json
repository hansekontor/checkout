{"ast":null,"code":"/*!\n * mnemonic.js - hd mnemonics for bcoin\n * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bio = require('bufio');\n\nconst sha256 = require('bcrypto/lib/sha256');\n\nconst cleanse = require('bcrypto/lib/cleanse');\n\nconst random = require('bcrypto/lib/random');\n\nconst pbkdf2 = require('bcrypto/lib/pbkdf2');\n\nconst sha512 = require('bcrypto/lib/sha512');\n\nconst wordlist = require('./wordlist');\n\nconst common = require('./common');\n\nconst nfkd = require('./nfkd');\n\nconst {\n  inspectSymbol\n} = require('../utils');\n/*\n * Constants\n */\n\n\nconst wordlistCache = Object.create(null);\n/**\n * HD Mnemonic\n * @alias module:hd.Mnemonic\n */\n\nclass Mnemonic {\n  /**\n   * Create a mnemonic.\n   * @constructor\n   * @param {Object} options\n   * @param {Number?} options.bit - Bits of entropy (Must\n   * be a multiple of 8) (default=128).\n   * @param {Buffer?} options.entropy - Entropy bytes. Will\n   * be generated with `options.bits` bits of entropy\n   * if not present.\n   * @param {String?} options.phrase - Mnemonic phrase (will\n   * be generated if not present).\n   * @param {String?} options.language - Language.\n   */\n  constructor(options) {\n    this.bits = common.MIN_ENTROPY;\n    this.language = 'english';\n    this.entropy = null;\n    this.phrase = null;\n    if (options) this.fromOptions(options);\n  }\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n\n  fromOptions(options) {\n    if (typeof options === 'string') options = {\n      phrase: options\n    };\n\n    if (options.bits != null) {\n      assert((options.bits & 0xffff) === options.bits);\n      assert(options.bits >= common.MIN_ENTROPY);\n      assert(options.bits <= common.MAX_ENTROPY);\n      assert(options.bits % 32 === 0);\n      this.bits = options.bits;\n    }\n\n    if (options.language) {\n      assert(typeof options.language === 'string');\n      assert(Mnemonic.languages.indexOf(options.language) !== -1);\n      this.language = options.language;\n    }\n\n    if (options.phrase) {\n      this.fromPhrase(options.phrase);\n      return this;\n    }\n\n    if (options.entropy) {\n      this.fromEntropy(options.entropy);\n      return this;\n    }\n\n    return this;\n  }\n  /**\n   * Instantiate mnemonic from options.\n   * @param {Object} options\n   * @returns {Mnemonic}\n   */\n\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n  /**\n   * Destroy the mnemonic (zeroes entropy).\n   */\n\n\n  destroy() {\n    this.bits = common.MIN_ENTROPY;\n    this.language = 'english';\n\n    if (this.entropy) {\n      cleanse(this.entropy);\n      this.entropy = null;\n    }\n\n    this.phrase = null;\n  }\n  /**\n   * Generate the seed.\n   * @param {String?} passphrase\n   * @returns {Buffer} pbkdf2 seed.\n   */\n\n\n  toSeed(passphrase) {\n    if (!passphrase) passphrase = '';\n    const phrase = nfkd(this.getPhrase());\n    const passwd = nfkd(`mnemonic${passphrase}`);\n    return pbkdf2.derive(sha512, Buffer.from(phrase, 'utf8'), Buffer.from(passwd, 'utf8'), 2048, 64);\n  }\n  /**\n   * Get or generate entropy.\n   * @returns {Buffer}\n   */\n\n\n  getEntropy() {\n    if (!this.entropy) this.entropy = random.randomBytes(this.bits / 8);\n    assert(this.bits / 8 === this.entropy.length);\n    return this.entropy;\n  }\n  /**\n   * Generate a mnemonic phrase from chosen language.\n   * @returns {String}\n   */\n\n\n  getPhrase() {\n    if (this.phrase) return this.phrase; // Include the first `ENT / 32` bits\n    // of the hash (the checksum).\n\n    const wbits = this.bits + this.bits / 32; // Get entropy and checksum.\n\n    const entropy = this.getEntropy();\n    const chk = sha256.digest(entropy); // Append the hash to the entropy to\n    // make things easy when grabbing\n    // the checksum bits.\n\n    const size = Math.ceil(wbits / 8);\n    const data = Buffer.allocUnsafe(size);\n    entropy.copy(data, 0);\n    chk.copy(data, entropy.length); // Build the mnemonic by reading\n    // 11 bit indexes from the entropy.\n\n    const list = Mnemonic.getWordlist(this.language);\n    let phrase = [];\n\n    for (let i = 0; i < wbits / 11; i++) {\n      let index = 0;\n\n      for (let j = 0; j < 11; j++) {\n        const pos = i * 11 + j;\n        const bit = pos % 8;\n        const oct = (pos - bit) / 8;\n        index <<= 1;\n        index |= data[oct] >>> 7 - bit & 1;\n      }\n\n      phrase.push(list.words[index]);\n    } // Japanese likes double-width spaces.\n\n\n    if (this.language === 'japanese') phrase = phrase.join('\\u3000');else phrase = phrase.join(' ');\n    this.phrase = phrase;\n    return phrase;\n  }\n  /**\n   * Inject properties from phrase.\n   * @private\n   * @param {String} phrase\n   */\n\n\n  fromPhrase(phrase) {\n    assert(typeof phrase === 'string');\n    assert(phrase.length <= 1000);\n    const words = phrase.trim().split(/[\\s\\u3000]+/);\n    const wbits = words.length * 11;\n    const cbits = wbits % 32;\n    assert(cbits !== 0, 'Invalid checksum.');\n    const bits = wbits - cbits;\n    assert(bits >= common.MIN_ENTROPY);\n    assert(bits <= common.MAX_ENTROPY);\n    assert(bits % 32 === 0);\n    const size = Math.ceil(wbits / 8);\n    const data = Buffer.allocUnsafe(size);\n    data.fill(0);\n    const lang = Mnemonic.getLanguage(words[0]);\n    const list = Mnemonic.getWordlist(lang); // Rebuild entropy bytes.\n\n    for (let i = 0; i < words.length; i++) {\n      const word = words[i];\n      const index = list.map[word];\n      if (index == null) throw new Error('Could not find word.');\n\n      for (let j = 0; j < 11; j++) {\n        const pos = i * 11 + j;\n        const bit = pos % 8;\n        const oct = (pos - bit) / 8;\n        const val = index >>> 10 - j & 1;\n        data[oct] |= val << 7 - bit;\n      }\n    }\n\n    const cbytes = Math.ceil(cbits / 8);\n    const entropy = data.slice(0, data.length - cbytes);\n    const chk1 = data.slice(data.length - cbytes);\n    const chk2 = sha256.digest(entropy); // Verify checksum.\n\n    for (let i = 0; i < cbits; i++) {\n      const bit = i % 8;\n      const oct = (i - bit) / 8;\n      const b1 = chk1[oct] >>> 7 - bit & 1;\n      const b2 = chk2[oct] >>> 7 - bit & 1;\n      if (b1 !== b2) throw new Error('Invalid checksum.');\n    }\n\n    assert(bits / 8 === entropy.length);\n    this.bits = bits;\n    this.language = lang;\n    this.entropy = entropy;\n    this.phrase = phrase;\n    return this;\n  }\n  /**\n   * Instantiate mnemonic from a phrase (validates checksum).\n   * @param {String} phrase\n   * @returns {Mnemonic}\n   * @throws on bad checksum\n   */\n\n\n  static fromPhrase(phrase) {\n    return new this().fromPhrase(phrase);\n  }\n  /**\n   * Inject properties from entropy.\n   * @private\n   * @param {Buffer} entropy\n   * @param {String?} lang\n   */\n\n\n  fromEntropy(entropy, lang) {\n    assert(Buffer.isBuffer(entropy));\n    assert(entropy.length * 8 >= common.MIN_ENTROPY);\n    assert(entropy.length * 8 <= common.MAX_ENTROPY);\n    assert(entropy.length * 8 % 32 === 0);\n    assert(!lang || Mnemonic.languages.indexOf(lang) !== -1);\n    this.entropy = entropy;\n    this.bits = entropy.length * 8;\n    if (lang) this.language = lang;\n    return this;\n  }\n  /**\n   * Instantiate mnemonic from entropy.\n   * @param {Buffer} entropy\n   * @param {String?} lang\n   * @returns {Mnemonic}\n   */\n\n\n  static fromEntropy(entropy, lang) {\n    return new this().fromEntropy(entropy, lang);\n  }\n  /**\n   * Determine a single word's language.\n   * @param {String} word\n   * @returns {String} Language.\n   * @throws on not found.\n   */\n\n\n  static getLanguage(word) {\n    for (const lang of Mnemonic.languages) {\n      const list = Mnemonic.getWordlist(lang);\n      if (list.map[word] != null) return lang;\n    }\n\n    throw new Error('Could not determine language.');\n  }\n  /**\n   * Retrieve the wordlist for a language.\n   * @param {String} lang\n   * @returns {Object}\n   */\n\n\n  static getWordlist(lang) {\n    const cache = wordlistCache[lang];\n    if (cache) return cache;\n    const words = wordlist.get(lang);\n    const list = new WordList(words);\n    wordlistCache[lang] = list;\n    return list;\n  }\n  /**\n   * Convert mnemonic to a json-friendly object.\n   * @returns {Object}\n   */\n\n\n  toJSON() {\n    return {\n      bits: this.bits,\n      language: this.language,\n      entropy: this.getEntropy().toString('hex'),\n      phrase: this.getPhrase()\n    };\n  }\n  /**\n   * Inject properties from json object.\n   * @private\n   * @param {Object} json\n   */\n\n\n  fromJSON(json) {\n    assert(json);\n    assert((json.bits & 0xffff) === json.bits);\n    assert(typeof json.language === 'string');\n    assert(typeof json.entropy === 'string');\n    assert(typeof json.phrase === 'string');\n    assert(json.bits >= common.MIN_ENTROPY);\n    assert(json.bits <= common.MAX_ENTROPY);\n    assert(json.bits % 32 === 0);\n    assert(json.bits / 8 === json.entropy.length / 2);\n    this.bits = json.bits;\n    this.language = json.language;\n    this.entropy = Buffer.from(json.entropy, 'hex');\n    this.phrase = json.phrase;\n    return this;\n  }\n  /**\n   * Instantiate mnemonic from json object.\n   * @param {Object} json\n   * @returns {Mnemonic}\n   */\n\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n  /**\n   * Calculate serialization size.\n   * @returns {Number}\n   */\n\n\n  getSize() {\n    let size = 0;\n    size += 3;\n    size += this.getEntropy().length;\n    return size;\n  }\n  /**\n   * Write the mnemonic to a buffer writer.\n   * @params {BufferWriter} bw\n   */\n\n\n  toWriter(bw) {\n    const lang = Mnemonic.languages.indexOf(this.language);\n    assert(lang !== -1);\n    bw.writeU16(this.bits);\n    bw.writeU8(lang);\n    bw.writeBytes(this.getEntropy());\n    return bw;\n  }\n  /**\n   * Serialize mnemonic.\n   * @returns {Buffer}\n   */\n\n\n  toRaw(writer) {\n    const size = this.getSize();\n    return this.toWriter(bio.write(size)).render();\n  }\n  /**\n   * Inject properties from buffer reader.\n   * @private\n   * @param {BufferReader} br\n   */\n\n\n  fromReader(br) {\n    const bits = br.readU16();\n    assert(bits >= common.MIN_ENTROPY);\n    assert(bits <= common.MAX_ENTROPY);\n    assert(bits % 32 === 0);\n    const language = Mnemonic.languages[br.readU8()];\n    assert(language);\n    this.bits = bits;\n    this.language = language;\n    this.entropy = br.readBytes(bits / 8);\n    return this;\n  }\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   */\n\n\n  fromRaw(data) {\n    return this.fromReader(bio.read(data));\n  }\n  /**\n   * Instantiate mnemonic from buffer reader.\n   * @param {BufferReader} br\n   * @returns {Mnemonic}\n   */\n\n\n  static fromReader(br) {\n    return new this().fromReader(br);\n  }\n  /**\n   * Instantiate mnemonic from serialized data.\n   * @param {Buffer} data\n   * @returns {Mnemonic}\n   */\n\n\n  static fromRaw(data) {\n    return new this().fromRaw(data);\n  }\n  /**\n   * Convert the mnemonic to a string.\n   * @returns {String}\n   */\n\n\n  toString() {\n    return this.getPhrase();\n  }\n  /**\n   * Inspect the mnemonic.\n   * @returns {String}\n   */\n\n\n  [inspectSymbol]() {\n    return `<Mnemonic: ${this.getPhrase()}>`;\n  }\n  /**\n   * Test whether an object is a Mnemonic.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n\n  static isMnemonic(obj) {\n    return obj instanceof Mnemonic;\n  }\n\n}\n/**\n * List of languages.\n * @const {String[]}\n * @default\n */\n\n\nMnemonic.languages = ['simplified chinese', 'traditional chinese', 'english', 'french', 'italian', 'japanese', 'spanish'];\n/**\n * Word List\n * @ignore\n */\n\nclass WordList {\n  /**\n   * Create word list.\n   * @constructor\n   * @ignore\n   * @param {Array} words\n   */\n  constructor(words) {\n    this.words = words;\n    this.map = Object.create(null);\n\n    for (let i = 0; i < words.length; i++) {\n      const word = words[i];\n      this.map[word] = i;\n    }\n  }\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = Mnemonic;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/hd/mnemonic.js"],"names":["assert","require","bio","sha256","cleanse","random","pbkdf2","sha512","wordlist","common","nfkd","inspectSymbol","wordlistCache","Object","create","Mnemonic","constructor","options","bits","MIN_ENTROPY","language","entropy","phrase","fromOptions","MAX_ENTROPY","languages","indexOf","fromPhrase","fromEntropy","destroy","toSeed","passphrase","getPhrase","passwd","derive","Buffer","from","getEntropy","randomBytes","length","wbits","chk","digest","size","Math","ceil","data","allocUnsafe","copy","list","getWordlist","i","index","j","pos","bit","oct","push","words","join","trim","split","cbits","fill","lang","getLanguage","word","map","Error","val","cbytes","slice","chk1","chk2","b1","b2","isBuffer","cache","get","WordList","toJSON","toString","fromJSON","json","getSize","toWriter","bw","writeU16","writeU8","writeBytes","toRaw","writer","write","render","fromReader","br","readU16","readU8","readBytes","fromRaw","read","isMnemonic","obj","module","exports"],"mappings":"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","sourcesContent":["/*!\n * mnemonic.js - hd mnemonics for bcoin\n * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bio = require('bufio');\nconst sha256 = require('bcrypto/lib/sha256');\nconst cleanse = require('bcrypto/lib/cleanse');\nconst random = require('bcrypto/lib/random');\nconst pbkdf2 = require('bcrypto/lib/pbkdf2');\nconst sha512 = require('bcrypto/lib/sha512');\nconst wordlist = require('./wordlist');\nconst common = require('./common');\nconst nfkd = require('./nfkd');\nconst {inspectSymbol} = require('../utils');\n\n/*\n * Constants\n */\n\nconst wordlistCache = Object.create(null);\n\n/**\n * HD Mnemonic\n * @alias module:hd.Mnemonic\n */\n\nclass Mnemonic {\n  /**\n   * Create a mnemonic.\n   * @constructor\n   * @param {Object} options\n   * @param {Number?} options.bit - Bits of entropy (Must\n   * be a multiple of 8) (default=128).\n   * @param {Buffer?} options.entropy - Entropy bytes. Will\n   * be generated with `options.bits` bits of entropy\n   * if not present.\n   * @param {String?} options.phrase - Mnemonic phrase (will\n   * be generated if not present).\n   * @param {String?} options.language - Language.\n   */\n\n  constructor(options) {\n    this.bits = common.MIN_ENTROPY;\n    this.language = 'english';\n    this.entropy = null;\n    this.phrase = null;\n\n    if (options)\n      this.fromOptions(options);\n  }\n\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n  fromOptions(options) {\n    if (typeof options === 'string')\n      options = { phrase: options };\n\n    if (options.bits != null) {\n      assert((options.bits & 0xffff) === options.bits);\n      assert(options.bits >= common.MIN_ENTROPY);\n      assert(options.bits <= common.MAX_ENTROPY);\n      assert(options.bits % 32 === 0);\n      this.bits = options.bits;\n    }\n\n    if (options.language) {\n      assert(typeof options.language === 'string');\n      assert(Mnemonic.languages.indexOf(options.language) !== -1);\n      this.language = options.language;\n    }\n\n    if (options.phrase) {\n      this.fromPhrase(options.phrase);\n      return this;\n    }\n\n    if (options.entropy) {\n      this.fromEntropy(options.entropy);\n      return this;\n    }\n\n    return this;\n  }\n\n  /**\n   * Instantiate mnemonic from options.\n   * @param {Object} options\n   * @returns {Mnemonic}\n   */\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n\n  /**\n   * Destroy the mnemonic (zeroes entropy).\n   */\n\n  destroy() {\n    this.bits = common.MIN_ENTROPY;\n    this.language = 'english';\n    if (this.entropy) {\n      cleanse(this.entropy);\n      this.entropy = null;\n    }\n    this.phrase = null;\n  }\n\n  /**\n   * Generate the seed.\n   * @param {String?} passphrase\n   * @returns {Buffer} pbkdf2 seed.\n   */\n\n  toSeed(passphrase) {\n    if (!passphrase)\n      passphrase = '';\n\n    const phrase = nfkd(this.getPhrase());\n    const passwd = nfkd(`mnemonic${passphrase}`);\n\n    return pbkdf2.derive(sha512,\n      Buffer.from(phrase, 'utf8'),\n      Buffer.from(passwd, 'utf8'),\n      2048, 64);\n  }\n\n  /**\n   * Get or generate entropy.\n   * @returns {Buffer}\n   */\n\n  getEntropy() {\n    if (!this.entropy)\n      this.entropy = random.randomBytes(this.bits / 8);\n\n    assert(this.bits / 8 === this.entropy.length);\n\n    return this.entropy;\n  }\n\n  /**\n   * Generate a mnemonic phrase from chosen language.\n   * @returns {String}\n   */\n\n  getPhrase() {\n    if (this.phrase)\n      return this.phrase;\n\n    // Include the first `ENT / 32` bits\n    // of the hash (the checksum).\n    const wbits = this.bits + (this.bits / 32);\n\n    // Get entropy and checksum.\n    const entropy = this.getEntropy();\n    const chk = sha256.digest(entropy);\n\n    // Append the hash to the entropy to\n    // make things easy when grabbing\n    // the checksum bits.\n    const size = Math.ceil(wbits / 8);\n    const data = Buffer.allocUnsafe(size);\n    entropy.copy(data, 0);\n    chk.copy(data, entropy.length);\n\n    // Build the mnemonic by reading\n    // 11 bit indexes from the entropy.\n    const list = Mnemonic.getWordlist(this.language);\n\n    let phrase = [];\n    for (let i = 0; i < wbits / 11; i++) {\n      let index = 0;\n      for (let j = 0; j < 11; j++) {\n        const pos = i * 11 + j;\n        const bit = pos % 8;\n        const oct = (pos - bit) / 8;\n        index <<= 1;\n        index |= (data[oct] >>> (7 - bit)) & 1;\n      }\n      phrase.push(list.words[index]);\n    }\n\n    // Japanese likes double-width spaces.\n    if (this.language === 'japanese')\n      phrase = phrase.join('\\u3000');\n    else\n      phrase = phrase.join(' ');\n\n    this.phrase = phrase;\n\n    return phrase;\n  }\n\n  /**\n   * Inject properties from phrase.\n   * @private\n   * @param {String} phrase\n   */\n\n  fromPhrase(phrase) {\n    assert(typeof phrase === 'string');\n    assert(phrase.length <= 1000);\n\n    const words = phrase.trim().split(/[\\s\\u3000]+/);\n    const wbits = words.length * 11;\n    const cbits = wbits % 32;\n\n    assert(cbits !== 0, 'Invalid checksum.');\n\n    const bits = wbits - cbits;\n\n    assert(bits >= common.MIN_ENTROPY);\n    assert(bits <= common.MAX_ENTROPY);\n    assert(bits % 32 === 0);\n\n    const size = Math.ceil(wbits / 8);\n    const data = Buffer.allocUnsafe(size);\n    data.fill(0);\n\n    const lang = Mnemonic.getLanguage(words[0]);\n    const list = Mnemonic.getWordlist(lang);\n\n    // Rebuild entropy bytes.\n    for (let i = 0; i < words.length; i++) {\n      const word = words[i];\n      const index = list.map[word];\n\n      if (index == null)\n        throw new Error('Could not find word.');\n\n      for (let j = 0; j < 11; j++) {\n        const pos = i * 11 + j;\n        const bit = pos % 8;\n        const oct = (pos - bit) / 8;\n        const val = (index >>> (10 - j)) & 1;\n        data[oct] |= val << (7 - bit);\n      }\n    }\n\n    const cbytes = Math.ceil(cbits / 8);\n    const entropy = data.slice(0, data.length - cbytes);\n    const chk1 = data.slice(data.length - cbytes);\n    const chk2 = sha256.digest(entropy);\n\n    // Verify checksum.\n    for (let i = 0; i < cbits; i++) {\n      const bit = i % 8;\n      const oct = (i - bit) / 8;\n      const b1 = (chk1[oct] >>> (7 - bit)) & 1;\n      const b2 = (chk2[oct] >>> (7 - bit)) & 1;\n      if (b1 !== b2)\n        throw new Error('Invalid checksum.');\n    }\n\n    assert(bits / 8 === entropy.length);\n\n    this.bits = bits;\n    this.language = lang;\n    this.entropy = entropy;\n    this.phrase = phrase;\n\n    return this;\n  }\n\n  /**\n   * Instantiate mnemonic from a phrase (validates checksum).\n   * @param {String} phrase\n   * @returns {Mnemonic}\n   * @throws on bad checksum\n   */\n\n  static fromPhrase(phrase) {\n    return new this().fromPhrase(phrase);\n  }\n\n  /**\n   * Inject properties from entropy.\n   * @private\n   * @param {Buffer} entropy\n   * @param {String?} lang\n   */\n\n  fromEntropy(entropy, lang) {\n    assert(Buffer.isBuffer(entropy));\n    assert(entropy.length * 8 >= common.MIN_ENTROPY);\n    assert(entropy.length * 8 <= common.MAX_ENTROPY);\n    assert((entropy.length * 8) % 32 === 0);\n    assert(!lang || Mnemonic.languages.indexOf(lang) !== -1);\n\n    this.entropy = entropy;\n    this.bits = entropy.length * 8;\n\n    if (lang)\n      this.language = lang;\n\n    return this;\n  }\n\n  /**\n   * Instantiate mnemonic from entropy.\n   * @param {Buffer} entropy\n   * @param {String?} lang\n   * @returns {Mnemonic}\n   */\n\n  static fromEntropy(entropy, lang) {\n    return new this().fromEntropy(entropy, lang);\n  }\n\n  /**\n   * Determine a single word's language.\n   * @param {String} word\n   * @returns {String} Language.\n   * @throws on not found.\n   */\n\n  static getLanguage(word) {\n    for (const lang of Mnemonic.languages) {\n      const list = Mnemonic.getWordlist(lang);\n      if (list.map[word] != null)\n        return lang;\n    }\n\n    throw new Error('Could not determine language.');\n  }\n\n  /**\n   * Retrieve the wordlist for a language.\n   * @param {String} lang\n   * @returns {Object}\n   */\n\n  static getWordlist(lang) {\n    const cache = wordlistCache[lang];\n\n    if (cache)\n      return cache;\n\n    const words = wordlist.get(lang);\n    const list = new WordList(words);\n\n    wordlistCache[lang] = list;\n\n    return list;\n  }\n\n  /**\n   * Convert mnemonic to a json-friendly object.\n   * @returns {Object}\n   */\n\n  toJSON() {\n    return {\n      bits: this.bits,\n      language: this.language,\n      entropy: this.getEntropy().toString('hex'),\n      phrase: this.getPhrase()\n    };\n  }\n\n  /**\n   * Inject properties from json object.\n   * @private\n   * @param {Object} json\n   */\n\n  fromJSON(json) {\n    assert(json);\n    assert((json.bits & 0xffff) === json.bits);\n    assert(typeof json.language === 'string');\n    assert(typeof json.entropy === 'string');\n    assert(typeof json.phrase === 'string');\n    assert(json.bits >= common.MIN_ENTROPY);\n    assert(json.bits <= common.MAX_ENTROPY);\n    assert(json.bits % 32 === 0);\n    assert(json.bits / 8 === json.entropy.length / 2);\n\n    this.bits = json.bits;\n    this.language = json.language;\n    this.entropy = Buffer.from(json.entropy, 'hex');\n    this.phrase = json.phrase;\n\n    return this;\n  }\n\n  /**\n   * Instantiate mnemonic from json object.\n   * @param {Object} json\n   * @returns {Mnemonic}\n   */\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n\n  /**\n   * Calculate serialization size.\n   * @returns {Number}\n   */\n\n  getSize() {\n    let size = 0;\n    size += 3;\n    size += this.getEntropy().length;\n    return size;\n  }\n\n  /**\n   * Write the mnemonic to a buffer writer.\n   * @params {BufferWriter} bw\n   */\n\n  toWriter(bw) {\n    const lang = Mnemonic.languages.indexOf(this.language);\n\n    assert(lang !== -1);\n\n    bw.writeU16(this.bits);\n    bw.writeU8(lang);\n    bw.writeBytes(this.getEntropy());\n\n    return bw;\n  }\n\n  /**\n   * Serialize mnemonic.\n   * @returns {Buffer}\n   */\n\n  toRaw(writer) {\n    const size = this.getSize();\n    return this.toWriter(bio.write(size)).render();\n  }\n\n  /**\n   * Inject properties from buffer reader.\n   * @private\n   * @param {BufferReader} br\n   */\n\n  fromReader(br) {\n    const bits = br.readU16();\n\n    assert(bits >= common.MIN_ENTROPY);\n    assert(bits <= common.MAX_ENTROPY);\n    assert(bits % 32 === 0);\n\n    const language = Mnemonic.languages[br.readU8()];\n    assert(language);\n\n    this.bits = bits;\n    this.language = language;\n    this.entropy = br.readBytes(bits / 8);\n\n    return this;\n  }\n\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   */\n\n  fromRaw(data) {\n    return this.fromReader(bio.read(data));\n  }\n\n  /**\n   * Instantiate mnemonic from buffer reader.\n   * @param {BufferReader} br\n   * @returns {Mnemonic}\n   */\n\n  static fromReader(br) {\n    return new this().fromReader(br);\n  }\n\n  /**\n   * Instantiate mnemonic from serialized data.\n   * @param {Buffer} data\n   * @returns {Mnemonic}\n   */\n\n  static fromRaw(data) {\n    return new this().fromRaw(data);\n  }\n\n  /**\n   * Convert the mnemonic to a string.\n   * @returns {String}\n   */\n\n  toString() {\n    return this.getPhrase();\n  }\n\n  /**\n   * Inspect the mnemonic.\n   * @returns {String}\n   */\n\n  [inspectSymbol]() {\n    return `<Mnemonic: ${this.getPhrase()}>`;\n  }\n\n  /**\n   * Test whether an object is a Mnemonic.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n  static isMnemonic(obj) {\n    return obj instanceof Mnemonic;\n  }\n}\n\n/**\n * List of languages.\n * @const {String[]}\n * @default\n */\n\nMnemonic.languages = [\n  'simplified chinese',\n  'traditional chinese',\n  'english',\n  'french',\n  'italian',\n  'japanese',\n  'spanish'\n];\n\n/**\n * Word List\n * @ignore\n */\n\nclass WordList {\n  /**\n   * Create word list.\n   * @constructor\n   * @ignore\n   * @param {Array} words\n   */\n\n  constructor(words) {\n    this.words = words;\n    this.map = Object.create(null);\n\n    for (let i = 0; i < words.length; i++) {\n      const word = words[i];\n      this.map[word] = i;\n    }\n  }\n}\n\n/*\n * Expose\n */\n\nmodule.exports = Mnemonic;\n"]},"metadata":{},"sourceType":"module"}