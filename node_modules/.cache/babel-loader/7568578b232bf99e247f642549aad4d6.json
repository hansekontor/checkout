{"ast":null,"code":"/*!\n * modes.js - cipher modes for bcrypto\n * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation\n */\n'use strict';\n\nconst assert = require('../../internal/assert');\n\nconst gcm = require('./gcm');\n/*\n * Constants\n */\n\n\nconst EMPTY = Buffer.alloc(0);\n/**\n * Cipher\n */\n\nclass Cipher {\n  constructor(ctx) {\n    let padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    assert(ctx && typeof ctx.encrypt === 'function');\n    assert(typeof ctx.blockSize === 'number');\n    assert(typeof padding === 'boolean');\n    this.ctx = ctx;\n    this.padding = padding;\n    this.block = Buffer.alloc(ctx.blockSize);\n    this.blockPos = -1;\n    this.last = null;\n    this.lastSize = 0;\n    if (padding) this.last = Buffer.alloc(ctx.blockSize);\n  }\n\n  get blockSize() {\n    return this.block.length;\n  }\n\n  init(key, iv) {\n    if (iv == null) iv = EMPTY;\n    assert(Buffer.isBuffer(key));\n    assert(Buffer.isBuffer(iv));\n    this.ctx.init(key);\n    this.blockPos = 0;\n    this.lastSize = 0;\n\n    this._init(key, iv);\n\n    return this;\n  }\n\n  update(input) {\n    assert(Buffer.isBuffer(input));\n    if (this.blockPos === -1) throw new Error('Cipher is not initialized.');\n    const bs = this.block.length;\n    let bpos = this.blockPos;\n    let ilen = input.length;\n    let olen = 0;\n    let ipos = 0;\n    let opos = 0;\n    this.blockPos = (this.blockPos + ilen) % bs;\n    if (this.padding) olen += this.lastSize;\n\n    if (bpos > 0) {\n      let want = bs - bpos;\n      if (want > ilen) want = ilen;\n      input.copy(this.block, bpos, ipos, ipos + want);\n      bpos += want;\n      ilen -= want;\n      ipos += want;\n      if (bpos < bs) return Buffer.alloc(0);\n      olen += bs;\n    }\n\n    olen += ilen - ilen % bs;\n    const output = Buffer.alloc(olen);\n    if (this.padding) opos += this.last.copy(output, opos, 0, this.lastSize);\n\n    if (bpos > 0) {\n      this._update(this.block, 0, output, opos);\n\n      opos += bs;\n    }\n\n    while (ilen >= bs) {\n      this._update(input, ipos, output, opos);\n\n      opos += bs;\n      ipos += bs;\n      ilen -= bs;\n    }\n\n    if (ilen > 0) input.copy(this.block, 0, ipos, ipos + ilen);\n\n    if (this.padding && olen > 0) {\n      this.lastSize = output.copy(this.last, 0, olen - bs, olen);\n      return output.slice(0, olen - bs);\n    }\n\n    return output;\n  }\n\n  final() {\n    if (this.blockPos === -1) throw new Error('Cipher is not initialized.');\n\n    try {\n      return this._final();\n    } finally {\n      this.destroy();\n    }\n  }\n\n  destroy() {\n    this.ctx.destroy();\n    this.blockPos = -1;\n    this.lastSize = 0;\n\n    for (let i = 0; i < this.blockSize; i++) this.block[i] = 0;\n\n    if (this.padding) {\n      for (let i = 0; i < this.blockSize; i++) this.last[i] = 0;\n    }\n\n    this._destroy();\n  }\n\n  setAAD(data) {\n    throw new Error('Cipher is not authenticated.');\n  }\n\n  getAuthTag() {\n    throw new Error('Cipher is not authenticated.');\n  }\n\n  setAuthTag(tag) {\n    throw new Error('Cipher is not authenticated.');\n  }\n\n  _init() {\n    throw new Error('Not implemented.');\n  }\n\n  _update() {\n    throw new Error('Not implemented.');\n  }\n\n  _final() {\n    throw new Error('Not implemented.');\n  }\n\n  _destroy() {\n    throw new Error('Not implemented.');\n  }\n\n}\n/**\n * Block Cipher\n * @extends Cipher\n */\n\n\nclass BlockCipher extends Cipher {\n  constructor(ctx) {\n    let chain = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    assert(typeof chain === 'boolean');\n    super(ctx, false);\n    this.chain = chain;\n    this.prev = null;\n    if (chain) this.prev = Buffer.alloc(this.blockSize);\n  }\n\n  _init(key, iv) {\n    assert(Buffer.isBuffer(iv));\n\n    if (this.chain) {\n      assert(iv.length === this.blockSize);\n      iv.copy(this.prev, 0);\n    } else {\n      assert(iv.length === 0);\n    }\n  }\n\n  _update(input, ipos, output, opos) {\n    if (this.chain) {\n      for (let i = 0; i < this.blockSize; i++) output[opos + i] = input[ipos + i] ^ this.prev[i];\n\n      this.ctx.encrypt(output, opos, output, opos);\n      output.copy(this.prev, 0, opos, opos + this.blockSize);\n    } else {\n      this.ctx.encrypt(input, ipos, output, opos);\n    }\n  }\n\n  _final() {\n    const left = this.blockSize - this.blockPos;\n    const block = Buffer.from(this.block);\n\n    for (let i = this.blockPos; i < this.blockSize; i++) block[i] = left;\n\n    this._update(block, 0, block, 0);\n\n    return block;\n  }\n\n  _destroy() {\n    if (this.chain) {\n      for (let i = 0; i < this.blockSize; i++) this.prev[i] = 0;\n    }\n  }\n\n}\n/**\n * Block Decipher\n * @extends Cipher\n */\n\n\nclass BlockDecipher extends Cipher {\n  constructor(ctx) {\n    let chain = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    assert(typeof chain === 'boolean');\n    super(ctx, true);\n    this.chain = chain;\n    this.prev = null;\n    if (chain) this.prev = Buffer.alloc(this.blockSize);\n  }\n\n  _init(key, iv) {\n    assert(Buffer.isBuffer(iv));\n\n    if (this.chain) {\n      assert(iv.length === this.blockSize);\n      iv.copy(this.prev, 0);\n    } else {\n      assert(iv.length === 0);\n    }\n  }\n\n  _update(input, ipos, output, opos) {\n    if (this.chain) {\n      this.ctx.decrypt(input, ipos, output, opos);\n\n      for (let i = 0; i < this.blockSize; i++) output[opos + i] ^= this.prev[i];\n\n      input.copy(this.prev, 0, ipos, ipos + this.blockSize);\n    } else {\n      this.ctx.decrypt(input, ipos, output, opos);\n    }\n  }\n\n  _final() {\n    if (this.blockPos !== 0) throw new Error('Bad decrypt (trailing bytes).');\n    if (this.lastSize === 0) throw new Error('Bad decrypt (no data).');\n    assert(this.lastSize === this.last.length);\n    assert(this.lastSize === this.blockSize);\n    const block = Buffer.from(this.last);\n    const left = block[block.length - 1];\n    if (left === 0 || left > this.blockSize) throw new Error('Bad decrypt (out of range).');\n    const end = this.blockSize - left;\n\n    for (let i = end; i < this.blockSize; i++) {\n      if (block[i] !== left) throw new Error('Bad decrypt (padding).');\n    }\n\n    return block.slice(0, end);\n  }\n\n  _destroy() {\n    if (this.chain) {\n      for (let i = 0; i < this.blockSize; i++) this.prev[i] = 0;\n    }\n  }\n\n}\n/**\n * ECB Cipher\n * @extends BlockCipher\n */\n\n\nclass ECBCipher extends BlockCipher {\n  constructor(ctx) {\n    super(ctx, false);\n  }\n\n}\n/**\n * ECB Decipher\n * @extends BlockDecipher\n */\n\n\nclass ECBDecipher extends BlockDecipher {\n  constructor(ctx) {\n    super(ctx, false);\n  }\n\n}\n/**\n * CBC Cipher\n * @extends BlockCipher\n */\n\n\nclass CBCCipher extends BlockCipher {\n  constructor(ctx) {\n    super(ctx, true);\n  }\n\n}\n/**\n * CBC Decipher\n * @extends BlockDecipher\n */\n\n\nclass CBCDecipher extends BlockDecipher {\n  constructor(ctx) {\n    super(ctx, true);\n  }\n\n}\n/**\n * CTR\n * @extends Cipher\n */\n\n\nclass CTR extends Cipher {\n  constructor(ctx) {\n    super(ctx, false);\n    this.state = Buffer.alloc(this.blockSize);\n    this.ctr = Buffer.alloc(this.blockSize);\n  }\n\n  _init(key, iv) {\n    assert(Buffer.isBuffer(iv));\n    assert(iv.length === this.blockSize);\n    iv.copy(this.ctr, 0);\n  }\n\n  _increment() {\n    for (let i = this.ctr.length - 1; i >= 0; i--) {\n      this.ctr[i] += 1;\n      if (this.ctr[i] !== 0x00) break;\n    }\n  }\n\n  _update(input, ipos, output, opos) {\n    this.ctx.encrypt(this.ctr, 0, this.state, 0);\n\n    this._increment();\n\n    for (let i = 0; i < this.blockSize; i++) output[opos + i] = input[ipos + i] ^ this.state[i];\n  }\n\n  _final() {\n    this.ctx.encrypt(this.ctr, 0, this.state, 0);\n    const out = Buffer.alloc(this.blockPos);\n\n    for (let i = 0; i < this.blockPos; i++) out[i] = this.block[i] ^ this.state[i];\n\n    return out;\n  }\n\n  _destroy() {\n    for (let i = 0; i < this.blockPos; i++) {\n      this.state[i] = 0;\n      this.ctr[i] = 0;\n    }\n  }\n\n}\n/**\n * CTR Cipher\n * @extends CTR\n */\n\n\nclass CTRCipher extends CTR {\n  constructor(ctx) {\n    super(ctx);\n  }\n\n}\n/**\n * CTR Decipher\n * @extends CTR\n */\n\n\nclass CTRDecipher extends CTR {\n  constructor(ctx) {\n    super(ctx);\n  }\n\n}\n/**\n * CFB\n * @extends Cipher\n */\n\n\nclass CFB extends Cipher {\n  constructor(ctx) {\n    let encrypt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    assert(typeof encrypt === 'boolean');\n    super(ctx, false);\n    this.encrypt = encrypt;\n    this.state = Buffer.alloc(this.blockSize);\n    this.prev = Buffer.alloc(this.blockSize);\n  }\n\n  _init(key, iv) {\n    assert(Buffer.isBuffer(iv));\n    assert(iv.length === this.blockSize);\n    iv.copy(this.prev, 0);\n  }\n\n  _update(input, ipos, output, opos) {\n    this.ctx.encrypt(this.prev, 0, this.state, 0);\n\n    for (let i = 0; i < this.blockSize; i++) output[opos + i] = input[ipos + i] ^ this.state[i];\n\n    if (this.encrypt) output.copy(this.prev, 0, opos, opos + this.blockSize);else input.copy(this.prev, 0, ipos, ipos + this.blockSize);\n  }\n\n  _final() {\n    this.ctx.encrypt(this.prev, 0, this.state, 0);\n    const out = Buffer.alloc(this.blockPos);\n\n    for (let i = 0; i < this.blockPos; i++) out[i] = this.block[i] ^ this.state[i];\n\n    return out;\n  }\n\n  _destroy() {\n    for (let i = 0; i < this.blockPos; i++) {\n      this.state[i] = 0;\n      this.prev[i] = 0;\n    }\n  }\n\n}\n/**\n * CFB Cipher\n * @extends CFB\n */\n\n\nclass CFBCipher extends CFB {\n  constructor(ctx) {\n    super(ctx, true);\n  }\n\n}\n/**\n * CFB Decipher\n * @extends CFB\n */\n\n\nclass CFBDecipher extends CFB {\n  constructor(ctx) {\n    super(ctx, false);\n  }\n\n}\n/**\n * OFB\n * @extends Cipher\n */\n\n\nclass OFB extends Cipher {\n  constructor(ctx) {\n    super(ctx, false);\n    this.state = Buffer.alloc(this.blockSize);\n  }\n\n  _init(key, iv) {\n    assert(Buffer.isBuffer(iv));\n    assert(iv.length === this.blockSize);\n    iv.copy(this.state, 0);\n  }\n\n  _update(input, ipos, output, opos) {\n    this.ctx.encrypt(this.state, 0, this.state, 0);\n\n    for (let i = 0; i < this.blockSize; i++) output[opos + i] = input[ipos + i] ^ this.state[i];\n  }\n\n  _final() {\n    this.ctx.encrypt(this.state, 0, this.state, 0);\n    const out = Buffer.alloc(this.blockPos);\n\n    for (let i = 0; i < this.blockPos; i++) out[i] = this.block[i] ^ this.state[i];\n\n    return out;\n  }\n\n  _destroy() {\n    for (let i = 0; i < this.blockPos; i++) this.state[i] = 0;\n  }\n\n}\n/**\n * OFB Cipher\n * @extends OFB\n */\n\n\nclass OFBCipher extends OFB {\n  constructor(ctx) {\n    super(ctx);\n  }\n\n}\n/**\n * OFB Decipher\n * @extends OFB\n */\n\n\nclass OFBDecipher extends OFB {\n  constructor(ctx) {\n    super(ctx);\n  }\n\n}\n/**\n * GCM\n * @extends Cipher\n */\n\n\nclass GCM {\n  constructor(ctx, encrypt) {\n    this.aead = new gcm.GCM(ctx);\n    this.encrypt = encrypt;\n    this.tag = null;\n    this.mac = null;\n  }\n\n  get blockSize() {\n    return 16;\n  }\n\n  init(key, iv) {\n    this.aead.init(key, iv);\n    this.tag = null;\n    this.mac = null;\n    return this;\n  }\n\n  update(input) {\n    assert(Buffer.isBuffer(input));\n    const out = Buffer.from(input);\n    if (this.encrypt) this.aead.encrypt(out);else this.aead.decrypt(out);\n    return out;\n  }\n\n  final() {\n    if (this.encrypt) {\n      this.mac = this.aead.final(16);\n      return Buffer.alloc(0);\n    }\n\n    if (!this.tag) throw new Error('No tag provided.');\n    if (!this.aead.verify(this.tag)) throw new Error('Invalid tag.');\n    return Buffer.alloc(0);\n  }\n\n  destroy() {\n    this.aead.destroy();\n\n    if (this.tag) {\n      for (let i = 0; i < this.tag.length; i++) this.tag[i] = 0;\n\n      this.tag = null;\n    }\n\n    if (this.mac) {\n      for (let i = 0; i < 16; i++) this.mac[i] = 0;\n\n      this.mac = null;\n    }\n  }\n\n  setAAD(data) {\n    this.aead.aad(data);\n    return this;\n  }\n\n  getAuthTag() {\n    if (!this.encrypt) throw new Error('Must be a cipher context.');\n    if (!this.mac) throw new Error('Cipher is not finalized.');\n    return Buffer.from(this.mac);\n  }\n\n  setAuthTag(tag) {\n    assert(Buffer.isBuffer(tag));\n    if (this.encrypt) throw new Error('Must be a decipher context.');\n    if (this.aead.mode === -1) throw new Error('Cipher is not initialized.');\n\n    if (tag.length !== 4 && tag.length !== 8 && (tag.length < 12 || tag.length > 16)) {\n      throw new RangeError('Invalid tag size.');\n    }\n\n    this.tag = Buffer.from(tag);\n    return this;\n  }\n\n}\n/**\n * GCM Cipher\n * @extends GCM\n */\n\n\nclass GCMCipher extends GCM {\n  constructor(ctx) {\n    super(ctx, true);\n  }\n\n}\n/**\n * GCM Decipher\n * @extends GCM\n */\n\n\nclass GCMDecipher extends GCM {\n  constructor(ctx) {\n    super(ctx, false);\n  }\n\n}\n/*\n * Helpers\n */\n\n\nfunction get(name) {\n  let encrypt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  assert(typeof name === 'string');\n  assert(typeof encrypt === 'boolean');\n\n  switch (name) {\n    case 'ECB':\n      return encrypt ? ECBCipher : ECBDecipher;\n\n    case 'CBC':\n      return encrypt ? CBCCipher : CBCDecipher;\n\n    case 'CTR':\n      return encrypt ? CTRCipher : CTRDecipher;\n\n    case 'CFB':\n      return encrypt ? CFBCipher : CFBDecipher;\n\n    case 'OFB':\n      return encrypt ? OFBCipher : OFBDecipher;\n\n    case 'GCM':\n      return encrypt ? GCMCipher : GCMDecipher;\n\n    default:\n      throw new Error(`Unknown mode: ${name}.`);\n  }\n}\n/*\n * Expose\n */\n\n\nexports.Cipher = Cipher;\nexports.BlockCipher = BlockCipher;\nexports.BlockDecipher = BlockDecipher;\nexports.ECBCipher = ECBCipher;\nexports.ECBDecipher = ECBDecipher;\nexports.CBCCipher = CBCCipher;\nexports.CBCDecipher = CBCDecipher;\nexports.CTR = CTR;\nexports.CTRCipher = CTRCipher;\nexports.CTRDecipher = CTRDecipher;\nexports.CFB = CFB;\nexports.CFBCipher = CFBCipher;\nexports.CFBDecipher = CFBDecipher;\nexports.OFB = OFB;\nexports.OFBCipher = OFBCipher;\nexports.OFBDecipher = OFBDecipher;\nexports.GCM = GCM;\nexports.GCMCipher = GCMCipher;\nexports.GCMDecipher = GCMDecipher;\nexports.get = get;","map":null,"metadata":{},"sourceType":"script"}