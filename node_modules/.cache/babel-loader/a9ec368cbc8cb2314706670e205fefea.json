{"ast":null,"code":"/*!\n * asn1.js - asn1 parsing for bcrypto\n * Copyright (c) 2020, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n */\n'use strict';\n\nconst assert = require('assert');\n\nconst BN = require('../bn');\n/*\n * ASN1\n */\n\n\nfunction readSize(data, pos, strict) {\n  assert(Buffer.isBuffer(data));\n  assert(pos >>> 0 === pos);\n  assert(typeof strict === 'boolean');\n  if (pos >= data.length) throw new Error('Invalid size.');\n  const field = data[pos];\n  const bytes = field & 0x7f;\n  pos += 1; // Definite form.\n\n  if ((field & 0x80) === 0) {\n    // Short form.\n    return [bytes, pos];\n  } // Indefinite form.\n\n\n  if (strict && bytes === 0) throw new Error('Indefinite length.'); // Long form.\n\n  let size = 0;\n\n  for (let i = 0; i < bytes; i++) {\n    assert(pos < data.length);\n    const ch = data[pos];\n    pos += 1;\n    if (size >= 1 << 24) throw new Error('Length too large.');\n    size *= 0x100;\n    size += ch;\n    if (strict && size === 0) throw new Error('Unexpected leading zeroes.');\n  }\n\n  if (strict && size < 0x80) throw new Error('Non-minimal length.');\n  return [size, pos];\n}\n\nfunction readSeq(data, pos) {\n  let strict = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  assert(Buffer.isBuffer(data));\n  assert(pos >>> 0 === pos);\n  assert(typeof strict === 'boolean');\n  if (pos >= data.length || data[pos] !== 0x30) throw new Error('Invalid sequence tag.');\n  pos += 1;\n  let size;\n  [size, pos] = readSize(data, pos, strict);\n  if (strict && pos + size !== data.length) throw new Error('Trailing bytes.');\n  return pos;\n}\n\nfunction readInt(data, pos) {\n  let strict = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  assert(Buffer.isBuffer(data));\n  assert(pos >>> 0 === pos);\n  assert(typeof strict === 'boolean');\n  if (pos >= data.length || data[pos] !== 0x02) throw new Error('Invalid integer tag.');\n  pos += 1;\n  let size;\n  [size, pos] = readSize(data, pos, strict);\n  if (pos + size > data.length) throw new Error('Integer body out of bounds.');\n\n  if (strict) {\n    // Zero length integer.\n    if (size === 0) throw new Error('Zero length integer.'); // No negatives.\n\n    if (data[pos] & 0x80) throw new Error('Integers must be positive.'); // Allow zero only if it prefixes a high bit.\n\n    if (size > 1) {\n      if (data[pos] === 0x00 && (data[pos + 1] & 0x80) === 0x00) throw new Error('Unexpected leading zeroes.');\n    }\n  } // Eat leading zeroes.\n\n\n  while (size > 1 && data[pos] === 0x00) {\n    pos += 1;\n    size -= 1;\n  } // No reason to have an integer larger than this.\n\n\n  if (size > 2048) throw new Error('Invalid integer size.');\n  const num = BN.decode(data.slice(pos, pos + size));\n  pos += size;\n  return [num, pos];\n}\n\nfunction readVersion(data, pos, version) {\n  let strict = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  assert(Buffer.isBuffer(data));\n  assert(pos >>> 0 === pos);\n  assert((version & 0xff) === version);\n  assert(typeof strict === 'boolean');\n  let num;\n  [num, pos] = readInt(data, pos, strict);\n  if (num.cmpn(version) !== 0) throw new Error('Invalid version.');\n  return pos;\n}\n\nfunction sizeSize(size) {\n  assert(size >>> 0 === size);\n  if (size <= 0x7f) // [size]\n    return 1;\n  if (size <= 0xff) // 0x81 [size]\n    return 2;\n  assert(size <= 0xffff);\n  return 3; // 0x82 [size-hi] [size-lo]\n}\n\nfunction sizeSeq(size) {\n  return 1 + sizeSize(size) + size;\n}\n\nfunction sizeInt(num) {\n  assert(num instanceof BN); // 0x02 [size] [0x00?] [int]\n\n  const bits = num.bitLength();\n  let size = bits + 7 >>> 3;\n  if (bits > 0 && (bits & 7) === 0) size += num.testn(bits - 1);\n  if (bits === 0) size = 1;\n  return 1 + sizeSize(size) + size;\n}\n\nfunction sizeVersion(version) {\n  assert((version & 0xff) === version);\n  return 3;\n}\n\nfunction writeSize(data, pos, size) {\n  assert(Buffer.isBuffer(data));\n  assert(pos >>> 0 === pos);\n  assert(size >>> 0 === size);\n\n  if (size <= 0x7f) {\n    // [size]\n    data[pos++] = size;\n  } else if (size <= 0xff) {\n    // 0x81 [size]\n    data[pos++] = 0x81;\n    data[pos++] = size;\n  } else {\n    // 0x82 [size-hi] [size-lo]\n    assert(size <= 0xffff);\n    data[pos++] = 0x82;\n    data[pos++] = size >> 8;\n    data[pos++] = size & 0xff;\n  }\n\n  assert(pos <= data.length);\n  return pos;\n}\n\nfunction writeSeq(data, pos, size) {\n  assert(Buffer.isBuffer(data));\n  assert(pos >>> 0 === pos);\n  data[pos++] = 0x30;\n  return writeSize(data, pos, size);\n}\n\nfunction writeInt(data, pos, num) {\n  assert(Buffer.isBuffer(data));\n  assert(pos >>> 0 === pos);\n  assert(num instanceof BN); // 0x02 [size] [0x00?] [int]\n\n  const bits = num.bitLength();\n  let size = bits + 7 >>> 3;\n  let pad = 0;\n  if (bits > 0 && (bits & 7) === 0) pad = num.testn(bits - 1);\n  if (bits === 0) size = 1;\n  data[pos++] = 0x02;\n  pos = writeSize(data, pos, pad + size);\n  if (pad) data[pos++] = 0x00;\n  if (bits !== 0) num.encode().copy(data, pos);else data[pos] = 0x00;\n  pos += size;\n  assert(pos <= data.length);\n  return pos;\n}\n\nfunction writeVersion(data, pos, version) {\n  assert(Buffer.isBuffer(data));\n  assert(pos >>> 0 === pos);\n  assert((version & 0xff) === version);\n  assert(pos + 3 <= data.length);\n  data[pos++] = 0x02;\n  data[pos++] = 0x01;\n  data[pos++] = version;\n  return pos;\n}\n/*\n * Expose\n */\n\n\nexports.readSize = readSize;\nexports.readSeq = readSeq;\nexports.readInt = readInt;\nexports.readVersion = readVersion;\nexports.sizeSize = sizeSize;\nexports.sizeSeq = sizeSeq;\nexports.sizeInt = sizeInt;\nexports.sizeVersion = sizeVersion;\nexports.writeSize = writeSize;\nexports.writeSeq = writeSeq;\nexports.writeInt = writeInt;\nexports.writeVersion = writeVersion;","map":null,"metadata":{},"sourceType":"script"}