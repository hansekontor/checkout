{"ast":null,"code":"/*!\n * buffer-map.js - buffer map for javascript\n * Copyright (c) 2018, Christopher Jeffrey (MIT License).\n * https://github.com/chjj/buffer-map\n */\n\n/* global SharedArrayBuffer */\n'use strict';\n\nconst {\n  custom\n} = require('./custom');\n/**\n * Buffer Map\n */\n\n\nclass BufferMap {\n  constructor(iterable) {\n    this.map = new Map();\n\n    if (iterable != null) {\n      for (const [key, value] of iterable) this.set(key, value);\n    }\n  }\n\n  get size() {\n    return this.map.size;\n  }\n\n  get(key) {\n    const item = this.map.get(toBinary(key));\n    if (!item) return undefined;\n    return item.value;\n  }\n\n  has(key) {\n    return this.map.has(toBinary(key));\n  }\n\n  set(key, value) {\n    this.map.set(toBinary(key), new BufferItem(key, value));\n    return this;\n  }\n\n  delete(key) {\n    return this.map.delete(toBinary(key));\n  }\n\n  clear() {\n    this.map.clear();\n  }\n\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n\n  *entries() {\n    for (const {\n      key,\n      value\n    } of this.map.values()) yield [key, value];\n  }\n\n  *keys() {\n    for (const {\n      key\n    } of this.map.values()) yield key;\n  }\n\n  *values() {\n    for (const {\n      value\n    } of this.map.values()) yield value;\n  }\n\n  forEach(func, self) {\n    if (typeof func !== 'function') throw new TypeError(`${typeof func} is not a function`);\n\n    for (const {\n      key,\n      value\n    } of this.map.values()) func.call(self, value, key, this);\n  }\n\n  toKeys() {\n    const out = [];\n\n    for (const {\n      key\n    } of this.map.values()) out.push(key);\n\n    return out;\n  }\n\n  toValues() {\n    const out = [];\n\n    for (const {\n      value\n    } of this.map.values()) out.push(value);\n\n    return out;\n  }\n\n  toArray() {\n    return this.toValues();\n  }\n\n  [custom]() {\n    const map = new Map();\n\n    for (const {\n      key,\n      value\n    } of this.map.values()) map.set(toHex(key), value);\n\n    return map;\n  }\n\n}\n/**\n * Buffer Set\n */\n\n\nclass BufferSet {\n  constructor(iterable) {\n    this.map = new Map();\n\n    if (iterable != null) {\n      for (const key of iterable) this.add(key);\n    }\n  }\n\n  get size() {\n    return this.map.size;\n  }\n\n  has(key) {\n    return this.map.has(toBinary(key));\n  }\n\n  add(key) {\n    this.map.set(toBinary(key), key);\n    return this;\n  }\n\n  delete(key) {\n    return this.map.delete(toBinary(key));\n  }\n\n  clear() {\n    this.map.clear();\n  }\n\n  [Symbol.iterator]() {\n    return this.keys();\n  }\n\n  *entries() {\n    for (const key of this.map.values()) yield [key, key];\n  }\n\n  keys() {\n    return this.map.values();\n  }\n\n  values() {\n    return this.map.values();\n  }\n\n  forEach(func, self) {\n    if (typeof func !== 'function') throw new TypeError(`${typeof func} is not a function`);\n\n    for (const key of this.map.values()) func.call(self, key, key, this);\n  }\n\n  toKeys() {\n    const out = [];\n\n    for (const key of this.map.values()) out.push(key);\n\n    return out;\n  }\n\n  toValues() {\n    return this.toKeys();\n  }\n\n  toArray() {\n    return this.toKeys();\n  }\n\n  [custom]() {\n    const set = new Set();\n\n    for (const key of this.map.values()) set.add(toHex(key));\n\n    return set;\n  }\n\n}\n/**\n * Buffer Item\n */\n\n\nclass BufferItem {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n  }\n\n}\n/*\n * Helpers\n */\n\n\nconst HAS_SHARED_ARRAY_BUFFER = typeof SharedArrayBuffer === 'function';\n\nfunction isArrayBuffer(key) {\n  if (key instanceof ArrayBuffer) return true;\n\n  if (HAS_SHARED_ARRAY_BUFFER) {\n    if (key instanceof SharedArrayBuffer) return true;\n  }\n\n  return false;\n}\n\nfunction toBuffer(key) {\n  if (ArrayBuffer.isView(key)) return Buffer.from(key.buffer, key.byteOffset, key.byteLength);\n  if (isArrayBuffer(key)) return Buffer.from(key, 0, key.byteLength);\n  throw new TypeError('Non-buffer passed to buffer map/set.');\n}\n\nfunction encode(key, encoding) {\n  if (!Buffer.isBuffer(key)) key = toBuffer(key);\n  return key.toString(encoding);\n}\n\nfunction toBinary(key) {\n  return encode(key, 'binary');\n}\n\nfunction toHex(key) {\n  return encode(key, 'hex');\n}\n/*\n * Expose\n */\n\n\nexports.BufferMap = BufferMap;\nexports.BufferSet = BufferSet;","map":null,"metadata":{},"sourceType":"script"}