{"ast":null,"code":"/*!\n * message.js - message signing utilities.\n * Copyright (c) 2019, The Bcoin Developers (MIT License).\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bufio = require('bufio');\n\nconst hash256 = require('bcrypto/lib/hash256');\n\nconst secp256k1 = require('bcrypto/lib/secp256k1');\n/**\n * @exports utils/message\n */\n\n\nconst message = exports;\n/**\n * Bitcoin signing magic string.\n * @const {String}\n * @default\n */\n\nmessage.MAGIC_STRING = 'eCash Signed Message:\\n';\n/**\n * Hash message with magic string.\n * @param {String} message\n * @param {String} [prefix = message.MAGIC_STRING]\n * @returns {Hash}\n */\n\nmessage.magicHash = function (msg) {\n  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : message.MAGIC_STRING;\n  assert(typeof prefix === 'string', 'prefix must be a string.');\n  assert(typeof msg === 'string', 'message must be a string');\n  const bw = bufio.write();\n  bw.writeVarString(prefix);\n  bw.writeVarString(msg, 'utf8');\n  return hash256.digest(bw.render());\n};\n/**\n * Sign message with key.\n * @param {String} msg\n * @param {KeyRing} ring\n * @param {String} [prefix = message.MAGIC_STRING]\n * @returns {Buffer}\n */\n\n\nmessage.sign = (msg, ring, prefix) => {\n  assert(ring.getPrivateKey(), 'Cannot sign without private key.');\n  const hash = message.magicHash(msg, prefix);\n  const compress = 0x04 !== ring.getPublicKey().readInt8(0);\n  const [signature, recovery] = secp256k1.signRecoverable(hash, ring.getPrivateKey());\n  const bw = bufio.write();\n  bw.writeI8(recovery + 27 + (compress ? 4 : 0));\n  bw.writeBytes(signature);\n  return bw.render();\n};\n/**\n * Recover raw public key from message and signature.\n * @param {String} msg\n * @param {Buffer} signature\n * @param {String} [prefix = MAGIC_STRING]\n */\n\n\nmessage.recover = (msg, signature, prefix) => {\n  assert(typeof msg === 'string', 'msg must be a string');\n  assert(Buffer.isBuffer(signature), 'sig must be a buffer');\n  const hash = message.magicHash(msg, prefix);\n  assert.strictEqual(signature.length, 65, 'Invalid signature length');\n  const flagByte = signature.readUInt8(0) - 27;\n  assert(flagByte < 8, 'Invalid signature parameter');\n  const compressed = Boolean(flagByte & 4);\n  const recovery = flagByte & 3;\n  return secp256k1.recover(hash, signature.slice(1), recovery, compressed);\n};\n/**\n * Verify signature for message.\n * @param {String} msg\n * @param {Buffer} signature\n * @param {Buffer} publicKey\n * @param {String} [prefix = message.MAGIC_STRING]\n */\n\n\nmessage.verify = (msg, signature, publicKey, prefix) => {\n  const recoveredKey = message.recover(msg, signature);\n  assert(Buffer.isBuffer(publicKey), 'publicKey must be a buffer');\n  if (Buffer.compare(publicKey, recoveredKey) !== 0) return false;\n  return secp256k1.verify(message.magicHash(msg, prefix), signature.slice(1), publicKey);\n};","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/utils/message.js"],"names":["assert","require","bufio","hash256","secp256k1","message","exports","MAGIC_STRING","magicHash","msg","prefix","bw","write","writeVarString","digest","render","sign","ring","getPrivateKey","hash","compress","getPublicKey","readInt8","signature","recovery","signRecoverable","writeI8","writeBytes","recover","Buffer","isBuffer","strictEqual","length","flagByte","readUInt8","compressed","Boolean","slice","verify","publicKey","recoveredKey","compare"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,OAAD,CAAtB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAArB;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,uBAAD,CAAzB;AAEA;AACA;AACA;;;AAEA,MAAMI,OAAO,GAAGC,OAAhB;AAEA;AACA;AACA;AACA;AACA;;AAEAD,OAAO,CAACE,YAAR,GAAuB,yBAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEAF,OAAO,CAACG,SAAR,GAAoB,UAACC,GAAD,EAAwC;AAAA,MAAlCC,MAAkC,uEAAzBL,OAAO,CAACE,YAAiB;AAC1DP,EAAAA,MAAM,CAAC,OAAOU,MAAP,KAAkB,QAAnB,EAA6B,0BAA7B,CAAN;AACAV,EAAAA,MAAM,CAAC,OAAOS,GAAP,KAAe,QAAhB,EAA0B,0BAA1B,CAAN;AAEA,QAAME,EAAE,GAAGT,KAAK,CAACU,KAAN,EAAX;AAEAD,EAAAA,EAAE,CAACE,cAAH,CAAkBH,MAAlB;AACAC,EAAAA,EAAE,CAACE,cAAH,CAAkBJ,GAAlB,EAAuB,MAAvB;AAEA,SAAON,OAAO,CAACW,MAAR,CAAeH,EAAE,CAACI,MAAH,EAAf,CAAP;AACD,CAVD;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAV,OAAO,CAACW,IAAR,GAAe,CAACP,GAAD,EAAMQ,IAAN,EAAYP,MAAZ,KAAuB;AACpCV,EAAAA,MAAM,CAACiB,IAAI,CAACC,aAAL,EAAD,EAAuB,kCAAvB,CAAN;AAEA,QAAMC,IAAI,GAAGd,OAAO,CAACG,SAAR,CAAkBC,GAAlB,EAAuBC,MAAvB,CAAb;AACA,QAAMU,QAAQ,GAAG,SAASH,IAAI,CAACI,YAAL,GAAoBC,QAApB,CAA6B,CAA7B,CAA1B;AACA,QAAM,CACJC,SADI,EAEJC,QAFI,IAGFpB,SAAS,CAACqB,eAAV,CAA0BN,IAA1B,EAAgCF,IAAI,CAACC,aAAL,EAAhC,CAHJ;AAKA,QAAMP,EAAE,GAAGT,KAAK,CAACU,KAAN,EAAX;AAEAD,EAAAA,EAAE,CAACe,OAAH,CAAWF,QAAQ,GAAG,EAAX,IAAiBJ,QAAQ,GAAG,CAAH,GAAO,CAAhC,CAAX;AACAT,EAAAA,EAAE,CAACgB,UAAH,CAAcJ,SAAd;AAEA,SAAOZ,EAAE,CAACI,MAAH,EAAP;AACD,CAhBD;AAkBA;AACA;AACA;AACA;AACA;AACA;;;AAEAV,OAAO,CAACuB,OAAR,GAAkB,CAACnB,GAAD,EAAMc,SAAN,EAAiBb,MAAjB,KAA4B;AAC5CV,EAAAA,MAAM,CAAC,OAAOS,GAAP,KAAe,QAAhB,EAA0B,sBAA1B,CAAN;AACAT,EAAAA,MAAM,CAAC6B,MAAM,CAACC,QAAP,CAAgBP,SAAhB,CAAD,EAA6B,sBAA7B,CAAN;AAEA,QAAMJ,IAAI,GAAGd,OAAO,CAACG,SAAR,CAAkBC,GAAlB,EAAuBC,MAAvB,CAAb;AAEAV,EAAAA,MAAM,CAAC+B,WAAP,CAAmBR,SAAS,CAACS,MAA7B,EAAqC,EAArC,EAAyC,0BAAzC;AAEA,QAAMC,QAAQ,GAAGV,SAAS,CAACW,SAAV,CAAoB,CAApB,IAAyB,EAA1C;AAEAlC,EAAAA,MAAM,CAACiC,QAAQ,GAAG,CAAZ,EAAe,6BAAf,CAAN;AAEA,QAAME,UAAU,GAAGC,OAAO,CAACH,QAAQ,GAAG,CAAZ,CAA1B;AACA,QAAMT,QAAQ,GAAGS,QAAQ,GAAG,CAA5B;AAEA,SAAO7B,SAAS,CAACwB,OAAV,CAAkBT,IAAlB,EAAwBI,SAAS,CAACc,KAAV,CAAgB,CAAhB,CAAxB,EAA4Cb,QAA5C,EAAsDW,UAAtD,CAAP;AACD,CAhBD;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA9B,OAAO,CAACiC,MAAR,GAAiB,CAAC7B,GAAD,EAAMc,SAAN,EAAiBgB,SAAjB,EAA4B7B,MAA5B,KAAuC;AACpD,QAAM8B,YAAY,GAAGnC,OAAO,CAACuB,OAAR,CAAgBnB,GAAhB,EAAqBc,SAArB,CAArB;AAEAvB,EAAAA,MAAM,CAAC6B,MAAM,CAACC,QAAP,CAAgBS,SAAhB,CAAD,EAA6B,4BAA7B,CAAN;AAEA,MAAIV,MAAM,CAACY,OAAP,CAAeF,SAAf,EAA0BC,YAA1B,MAA4C,CAAhD,EACI,OAAO,KAAP;AAEJ,SAAOpC,SAAS,CAACkC,MAAV,CACHjC,OAAO,CAACG,SAAR,CAAkBC,GAAlB,EAAuBC,MAAvB,CADG,EAEHa,SAAS,CAACc,KAAV,CAAgB,CAAhB,CAFG,EAGHE,SAHG,CAAP;AAKH,CAbD","sourcesContent":["/*!\n * message.js - message signing utilities.\n * Copyright (c) 2019, The Bcoin Developers (MIT License).\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bufio = require('bufio');\nconst hash256 = require('bcrypto/lib/hash256');\nconst secp256k1 = require('bcrypto/lib/secp256k1');\n\n/**\n * @exports utils/message\n */\n\nconst message = exports;\n\n/**\n * Bitcoin signing magic string.\n * @const {String}\n * @default\n */\n\nmessage.MAGIC_STRING = 'eCash Signed Message:\\n';\n\n/**\n * Hash message with magic string.\n * @param {String} message\n * @param {String} [prefix = message.MAGIC_STRING]\n * @returns {Hash}\n */\n\nmessage.magicHash = (msg, prefix = message.MAGIC_STRING) => {\n  assert(typeof prefix === 'string', 'prefix must be a string.');\n  assert(typeof msg === 'string', 'message must be a string');\n\n  const bw = bufio.write();\n\n  bw.writeVarString(prefix);\n  bw.writeVarString(msg, 'utf8');\n\n  return hash256.digest(bw.render());\n};\n\n/**\n * Sign message with key.\n * @param {String} msg\n * @param {KeyRing} ring\n * @param {String} [prefix = message.MAGIC_STRING]\n * @returns {Buffer}\n */\n\nmessage.sign = (msg, ring, prefix) => {\n  assert(ring.getPrivateKey(), 'Cannot sign without private key.');\n\n  const hash = message.magicHash(msg, prefix);\n  const compress = 0x04 !== ring.getPublicKey().readInt8(0);\n  const [\n    signature,\n    recovery\n  ] = secp256k1.signRecoverable(hash, ring.getPrivateKey());\n\n  const bw = bufio.write();\n\n  bw.writeI8(recovery + 27 + (compress ? 4 : 0));\n  bw.writeBytes(signature);\n\n  return bw.render();\n};\n\n/**\n * Recover raw public key from message and signature.\n * @param {String} msg\n * @param {Buffer} signature\n * @param {String} [prefix = MAGIC_STRING]\n */\n\nmessage.recover = (msg, signature, prefix) => {\n  assert(typeof msg === 'string', 'msg must be a string');\n  assert(Buffer.isBuffer(signature), 'sig must be a buffer');\n\n  const hash = message.magicHash(msg, prefix);\n\n  assert.strictEqual(signature.length, 65, 'Invalid signature length');\n\n  const flagByte = signature.readUInt8(0) - 27;\n\n  assert(flagByte < 8, 'Invalid signature parameter');\n\n  const compressed = Boolean(flagByte & 4);\n  const recovery = flagByte & 3;\n\n  return secp256k1.recover(hash, signature.slice(1), recovery, compressed);\n};\n\n/**\n * Verify signature for message.\n * @param {String} msg\n * @param {Buffer} signature\n * @param {Buffer} publicKey\n * @param {String} [prefix = message.MAGIC_STRING]\n */\n\nmessage.verify = (msg, signature, publicKey, prefix) => {\n    const recoveredKey = message.recover(msg, signature);\n\n    assert(Buffer.isBuffer(publicKey), 'publicKey must be a buffer');\n\n    if (Buffer.compare(publicKey, recoveredKey) !== 0)\n        return false;\n\n    return secp256k1.verify(\n        message.magicHash(msg, prefix),\n        signature.slice(1),\n        publicKey\n    );\n}\n"]},"metadata":{},"sourceType":"module"}