{"ast":null,"code":"/*!\n * gcm.js - gcm for javascript\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on golang/go:\n *   Copyright (c) 2009, The Go Authors. All rights reserved.\n *   https://github.com/golang/go\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/Galois/Counter_Mode\n *   https://dx.doi.org/10.6028/NIST.SP.800-38D\n *   https://github.com/golang/go/blob/master/src/crypto/cipher/gcm.go\n *   https://github.com/golang/go/blob/master/src/crypto/cipher/gcm_test.go\n *   https://github.com/DaGenix/rust-crypto/blob/master/src/ghash.rs\n */\n'use strict';\n\nconst assert = require('../../internal/assert');\n/*\n * Constants\n */\n\n\nconst PADDING = Buffer.alloc(16, 0x00);\nconst FINALIZED = -1;\nconst REDUCTION = new Uint16Array([0x0000, 0x1c20, 0x3840, 0x2460, 0x7080, 0x6ca0, 0x48c0, 0x54e0, 0xe100, 0xfd20, 0xd940, 0xc560, 0x9180, 0x8da0, 0xa9c0, 0xb5e0]);\n/**\n * GHASH\n */\n\nclass GHASH {\n  constructor() {\n    this.state = new Uint32Array(4);\n    this.block = Buffer.alloc(16);\n    this.size = FINALIZED;\n    this.adLen = 0;\n    this.ctLen = 0;\n    this.table = new Array(16);\n\n    for (let i = 0; i < 16; i++) this.table[i] = new Uint32Array(4);\n  }\n\n  init(key) {\n    assert(Buffer.isBuffer(key));\n    assert(key.length === 16);\n\n    for (let i = 0; i < 4; i++) this.state[i] = 0;\n\n    this.size = 0;\n    this.adLen = 0;\n    this.ctLen = 0;\n\n    for (let i = 0; i < 16; i++) {\n      for (let j = 0; j < 4; j++) this.table[i][j] = 0;\n    }\n\n    const x = new Uint32Array(4);\n    x[1] = readU32(key, 0);\n    x[0] = readU32(key, 4);\n    x[3] = readU32(key, 8);\n    x[2] = readU32(key, 12);\n    this.table[reverse(1)] = x;\n\n    for (let i = 2; i < 16; i += 2) {\n      this.table[reverse(i)] = this.double(this.table[reverse(i >>> 1)]);\n      this.table[reverse(i + 1)] = this.add(this.table[reverse(i)], x);\n    }\n\n    return this;\n  }\n\n  absorb(data) {\n    this._absorb(data, data.length);\n\n    return this;\n  }\n\n  _absorb(data, len) {\n    assert(this.size !== FINALIZED, 'Context is not initialized.');\n    let pos = this.size & 15;\n    let off = 0;\n    this.size += len;\n\n    if (pos > 0) {\n      let want = 16 - pos;\n      if (want > len) want = len;\n      data.copy(this.block, pos, off, off + want);\n      pos += want;\n      len -= want;\n      off += want;\n      if (pos < 16) return;\n      this.transform(this.block, 0);\n    }\n\n    while (len >= 16) {\n      this.transform(data, off);\n      off += 16;\n      len -= 16;\n    }\n\n    if (len > 0) data.copy(this.block, 0, off, off + len);\n  }\n\n  transform(block, off) {\n    this.state[1] ^= readU32(block, off + 0);\n    this.state[0] ^= readU32(block, off + 4);\n    this.state[3] ^= readU32(block, off + 8);\n    this.state[2] ^= readU32(block, off + 12);\n    this.mul(this.state);\n  }\n\n  pad() {\n    const pos = this.size & 15;\n    if (pos !== 0) this._absorb(PADDING, 16 - pos);\n  }\n\n  aad(data) {\n    assert(Buffer.isBuffer(data));\n    assert(this.ctLen === 0);\n    this.adLen += data.length;\n    return this.absorb(data);\n  }\n\n  update(data) {\n    assert(Buffer.isBuffer(data));\n    if (data.length === 0) return this;\n    if (this.ctLen === 0) this.pad();\n    this.ctLen += data.length;\n    return this.absorb(data);\n  }\n\n  final() {\n    const out = Buffer.alloc(16);\n    this.pad();\n    const adLen = this.adLen * 8;\n    const ctLen = this.ctLen * 8;\n    this.state[1] ^= hi32(adLen);\n    this.state[0] ^= lo32(adLen);\n    this.state[3] ^= hi32(ctLen);\n    this.state[2] ^= lo32(ctLen);\n    this.mul(this.state);\n    writeU32(out, this.state[1], 0);\n    writeU32(out, this.state[0], 4);\n    writeU32(out, this.state[3], 8);\n    writeU32(out, this.state[2], 12);\n\n    for (let i = 0; i < 4; i++) this.state[i] = 0;\n\n    for (let i = 0; i < 16; i++) this.block[i] = 0;\n\n    this.size = FINALIZED;\n    this.adLen = 0;\n    this.ctLen = 0;\n\n    for (let i = 0; i < 16; i++) {\n      for (let j = 0; j < 4; j++) this.table[i][j] = 0;\n    }\n\n    return out;\n  }\n\n  destroy() {\n    for (let i = 0; i < 4; i++) this.state[i] = 0;\n\n    for (let i = 0; i < 16; i++) this.block[i] = 0;\n\n    this.size = FINALIZED;\n    this.adLen = 0;\n    this.ctLen = 0;\n\n    for (let i = 0; i < 16; i++) {\n      for (let j = 0; j < 4; j++) this.table[i][j] = 0;\n    }\n  }\n\n  add(x, y) {\n    assert(x instanceof Uint32Array);\n    assert(x.length === 4);\n    assert(y instanceof Uint32Array);\n    assert(y.length === 4);\n    const z = new Uint32Array(4);\n    z[0] = x[0] ^ y[0];\n    z[1] = x[1] ^ y[1];\n    z[2] = x[2] ^ y[2];\n    z[3] = x[3] ^ y[3];\n    return z;\n  }\n\n  double(x) {\n    assert(x instanceof Uint32Array);\n    assert(x.length === 4);\n    const d = new Uint32Array(4);\n    const msb = (x[2] & 1) === 1;\n    let v;\n    d[3] = x[3];\n    d[2] = x[2];\n    v = d[3] & 1;\n    d[3] >>>= 1;\n    d[2] >>>= 1;\n    d[2] |= v << 31;\n    d[3] |= (x[0] & 1) << 31;\n    d[1] = x[1];\n    d[0] = x[0];\n    v = d[1] & 1;\n    d[1] >>>= 1;\n    d[0] >>>= 1;\n    d[0] |= v << 31;\n\n    if (msb) {\n      d[1] ^= 0xe1000000;\n      d[0] ^= 0x00000000;\n    }\n\n    return d;\n  }\n\n  mul(y) {\n    assert(y instanceof Uint32Array);\n    assert(y.length === 4);\n    const z = new Uint32Array(4);\n    const w = new Uint32Array(2);\n    let v, t;\n\n    for (let i = 0; i < 2; i++) {\n      w[0] = y[2];\n      w[1] = y[3];\n\n      if (i === 1) {\n        w[0] = y[0];\n        w[1] = y[1];\n      }\n\n      for (let j = 0; j < 64; j += 4) {\n        const msw = z[2] & 0x0f;\n        v = z[3] & 0x0f;\n        z[3] >>>= 4;\n        z[2] >>>= 4;\n        z[2] |= v << 28;\n        z[3] |= z[0] << 28;\n        v = z[1] & 0x0f;\n        z[1] >>>= 4;\n        z[0] >>>= 4;\n        z[0] |= v << 28;\n        z[1] ^= REDUCTION[msw] << 16;\n        t = this.table[w[0] & 0x0f];\n        z[0] ^= t[0];\n        z[1] ^= t[1];\n        z[2] ^= t[2];\n        z[3] ^= t[3];\n        v = w[1] & 0x0f;\n        w[1] >>>= 4;\n        w[0] >>>= 4;\n        w[0] |= v << 28;\n      }\n    }\n\n    y[0] = z[0];\n    y[1] = z[1];\n    y[2] = z[2];\n    y[3] = z[3];\n  }\n\n}\n/**\n * CTR\n */\n\n\nclass CTR {\n  constructor(ctx) {\n    assert(ctx && typeof ctx === 'object');\n    assert(typeof ctx.blockSize === 'number');\n    if (ctx.blockSize !== 16) throw new Error('GCM only available with a 128 bit block size.');\n    this.ctx = ctx;\n    this.state = Buffer.alloc(16);\n    this.block = Buffer.alloc(16);\n    this.pos = 0;\n  }\n\n  init(key) {\n    this.ctx.init(key);\n\n    for (let i = 0; i < 16; i++) this.state[i] = 0;\n\n    this.pos = 0;\n    return this;\n  }\n\n  set(nonce) {\n    assert(Buffer.isBuffer(nonce));\n    assert(nonce.length === 12 || nonce.length === 16);\n    this.state[0] = nonce[0];\n    this.state[1] = nonce[1];\n    this.state[2] = nonce[2];\n    this.state[3] = nonce[3];\n    this.state[4] = nonce[4];\n    this.state[5] = nonce[5];\n    this.state[6] = nonce[6];\n    this.state[7] = nonce[7];\n    this.state[8] = nonce[8];\n    this.state[9] = nonce[9];\n    this.state[10] = nonce[10];\n    this.state[11] = nonce[11];\n\n    if (nonce.length === 16) {\n      this.state[12] = nonce[12];\n      this.state[13] = nonce[13];\n      this.state[14] = nonce[14];\n      this.state[15] = nonce[15];\n    } else {\n      this.state[12] = 0x00;\n      this.state[13] = 0x00;\n      this.state[14] = 0x00;\n      this.state[15] = 0x01;\n    }\n\n    return this;\n  }\n\n  encrypt(data) {\n    assert(Buffer.isBuffer(data));\n\n    for (let i = 0; i < data.length; i++) {\n      if ((this.pos & 15) === 0) {\n        this.ctx.encrypt(this.state, 0, this.block, 0);\n\n        for (let j = 15; j >= 12; j--) {\n          this.state[j] += 1;\n          if (this.state[j] !== 0) break;\n        }\n\n        this.pos = 0;\n      }\n\n      data[i] ^= this.block[this.pos++];\n    }\n\n    return data;\n  }\n\n  destroy() {\n    this.ctx.destroy();\n\n    for (let i = 0; i < 16; i++) {\n      this.state[i] = 0;\n      this.block[i] = 0;\n    }\n\n    this.pos = 0;\n    return this;\n  }\n\n}\n/**\n * GCM\n */\n\n\nclass GCM {\n  constructor(ctx) {\n    this.cipher = new CTR(ctx);\n    this.mac = new GHASH();\n    this.key = Buffer.alloc(16);\n    this.mask = Buffer.alloc(16);\n    this.mode = -1;\n  }\n\n  init(key, iv) {\n    assert(Buffer.isBuffer(iv));\n\n    for (let i = 0; i < 16; i++) {\n      this.key[i] = 0;\n      this.mask[i] = 0;\n    }\n\n    this.mode = 0;\n    this.cipher.init(key);\n    this.cipher.encrypt(this.key);\n    this.mac.init(this.key); // Full round of ghash with same key.\n\n    if (iv.length !== 12) {\n      this.mac.update(iv);\n      iv = this.mac.final();\n      this.mac.init(this.key);\n    }\n\n    this.cipher.set(iv);\n    this.cipher.encrypt(this.mask);\n    return this;\n  }\n\n  aad(data) {\n    if (this.mode === -1) throw new Error('Cipher is not initialized.');\n    if (this.mode !== 0) throw new Error('Invalid state for aad.');\n    this.mac.aad(data);\n    return this;\n  }\n\n  encrypt(data) {\n    if (this.mode === -1) throw new Error('Cipher is not initialized.');\n    if (this.mode !== 0 && this.mode !== 1) throw new Error('Invalid state for encrypt.');\n    this.mode = 1;\n    this.cipher.encrypt(data);\n    this.mac.update(data);\n    return data;\n  }\n\n  decrypt(data) {\n    if (this.mode === -1) throw new Error('Cipher is not initialized.');\n    if (this.mode !== 0 && this.mode !== 2) throw new Error('Invalid state for decrypt.');\n    this.mode = 2;\n    this.mac.update(data);\n    this.cipher.encrypt(data);\n    return data;\n  }\n\n  auth(data) {\n    if (this.mode === -1) throw new Error('Cipher is not initialized.');\n    if (this.mode !== 0 && this.mode !== 3) throw new Error('Invalid state for auth.');\n    this.mode = 3;\n    this.mac.update(data);\n    return data;\n  }\n\n  final() {\n    let size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;\n    assert(size >>> 0 === size);\n    assert(size === 4 || size === 8 || size >= 12 && size <= 16);\n    if (this.mode === -1) throw new Error('Cipher is not initialized.');\n    const mac = this.mac.final();\n\n    for (let i = 0; i < 16; i++) mac[i] ^= this.mask[i];\n\n    this.mode = -1;\n    return mac.slice(0, size);\n  }\n\n  verify(tag) {\n    assert(Buffer.isBuffer(tag));\n    const mac = this.final(tag.length);\n    let z = 0;\n\n    for (let i = 0; i < mac.length; i++) z |= mac[i] ^ tag[i];\n\n    return z - 1 >>> 31 !== 0;\n  }\n\n  destroy() {\n    this.cipher.destroy();\n    this.mac.destroy();\n\n    for (let i = 0; i < 16; i++) {\n      this.key[i] = 0;\n      this.mask[i] = 0;\n    }\n\n    this.mode = -1;\n  }\n\n}\n/*\n * Helpers\n */\n\n\nfunction hi32(num) {\n  return num * (1 / 0x100000000) >>> 0;\n}\n\nfunction lo32(num) {\n  return num >>> 0;\n}\n\nfunction reverse(i) {\n  i = i << 2 & 0x0c | i >>> 2 & 0x03;\n  i = i << 1 & 0x0a | i >>> 1 & 0x05;\n  return i;\n}\n\nfunction readU32(data, off) {\n  return data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off++];\n}\n\nfunction writeU32(dst, num, off) {\n  dst[off++] = num >>> 24;\n  dst[off++] = num >>> 16;\n  dst[off++] = num >>> 8;\n  dst[off++] = num;\n  return off;\n}\n/*\n * Expose\n */\n\n\nexports.GHASH = GHASH;\nexports.CTR = CTR;\nexports.GCM = GCM;","map":null,"metadata":{},"sourceType":"script"}