{"ast":null,"code":"/*!\n * private.js - hd private keys for bcoin\n * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bio = require('bufio');\n\nconst {\n  base58\n} = require('bstring');\n\nconst sha512 = require('bcrypto/lib/sha512');\n\nconst hash160 = require('bcrypto/lib/hash160');\n\nconst hash256 = require('bcrypto/lib/hash256');\n\nconst cleanse = require('bcrypto/lib/cleanse');\n\nconst random = require('bcrypto/lib/random');\n\nconst secp256k1 = require('bcrypto/lib/secp256k1');\n\nconst Network = require('../protocol/network');\n\nconst consensus = require('../protocol/consensus');\n\nconst common = require('./common');\n\nconst Mnemonic = require('./mnemonic');\n\nconst HDPublicKey = require('./public');\n/*\n * Constants\n */\n\n\nconst SEED_SALT = Buffer.from('Bitcoin seed', 'ascii');\n/**\n * HDPrivateKey\n * @alias module:hd.PrivateKey\n * @property {Number} depth\n * @property {Number} parentFingerPrint\n * @property {Number} childIndex\n * @property {Buffer} chainCode\n * @property {Buffer} privateKey\n */\n\nclass HDPrivateKey {\n  /**\n   * Create an hd private key.\n   * @constructor\n   * @param {Object|String} options\n   * @param {Number?} options.depth\n   * @param {Number?} options.parentFingerPrint\n   * @param {Number?} options.childIndex\n   * @param {Buffer?} options.chainCode\n   * @param {Buffer?} options.privateKey\n   */\n  constructor(options) {\n    this.depth = 0;\n    this.parentFingerPrint = 0;\n    this.childIndex = 0;\n    this.chainCode = consensus.ZERO_HASH;\n    this.privateKey = consensus.ZERO_HASH;\n    this.publicKey = common.ZERO_KEY;\n    this.fingerPrint = -1;\n    this._hdPublicKey = null;\n    if (options) this.fromOptions(options);\n  }\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n\n  fromOptions(options) {\n    assert(options, 'No options for HD private key.');\n    assert((options.depth & 0xff) === options.depth);\n    assert(options.parentFingerPrint >>> 0 === options.parentFingerPrint);\n    assert(options.childIndex >>> 0 === options.childIndex);\n    assert(Buffer.isBuffer(options.chainCode));\n    assert(Buffer.isBuffer(options.privateKey));\n    this.depth = options.depth;\n    this.parentFingerPrint = options.parentFingerPrint;\n    this.childIndex = options.childIndex;\n    this.chainCode = options.chainCode;\n    this.privateKey = options.privateKey;\n    this.publicKey = secp256k1.publicKeyCreate(options.privateKey, true);\n    return this;\n  }\n  /**\n   * Instantiate HD private key from options object.\n   * @param {Object} options\n   * @returns {HDPrivateKey}\n   */\n\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n  /**\n   * Get HD public key.\n   * @returns {HDPublicKey}\n   */\n\n\n  toPublic() {\n    let key = this._hdPublicKey;\n\n    if (!key) {\n      key = new HDPublicKey();\n      key.depth = this.depth;\n      key.parentFingerPrint = this.parentFingerPrint;\n      key.childIndex = this.childIndex;\n      key.chainCode = this.chainCode;\n      key.publicKey = this.publicKey;\n      this._hdPublicKey = key;\n    }\n\n    return key;\n  }\n  /**\n   * Get cached base58 xprivkey.\n   * @returns {Base58String}\n   */\n\n\n  xprivkey(network) {\n    return this.toBase58(network);\n  }\n  /**\n   * Get cached base58 xpubkey.\n   * @returns {Base58String}\n   */\n\n\n  xpubkey(network) {\n    return this.toPublic().xpubkey(network);\n  }\n  /**\n   * Destroy the key (zeroes chain code, privkey, and pubkey).\n   * @param {Boolean} pub - Destroy hd public key as well.\n   */\n\n\n  destroy(pub) {\n    this.depth = 0;\n    this.childIndex = 0;\n    this.parentFingerPrint = 0;\n    cleanse(this.chainCode);\n    cleanse(this.privateKey);\n    cleanse(this.publicKey);\n    this.fingerPrint = -1;\n\n    if (this._hdPublicKey) {\n      if (pub) this._hdPublicKey.destroy();\n      this._hdPublicKey = null;\n    }\n  }\n  /**\n   * Derive a child key.\n   * @param {Number} index - Derivation index.\n   * @param {Boolean?} hardened - Whether the derivation should be hardened.\n   * @returns {HDPrivateKey}\n   */\n\n\n  derive(index, hardened) {\n    assert(typeof index === 'number');\n    if (index >>> 0 !== index) throw new Error('Index out of range.');\n    if (this.depth >= 0xff) throw new Error('Depth too high.');\n\n    if (hardened) {\n      index |= common.HARDENED;\n      index >>>= 0;\n    }\n\n    const id = this.getID(index);\n    const cache = common.cache.get(id);\n    if (cache) return cache;\n    const bw = bio.pool(37);\n\n    if (index & common.HARDENED) {\n      bw.writeU8(0);\n      bw.writeBytes(this.privateKey);\n      bw.writeU32BE(index);\n    } else {\n      bw.writeBytes(this.publicKey);\n      bw.writeU32BE(index);\n    }\n\n    const data = bw.render();\n    const hash = sha512.mac(data, this.chainCode);\n    const left = hash.slice(0, 32);\n    const right = hash.slice(32, 64);\n    let key;\n\n    try {\n      key = secp256k1.privateKeyTweakAdd(this.privateKey, left);\n    } catch (e) {\n      return this.derive(index + 1);\n    }\n\n    if (this.fingerPrint === -1) {\n      const fp = hash160.digest(this.publicKey);\n      this.fingerPrint = fp.readUInt32BE(0, true);\n    }\n\n    const child = new this.constructor();\n    child.depth = this.depth + 1;\n    child.parentFingerPrint = this.fingerPrint;\n    child.childIndex = index;\n    child.chainCode = right;\n    child.privateKey = key;\n    child.publicKey = secp256k1.publicKeyCreate(key, true);\n    common.cache.set(id, child);\n    return child;\n  }\n  /**\n   * Unique HD key ID.\n   * @private\n   * @param {Number} index\n   * @returns {String}\n   */\n\n\n  getID(index) {\n    return 'v' + this.publicKey.toString('hex') + index;\n  }\n  /**\n   * Derive a BIP44 account key.\n   * @param {Number} purpose\n   * @param {Number} type\n   * @param {Number} account\n   * @returns {HDPrivateKey}\n   * @throws Error if key is not a master key.\n   */\n\n\n  deriveAccount(purpose, type, account) {\n    assert(purpose >>> 0 === purpose, 'Purpose must be a number.');\n    assert(type >>> 0 === type, 'Account index must be a number.');\n    assert(account >>> 0 === account, 'Account index must be a number.');\n    assert(this.isMaster(), 'Cannot derive account index.');\n    return this.derive(purpose, true).derive(type, true).derive(account, true);\n  }\n  /**\n   * Test whether the key is a master key.\n   * @returns {Boolean}\n   */\n\n\n  isMaster() {\n    return common.isMaster(this);\n  }\n  /**\n   * Test whether the key is (most likely) a BIP44 account key.\n   * @param {Number?} account\n   * @returns {Boolean}\n   */\n\n\n  isAccount(account) {\n    return common.isAccount(this, account);\n  }\n  /**\n   * Test whether an object is in the form of a base58 xprivkey.\n   * @param {String} data\n   * @param {Network?} network\n   * @returns {Boolean}\n   */\n\n\n  static isBase58(data, network) {\n    if (typeof data !== 'string') return false;\n    if (data.length < 4) return false;\n    const prefix = data.substring(0, 4);\n\n    try {\n      Network.fromPrivate58(prefix, network);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n   * Test whether a buffer has a valid network prefix.\n   * @param {Buffer} data\n   * @param {Network?} network\n   * @returns {Boolean}\n   */\n\n\n  static isRaw(data, network) {\n    if (!Buffer.isBuffer(data)) return false;\n    if (data.length < 4) return false;\n    const version = data.readUInt32BE(0, true);\n\n    try {\n      Network.fromPrivate(version, network);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n   * Test whether a string is a valid path.\n   * @param {String} path\n   * @returns {Boolean}\n   */\n\n\n  static isValidPath(path) {\n    try {\n      common.parsePath(path, true);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n   * Derive a key from a derivation path.\n   * @param {String} path\n   * @returns {HDPrivateKey}\n   * @throws Error if `path` is not a valid path.\n   */\n\n\n  derivePath(path) {\n    const indexes = common.parsePath(path, true);\n    let key = this;\n\n    for (const index of indexes) key = key.derive(index);\n\n    return key;\n  }\n  /**\n   * Compare a key against an object.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n\n  equals(obj) {\n    assert(HDPrivateKey.isHDPrivateKey(obj));\n    return this.depth === obj.depth && this.parentFingerPrint === obj.parentFingerPrint && this.childIndex === obj.childIndex && this.chainCode.equals(obj.chainCode) && this.privateKey.equals(obj.privateKey);\n  }\n  /**\n   * Compare a key against an object.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n\n  compare(key) {\n    assert(HDPrivateKey.isHDPrivateKey(key));\n    let cmp = this.depth - key.depth;\n    if (cmp !== 0) return cmp;\n    cmp = this.parentFingerPrint - key.parentFingerPrint;\n    if (cmp !== 0) return cmp;\n    cmp = this.childIndex - key.childIndex;\n    if (cmp !== 0) return cmp;\n    cmp = this.chainCode.compare(key.chainCode);\n    if (cmp !== 0) return cmp;\n    cmp = this.privateKey.compare(key.privateKey);\n    if (cmp !== 0) return cmp;\n    return 0;\n  }\n  /**\n   * Inject properties from seed.\n   * @private\n   * @param {Buffer} seed\n   */\n\n\n  fromSeed(seed) {\n    assert(Buffer.isBuffer(seed));\n\n    if (seed.length * 8 < common.MIN_ENTROPY || seed.length * 8 > common.MAX_ENTROPY) {\n      throw new Error('Entropy not in range.');\n    }\n\n    const hash = sha512.mac(seed, SEED_SALT);\n    const left = hash.slice(0, 32);\n    const right = hash.slice(32, 64); // Only a 1 in 2^127 chance of happening.\n\n    if (!secp256k1.privateKeyVerify(left)) throw new Error('Master private key is invalid.');\n    this.depth = 0;\n    this.parentFingerPrint = 0;\n    this.childIndex = 0;\n    this.chainCode = right;\n    this.privateKey = left;\n    this.publicKey = secp256k1.publicKeyCreate(left, true);\n    return this;\n  }\n  /**\n   * Instantiate an hd private key from a 512 bit seed.\n   * @param {Buffer} seed\n   * @returns {HDPrivateKey}\n   */\n\n\n  static fromSeed(seed) {\n    return new this().fromSeed(seed);\n  }\n  /**\n   * Inject properties from a mnemonic.\n   * @private\n   * @param {Mnemonic} mnemonic\n   * @param {String?} passphrase\n   */\n\n\n  fromMnemonic(mnemonic, passphrase) {\n    assert(mnemonic instanceof Mnemonic);\n    return this.fromSeed(mnemonic.toSeed(passphrase));\n  }\n  /**\n   * Instantiate an hd private key from a mnemonic.\n   * @param {Mnemonic} mnemonic\n   * @param {String?} passphrase\n   * @returns {HDPrivateKey}\n   */\n\n\n  static fromMnemonic(mnemonic, passphrase) {\n    return new this().fromMnemonic(mnemonic, passphrase);\n  }\n  /**\n   * Inject properties from a mnemonic.\n   * @private\n   * @param {String} mnemonic\n   */\n\n\n  fromPhrase(phrase) {\n    const mnemonic = Mnemonic.fromPhrase(phrase);\n    this.fromMnemonic(mnemonic);\n    return this;\n  }\n  /**\n   * Instantiate an hd private key from a phrase.\n   * @param {String} phrase\n   * @returns {HDPrivateKey}\n   */\n\n\n  static fromPhrase(phrase) {\n    return new this().fromPhrase(phrase);\n  }\n  /**\n   * Inject properties from privateKey and entropy.\n   * @private\n   * @param {Buffer} key\n   * @param {Buffer} entropy\n   */\n\n\n  fromKey(key, entropy) {\n    assert(Buffer.isBuffer(key) && key.length === 32);\n    assert(Buffer.isBuffer(entropy) && entropy.length === 32);\n    this.depth = 0;\n    this.parentFingerPrint = 0;\n    this.childIndex = 0;\n    this.chainCode = entropy;\n    this.privateKey = key;\n    this.publicKey = secp256k1.publicKeyCreate(key, true);\n    return this;\n  }\n  /**\n   * Create an hd private key from a key and entropy bytes.\n   * @param {Buffer} key\n   * @param {Buffer} entropy\n   * @returns {HDPrivateKey}\n   */\n\n\n  static fromKey(key, entropy) {\n    return new this().fromKey(key, entropy);\n  }\n  /**\n   * Generate an hd private key.\n   * @returns {HDPrivateKey}\n   */\n\n\n  static generate() {\n    const key = secp256k1.privateKeyGenerate();\n    const entropy = random.randomBytes(32);\n    return HDPrivateKey.fromKey(key, entropy);\n  }\n  /**\n   * Inject properties from base58 key.\n   * @private\n   * @param {Base58String} xkey\n   * @param {Network?} network\n   */\n\n\n  fromBase58(xkey, network) {\n    assert(typeof xkey === 'string');\n    return this.fromRaw(base58.decode(xkey), network);\n  }\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {BufferReader} br\n   * @param {(Network|NetworkType)?} network\n   */\n\n\n  fromReader(br, network) {\n    const version = br.readU32BE();\n    Network.fromPrivate(version, network);\n    this.depth = br.readU8();\n    this.parentFingerPrint = br.readU32BE();\n    this.childIndex = br.readU32BE();\n    this.chainCode = br.readBytes(32);\n    assert(br.readU8() === 0);\n    this.privateKey = br.readBytes(32);\n    this.publicKey = secp256k1.publicKeyCreate(this.privateKey, true);\n    br.verifyChecksum(hash256.digest);\n    return this;\n  }\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   * @param {(Network|NetworkType)?} network\n   */\n\n\n  fromRaw(data, network) {\n    return this.fromReader(bio.read(data), network);\n  }\n  /**\n   * Serialize key to a base58 string.\n   * @param {(Network|NetworkType)?} network\n   * @returns {Base58String}\n   */\n\n\n  toBase58(network) {\n    return base58.encode(this.toRaw(network));\n  }\n  /**\n   * Calculate serialization size.\n   * @returns {Number}\n   */\n\n\n  getSize() {\n    return 82;\n  }\n  /**\n   * Write the key to a buffer writer.\n   * @param {BufferWriter} bw\n   * @param {(Network|NetworkType)?} network\n   */\n\n\n  toWriter(bw, network) {\n    network = Network.get(network);\n    bw.writeU32BE(network.keyPrefix.xprivkey);\n    bw.writeU8(this.depth);\n    bw.writeU32BE(this.parentFingerPrint);\n    bw.writeU32BE(this.childIndex);\n    bw.writeBytes(this.chainCode);\n    bw.writeU8(0);\n    bw.writeBytes(this.privateKey);\n    bw.writeChecksum(hash256.digest);\n    return bw;\n  }\n  /**\n   * Serialize the key.\n   * @param {(Network|NetworkType)?} network\n   * @returns {Buffer}\n   */\n\n\n  toRaw(network) {\n    return this.toWriter(bio.write(82), network).render();\n  }\n  /**\n   * Instantiate an HD private key from a base58 string.\n   * @param {Base58String} xkey\n   * @param {Network?} network\n   * @returns {HDPrivateKey}\n   */\n\n\n  static fromBase58(xkey, network) {\n    return new this().fromBase58(xkey, network);\n  }\n  /**\n   * Instantiate key from buffer reader.\n   * @param {BufferReader} br\n   * @param {(Network|NetworkType)?} network\n   * @returns {HDPrivateKey}\n   */\n\n\n  static fromReader(br, network) {\n    return new this().fromReader(br, network);\n  }\n  /**\n   * Instantiate key from serialized data.\n   * @param {Buffer} data\n   * @param {(Network|NetworkType)?} network\n   * @returns {HDPrivateKey}\n   */\n\n\n  static fromRaw(data, network) {\n    return new this().fromRaw(data, network);\n  }\n  /**\n   * Convert key to a more json-friendly object.\n   * @returns {Object}\n   */\n\n\n  toJSON(network) {\n    return {\n      xprivkey: this.xprivkey(network)\n    };\n  }\n  /**\n   * Inject properties from json object.\n   * @private\n   * @param {Object} json\n   * @param {Network?} network\n   */\n\n\n  fromJSON(json, network) {\n    assert(json.xprivkey, 'Could not handle key JSON.');\n    this.fromBase58(json.xprivkey, network);\n    return this;\n  }\n  /**\n   * Instantiate an HDPrivateKey from a jsonified key object.\n   * @param {Object} json - The jsonified key object.\n   * @param {Network?} network\n   * @returns {HDPrivateKey}\n   */\n\n\n  static fromJSON(json, network) {\n    return new this().fromJSON(json, network);\n  }\n  /**\n   * Test whether an object is an HDPrivateKey.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n\n  static isHDPrivateKey(obj) {\n    return obj instanceof HDPrivateKey;\n  }\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = HDPrivateKey;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/hd/private.js"],"names":["assert","require","bio","base58","sha512","hash160","hash256","cleanse","random","secp256k1","Network","consensus","common","Mnemonic","HDPublicKey","SEED_SALT","Buffer","from","HDPrivateKey","constructor","options","depth","parentFingerPrint","childIndex","chainCode","ZERO_HASH","privateKey","publicKey","ZERO_KEY","fingerPrint","_hdPublicKey","fromOptions","isBuffer","publicKeyCreate","toPublic","key","xprivkey","network","toBase58","xpubkey","destroy","pub","derive","index","hardened","Error","HARDENED","id","getID","cache","get","bw","pool","writeU8","writeBytes","writeU32BE","data","render","hash","mac","left","slice","right","privateKeyTweakAdd","e","fp","digest","readUInt32BE","child","set","toString","deriveAccount","purpose","type","account","isMaster","isAccount","isBase58","length","prefix","substring","fromPrivate58","isRaw","version","fromPrivate","isValidPath","path","parsePath","derivePath","indexes","equals","obj","isHDPrivateKey","compare","cmp","fromSeed","seed","MIN_ENTROPY","MAX_ENTROPY","privateKeyVerify","fromMnemonic","mnemonic","passphrase","toSeed","fromPhrase","phrase","fromKey","entropy","generate","privateKeyGenerate","randomBytes","fromBase58","xkey","fromRaw","decode","fromReader","br","readU32BE","readU8","readBytes","verifyChecksum","read","encode","toRaw","getSize","toWriter","keyPrefix","writeChecksum","write","toJSON","fromJSON","json","module","exports"],"mappings":"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","sourcesContent":["/*!\n * private.js - hd private keys for bcoin\n * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bio = require('bufio');\nconst {base58} = require('bstring');\nconst sha512 = require('bcrypto/lib/sha512');\nconst hash160 = require('bcrypto/lib/hash160');\nconst hash256 = require('bcrypto/lib/hash256');\nconst cleanse = require('bcrypto/lib/cleanse');\nconst random = require('bcrypto/lib/random');\nconst secp256k1 = require('bcrypto/lib/secp256k1');\nconst Network = require('../protocol/network');\nconst consensus = require('../protocol/consensus');\nconst common = require('./common');\nconst Mnemonic = require('./mnemonic');\nconst HDPublicKey = require('./public');\n\n/*\n * Constants\n */\n\nconst SEED_SALT = Buffer.from('Bitcoin seed', 'ascii');\n\n/**\n * HDPrivateKey\n * @alias module:hd.PrivateKey\n * @property {Number} depth\n * @property {Number} parentFingerPrint\n * @property {Number} childIndex\n * @property {Buffer} chainCode\n * @property {Buffer} privateKey\n */\n\nclass HDPrivateKey {\n  /**\n   * Create an hd private key.\n   * @constructor\n   * @param {Object|String} options\n   * @param {Number?} options.depth\n   * @param {Number?} options.parentFingerPrint\n   * @param {Number?} options.childIndex\n   * @param {Buffer?} options.chainCode\n   * @param {Buffer?} options.privateKey\n   */\n\n  constructor(options) {\n    this.depth = 0;\n    this.parentFingerPrint = 0;\n    this.childIndex = 0;\n    this.chainCode = consensus.ZERO_HASH;\n    this.privateKey = consensus.ZERO_HASH;\n\n    this.publicKey = common.ZERO_KEY;\n    this.fingerPrint = -1;\n\n    this._hdPublicKey = null;\n\n    if (options)\n      this.fromOptions(options);\n  }\n\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n  fromOptions(options) {\n    assert(options, 'No options for HD private key.');\n    assert((options.depth & 0xff) === options.depth);\n    assert((options.parentFingerPrint >>> 0) === options.parentFingerPrint);\n    assert((options.childIndex >>> 0) === options.childIndex);\n    assert(Buffer.isBuffer(options.chainCode));\n    assert(Buffer.isBuffer(options.privateKey));\n\n    this.depth = options.depth;\n    this.parentFingerPrint = options.parentFingerPrint;\n    this.childIndex = options.childIndex;\n    this.chainCode = options.chainCode;\n    this.privateKey = options.privateKey;\n    this.publicKey = secp256k1.publicKeyCreate(options.privateKey, true);\n\n    return this;\n  }\n\n  /**\n   * Instantiate HD private key from options object.\n   * @param {Object} options\n   * @returns {HDPrivateKey}\n   */\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n\n  /**\n   * Get HD public key.\n   * @returns {HDPublicKey}\n   */\n\n  toPublic() {\n    let key = this._hdPublicKey;\n\n    if (!key) {\n      key = new HDPublicKey();\n      key.depth = this.depth;\n      key.parentFingerPrint = this.parentFingerPrint;\n      key.childIndex = this.childIndex;\n      key.chainCode = this.chainCode;\n      key.publicKey = this.publicKey;\n      this._hdPublicKey = key;\n    }\n\n    return key;\n  }\n\n  /**\n   * Get cached base58 xprivkey.\n   * @returns {Base58String}\n   */\n\n  xprivkey(network) {\n    return this.toBase58(network);\n  }\n\n  /**\n   * Get cached base58 xpubkey.\n   * @returns {Base58String}\n   */\n\n  xpubkey(network) {\n    return this.toPublic().xpubkey(network);\n  }\n\n  /**\n   * Destroy the key (zeroes chain code, privkey, and pubkey).\n   * @param {Boolean} pub - Destroy hd public key as well.\n   */\n\n  destroy(pub) {\n    this.depth = 0;\n    this.childIndex = 0;\n    this.parentFingerPrint = 0;\n\n    cleanse(this.chainCode);\n    cleanse(this.privateKey);\n    cleanse(this.publicKey);\n\n    this.fingerPrint = -1;\n\n    if (this._hdPublicKey) {\n      if (pub)\n        this._hdPublicKey.destroy();\n      this._hdPublicKey = null;\n    }\n  }\n\n  /**\n   * Derive a child key.\n   * @param {Number} index - Derivation index.\n   * @param {Boolean?} hardened - Whether the derivation should be hardened.\n   * @returns {HDPrivateKey}\n   */\n\n  derive(index, hardened) {\n    assert(typeof index === 'number');\n\n    if ((index >>> 0) !== index)\n      throw new Error('Index out of range.');\n\n    if (this.depth >= 0xff)\n      throw new Error('Depth too high.');\n\n    if (hardened) {\n      index |= common.HARDENED;\n      index >>>= 0;\n    }\n\n    const id = this.getID(index);\n    const cache = common.cache.get(id);\n\n    if (cache)\n      return cache;\n\n    const bw = bio.pool(37);\n\n    if (index & common.HARDENED) {\n      bw.writeU8(0);\n      bw.writeBytes(this.privateKey);\n      bw.writeU32BE(index);\n    } else {\n      bw.writeBytes(this.publicKey);\n      bw.writeU32BE(index);\n    }\n\n    const data = bw.render();\n\n    const hash = sha512.mac(data, this.chainCode);\n    const left = hash.slice(0, 32);\n    const right = hash.slice(32, 64);\n\n    let key;\n    try {\n      key = secp256k1.privateKeyTweakAdd(this.privateKey, left);\n    } catch (e) {\n      return this.derive(index + 1);\n    }\n\n    if (this.fingerPrint === -1) {\n      const fp = hash160.digest(this.publicKey);\n      this.fingerPrint = fp.readUInt32BE(0, true);\n    }\n\n    const child = new this.constructor();\n    child.depth = this.depth + 1;\n    child.parentFingerPrint = this.fingerPrint;\n    child.childIndex = index;\n    child.chainCode = right;\n    child.privateKey = key;\n    child.publicKey = secp256k1.publicKeyCreate(key, true);\n\n    common.cache.set(id, child);\n\n    return child;\n  }\n\n  /**\n   * Unique HD key ID.\n   * @private\n   * @param {Number} index\n   * @returns {String}\n   */\n\n  getID(index) {\n    return 'v' + this.publicKey.toString('hex') + index;\n  }\n\n  /**\n   * Derive a BIP44 account key.\n   * @param {Number} purpose\n   * @param {Number} type\n   * @param {Number} account\n   * @returns {HDPrivateKey}\n   * @throws Error if key is not a master key.\n   */\n\n  deriveAccount(purpose, type, account) {\n    assert((purpose >>> 0) === purpose, 'Purpose must be a number.');\n    assert((type >>> 0) === type, 'Account index must be a number.');\n    assert((account >>> 0) === account, 'Account index must be a number.');\n    assert(this.isMaster(), 'Cannot derive account index.');\n    return this\n      .derive(purpose, true)\n      .derive(type, true)\n      .derive(account, true);\n  }\n\n  /**\n   * Test whether the key is a master key.\n   * @returns {Boolean}\n   */\n\n  isMaster() {\n    return common.isMaster(this);\n  }\n\n  /**\n   * Test whether the key is (most likely) a BIP44 account key.\n   * @param {Number?} account\n   * @returns {Boolean}\n   */\n\n  isAccount(account) {\n    return common.isAccount(this, account);\n  }\n\n  /**\n   * Test whether an object is in the form of a base58 xprivkey.\n   * @param {String} data\n   * @param {Network?} network\n   * @returns {Boolean}\n   */\n\n  static isBase58(data, network) {\n    if (typeof data !== 'string')\n      return false;\n\n    if (data.length < 4)\n      return false;\n\n    const prefix = data.substring(0, 4);\n\n    try {\n      Network.fromPrivate58(prefix, network);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Test whether a buffer has a valid network prefix.\n   * @param {Buffer} data\n   * @param {Network?} network\n   * @returns {Boolean}\n   */\n\n  static isRaw(data, network) {\n    if (!Buffer.isBuffer(data))\n      return false;\n\n    if (data.length < 4)\n      return false;\n\n    const version = data.readUInt32BE(0, true);\n\n    try {\n      Network.fromPrivate(version, network);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Test whether a string is a valid path.\n   * @param {String} path\n   * @returns {Boolean}\n   */\n\n  static isValidPath(path) {\n    try {\n      common.parsePath(path, true);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Derive a key from a derivation path.\n   * @param {String} path\n   * @returns {HDPrivateKey}\n   * @throws Error if `path` is not a valid path.\n   */\n\n  derivePath(path) {\n    const indexes = common.parsePath(path, true);\n\n    let key = this;\n\n    for (const index of indexes)\n      key = key.derive(index);\n\n    return key;\n  }\n\n  /**\n   * Compare a key against an object.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n  equals(obj) {\n    assert(HDPrivateKey.isHDPrivateKey(obj));\n\n    return this.depth === obj.depth\n      && this.parentFingerPrint === obj.parentFingerPrint\n      && this.childIndex === obj.childIndex\n      && this.chainCode.equals(obj.chainCode)\n      && this.privateKey.equals(obj.privateKey);\n  }\n\n  /**\n   * Compare a key against an object.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n  compare(key) {\n    assert(HDPrivateKey.isHDPrivateKey(key));\n\n    let cmp = this.depth - key.depth;\n\n    if (cmp !== 0)\n      return cmp;\n\n    cmp = this.parentFingerPrint - key.parentFingerPrint;\n\n    if (cmp !== 0)\n      return cmp;\n\n    cmp = this.childIndex - key.childIndex;\n\n    if (cmp !== 0)\n      return cmp;\n\n    cmp = this.chainCode.compare(key.chainCode);\n\n    if (cmp !== 0)\n      return cmp;\n\n    cmp = this.privateKey.compare(key.privateKey);\n\n    if (cmp !== 0)\n      return cmp;\n\n    return 0;\n  }\n\n  /**\n   * Inject properties from seed.\n   * @private\n   * @param {Buffer} seed\n   */\n\n  fromSeed(seed) {\n    assert(Buffer.isBuffer(seed));\n\n    if (seed.length * 8 < common.MIN_ENTROPY\n        || seed.length * 8 > common.MAX_ENTROPY) {\n      throw new Error('Entropy not in range.');\n    }\n\n    const hash = sha512.mac(seed, SEED_SALT);\n    const left = hash.slice(0, 32);\n    const right = hash.slice(32, 64);\n\n    // Only a 1 in 2^127 chance of happening.\n    if (!secp256k1.privateKeyVerify(left))\n      throw new Error('Master private key is invalid.');\n\n    this.depth = 0;\n    this.parentFingerPrint = 0;\n    this.childIndex = 0;\n    this.chainCode = right;\n    this.privateKey = left;\n    this.publicKey = secp256k1.publicKeyCreate(left, true);\n\n    return this;\n  }\n\n  /**\n   * Instantiate an hd private key from a 512 bit seed.\n   * @param {Buffer} seed\n   * @returns {HDPrivateKey}\n   */\n\n  static fromSeed(seed) {\n    return new this().fromSeed(seed);\n  }\n\n  /**\n   * Inject properties from a mnemonic.\n   * @private\n   * @param {Mnemonic} mnemonic\n   * @param {String?} passphrase\n   */\n\n  fromMnemonic(mnemonic, passphrase) {\n    assert(mnemonic instanceof Mnemonic);\n    return this.fromSeed(mnemonic.toSeed(passphrase));\n  }\n\n  /**\n   * Instantiate an hd private key from a mnemonic.\n   * @param {Mnemonic} mnemonic\n   * @param {String?} passphrase\n   * @returns {HDPrivateKey}\n   */\n\n  static fromMnemonic(mnemonic, passphrase) {\n    return new this().fromMnemonic(mnemonic, passphrase);\n  }\n\n  /**\n   * Inject properties from a mnemonic.\n   * @private\n   * @param {String} mnemonic\n   */\n\n  fromPhrase(phrase) {\n    const mnemonic = Mnemonic.fromPhrase(phrase);\n    this.fromMnemonic(mnemonic);\n    return this;\n  }\n\n  /**\n   * Instantiate an hd private key from a phrase.\n   * @param {String} phrase\n   * @returns {HDPrivateKey}\n   */\n\n  static fromPhrase(phrase) {\n    return new this().fromPhrase(phrase);\n  }\n\n  /**\n   * Inject properties from privateKey and entropy.\n   * @private\n   * @param {Buffer} key\n   * @param {Buffer} entropy\n   */\n\n  fromKey(key, entropy) {\n    assert(Buffer.isBuffer(key) && key.length === 32);\n    assert(Buffer.isBuffer(entropy) && entropy.length === 32);\n    this.depth = 0;\n    this.parentFingerPrint = 0;\n    this.childIndex = 0;\n    this.chainCode = entropy;\n    this.privateKey = key;\n    this.publicKey = secp256k1.publicKeyCreate(key, true);\n    return this;\n  }\n\n  /**\n   * Create an hd private key from a key and entropy bytes.\n   * @param {Buffer} key\n   * @param {Buffer} entropy\n   * @returns {HDPrivateKey}\n   */\n\n  static fromKey(key, entropy) {\n    return new this().fromKey(key, entropy);\n  }\n\n  /**\n   * Generate an hd private key.\n   * @returns {HDPrivateKey}\n   */\n\n  static generate() {\n    const key = secp256k1.privateKeyGenerate();\n    const entropy = random.randomBytes(32);\n    return HDPrivateKey.fromKey(key, entropy);\n  }\n\n  /**\n   * Inject properties from base58 key.\n   * @private\n   * @param {Base58String} xkey\n   * @param {Network?} network\n   */\n\n  fromBase58(xkey, network) {\n    assert(typeof xkey === 'string');\n    return this.fromRaw(base58.decode(xkey), network);\n  }\n\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {BufferReader} br\n   * @param {(Network|NetworkType)?} network\n   */\n\n  fromReader(br, network) {\n    const version = br.readU32BE();\n\n    Network.fromPrivate(version, network);\n\n    this.depth = br.readU8();\n    this.parentFingerPrint = br.readU32BE();\n    this.childIndex = br.readU32BE();\n    this.chainCode = br.readBytes(32);\n    assert(br.readU8() === 0);\n    this.privateKey = br.readBytes(32);\n    this.publicKey = secp256k1.publicKeyCreate(this.privateKey, true);\n\n    br.verifyChecksum(hash256.digest);\n\n    return this;\n  }\n\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   * @param {(Network|NetworkType)?} network\n   */\n\n  fromRaw(data, network) {\n    return this.fromReader(bio.read(data), network);\n  }\n\n  /**\n   * Serialize key to a base58 string.\n   * @param {(Network|NetworkType)?} network\n   * @returns {Base58String}\n   */\n\n  toBase58(network) {\n    return base58.encode(this.toRaw(network));\n  }\n\n  /**\n   * Calculate serialization size.\n   * @returns {Number}\n   */\n\n  getSize() {\n    return 82;\n  }\n\n  /**\n   * Write the key to a buffer writer.\n   * @param {BufferWriter} bw\n   * @param {(Network|NetworkType)?} network\n   */\n\n  toWriter(bw, network) {\n    network = Network.get(network);\n\n    bw.writeU32BE(network.keyPrefix.xprivkey);\n    bw.writeU8(this.depth);\n    bw.writeU32BE(this.parentFingerPrint);\n    bw.writeU32BE(this.childIndex);\n    bw.writeBytes(this.chainCode);\n    bw.writeU8(0);\n    bw.writeBytes(this.privateKey);\n    bw.writeChecksum(hash256.digest);\n\n    return bw;\n  }\n\n  /**\n   * Serialize the key.\n   * @param {(Network|NetworkType)?} network\n   * @returns {Buffer}\n   */\n\n  toRaw(network) {\n    return this.toWriter(bio.write(82), network).render();\n  }\n\n  /**\n   * Instantiate an HD private key from a base58 string.\n   * @param {Base58String} xkey\n   * @param {Network?} network\n   * @returns {HDPrivateKey}\n   */\n\n  static fromBase58(xkey, network) {\n    return new this().fromBase58(xkey, network);\n  }\n\n  /**\n   * Instantiate key from buffer reader.\n   * @param {BufferReader} br\n   * @param {(Network|NetworkType)?} network\n   * @returns {HDPrivateKey}\n   */\n\n  static fromReader(br, network) {\n    return new this().fromReader(br, network);\n  }\n\n  /**\n   * Instantiate key from serialized data.\n   * @param {Buffer} data\n   * @param {(Network|NetworkType)?} network\n   * @returns {HDPrivateKey}\n   */\n\n  static fromRaw(data, network) {\n    return new this().fromRaw(data, network);\n  }\n\n  /**\n   * Convert key to a more json-friendly object.\n   * @returns {Object}\n   */\n\n  toJSON(network) {\n    return {\n      xprivkey: this.xprivkey(network)\n    };\n  }\n\n  /**\n   * Inject properties from json object.\n   * @private\n   * @param {Object} json\n   * @param {Network?} network\n   */\n\n  fromJSON(json, network) {\n    assert(json.xprivkey, 'Could not handle key JSON.');\n\n    this.fromBase58(json.xprivkey, network);\n\n    return this;\n  }\n\n  /**\n   * Instantiate an HDPrivateKey from a jsonified key object.\n   * @param {Object} json - The jsonified key object.\n   * @param {Network?} network\n   * @returns {HDPrivateKey}\n   */\n\n  static fromJSON(json, network) {\n    return new this().fromJSON(json, network);\n  }\n\n  /**\n   * Test whether an object is an HDPrivateKey.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n  static isHDPrivateKey(obj) {\n    return obj instanceof HDPrivateKey;\n  }\n}\n\n/*\n * Expose\n */\n\nmodule.exports = HDPrivateKey;\n"]},"metadata":{},"sourceType":"module"}