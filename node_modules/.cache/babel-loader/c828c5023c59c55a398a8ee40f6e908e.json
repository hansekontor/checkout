{"ast":null,"code":"/*!\n * address.js - address object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bio = require('bufio');\n\nconst {\n  base58,\n  cashaddr\n} = require('bstring');\n\nconst ecashaddr = require('ecashaddrjs');\n\nconst hash160 = require('bcrypto/lib/hash160');\n\nconst hash256 = require('bcrypto/lib/hash256');\n\nconst Network = require('../protocol/network');\n\nconst consensus = require('../protocol/consensus');\n\nconst {\n  inspectSymbol\n} = require('../utils');\n/*\n * Constants\n */\n\n\nconst ZERO_HASH160 = Buffer.alloc(20, 0x00);\n/**\n * Address\n * Represents an address.\n * @alias module:primitives.Address\n * @property {Buffer} hash\n * @property {AddressPrefix} type\n */\n\nclass Address {\n  /**\n   * Create an address.\n   * @constructor\n   * @param {Object?} options\n   */\n  constructor(options, network) {\n    this.type = Address.types.PUBKEYHASH;\n    this.hash = ZERO_HASH160;\n    if (options) this.fromOptions(options, network);\n  }\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n\n  fromOptions(options, network) {\n    if (typeof options === 'string') return this.fromString(options, network);\n    assert(options);\n    const {\n      hash,\n      type\n    } = options;\n    return this.fromHash(hash, type);\n  }\n  /**\n   * Insantiate address from options.\n   * @param {Object} options\n   * @returns {Address}\n   */\n\n\n  static fromOptions(options, network) {\n    return new this().fromOptions(options, network);\n  }\n  /**\n   * Get the address hash.\n   * @param {String?} enc - Can be `\"hex\"` or `null`.\n   * @returns {Hash|Buffer}\n   */\n\n\n  getHash(enc) {\n    if (enc === 'hex') return this.hash.toString('hex');\n    return this.hash;\n  }\n  /**\n   * Test whether the address is null.\n   * @returns {Boolean}\n   */\n\n\n  isNull() {\n    if (this.hash.length === 20) return this.hash.equals(ZERO_HASH160);\n    if (this.hash.length === 32) return this.hash.equals(consensus.ZERO_HASH);\n\n    for (let i = 0; i < this.hash.length; i++) {\n      if (this.hash[i] !== 0) return false;\n    }\n\n    return true;\n  }\n  /**\n   * Test equality against another address.\n   * @param {Address} addr\n   * @returns {Boolean}\n   */\n\n\n  equals(addr) {\n    assert(addr instanceof Address);\n    return this.type === addr.type && this.hash.equals(addr.hash);\n  }\n  /**\n   * Get the address type as a string.\n   * @returns {String}\n   */\n\n\n  getType() {\n    return Address.typesByVal[this.type].toLowerCase();\n  }\n  /**\n   * Get a network address prefix for the address.\n   * @param {Network?} network\n   * @returns {Number}\n   */\n\n\n  getPrefix(network) {\n    network = Network.get(network);\n    const prefixes = network.addressPrefix;\n\n    switch (this.type) {\n      case Address.types.PUBKEYHASH:\n        return prefixes.pubkeyhash;\n\n      case Address.types.SCRIPTHASH:\n        return prefixes.scripthash;\n    }\n\n    return -1;\n  }\n  /**\n   * Calculate size of serialized address.\n   * @returns {Number}\n   */\n\n\n  getSize() {\n    return 5 + this.hash.length;\n  }\n  /**\n   * Compile the address object to its raw serialization.\n   * @param {{NetworkType|Network)?} network\n   * @returns {Buffer}\n   * @throws Error on bad hash/prefix.\n   */\n\n\n  toRaw(network) {\n    const size = this.getSize();\n    const bw = bio.write(size);\n    const prefix = this.getPrefix(network);\n    assert(prefix !== -1, 'Not a valid address prefix.');\n    bw.writeU8(prefix);\n    bw.writeBytes(this.hash);\n    bw.writeChecksum(hash256.digest);\n    return bw.render();\n  }\n  /**\n   * Compile the address object to a base58 address.\n   * @param {{NetworkType|Network)?} network\n   * @returns {AddressString}\n   * @throws Error on bad hash/prefix.\n   */\n\n\n  toBase58(network) {\n    return base58.encode(this.toRaw(network));\n  }\n  /**\n   * Compile the address object to a cashaddr address.\n   * @param {{NetworkType|Network)?} network\n   * @returns {String}\n   * @throws Error on bad hash/prefix.\n   */\n\n\n  toCashAddr(network) {\n    const type = this.type;\n    const hash = this.hash;\n    network = Network.get(network);\n    const prefix = network.addressPrefix.cashaddr;\n    return cashaddr.encode(prefix, type, hash);\n  }\n  /**\n   * Inject properties from string.\n   * @private\n   * @param {String} addr\n   * @param {(Network|NetworkType)?} network\n   * @returns {Address}\n   */\n\n\n  fromString(addr, network) {\n    assert(typeof addr === 'string');\n    assert(addr.length > 0);\n    assert(addr.length <= 100); // If the address is mixed case,\n    // it can only ever be base58.\n\n    if (isMixedCase(addr)) return this.fromBase58(addr, network); // Otherwise, it's most likely cashaddr.\n\n    try {\n      return this.fromCashAddr(addr, network);\n    } catch (e) {\n      return this.fromBase58(addr, network);\n    }\n  }\n  /**\n   * Instantiate address from string.\n   * @param {String} addr\n   * @param {(Network|NetworkType)?} network\n   * @returns {Address}\n   */\n\n\n  static fromString(addr, network) {\n    return new this().fromString(addr, network);\n  }\n  /**\n   * Return cashaddr by default\n   * @param {(Network|NetworkType)?} network\n   * @returns {AddressString}\n   */\n\n\n  toString(network) {\n    return this.toCashAddr(network);\n  }\n  /**\n   * Inspect the Address.\n   * @returns {Object}\n   */\n\n\n  [inspectSymbol]() {\n    return '<Address:' + ` type=${this.getType()}` + ` str=${this.toString()}` + '>';\n  }\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   * @throws Parse error\n   */\n\n\n  fromRaw(data, network) {\n    const br = bio.read(data, true);\n    const prefix = br.readU8();\n    network = Network.fromAddress(prefix, network);\n    const type = Address.getType(prefix, network);\n    if (data.length !== 25) throw new Error('Address is too long.');\n    const hash = br.readBytes(br.left() - 4);\n    br.verifyChecksum(hash256.digest);\n    return this.fromHash(hash, type);\n  }\n  /**\n   * Create an address object from a serialized address.\n   * @param {Buffer} data\n   * @returns {Address}\n   * @throws Parse error.\n   */\n\n\n  static fromRaw(data, network) {\n    return new this().fromRaw(data, network);\n  }\n  /**\n   * Inject properties from base58 address.\n   * @private\n   * @param {AddressString} data\n   * @param {Network?} network\n   * @throws Parse error\n   */\n\n\n  fromBase58(data, network) {\n    assert(typeof data === 'string');\n    if (data.length > 55) throw new Error('Address is too long.');\n    return this.fromRaw(base58.decode(data), network);\n  }\n  /**\n   * Create an address object from a base58 address.\n   * @param {AddressString} data\n   * @param {Network?} network\n   * @returns {Address}\n   * @throws Parse error.\n   */\n\n\n  static fromBase58(data, network) {\n    return new this().fromBase58(data, network);\n  }\n  /**\n   * Inject properties from cashaddr address.\n   * @private\n   * @param {String} data\n   * @param {Network?} network\n   * @throws Parse error\n   */\n\n\n  fromCashAddr(data, network) {\n    assert(typeof data === 'string');\n    network = Network.get(network);\n    const prefix = network.addressPrefix.cashaddr;\n    const addr = ecashaddr.decode(data);\n    addr.type = addr.type === 'P2PKH' ? 'PUBKEYHASH' : 'SCRIPTHASH';\n    Network.fromCashAddr(addr.prefix, network);\n    return this.fromHash(Buffer.from(addr.hash), addr.type);\n  }\n  /**\n   * Create an address object from a cashaddr address.\n   * @param {String} data\n   * @param {Network?} network\n   * @returns {Address}\n   * @throws Parse error.\n   */\n\n\n  static fromCashAddr(data, network) {\n    return new this().fromCashAddr(data, network);\n  }\n  /**\n   * Inject properties from output script.\n   * @private\n   * @param {Script} script\n   */\n\n\n  fromScript(script) {\n    const pk = script.getPubkey();\n\n    if (pk) {\n      this.hash = hash160.digest(pk);\n      this.type = Address.types.PUBKEYHASH;\n      return this;\n    }\n\n    const pkh = script.getPubkeyhash();\n\n    if (pkh) {\n      this.hash = pkh;\n      this.type = Address.types.PUBKEYHASH;\n      return this;\n    }\n\n    const sh = script.getScripthash();\n\n    if (sh) {\n      this.hash = sh;\n      this.type = Address.types.SCRIPTHASH;\n      return this;\n    } // Put this last: it's the slowest to check.\n\n\n    if (script.isMultisig()) {\n      this.hash = script.hash160();\n      this.type = Address.types.SCRIPTHASH;\n      return this;\n    }\n\n    return null;\n  }\n  /**\n   * Inject properties from input script.\n   * @private\n   * @param {Script} script\n   */\n\n\n  fromInputScript(script) {\n    const [, pk] = script.getPubkeyhashInput();\n\n    if (pk) {\n      this.hash = hash160.digest(pk);\n      this.type = Address.types.PUBKEYHASH;\n      return this;\n    }\n\n    const redeem = script.getScripthashInput();\n\n    if (redeem) {\n      this.hash = hash160.digest(redeem);\n      this.type = Address.types.SCRIPTHASH;\n      return this;\n    }\n\n    return null;\n  }\n  /**\n   * Create an Address from an input script.\n   * Attempt to extract address\n   * properties from an input script.\n   * @param {Script}\n   * @returns {Address|null}\n   */\n\n\n  static fromInputScript(script) {\n    return new this().fromInputScript(script);\n  }\n  /**\n   * Create an Address from an output script.\n   * Parse an output script and extract address\n   * properties. Converts pubkey and multisig\n   * scripts to pubkeyhash and scripthash addresses.\n   * @param {Script}\n   * @returns {Address|null}\n   */\n\n\n  static fromScript(script) {\n    return new this().fromScript(script);\n  }\n  /**\n   * Inject properties from a hash.\n   * @private\n   * @param {Buffer|Hash} hash\n   * @param {AddressPrefix} type\n   * @throws on bad hash size\n   */\n\n\n  fromHash(hash, type) {\n    if (typeof type === 'string') {\n      type = Address.types[type.toUpperCase()];\n      assert(type != null, 'Not a valid address type.');\n    }\n\n    if (type == null) type = Address.types.PUBKEYHASH;\n    assert(Buffer.isBuffer(hash));\n    assert(type >>> 0 === type);\n    assert(type >= Address.types.PUBKEYHASH && type <= Address.types.SCRIPTHASH, 'Not a valid address type.');\n    assert(hash.length === 20, 'Hash is the wrong size.');\n    this.hash = hash;\n    this.type = type;\n    return this;\n  }\n  /**\n   * Create a naked address from hash/type.\n   * @param {Hash} hash\n   * @param {AddressPrefix} type\n   * @returns {Address}\n   * @throws on bad hash size\n   */\n\n\n  static fromHash(hash, type) {\n    return new this().fromHash(hash, type);\n  }\n  /**\n   * Inject properties from pubkeyhash.\n   * @private\n   * @param {Buffer} hash\n   * @returns {Address}\n   */\n\n\n  fromPubkeyhash(hash) {\n    const type = Address.types.PUBKEYHASH;\n    assert(hash.length === 20, 'P2PKH must be 20 bytes.');\n    return this.fromHash(hash, type, -1);\n  }\n  /**\n   * Instantiate address from pubkeyhash.\n   * @param {Buffer} hash\n   * @returns {Address}\n   */\n\n\n  static fromPubkeyhash(hash) {\n    return new this().fromPubkeyhash(hash);\n  }\n  /**\n   * Inject properties from scripthash.\n   * @private\n   * @param {Buffer} hash\n   * @returns {Address}\n   */\n\n\n  fromScripthash(hash) {\n    const type = Address.types.SCRIPTHASH;\n    assert(hash && hash.length === 20, 'P2SH must be 20 bytes.');\n    return this.fromHash(hash, type, -1);\n  }\n  /**\n   * Instantiate address from scripthash.\n   * @param {Buffer} hash\n   * @returns {Address}\n   */\n\n\n  static fromScripthash(hash) {\n    return new this().fromScripthash(hash);\n  }\n  /**\n   * Test whether the address is pubkeyhash.\n   * @returns {Boolean}\n   */\n\n\n  isPubkeyhash() {\n    return this.type === Address.types.PUBKEYHASH;\n  }\n  /**\n   * Test whether the address is scripthash.\n   * @returns {Boolean}\n   */\n\n\n  isScripthash() {\n    return this.type === Address.types.SCRIPTHASH;\n  }\n  /**\n   * Get the hash of a base58 address or address-related object.\n   * @param {Address|Hash} data\n   * @param {String?} enc - Can be `\"hex\"` or `null`.\n   * @returns {Hash}\n   */\n\n\n  static getHash(data, enc) {\n    if (!data) throw new Error('Object is not an address.');\n    let hash;\n\n    if (Buffer.isBuffer(data)) {\n      if (data.length !== 20) throw new Error('Object is not an address.');\n      hash = data;\n    } else if (data instanceof Address) {\n      hash = data.hash;\n    } else {\n      throw new Error('Object is not an address.');\n    }\n\n    if (enc === 'hex') return hash.toString('hex');\n    return hash;\n  }\n  /**\n   * Get an address type for a specified network address prefix.\n   * @param {Number} prefix\n   * @param {Network} network\n   * @returns {AddressType}\n   */\n\n\n  static getType(prefix, network) {\n    const prefixes = network.addressPrefix;\n\n    switch (prefix) {\n      case prefixes.pubkeyhash:\n        return Address.types.PUBKEYHASH;\n\n      case prefixes.scripthash:\n        return Address.types.SCRIPTHASH;\n\n      default:\n        throw new Error('Unknown address prefix.');\n    }\n  }\n\n}\n/**\n * Address types.\n * @enum {Number}\n */\n\n\nAddress.types = {\n  PUBKEYHASH: 0,\n  SCRIPTHASH: 1\n};\n/**\n * Address types by value.\n * @const {Object}\n */\n\nAddress.typesByVal = ['PUBKEYHASH', 'SCRIPTHASH'];\n/*\n * Helpers\n */\n\nfunction isMixedCase(str) {\n  let lower = false;\n  let upper = false;\n\n  for (let i = 0; i < str.length; i++) {\n    const ch = str.charCodeAt(i);\n    if (ch >= 0x30 && ch <= 0x39) continue; // skip :\n\n    if (ch === 0x3a) continue;\n\n    if (ch & 32) {\n      assert(ch >= 0x61 && ch <= 0x7a);\n      lower = true;\n    } else {\n      assert(ch >= 0x41 && ch <= 0x5a);\n      upper = true;\n    }\n\n    if (lower && upper) return true;\n  }\n\n  return false;\n}\n/*\n * Expose\n */\n\n\nmodule.exports = Address;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/primitives/address.js"],"names":["assert","require","bio","base58","cashaddr","ecashaddr","hash160","hash256","Network","consensus","inspectSymbol","ZERO_HASH160","Buffer","alloc","Address","constructor","options","network","type","types","PUBKEYHASH","hash","fromOptions","fromString","fromHash","getHash","enc","toString","isNull","length","equals","ZERO_HASH","i","addr","getType","typesByVal","toLowerCase","getPrefix","get","prefixes","addressPrefix","pubkeyhash","SCRIPTHASH","scripthash","getSize","toRaw","size","bw","write","prefix","writeU8","writeBytes","writeChecksum","digest","render","toBase58","encode","toCashAddr","isMixedCase","fromBase58","fromCashAddr","e","fromRaw","data","br","read","readU8","fromAddress","Error","readBytes","left","verifyChecksum","decode","from","fromScript","script","pk","getPubkey","pkh","getPubkeyhash","sh","getScripthash","isMultisig","fromInputScript","getPubkeyhashInput","redeem","getScripthashInput","toUpperCase","isBuffer","fromPubkeyhash","fromScripthash","isPubkeyhash","isScripthash","str","lower","upper","ch","charCodeAt","module","exports"],"mappings":"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","sourcesContent":["/*!\n * address.js - address object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bio = require('bufio');\nconst {base58, cashaddr} = require('bstring');\nconst ecashaddr = require('ecashaddrjs');\nconst hash160 = require('bcrypto/lib/hash160');\nconst hash256 = require('bcrypto/lib/hash256');\nconst Network = require('../protocol/network');\nconst consensus = require('../protocol/consensus');\nconst {inspectSymbol} = require('../utils');\n\n/*\n * Constants\n */\n\nconst ZERO_HASH160 = Buffer.alloc(20, 0x00);\n\n/**\n * Address\n * Represents an address.\n * @alias module:primitives.Address\n * @property {Buffer} hash\n * @property {AddressPrefix} type\n */\n\nclass Address {\n  /**\n   * Create an address.\n   * @constructor\n   * @param {Object?} options\n   */\n\n  constructor(options, network) {\n    this.type = Address.types.PUBKEYHASH;\n    this.hash = ZERO_HASH160;\n\n    if (options)\n      this.fromOptions(options, network);\n  }\n\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n  fromOptions(options, network) {\n    if (typeof options === 'string')\n      return this.fromString(options, network);\n\n    assert(options);\n\n    const {hash, type} = options;\n\n    return this.fromHash(hash, type);\n  }\n\n  /**\n   * Insantiate address from options.\n   * @param {Object} options\n   * @returns {Address}\n   */\n\n  static fromOptions(options, network) {\n    return new this().fromOptions(options, network);\n  }\n\n  /**\n   * Get the address hash.\n   * @param {String?} enc - Can be `\"hex\"` or `null`.\n   * @returns {Hash|Buffer}\n   */\n\n  getHash(enc) {\n    if (enc === 'hex')\n      return this.hash.toString('hex');\n    return this.hash;\n  }\n\n  /**\n   * Test whether the address is null.\n   * @returns {Boolean}\n   */\n\n  isNull() {\n    if (this.hash.length === 20)\n      return this.hash.equals(ZERO_HASH160);\n\n    if (this.hash.length === 32)\n      return this.hash.equals(consensus.ZERO_HASH);\n\n    for (let i = 0; i < this.hash.length; i++) {\n      if (this.hash[i] !== 0)\n        return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Test equality against another address.\n   * @param {Address} addr\n   * @returns {Boolean}\n   */\n\n  equals(addr) {\n    assert(addr instanceof Address);\n\n    return this.type === addr.type\n      && this.hash.equals(addr.hash);\n  }\n\n  /**\n   * Get the address type as a string.\n   * @returns {String}\n   */\n\n  getType() {\n    return Address.typesByVal[this.type].toLowerCase();\n  }\n\n  /**\n   * Get a network address prefix for the address.\n   * @param {Network?} network\n   * @returns {Number}\n   */\n\n  getPrefix(network) {\n    network = Network.get(network);\n\n    const prefixes = network.addressPrefix;\n\n    switch (this.type) {\n      case Address.types.PUBKEYHASH:\n        return prefixes.pubkeyhash;\n      case Address.types.SCRIPTHASH:\n        return prefixes.scripthash;\n    }\n\n    return -1;\n  }\n\n  /**\n   * Calculate size of serialized address.\n   * @returns {Number}\n   */\n\n  getSize() {\n    return 5 + this.hash.length;\n  }\n\n  /**\n   * Compile the address object to its raw serialization.\n   * @param {{NetworkType|Network)?} network\n   * @returns {Buffer}\n   * @throws Error on bad hash/prefix.\n   */\n\n  toRaw(network) {\n    const size = this.getSize();\n    const bw = bio.write(size);\n    const prefix = this.getPrefix(network);\n\n    assert(prefix !== -1, 'Not a valid address prefix.');\n\n    bw.writeU8(prefix);\n\n    bw.writeBytes(this.hash);\n    bw.writeChecksum(hash256.digest);\n\n    return bw.render();\n  }\n\n  /**\n   * Compile the address object to a base58 address.\n   * @param {{NetworkType|Network)?} network\n   * @returns {AddressString}\n   * @throws Error on bad hash/prefix.\n   */\n\n  toBase58(network) {\n    return base58.encode(this.toRaw(network));\n  }\n\n  /**\n   * Compile the address object to a cashaddr address.\n   * @param {{NetworkType|Network)?} network\n   * @returns {String}\n   * @throws Error on bad hash/prefix.\n   */\n\n  toCashAddr(network) {\n    const type = this.type;\n    const hash = this.hash;\n\n    network = Network.get(network);\n\n    const prefix = network.addressPrefix.cashaddr;\n\n    return cashaddr.encode(prefix, type, hash);\n  }\n\n  /**\n   * Inject properties from string.\n   * @private\n   * @param {String} addr\n   * @param {(Network|NetworkType)?} network\n   * @returns {Address}\n   */\n\n  fromString(addr, network) {\n    assert(typeof addr === 'string');\n    assert(addr.length > 0);\n    assert(addr.length <= 100);\n\n    // If the address is mixed case,\n    // it can only ever be base58.\n    if (isMixedCase(addr))\n      return this.fromBase58(addr, network);\n\n    // Otherwise, it's most likely cashaddr.\n    try {\n      return this.fromCashAddr(addr, network);\n    } catch (e) {\n      return this.fromBase58(addr, network);\n    }\n  }\n\n  /**\n   * Instantiate address from string.\n   * @param {String} addr\n   * @param {(Network|NetworkType)?} network\n   * @returns {Address}\n   */\n\n  static fromString(addr, network) {\n    return new this().fromString(addr, network);\n  }\n\n  /**\n   * Return cashaddr by default\n   * @param {(Network|NetworkType)?} network\n   * @returns {AddressString}\n   */\n\n  toString(network) {\n    return this.toCashAddr(network);\n  }\n\n  /**\n   * Inspect the Address.\n   * @returns {Object}\n   */\n\n  [inspectSymbol]() {\n    return '<Address:'\n      + ` type=${this.getType()}`\n      + ` str=${this.toString()}`\n      + '>';\n  }\n\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   * @throws Parse error\n   */\n\n  fromRaw(data, network) {\n    const br = bio.read(data, true);\n    const prefix = br.readU8();\n\n    network = Network.fromAddress(prefix, network);\n\n    const type = Address.getType(prefix, network);\n\n    if (data.length !== 25)\n      throw new Error('Address is too long.');\n\n    const hash = br.readBytes(br.left() - 4);\n\n    br.verifyChecksum(hash256.digest);\n\n    return this.fromHash(hash, type);\n  }\n\n  /**\n   * Create an address object from a serialized address.\n   * @param {Buffer} data\n   * @returns {Address}\n   * @throws Parse error.\n   */\n\n  static fromRaw(data, network) {\n    return new this().fromRaw(data, network);\n  }\n\n  /**\n   * Inject properties from base58 address.\n   * @private\n   * @param {AddressString} data\n   * @param {Network?} network\n   * @throws Parse error\n   */\n\n  fromBase58(data, network) {\n    assert(typeof data === 'string');\n\n    if (data.length > 55)\n      throw new Error('Address is too long.');\n\n    return this.fromRaw(base58.decode(data), network);\n  }\n\n  /**\n   * Create an address object from a base58 address.\n   * @param {AddressString} data\n   * @param {Network?} network\n   * @returns {Address}\n   * @throws Parse error.\n   */\n\n  static fromBase58(data, network) {\n    return new this().fromBase58(data, network);\n  }\n\n  /**\n   * Inject properties from cashaddr address.\n   * @private\n   * @param {String} data\n   * @param {Network?} network\n   * @throws Parse error\n   */\n\n  fromCashAddr(data, network) {\n    assert(typeof data === 'string');\n\n    network = Network.get(network);\n\n    const prefix = network.addressPrefix.cashaddr;\n    const addr = ecashaddr.decode(data);\n    addr.type = addr.type === 'P2PKH' ? 'PUBKEYHASH' : 'SCRIPTHASH';\n\n    Network.fromCashAddr(addr.prefix, network);\n\n    return this.fromHash(Buffer.from(addr.hash), addr.type);\n  }\n\n  /**\n   * Create an address object from a cashaddr address.\n   * @param {String} data\n   * @param {Network?} network\n   * @returns {Address}\n   * @throws Parse error.\n   */\n\n  static fromCashAddr(data, network) {\n    return new this().fromCashAddr(data, network);\n  }\n\n  /**\n   * Inject properties from output script.\n   * @private\n   * @param {Script} script\n   */\n\n  fromScript(script) {\n    const pk = script.getPubkey();\n\n    if (pk) {\n      this.hash = hash160.digest(pk);\n      this.type = Address.types.PUBKEYHASH;\n      return this;\n    }\n\n    const pkh = script.getPubkeyhash();\n\n    if (pkh) {\n      this.hash = pkh;\n      this.type = Address.types.PUBKEYHASH;\n      return this;\n    }\n\n    const sh = script.getScripthash();\n\n    if (sh) {\n      this.hash = sh;\n      this.type = Address.types.SCRIPTHASH;\n      return this;\n    }\n\n    // Put this last: it's the slowest to check.\n    if (script.isMultisig()) {\n      this.hash = script.hash160();\n      this.type = Address.types.SCRIPTHASH;\n      return this;\n    }\n\n    return null;\n  }\n\n  /**\n   * Inject properties from input script.\n   * @private\n   * @param {Script} script\n   */\n\n  fromInputScript(script) {\n    const [, pk] = script.getPubkeyhashInput();\n\n    if (pk) {\n      this.hash = hash160.digest(pk);\n      this.type = Address.types.PUBKEYHASH;\n      return this;\n    }\n\n    const redeem = script.getScripthashInput();\n\n    if (redeem) {\n      this.hash = hash160.digest(redeem);\n      this.type = Address.types.SCRIPTHASH;\n      return this;\n    }\n\n    return null;\n  }\n\n  /**\n   * Create an Address from an input script.\n   * Attempt to extract address\n   * properties from an input script.\n   * @param {Script}\n   * @returns {Address|null}\n   */\n\n  static fromInputScript(script) {\n    return new this().fromInputScript(script);\n  }\n\n  /**\n   * Create an Address from an output script.\n   * Parse an output script and extract address\n   * properties. Converts pubkey and multisig\n   * scripts to pubkeyhash and scripthash addresses.\n   * @param {Script}\n   * @returns {Address|null}\n   */\n\n  static fromScript(script) {\n    return new this().fromScript(script);\n  }\n\n  /**\n   * Inject properties from a hash.\n   * @private\n   * @param {Buffer|Hash} hash\n   * @param {AddressPrefix} type\n   * @throws on bad hash size\n   */\n\n  fromHash(hash, type) {\n    if (typeof type === 'string') {\n      type = Address.types[type.toUpperCase()];\n      assert(type != null, 'Not a valid address type.');\n    }\n\n    if (type == null)\n      type = Address.types.PUBKEYHASH;\n\n    assert(Buffer.isBuffer(hash));\n    assert((type >>> 0) === type);\n\n    assert(type >= Address.types.PUBKEYHASH && type <= Address.types.SCRIPTHASH,\n      'Not a valid address type.');\n\n    assert(hash.length === 20, 'Hash is the wrong size.');\n\n    this.hash = hash;\n    this.type = type;\n\n    return this;\n  }\n\n  /**\n   * Create a naked address from hash/type.\n   * @param {Hash} hash\n   * @param {AddressPrefix} type\n   * @returns {Address}\n   * @throws on bad hash size\n   */\n\n  static fromHash(hash, type) {\n    return new this().fromHash(hash, type);\n  }\n\n  /**\n   * Inject properties from pubkeyhash.\n   * @private\n   * @param {Buffer} hash\n   * @returns {Address}\n   */\n\n  fromPubkeyhash(hash) {\n    const type = Address.types.PUBKEYHASH;\n    assert(hash.length === 20, 'P2PKH must be 20 bytes.');\n    return this.fromHash(hash, type, -1);\n  }\n\n  /**\n   * Instantiate address from pubkeyhash.\n   * @param {Buffer} hash\n   * @returns {Address}\n   */\n\n  static fromPubkeyhash(hash) {\n    return new this().fromPubkeyhash(hash);\n  }\n\n  /**\n   * Inject properties from scripthash.\n   * @private\n   * @param {Buffer} hash\n   * @returns {Address}\n   */\n\n  fromScripthash(hash) {\n    const type = Address.types.SCRIPTHASH;\n    assert(hash && hash.length === 20, 'P2SH must be 20 bytes.');\n    return this.fromHash(hash, type, -1);\n  }\n\n  /**\n   * Instantiate address from scripthash.\n   * @param {Buffer} hash\n   * @returns {Address}\n   */\n\n  static fromScripthash(hash) {\n    return new this().fromScripthash(hash);\n  }\n\n  /**\n   * Test whether the address is pubkeyhash.\n   * @returns {Boolean}\n   */\n\n  isPubkeyhash() {\n    return this.type === Address.types.PUBKEYHASH;\n  }\n\n  /**\n   * Test whether the address is scripthash.\n   * @returns {Boolean}\n   */\n\n  isScripthash() {\n    return this.type === Address.types.SCRIPTHASH;\n  }\n\n  /**\n   * Get the hash of a base58 address or address-related object.\n   * @param {Address|Hash} data\n   * @param {String?} enc - Can be `\"hex\"` or `null`.\n   * @returns {Hash}\n   */\n\n  static getHash(data, enc) {\n    if (!data)\n      throw new Error('Object is not an address.');\n\n    let hash;\n\n    if (Buffer.isBuffer(data)) {\n      if (data.length !== 20)\n        throw new Error('Object is not an address.');\n      hash = data;\n    } else if (data instanceof Address) {\n      hash = data.hash;\n    } else {\n      throw new Error('Object is not an address.');\n    }\n\n    if (enc === 'hex')\n      return hash.toString('hex');\n\n    return hash;\n  }\n\n  /**\n   * Get an address type for a specified network address prefix.\n   * @param {Number} prefix\n   * @param {Network} network\n   * @returns {AddressType}\n   */\n\n  static getType(prefix, network) {\n    const prefixes = network.addressPrefix;\n\n    switch (prefix) {\n      case prefixes.pubkeyhash:\n        return Address.types.PUBKEYHASH;\n      case prefixes.scripthash:\n        return Address.types.SCRIPTHASH;\n      default:\n        throw new Error('Unknown address prefix.');\n    }\n  }\n}\n\n/**\n * Address types.\n * @enum {Number}\n */\n\nAddress.types = {\n  PUBKEYHASH: 0,\n  SCRIPTHASH: 1\n};\n\n/**\n * Address types by value.\n * @const {Object}\n */\n\nAddress.typesByVal = [\n  'PUBKEYHASH',\n  'SCRIPTHASH'\n];\n\n/*\n * Helpers\n */\n\nfunction isMixedCase(str) {\n  let lower = false;\n  let upper = false;\n\n  for (let i = 0; i < str.length; i++) {\n    const ch = str.charCodeAt(i);\n\n    if (ch >= 0x30 && ch <= 0x39)\n      continue;\n\n    // skip :\n    if (ch === 0x3a)\n      continue;\n\n    if (ch & 32) {\n      assert(ch >= 0x61 && ch <= 0x7a);\n      lower = true;\n    } else {\n      assert(ch >= 0x41 && ch <= 0x5a);\n      upper = true;\n    }\n\n    if (lower && upper)\n      return true;\n  }\n\n  return false;\n}\n\n/*\n * Expose\n */\n\nmodule.exports = Address;\n"]},"metadata":{},"sourceType":"module"}