{"ast":null,"code":"/*!\n * cshake.js - cSHAKE implementation for bcrypto\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://keccak.team/specifications.html\n *   https://www.nist.gov/node/1131611\n *   https://doi.org/10.6028/NIST.SP.800-185\n *   https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf\n *   https://github.com/XKCP/XKCP/blob/8f447eb/lib/high/Keccak/SP800-185/SP800-185.inc\n *   https://github.com/XKCP/XKCP/blob/8f447eb/lib/high/Keccak/SP800-185/SP800-185.c\n *   https://github.com/XKCP/XKCP/blob/8f447eb/tests/UnitTests/testSP800-185.c\n *   https://github.com/emn178/js-sha3/blob/master/src/sha3.js\n */\n'use strict';\n\nconst assert = require('./internal/assert');\n\nconst Keccak = require('./keccak');\n\nconst HMAC = require('./internal/hmac');\n/*\n * Constants\n */\n\n\nconst EMPTY = Buffer.alloc(0);\nconst ZEROES = Buffer.alloc(200, 0x00);\n/*\n * CSHAKE\n */\n\nclass CSHAKE extends Keccak {\n  constructor() {\n    super();\n    this.pad = 0x04;\n    this.rate = 1088;\n  }\n\n  init(bits, name, pers) {\n    if (bits == null) bits = 256;\n    if (name == null) name = EMPTY;\n    if (pers == null) pers = EMPTY;\n    assert(bits >>> 0 === bits);\n    assert(bits === 128 || bits === 256);\n    assert(Buffer.isBuffer(name));\n    assert(Buffer.isBuffer(pers));\n    super.init(bits);\n\n    if (name.length === 0 && pers.length === 0) {\n      this.pad = 0x1f;\n    } else {\n      const rate = 1600 - bits * 2;\n      const size = rate / 8;\n      this.bytePad([name, pers], size);\n      this.rate = rate;\n      this.pad = 0x04;\n    }\n\n    return this;\n  }\n\n  final(len) {\n    return super.final(this.pad, len);\n  }\n\n  bytePad(items, w) {\n    assert(Array.isArray(items));\n    assert(w >>> 0 === w);\n    assert(w > 0);\n    let z = this.leftEncode(w);\n\n    for (const x of items) z += this.encodeString(x);\n\n    const left = w - z % w;\n    if (left === w) return z;\n    z += this.zeroPad(left);\n    return z;\n  }\n\n  encodeString(s) {\n    assert(Buffer.isBuffer(s));\n    const n = this.leftEncode(s.length * 8);\n    this.update(s);\n    return n + s.length;\n  }\n\n  zeroPad(size) {\n    assert(size >>> 0 === size);\n    assert(size <= 200);\n    const buf = ZEROES.slice(0, size);\n    this.update(buf);\n    return buf.length;\n  }\n\n  leftEncode(x) {\n    assert(x >>> 0 === x);\n    assert(x >= 0 && x < 22040);\n    let v = x;\n    let n = 0;\n\n    while (v && n < 4) {\n      n += 1;\n      v >>>= 8;\n    }\n\n    if (n === 0) n = 1;\n    const buf = Buffer.allocUnsafe(n + 1);\n\n    for (let i = 1; i <= n; i++) buf[i] = x >>> 8 * (n - i);\n\n    buf[0] = n;\n    this.update(buf);\n    return buf.length;\n  }\n\n  rightEncode(x) {\n    assert(x >>> 0 === x);\n    assert(x >= 0 && x < 22040);\n    let v = x;\n    let n = 0;\n\n    while (v && n < 4) {\n      n += 1;\n      v >>>= 8;\n    }\n\n    if (n === 0) n = 1;\n    const buf = Buffer.allocUnsafe(n + 1);\n\n    for (let i = 1; i <= n; i++) buf[i - 1] = x >>> 8 * (n - i);\n\n    buf[n] = n;\n    this.update(buf);\n    return buf.length;\n  }\n\n  static hash() {\n    return new CSHAKE();\n  }\n\n  static hmac(bits, name, pers, len) {\n    if (bits == null) bits = 256;\n    assert(bits >>> 0 === bits);\n    assert(bits === 128 || bits === 256);\n    const rate = 1600 - bits * 2;\n    return new HMAC(CSHAKE, rate / 8, [bits, name, pers], [len]);\n  }\n\n  static digest(data, bits, name, pers, len) {\n    return CSHAKE.ctx.init(bits, name, pers).update(data).final(len);\n  }\n\n  static root(left, right, bits, name, pers, len) {\n    if (bits == null) bits = 256;\n    if (len == null) len = 0;\n\n    if (len === 0) {\n      assert(bits >>> 0 === bits);\n      len = bits >>> 3;\n    }\n\n    assert(len >>> 0 === len);\n    assert(Buffer.isBuffer(left) && left.length === len);\n    assert(Buffer.isBuffer(right) && right.length === len);\n    const {\n      ctx\n    } = CSHAKE;\n    ctx.init(bits, name, pers);\n    ctx.update(left);\n    ctx.update(right);\n    return ctx.final(len);\n  }\n\n  static multi(x, y, z, bits, name, pers, len) {\n    const {\n      ctx\n    } = CSHAKE;\n    ctx.init(bits, name, pers);\n    ctx.update(x);\n    ctx.update(y);\n    if (z) ctx.update(z);\n    return ctx.final(len);\n  }\n\n  static mac(data, key, bits, name, pers, len) {\n    return CSHAKE.hmac(bits, name, pers, len).init(key).update(data).final();\n  }\n\n}\n/*\n * Static\n */\n\n\nCSHAKE.native = Keccak.native;\nCSHAKE.id = 'CSHAKE256';\nCSHAKE.size = 32;\nCSHAKE.bits = 256;\nCSHAKE.blockSize = 136;\nCSHAKE.zero = Buffer.alloc(32, 0x00);\nCSHAKE.ctx = new CSHAKE();\n/*\n * Expose\n */\n\nmodule.exports = CSHAKE;","map":null,"metadata":{},"sourceType":"script"}