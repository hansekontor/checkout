{"ast":null,"code":"/*!\n * staticwriter.js - buffer writer for bcoin\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst enforce = require('./enforce');\n\nconst encoding = require('./encoding');\n\nconst EncodingError = require('./error');\n/*\n * Constants\n */\n\n\nconst EMPTY = Buffer.alloc(0);\nconst POOL_SIZE = 100 << 10;\nlet POOL = null;\n/**\n * Statically Allocated Writer\n */\n\nclass StaticWriter {\n  /**\n   * Statically allocated buffer writer.\n   * @constructor\n   * @param {Number|Buffer} options\n   */\n  constructor(options) {\n    this.data = EMPTY;\n    this.offset = 0;\n    if (options != null) this.init(options);\n  }\n  /**\n   * Assertion.\n   * @param {Number} size\n   */\n\n\n  check(size) {\n    if (this.offset + size > this.data.length) throw new EncodingError(this.offset, 'Out of bounds write', this.check);\n  }\n  /**\n   * Initialize options.\n   * @param {Object} options\n   */\n\n\n  init(options) {\n    if (Buffer.isBuffer(options)) {\n      this.data = options;\n      this.offset = 0;\n      return this;\n    }\n\n    enforce(options >>> 0 === options, 'size', 'integer');\n    this.data = Buffer.allocUnsafeSlow(options);\n    this.offset = 0;\n    return this;\n  }\n  /**\n   * Allocate writer from preallocated 100kb pool.\n   * @param {Number} size\n   * @returns {StaticWriter}\n   */\n\n\n  static pool(size) {\n    enforce(size >>> 0 === size, 'size', 'integer');\n\n    if (size <= POOL_SIZE) {\n      if (!POOL) POOL = Buffer.allocUnsafeSlow(POOL_SIZE);\n      const bw = new StaticWriter();\n      bw.data = POOL.slice(0, size);\n      return bw;\n    }\n\n    return new StaticWriter(size);\n  }\n  /**\n   * Allocate and render the final buffer.\n   * @returns {Buffer} Rendered buffer.\n   */\n\n\n  render() {\n    const {\n      data,\n      offset\n    } = this;\n    if (offset !== data.length) throw new EncodingError(offset, 'Out of bounds write');\n    this.destroy();\n    return data;\n  }\n  /**\n   * Slice the final buffer at written offset.\n   * @returns {Buffer} Rendered buffer.\n   */\n\n\n  slice() {\n    const {\n      data,\n      offset\n    } = this;\n    if (offset > data.length) throw new EncodingError(offset, 'Out of bounds write');\n    this.destroy();\n    return data.slice(0, offset);\n  }\n  /**\n   * Get size of data written so far.\n   * @returns {Number}\n   */\n\n\n  getSize() {\n    return this.offset;\n  }\n  /**\n   * Seek to relative offset.\n   * @param {Number} off\n   */\n\n\n  seek(off) {\n    enforce(Number.isSafeInteger(off), 'off', 'integer');\n    if (this.offset + off < 0) throw new EncodingError(this.offset, 'Out of bounds write');\n    this.check(off);\n    this.offset += off;\n    return this;\n  }\n  /**\n   * Destroy the buffer writer.\n   */\n\n\n  destroy() {\n    this.data = EMPTY;\n    this.offset = 0;\n    return this;\n  }\n  /**\n   * Write uint8.\n   * @param {Number} value\n   */\n\n\n  writeU8(value) {\n    this.check(1);\n    this.offset = encoding.writeU8(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write uint16le.\n   * @param {Number} value\n   */\n\n\n  writeU16(value) {\n    this.check(2);\n    this.offset = encoding.writeU16(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write uint16be.\n   * @param {Number} value\n   */\n\n\n  writeU16BE(value) {\n    this.check(2);\n    this.offset = encoding.writeU16BE(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write uint24le.\n   * @param {Number} value\n   */\n\n\n  writeU24(value) {\n    this.check(3);\n    this.offset = encoding.writeU24(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write uint24be.\n   * @param {Number} value\n   */\n\n\n  writeU24BE(value) {\n    this.check(3);\n    this.offset = encoding.writeU24BE(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write uint32le.\n   * @param {Number} value\n   */\n\n\n  writeU32(value) {\n    this.check(4);\n    this.offset = encoding.writeU32(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write uint32be.\n   * @param {Number} value\n   */\n\n\n  writeU32BE(value) {\n    this.check(4);\n    this.offset = encoding.writeU32BE(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write uint40le.\n   * @param {Number} value\n   */\n\n\n  writeU40(value) {\n    this.check(5);\n    this.offset = encoding.writeU40(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write uint40be.\n   * @param {Number} value\n   */\n\n\n  writeU40BE(value) {\n    this.check(5);\n    this.offset = encoding.writeU40BE(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write uint48le.\n   * @param {Number} value\n   */\n\n\n  writeU48(value) {\n    this.check(6);\n    this.offset = encoding.writeU48(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write uint48be.\n   * @param {Number} value\n   */\n\n\n  writeU48BE(value) {\n    this.check(6);\n    this.offset = encoding.writeU48BE(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write uint56le.\n   * @param {Number} value\n   */\n\n\n  writeU56(value) {\n    this.check(7);\n    this.offset = encoding.writeU56(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write uint56be.\n   * @param {Number} value\n   */\n\n\n  writeU56BE(value) {\n    this.check(7);\n    this.offset = encoding.writeU56BE(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write uint64le.\n   * @param {Number} value\n   */\n\n\n  writeU64(value) {\n    this.check(8);\n    this.offset = encoding.writeU64(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write uint64be.\n   * @param {Number} value\n   */\n\n\n  writeU64BE(value) {\n    this.check(8);\n    this.offset = encoding.writeU64BE(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write int8.\n   * @param {Number} value\n   */\n\n\n  writeI8(value) {\n    this.check(1);\n    this.offset = encoding.writeI8(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write int16le.\n   * @param {Number} value\n   */\n\n\n  writeI16(value) {\n    this.check(2);\n    this.offset = encoding.writeI16(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write int16be.\n   * @param {Number} value\n   */\n\n\n  writeI16BE(value) {\n    this.check(2);\n    this.offset = encoding.writeI16BE(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write int24le.\n   * @param {Number} value\n   */\n\n\n  writeI24(value) {\n    this.check(3);\n    this.offset = encoding.writeI24(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write int24be.\n   * @param {Number} value\n   */\n\n\n  writeI24BE(value) {\n    this.check(3);\n    this.offset = encoding.writeI24BE(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write int32le.\n   * @param {Number} value\n   */\n\n\n  writeI32(value) {\n    this.check(4);\n    this.offset = encoding.writeI32(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write int32be.\n   * @param {Number} value\n   */\n\n\n  writeI32BE(value) {\n    this.check(4);\n    this.offset = encoding.writeI32BE(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write int40le.\n   * @param {Number} value\n   */\n\n\n  writeI40(value) {\n    this.check(5);\n    this.offset = encoding.writeI40(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write int40be.\n   * @param {Number} value\n   */\n\n\n  writeI40BE(value) {\n    this.check(5);\n    this.offset = encoding.writeI40BE(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write int48le.\n   * @param {Number} value\n   */\n\n\n  writeI48(value) {\n    this.check(6);\n    this.offset = encoding.writeI48(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write int48be.\n   * @param {Number} value\n   */\n\n\n  writeI48BE(value) {\n    this.check(6);\n    this.offset = encoding.writeI48BE(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write int56le.\n   * @param {Number} value\n   */\n\n\n  writeI56(value) {\n    this.check(7);\n    this.offset = encoding.writeI56(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write int56be.\n   * @param {Number} value\n   */\n\n\n  writeI56BE(value) {\n    this.check(7);\n    this.offset = encoding.writeI56BE(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write int64le.\n   * @param {Number} value\n   */\n\n\n  writeI64(value) {\n    this.check(8);\n    this.offset = encoding.writeI64(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write int64be.\n   * @param {Number} value\n   */\n\n\n  writeI64BE(value) {\n    this.check(8);\n    this.offset = encoding.writeI64BE(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write float le.\n   * @param {Number} value\n   */\n\n\n  writeFloat(value) {\n    this.check(4);\n    this.offset = encoding.writeFloat(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write float be.\n   * @param {Number} value\n   */\n\n\n  writeFloatBE(value) {\n    this.check(4);\n    this.offset = encoding.writeFloatBE(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write double le.\n   * @param {Number} value\n   */\n\n\n  writeDouble(value) {\n    this.check(8);\n    this.offset = encoding.writeDouble(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write double be.\n   * @param {Number} value\n   */\n\n\n  writeDoubleBE(value) {\n    this.check(8);\n    this.offset = encoding.writeDoubleBE(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write a varint.\n   * @param {Number} value\n   */\n\n\n  writeVarint(value) {\n    this.offset = encoding.writeVarint(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write a varint (type 2).\n   * @param {Number} value\n   */\n\n\n  writeVarint2(value) {\n    this.offset = encoding.writeVarint2(this.data, value, this.offset);\n    return this;\n  }\n  /**\n   * Write bytes.\n   * @param {Buffer} value\n   */\n\n\n  writeBytes(value) {\n    enforce(Buffer.isBuffer(value), 'value', 'buffer');\n    this.check(value.length);\n    this.offset += value.copy(this.data, this.offset);\n    return this;\n  }\n  /**\n   * Write bytes with a varint length before them.\n   * @param {Buffer} value\n   */\n\n\n  writeVarBytes(value) {\n    enforce(Buffer.isBuffer(value), 'value', 'buffer');\n    this.writeVarint(value.length);\n    this.writeBytes(value);\n    return this;\n  }\n  /**\n   * Copy bytes.\n   * @param {Buffer} value\n   * @param {Number} start\n   * @param {Number} end\n   */\n\n\n  copy(value, start, end) {\n    enforce(Buffer.isBuffer(value), 'value', 'buffer');\n    enforce(start >>> 0 === start, 'start', 'integer');\n    enforce(end >>> 0 === end, 'end', 'integer');\n    enforce(end >= start, 'start', 'integer');\n    this.check(end - start);\n    this.offset += value.copy(this.data, this.offset, start, end);\n    return this;\n  }\n  /**\n   * Write string to buffer.\n   * @param {String} value\n   * @param {String?} enc - Any buffer-supported encoding.\n   */\n\n\n  writeString(value, enc) {\n    if (enc == null) enc = 'binary';\n    enforce(typeof value === 'string', 'value', 'string');\n    enforce(typeof enc === 'string', 'enc', 'string');\n    if (value.length === 0) return this;\n    const size = Buffer.byteLength(value, enc);\n    this.check(size);\n    this.offset += this.data.write(value, this.offset, enc);\n    return this;\n  }\n  /**\n   * Write a 32 byte hash.\n   * @param {Hash} value\n   */\n\n\n  writeHash(value) {\n    if (typeof value !== 'string') {\n      enforce(Buffer.isBuffer(value), 'value', 'buffer');\n      enforce(value.length === 32, 'value', '32-byte hash');\n      this.writeBytes(value);\n      return this;\n    }\n\n    enforce(value.length === 64, 'value', '32-byte hash');\n    this.check(32);\n    this.offset += this.data.write(value, this.offset, 'hex');\n    return this;\n  }\n  /**\n   * Write a string with a varint length before it.\n   * @param {String}\n   * @param {String?} enc - Any buffer-supported encoding.\n   */\n\n\n  writeVarString(value, enc) {\n    if (enc == null) enc = 'binary';\n    enforce(typeof value === 'string', 'value', 'string');\n    enforce(typeof enc === 'string', 'enc', 'string');\n\n    if (value.length === 0) {\n      this.writeVarint(0);\n      return this;\n    }\n\n    const size = Buffer.byteLength(value, enc);\n    this.writeVarint(size);\n    this.check(size);\n    this.offset += this.data.write(value, this.offset, enc);\n    return this;\n  }\n  /**\n   * Write a null-terminated string.\n   * @param {String|Buffer}\n   * @param {String?} enc - Any buffer-supported encoding.\n   */\n\n\n  writeNullString(value, enc) {\n    this.writeString(value, enc);\n    this.writeU8(0);\n    return this;\n  }\n  /**\n   * Calculate and write a checksum for the data written so far.\n   * @param {Function} hash\n   */\n\n\n  writeChecksum(hash) {\n    if (!hash || typeof hash.digest !== 'function') enforce(typeof hash === 'function', 'hash', 'function');\n    this.check(4);\n    const data = this.data.slice(0, this.offset);\n    const raw = hash.digest ? hash.digest(data) : hash(data);\n    raw.copy(this.data, this.offset, 0, 4);\n    this.offset += 4;\n    return this;\n  }\n  /**\n   * Fill N bytes with value.\n   * @param {Number} value\n   * @param {Number} size\n   */\n\n\n  fill(value, size) {\n    enforce((value & 0xff) === value, 'value', 'byte');\n    enforce(size >>> 0 === size, 'size', 'integer');\n    this.check(size);\n    this.data.fill(value, this.offset, this.offset + size);\n    this.offset += size;\n    return this;\n  }\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = StaticWriter;","map":null,"metadata":{},"sourceType":"script"}