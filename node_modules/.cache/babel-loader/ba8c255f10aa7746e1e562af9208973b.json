{"ast":null,"code":"/*!\n * blake2b.js - BLAKE2b implementation for bcrypto\n * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on dcposch/blakejs:\n *   Daniel Clemens Posch (CC0)\n *   https://github.com/dcposch/blakejs/blob/master/blake2b.js\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/BLAKE_(hash_function)\n *   https://tools.ietf.org/html/rfc7693\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst HMAC = require('../internal/hmac');\n/*\n * Constants\n */\n\n\nconst FINALIZED = 0x80000000;\nconst IV = new Uint32Array([0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a, 0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19]);\nconst SIGMA = new Uint8Array([0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e, 0x1c, 0x14, 0x08, 0x10, 0x12, 0x1e, 0x1a, 0x0c, 0x02, 0x18, 0x00, 0x04, 0x16, 0x0e, 0x0a, 0x06, 0x16, 0x10, 0x18, 0x00, 0x0a, 0x04, 0x1e, 0x1a, 0x14, 0x1c, 0x06, 0x0c, 0x0e, 0x02, 0x12, 0x08, 0x0e, 0x12, 0x06, 0x02, 0x1a, 0x18, 0x16, 0x1c, 0x04, 0x0c, 0x0a, 0x14, 0x08, 0x00, 0x1e, 0x10, 0x12, 0x00, 0x0a, 0x0e, 0x04, 0x08, 0x14, 0x1e, 0x1c, 0x02, 0x16, 0x18, 0x0c, 0x10, 0x06, 0x1a, 0x04, 0x18, 0x0c, 0x14, 0x00, 0x16, 0x10, 0x06, 0x08, 0x1a, 0x0e, 0x0a, 0x1e, 0x1c, 0x02, 0x12, 0x18, 0x0a, 0x02, 0x1e, 0x1c, 0x1a, 0x08, 0x14, 0x00, 0x0e, 0x0c, 0x06, 0x12, 0x04, 0x10, 0x16, 0x1a, 0x16, 0x0e, 0x1c, 0x18, 0x02, 0x06, 0x12, 0x0a, 0x00, 0x1e, 0x08, 0x10, 0x0c, 0x04, 0x14, 0x0c, 0x1e, 0x1c, 0x12, 0x16, 0x06, 0x00, 0x10, 0x18, 0x04, 0x1a, 0x0e, 0x02, 0x08, 0x14, 0x0a, 0x14, 0x04, 0x10, 0x08, 0x0e, 0x0c, 0x02, 0x0a, 0x1e, 0x16, 0x12, 0x1c, 0x06, 0x18, 0x1a, 0x00, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e, 0x1c, 0x14, 0x08, 0x10, 0x12, 0x1e, 0x1a, 0x0c, 0x02, 0x18, 0x00, 0x04, 0x16, 0x0e, 0x0a, 0x06]);\n/**\n * BLAKE2b\n */\n\nclass BLAKE2b {\n  constructor() {\n    this.state = new Uint32Array(16);\n    this.V = new Uint32Array(32);\n    this.M = new Uint32Array(32);\n    this.block = Buffer.allocUnsafe(128);\n    this.size = 32;\n    this.count = 0;\n    this.pos = FINALIZED;\n  }\n\n  init(size, key) {\n    if (size == null) size = 32;\n    assert(size >>> 0 === size);\n    assert(key == null || Buffer.isBuffer(key));\n    if (size === 0 || size > 64) throw new Error('Bad output length.');\n    if (key && key.length > 64) throw new Error('Bad key length.');\n    const klen = key ? key.length : 0;\n\n    for (let i = 0; i < 16; i++) this.state[i] = IV[i];\n\n    this.size = size;\n    this.count = 0;\n    this.pos = 0;\n    this.state[0] ^= 0x01010000 ^ klen << 8 ^ this.size;\n\n    if (klen > 0) {\n      const block = Buffer.alloc(128, 0x00);\n      key.copy(block, 0);\n      this.update(block);\n    }\n\n    return this;\n  }\n\n  update(data) {\n    assert(Buffer.isBuffer(data));\n    assert(!(this.pos & FINALIZED), 'Context is not initialized.');\n    let off = 0;\n    let len = data.length;\n\n    if (len > 0) {\n      const left = this.pos;\n      const fill = 128 - left;\n\n      if (len > fill) {\n        this.pos = 0;\n        data.copy(this.block, left, off, off + fill);\n        this.count += 128;\n\n        this._compress(this.block, 0, false);\n\n        off += fill;\n        len -= fill;\n\n        while (len > 128) {\n          this.count += 128;\n\n          this._compress(data, off, false);\n\n          off += 128;\n          len -= 128;\n        }\n      }\n\n      data.copy(this.block, this.pos, off, off + len);\n      this.pos += len;\n    }\n\n    return this;\n  }\n\n  final() {\n    assert(!(this.pos & FINALIZED), 'Context is not initialized.');\n    this.count += this.pos;\n    this.block.fill(0, this.pos, 128);\n\n    this._compress(this.block, 0, true);\n\n    this.pos = FINALIZED;\n    const out = Buffer.allocUnsafe(this.size);\n\n    for (let i = 0; i < this.size; i++) out[i] = this.state[i >>> 2] >>> 8 * (i & 3);\n\n    for (let i = 0; i < 16; i++) this.state[i] = 0;\n\n    for (let i = 0; i < 32; i++) {\n      this.V[i] = 0;\n      this.M[i] = 0;\n    }\n\n    for (let i = 0; i < 128; i++) this.block[i] = 0;\n\n    return out;\n  }\n\n  _compress(block, off, last) {\n    const {\n      V,\n      M\n    } = this;\n\n    for (let i = 0; i < 16; i++) {\n      V[i] = this.state[i];\n      V[i + 16] = IV[i];\n    } // uint128\n\n\n    V[24] ^= this.count;\n    V[25] ^= this.count * (1 / 0x100000000);\n    V[26] ^= 0;\n    V[27] ^= 0;\n\n    if (last) {\n      // last block\n      V[28] ^= -1;\n      V[29] ^= -1; // last node\n\n      V[29] ^= 0;\n      V[30] ^= 0;\n    }\n\n    for (let i = 0; i < 32; i++) {\n      M[i] = readU32(block, off);\n      off += 4;\n    }\n\n    for (let i = 0; i < 12; i++) {\n      G(V, M, 0, 8, 16, 24, SIGMA[i * 16 + 0], SIGMA[i * 16 + 1]);\n      G(V, M, 2, 10, 18, 26, SIGMA[i * 16 + 2], SIGMA[i * 16 + 3]);\n      G(V, M, 4, 12, 20, 28, SIGMA[i * 16 + 4], SIGMA[i * 16 + 5]);\n      G(V, M, 6, 14, 22, 30, SIGMA[i * 16 + 6], SIGMA[i * 16 + 7]);\n      G(V, M, 0, 10, 20, 30, SIGMA[i * 16 + 8], SIGMA[i * 16 + 9]);\n      G(V, M, 2, 12, 22, 24, SIGMA[i * 16 + 10], SIGMA[i * 16 + 11]);\n      G(V, M, 4, 14, 16, 26, SIGMA[i * 16 + 12], SIGMA[i * 16 + 13]);\n      G(V, M, 6, 8, 18, 28, SIGMA[i * 16 + 14], SIGMA[i * 16 + 15]);\n    }\n\n    for (let i = 0; i < 16; i++) this.state[i] ^= V[i] ^ V[i + 16];\n  }\n\n  static hash() {\n    return new BLAKE2b();\n  }\n\n  static hmac(size) {\n    return new HMAC(BLAKE2b, 128, [size]);\n  }\n\n  static digest(data, size, key) {\n    const {\n      ctx\n    } = BLAKE2b;\n    ctx.init(size, key);\n    ctx.update(data);\n    return ctx.final();\n  }\n\n  static root(left, right, size, key) {\n    if (size == null) size = 32;\n    assert(Buffer.isBuffer(left) && left.length === size);\n    assert(Buffer.isBuffer(right) && right.length === size);\n    const {\n      ctx\n    } = BLAKE2b;\n    ctx.init(size, key);\n    ctx.update(left);\n    ctx.update(right);\n    return ctx.final();\n  }\n\n  static multi(x, y, z, size, key) {\n    const {\n      ctx\n    } = BLAKE2b;\n    ctx.init(size, key);\n    ctx.update(x);\n    ctx.update(y);\n    if (z) ctx.update(z);\n    return ctx.final();\n  }\n\n  static mac(data, key, size) {\n    return BLAKE2b.hmac(size).init(key).update(data).final();\n  }\n\n}\n/*\n * Static\n */\n\n\nBLAKE2b.native = 0;\nBLAKE2b.id = 'BLAKE2B256';\nBLAKE2b.size = 32;\nBLAKE2b.bits = 256;\nBLAKE2b.blockSize = 128;\nBLAKE2b.zero = Buffer.alloc(32, 0x00);\nBLAKE2b.ctx = new BLAKE2b();\n/*\n * Helpers\n */\n\nfunction sum64i(v, a, b) {\n  const o0 = v[a + 0] + v[b + 0];\n  const o1 = v[a + 1] + v[b + 1];\n  const c = o0 >= 0x100000000 | 0;\n  v[a + 0] = o0;\n  v[a + 1] = o1 + c;\n}\n\nfunction sum64w(v, a, b0, b1) {\n  const o0 = v[a + 0] + b0;\n  const o1 = v[a + 1] + b1;\n  const c = o0 >= 0x100000000 | 0;\n  v[a + 0] = o0;\n  v[a + 1] = o1 + c;\n}\n\nfunction G(v, m, a, b, c, d, ix, iy) {\n  const x0 = m[ix + 0];\n  const x1 = m[ix + 1];\n  const y0 = m[iy + 0];\n  const y1 = m[iy + 1];\n  sum64i(v, a, b);\n  sum64w(v, a, x0, x1);\n  const xor0 = v[d + 0] ^ v[a + 0];\n  const xor1 = v[d + 1] ^ v[a + 1];\n  v[d + 0] = xor1;\n  v[d + 1] = xor0;\n  sum64i(v, c, d);\n  const xor2 = v[b + 0] ^ v[c + 0];\n  const xor3 = v[b + 1] ^ v[c + 1];\n  v[b + 0] = xor2 >>> 24 ^ xor3 << 8;\n  v[b + 1] = xor3 >>> 24 ^ xor2 << 8;\n  sum64i(v, a, b);\n  sum64w(v, a, y0, y1);\n  const xor4 = v[d + 0] ^ v[a + 0];\n  const xor5 = v[d + 1] ^ v[a + 1];\n  v[d + 0] = xor4 >>> 16 ^ xor5 << 16;\n  v[d + 1] = xor5 >>> 16 ^ xor4 << 16;\n  sum64i(v, c, d);\n  const xor6 = v[b + 0] ^ v[c + 0];\n  const xor7 = v[b + 1] ^ v[c + 1];\n  v[b + 0] = xor7 >>> 31 ^ xor6 << 1;\n  v[b + 1] = xor6 >>> 31 ^ xor7 << 1;\n}\n\nfunction readU32(data, off) {\n  return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;\n}\n/*\n * Expose\n */\n\n\nmodule.exports = BLAKE2b;","map":null,"metadata":{},"sourceType":"script"}