{"ast":null,"code":"/*!\n * public.js - hd public keys for bcoin\n * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bio = require('bufio');\n\nconst {\n  base58\n} = require('bstring');\n\nconst sha512 = require('bcrypto/lib/sha512');\n\nconst hash160 = require('bcrypto/lib/hash160');\n\nconst hash256 = require('bcrypto/lib/hash256');\n\nconst cleanse = require('bcrypto/lib/cleanse');\n\nconst secp256k1 = require('bcrypto/lib/secp256k1');\n\nconst Network = require('../protocol/network');\n\nconst consensus = require('../protocol/consensus');\n\nconst common = require('./common');\n/**\n * HDPublicKey\n * @alias module:hd.PublicKey\n * @property {Number} depth\n * @property {Number} parentFingerPrint\n * @property {Number} childIndex\n * @property {Buffer} chainCode\n * @property {Buffer} publicKey\n */\n\n\nclass HDPublicKey {\n  /**\n   * Create an HD public key.\n   * @constructor\n   * @param {Object|Base58String} options\n   * @param {Base58String?} options.xkey - Serialized base58 key.\n   * @param {Number?} options.depth\n   * @param {Number?} options.parentFingerPrint\n   * @param {Number?} options.childIndex\n   * @param {Buffer?} options.chainCode\n   * @param {Buffer?} options.publicKey\n   */\n  constructor(options) {\n    this.depth = 0;\n    this.parentFingerPrint = 0;\n    this.childIndex = 0;\n    this.chainCode = consensus.ZERO_HASH;\n    this.publicKey = common.ZERO_KEY;\n    this.fingerPrint = -1;\n    if (options) this.fromOptions(options);\n  }\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n\n  fromOptions(options) {\n    assert(options, 'No options for HDPublicKey');\n    assert((options.depth & 0xff) === options.depth);\n    assert(options.parentFingerPrint >>> 0 === options.parentFingerPrint);\n    assert(options.childIndex >>> 0 === options.childIndex);\n    assert(Buffer.isBuffer(options.chainCode));\n    assert(Buffer.isBuffer(options.publicKey));\n    this.depth = options.depth;\n    this.parentFingerPrint = options.parentFingerPrint;\n    this.childIndex = options.childIndex;\n    this.chainCode = options.chainCode;\n    this.publicKey = options.publicKey;\n    return this;\n  }\n  /**\n   * Instantiate HD public key from options object.\n   * @param {Object} options\n   * @returns {HDPublicKey}\n   */\n\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n  /**\n   * Get HD public key (self).\n   * @returns {HDPublicKey}\n   */\n\n\n  toPublic() {\n    return this;\n  }\n  /**\n   * Get cached base58 xprivkey (always null here).\n   * @returns {null}\n   */\n\n\n  xprivkey(network) {\n    return null;\n  }\n  /**\n   * Get cached base58 xpubkey.\n   * @returns {Base58String}\n   */\n\n\n  xpubkey(network) {\n    return this.toBase58(network);\n  }\n  /**\n   * Destroy the key (zeroes chain code and pubkey).\n   */\n\n\n  destroy() {\n    this.depth = 0;\n    this.childIndex = 0;\n    this.parentFingerPrint = 0;\n    cleanse(this.chainCode);\n    cleanse(this.publicKey);\n    this.fingerPrint = -1;\n  }\n  /**\n   * Derive a child key.\n   * @param {Number} index - Derivation index.\n   * @param {Boolean?} hardened - Whether the derivation\n   * should be hardened (throws if true).\n   * @returns {HDPrivateKey}\n   * @throws on `hardened`\n   */\n\n\n  derive(index, hardened) {\n    assert(typeof index === 'number');\n    if (index >>> 0 !== index) throw new Error('Index out of range.');\n    if (index & common.HARDENED || hardened) throw new Error('Cannot derive hardened.');\n    if (this.depth >= 0xff) throw new Error('Depth too high.');\n    const id = this.getID(index);\n    const cache = common.cache.get(id);\n    if (cache) return cache;\n    const bw = bio.pool(37);\n    bw.writeBytes(this.publicKey);\n    bw.writeU32BE(index);\n    const data = bw.render();\n    const hash = sha512.mac(data, this.chainCode);\n    const left = hash.slice(0, 32);\n    const right = hash.slice(32, 64);\n    let key;\n\n    try {\n      key = secp256k1.publicKeyTweakAdd(this.publicKey, left, true);\n    } catch (e) {\n      return this.derive(index + 1);\n    }\n\n    if (this.fingerPrint === -1) {\n      const fp = hash160.digest(this.publicKey);\n      this.fingerPrint = fp.readUInt32BE(0, true);\n    }\n\n    const child = new this.constructor();\n    child.depth = this.depth + 1;\n    child.parentFingerPrint = this.fingerPrint;\n    child.childIndex = index;\n    child.chainCode = right;\n    child.publicKey = key;\n    common.cache.set(id, child);\n    return child;\n  }\n  /**\n   * Unique HD key ID.\n   * @private\n   * @param {Number} index\n   * @returns {String}\n   */\n\n\n  getID(index) {\n    return 'b' + this.publicKey.toString('hex') + index;\n  }\n  /**\n   * Derive a BIP44 account key (does not derive, only ensures account key).\n   * @method\n   * @param {Number} purpose\n   * @param {Number} type\n   * @param {Number} account\n   * @returns {HDPublicKey}\n   * @throws Error if key is not already an account key.\n   */\n\n\n  deriveAccount(purpose, type, account) {\n    assert(purpose >>> 0 === purpose);\n    assert(type >>> 0 === type);\n    assert(account >>> 0 === account);\n    assert(this.isAccount(account), 'Cannot derive account index.');\n    return this;\n  }\n  /**\n   * Test whether the key is a master key.\n   * @method\n   * @returns {Boolean}\n   */\n\n\n  isMaster() {\n    return common.isMaster(this);\n  }\n  /**\n   * Test whether the key is (most likely) a BIP44 account key.\n   * @method\n   * @param {Number?} account\n   * @returns {Boolean}\n   */\n\n\n  isAccount(account) {\n    return common.isAccount(this, account);\n  }\n  /**\n   * Test whether a string is a valid path.\n   * @param {String} path\n   * @param {Boolean?} hardened\n   * @returns {Boolean}\n   */\n\n\n  static isValidPath(path) {\n    try {\n      common.parsePath(path, false);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n   * Derive a key from a derivation path.\n   * @param {String} path\n   * @returns {HDPublicKey}\n   * @throws Error if `path` is not a valid path.\n   * @throws Error if hardened.\n   */\n\n\n  derivePath(path) {\n    const indexes = common.parsePath(path, false);\n    let key = this;\n\n    for (const index of indexes) key = key.derive(index);\n\n    return key;\n  }\n  /**\n   * Compare a key against an object.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n\n  equals(obj) {\n    assert(HDPublicKey.isHDPublicKey(obj));\n    return this.depth === obj.depth && this.parentFingerPrint === obj.parentFingerPrint && this.childIndex === obj.childIndex && this.chainCode.equals(obj.chainCode) && this.publicKey.equals(obj.publicKey);\n  }\n  /**\n   * Compare a key against an object.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n\n  compare(key) {\n    assert(HDPublicKey.isHDPublicKey(key));\n    let cmp = this.depth - key.depth;\n    if (cmp !== 0) return cmp;\n    cmp = this.parentFingerPrint - key.parentFingerPrint;\n    if (cmp !== 0) return cmp;\n    cmp = this.childIndex - key.childIndex;\n    if (cmp !== 0) return cmp;\n    cmp = this.chainCode.compare(key.chainCode);\n    if (cmp !== 0) return cmp;\n    cmp = this.publicKey.compare(key.publicKey);\n    if (cmp !== 0) return cmp;\n    return 0;\n  }\n  /**\n   * Convert key to a more json-friendly object.\n   * @returns {Object}\n   */\n\n\n  toJSON(network) {\n    return {\n      xpubkey: this.xpubkey(network)\n    };\n  }\n  /**\n   * Inject properties from json object.\n   * @private\n   * @param {Object} json\n   * @param {Network?} network\n   */\n\n\n  fromJSON(json, network) {\n    assert(json.xpubkey, 'Could not handle HD key JSON.');\n    this.fromBase58(json.xpubkey, network);\n    return this;\n  }\n  /**\n   * Instantiate an HDPublicKey from a jsonified key object.\n   * @param {Object} json - The jsonified transaction object.\n   * @param {Network?} network\n   * @returns {HDPrivateKey}\n   */\n\n\n  static fromJSON(json, network) {\n    return new this().fromJSON(json, network);\n  }\n  /**\n   * Test whether an object is in the form of a base58 xpubkey.\n   * @param {String} data\n   * @param {(Network|NetworkType)?} network\n   * @returns {Boolean}\n   */\n\n\n  static isBase58(data, network) {\n    if (typeof data !== 'string') return false;\n    if (data.length < 4) return false;\n    const prefix = data.substring(0, 4);\n\n    try {\n      Network.fromPublic58(prefix, network);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n   * Test whether a buffer has a valid network prefix.\n   * @param {Buffer} data\n   * @param {(Network|NetworkType)?} network\n   * @returns {NetworkType}\n   */\n\n\n  static isRaw(data, network) {\n    if (!Buffer.isBuffer(data)) return false;\n    if (data.length < 4) return false;\n    const version = data.readUInt32BE(0, true);\n\n    try {\n      Network.fromPublic(version, network);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n   * Inject properties from a base58 key.\n   * @private\n   * @param {Base58String} xkey\n   * @param {Network?} network\n   */\n\n\n  fromBase58(xkey, network) {\n    assert(typeof xkey === 'string');\n    return this.fromRaw(base58.decode(xkey), network);\n  }\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {BufferReader} br\n   * @param {(Network|NetworkType)?} network\n   */\n\n\n  fromReader(br, network) {\n    const version = br.readU32BE();\n    Network.fromPublic(version, network);\n    this.depth = br.readU8();\n    this.parentFingerPrint = br.readU32BE();\n    this.childIndex = br.readU32BE();\n    this.chainCode = br.readBytes(32);\n    this.publicKey = br.readBytes(33);\n    br.verifyChecksum(hash256.digest);\n    return this;\n  }\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   * @param {(Network|NetworkType)?} network\n   */\n\n\n  fromRaw(data, network) {\n    return this.fromReader(bio.read(data), network);\n  }\n  /**\n   * Serialize key data to base58 extended key.\n   * @param {(Network|NetworkType)?} network\n   * @returns {Base58String}\n   */\n\n\n  toBase58(network) {\n    return base58.encode(this.toRaw(network));\n  }\n  /**\n   * Write the key to a buffer writer.\n   * @param {BufferWriter} bw\n   * @param {(Network|NetworkType)?} network\n   */\n\n\n  toWriter(bw, network) {\n    network = Network.get(network);\n    bw.writeU32BE(network.keyPrefix.xpubkey);\n    bw.writeU8(this.depth);\n    bw.writeU32BE(this.parentFingerPrint);\n    bw.writeU32BE(this.childIndex);\n    bw.writeBytes(this.chainCode);\n    bw.writeBytes(this.publicKey);\n    bw.writeChecksum(hash256.digest);\n    return bw;\n  }\n  /**\n   * Calculate serialization size.\n   * @returns {Number}\n   */\n\n\n  getSize() {\n    return 82;\n  }\n  /**\n   * Serialize the key.\n   * @param {(Network|NetworkType)?} network\n   * @returns {Buffer}\n   */\n\n\n  toRaw(network) {\n    return this.toWriter(bio.write(82), network).render();\n  }\n  /**\n   * Instantiate an HD public key from a base58 string.\n   * @param {Base58String} xkey\n   * @param {Network?} network\n   * @returns {HDPublicKey}\n   */\n\n\n  static fromBase58(xkey, network) {\n    return new this().fromBase58(xkey, network);\n  }\n  /**\n   * Instantiate key from serialized data.\n   * @param {BufferReader} br\n   * @param {(Network|NetworkType)?} network\n   * @returns {HDPublicKey}\n   */\n\n\n  static fromReader(br, network) {\n    return new this().fromReader(br, network);\n  }\n  /**\n   * Instantiate key from serialized data.\n   * @param {Buffer} data\n   * @param {(Network|NetworkType)?} network\n   * @returns {HDPublicKey}\n   */\n\n\n  static fromRaw(data, network) {\n    return new this().fromRaw(data, network);\n  }\n  /**\n   * Test whether an object is a HDPublicKey.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n\n  static isHDPublicKey(obj) {\n    return obj instanceof HDPublicKey;\n  }\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = HDPublicKey;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/hd/public.js"],"names":["assert","require","bio","base58","sha512","hash160","hash256","cleanse","secp256k1","Network","consensus","common","HDPublicKey","constructor","options","depth","parentFingerPrint","childIndex","chainCode","ZERO_HASH","publicKey","ZERO_KEY","fingerPrint","fromOptions","Buffer","isBuffer","toPublic","xprivkey","network","xpubkey","toBase58","destroy","derive","index","hardened","Error","HARDENED","id","getID","cache","get","bw","pool","writeBytes","writeU32BE","data","render","hash","mac","left","slice","right","key","publicKeyTweakAdd","e","fp","digest","readUInt32BE","child","set","toString","deriveAccount","purpose","type","account","isAccount","isMaster","isValidPath","path","parsePath","derivePath","indexes","equals","obj","isHDPublicKey","compare","cmp","toJSON","fromJSON","json","fromBase58","isBase58","length","prefix","substring","fromPublic58","isRaw","version","fromPublic","xkey","fromRaw","decode","fromReader","br","readU32BE","readU8","readBytes","verifyChecksum","read","encode","toRaw","toWriter","keyPrefix","writeU8","writeChecksum","getSize","write","module","exports"],"mappings":"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","sourcesContent":["/*!\n * public.js - hd public keys for bcoin\n * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bio = require('bufio');\nconst {base58} = require('bstring');\nconst sha512 = require('bcrypto/lib/sha512');\nconst hash160 = require('bcrypto/lib/hash160');\nconst hash256 = require('bcrypto/lib/hash256');\nconst cleanse = require('bcrypto/lib/cleanse');\nconst secp256k1 = require('bcrypto/lib/secp256k1');\nconst Network = require('../protocol/network');\nconst consensus = require('../protocol/consensus');\nconst common = require('./common');\n\n/**\n * HDPublicKey\n * @alias module:hd.PublicKey\n * @property {Number} depth\n * @property {Number} parentFingerPrint\n * @property {Number} childIndex\n * @property {Buffer} chainCode\n * @property {Buffer} publicKey\n */\n\nclass HDPublicKey {\n  /**\n   * Create an HD public key.\n   * @constructor\n   * @param {Object|Base58String} options\n   * @param {Base58String?} options.xkey - Serialized base58 key.\n   * @param {Number?} options.depth\n   * @param {Number?} options.parentFingerPrint\n   * @param {Number?} options.childIndex\n   * @param {Buffer?} options.chainCode\n   * @param {Buffer?} options.publicKey\n   */\n\n  constructor(options) {\n    this.depth = 0;\n    this.parentFingerPrint = 0;\n    this.childIndex = 0;\n    this.chainCode = consensus.ZERO_HASH;\n    this.publicKey = common.ZERO_KEY;\n\n    this.fingerPrint = -1;\n\n    if (options)\n      this.fromOptions(options);\n  }\n\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n  fromOptions(options) {\n    assert(options, 'No options for HDPublicKey');\n    assert((options.depth & 0xff) === options.depth);\n    assert((options.parentFingerPrint >>> 0) === options.parentFingerPrint);\n    assert((options.childIndex >>> 0) === options.childIndex);\n    assert(Buffer.isBuffer(options.chainCode));\n    assert(Buffer.isBuffer(options.publicKey));\n\n    this.depth = options.depth;\n    this.parentFingerPrint = options.parentFingerPrint;\n    this.childIndex = options.childIndex;\n    this.chainCode = options.chainCode;\n    this.publicKey = options.publicKey;\n\n    return this;\n  }\n\n  /**\n   * Instantiate HD public key from options object.\n   * @param {Object} options\n   * @returns {HDPublicKey}\n   */\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n\n  /**\n   * Get HD public key (self).\n   * @returns {HDPublicKey}\n   */\n\n  toPublic() {\n    return this;\n  }\n\n  /**\n   * Get cached base58 xprivkey (always null here).\n   * @returns {null}\n   */\n\n  xprivkey(network) {\n    return null;\n  }\n\n  /**\n   * Get cached base58 xpubkey.\n   * @returns {Base58String}\n   */\n\n  xpubkey(network) {\n    return this.toBase58(network);\n  }\n\n  /**\n   * Destroy the key (zeroes chain code and pubkey).\n   */\n\n  destroy() {\n    this.depth = 0;\n    this.childIndex = 0;\n    this.parentFingerPrint = 0;\n\n    cleanse(this.chainCode);\n    cleanse(this.publicKey);\n\n    this.fingerPrint = -1;\n  }\n\n  /**\n   * Derive a child key.\n   * @param {Number} index - Derivation index.\n   * @param {Boolean?} hardened - Whether the derivation\n   * should be hardened (throws if true).\n   * @returns {HDPrivateKey}\n   * @throws on `hardened`\n   */\n\n  derive(index, hardened) {\n    assert(typeof index === 'number');\n\n    if ((index >>> 0) !== index)\n      throw new Error('Index out of range.');\n\n    if ((index & common.HARDENED) || hardened)\n      throw new Error('Cannot derive hardened.');\n\n    if (this.depth >= 0xff)\n      throw new Error('Depth too high.');\n\n    const id = this.getID(index);\n    const cache = common.cache.get(id);\n\n    if (cache)\n      return cache;\n\n    const bw = bio.pool(37);\n\n    bw.writeBytes(this.publicKey);\n    bw.writeU32BE(index);\n\n    const data = bw.render();\n\n    const hash = sha512.mac(data, this.chainCode);\n    const left = hash.slice(0, 32);\n    const right = hash.slice(32, 64);\n\n    let key;\n    try {\n      key = secp256k1.publicKeyTweakAdd(this.publicKey, left, true);\n    } catch (e) {\n      return this.derive(index + 1);\n    }\n\n    if (this.fingerPrint === -1) {\n      const fp = hash160.digest(this.publicKey);\n      this.fingerPrint = fp.readUInt32BE(0, true);\n    }\n\n    const child = new this.constructor();\n    child.depth = this.depth + 1;\n    child.parentFingerPrint = this.fingerPrint;\n    child.childIndex = index;\n    child.chainCode = right;\n    child.publicKey = key;\n\n    common.cache.set(id, child);\n\n    return child;\n  }\n\n  /**\n   * Unique HD key ID.\n   * @private\n   * @param {Number} index\n   * @returns {String}\n   */\n\n  getID(index) {\n    return 'b' + this.publicKey.toString('hex') + index;\n  }\n\n  /**\n   * Derive a BIP44 account key (does not derive, only ensures account key).\n   * @method\n   * @param {Number} purpose\n   * @param {Number} type\n   * @param {Number} account\n   * @returns {HDPublicKey}\n   * @throws Error if key is not already an account key.\n   */\n\n  deriveAccount(purpose, type, account) {\n    assert((purpose >>> 0) === purpose);\n    assert((type >>> 0) === type);\n    assert((account >>> 0) === account);\n    assert(this.isAccount(account), 'Cannot derive account index.');\n    return this;\n  }\n\n  /**\n   * Test whether the key is a master key.\n   * @method\n   * @returns {Boolean}\n   */\n\n  isMaster() {\n    return common.isMaster(this);\n  }\n\n  /**\n   * Test whether the key is (most likely) a BIP44 account key.\n   * @method\n   * @param {Number?} account\n   * @returns {Boolean}\n   */\n\n  isAccount(account) {\n    return common.isAccount(this, account);\n  }\n\n  /**\n   * Test whether a string is a valid path.\n   * @param {String} path\n   * @param {Boolean?} hardened\n   * @returns {Boolean}\n   */\n\n  static isValidPath(path) {\n    try {\n      common.parsePath(path, false);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Derive a key from a derivation path.\n   * @param {String} path\n   * @returns {HDPublicKey}\n   * @throws Error if `path` is not a valid path.\n   * @throws Error if hardened.\n   */\n\n  derivePath(path) {\n    const indexes = common.parsePath(path, false);\n\n    let key = this;\n\n    for (const index of indexes)\n      key = key.derive(index);\n\n    return key;\n  }\n\n  /**\n   * Compare a key against an object.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n  equals(obj) {\n    assert(HDPublicKey.isHDPublicKey(obj));\n\n    return this.depth === obj.depth\n      && this.parentFingerPrint === obj.parentFingerPrint\n      && this.childIndex === obj.childIndex\n      && this.chainCode.equals(obj.chainCode)\n      && this.publicKey.equals(obj.publicKey);\n  }\n\n  /**\n   * Compare a key against an object.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n  compare(key) {\n    assert(HDPublicKey.isHDPublicKey(key));\n\n    let cmp = this.depth - key.depth;\n\n    if (cmp !== 0)\n      return cmp;\n\n    cmp = this.parentFingerPrint - key.parentFingerPrint;\n\n    if (cmp !== 0)\n      return cmp;\n\n    cmp = this.childIndex - key.childIndex;\n\n    if (cmp !== 0)\n      return cmp;\n\n    cmp = this.chainCode.compare(key.chainCode);\n\n    if (cmp !== 0)\n      return cmp;\n\n    cmp = this.publicKey.compare(key.publicKey);\n\n    if (cmp !== 0)\n      return cmp;\n\n    return 0;\n  }\n\n  /**\n   * Convert key to a more json-friendly object.\n   * @returns {Object}\n   */\n\n  toJSON(network) {\n    return {\n      xpubkey: this.xpubkey(network)\n    };\n  }\n\n  /**\n   * Inject properties from json object.\n   * @private\n   * @param {Object} json\n   * @param {Network?} network\n   */\n\n  fromJSON(json, network) {\n    assert(json.xpubkey, 'Could not handle HD key JSON.');\n    this.fromBase58(json.xpubkey, network);\n    return this;\n  }\n\n  /**\n   * Instantiate an HDPublicKey from a jsonified key object.\n   * @param {Object} json - The jsonified transaction object.\n   * @param {Network?} network\n   * @returns {HDPrivateKey}\n   */\n\n  static fromJSON(json, network) {\n    return new this().fromJSON(json, network);\n  }\n\n  /**\n   * Test whether an object is in the form of a base58 xpubkey.\n   * @param {String} data\n   * @param {(Network|NetworkType)?} network\n   * @returns {Boolean}\n   */\n\n  static isBase58(data, network) {\n    if (typeof data !== 'string')\n      return false;\n\n    if (data.length < 4)\n      return false;\n\n    const prefix = data.substring(0, 4);\n\n    try {\n      Network.fromPublic58(prefix, network);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Test whether a buffer has a valid network prefix.\n   * @param {Buffer} data\n   * @param {(Network|NetworkType)?} network\n   * @returns {NetworkType}\n   */\n\n  static isRaw(data, network) {\n    if (!Buffer.isBuffer(data))\n      return false;\n\n    if (data.length < 4)\n      return false;\n\n    const version = data.readUInt32BE(0, true);\n\n    try {\n      Network.fromPublic(version, network);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Inject properties from a base58 key.\n   * @private\n   * @param {Base58String} xkey\n   * @param {Network?} network\n   */\n\n  fromBase58(xkey, network) {\n    assert(typeof xkey === 'string');\n    return this.fromRaw(base58.decode(xkey), network);\n  }\n\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {BufferReader} br\n   * @param {(Network|NetworkType)?} network\n   */\n\n  fromReader(br, network) {\n    const version = br.readU32BE();\n\n    Network.fromPublic(version, network);\n\n    this.depth = br.readU8();\n    this.parentFingerPrint = br.readU32BE();\n    this.childIndex = br.readU32BE();\n    this.chainCode = br.readBytes(32);\n    this.publicKey = br.readBytes(33);\n\n    br.verifyChecksum(hash256.digest);\n\n    return this;\n  }\n\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   * @param {(Network|NetworkType)?} network\n   */\n\n  fromRaw(data, network) {\n    return this.fromReader(bio.read(data), network);\n  }\n\n  /**\n   * Serialize key data to base58 extended key.\n   * @param {(Network|NetworkType)?} network\n   * @returns {Base58String}\n   */\n\n  toBase58(network) {\n    return base58.encode(this.toRaw(network));\n  }\n\n  /**\n   * Write the key to a buffer writer.\n   * @param {BufferWriter} bw\n   * @param {(Network|NetworkType)?} network\n   */\n\n  toWriter(bw, network) {\n    network = Network.get(network);\n\n    bw.writeU32BE(network.keyPrefix.xpubkey);\n    bw.writeU8(this.depth);\n    bw.writeU32BE(this.parentFingerPrint);\n    bw.writeU32BE(this.childIndex);\n    bw.writeBytes(this.chainCode);\n    bw.writeBytes(this.publicKey);\n    bw.writeChecksum(hash256.digest);\n\n    return bw;\n  }\n\n  /**\n   * Calculate serialization size.\n   * @returns {Number}\n   */\n\n  getSize() {\n    return 82;\n  }\n\n  /**\n   * Serialize the key.\n   * @param {(Network|NetworkType)?} network\n   * @returns {Buffer}\n   */\n\n  toRaw(network) {\n    return this.toWriter(bio.write(82), network).render();\n  }\n\n  /**\n   * Instantiate an HD public key from a base58 string.\n   * @param {Base58String} xkey\n   * @param {Network?} network\n   * @returns {HDPublicKey}\n   */\n\n  static fromBase58(xkey, network) {\n    return new this().fromBase58(xkey, network);\n  }\n\n  /**\n   * Instantiate key from serialized data.\n   * @param {BufferReader} br\n   * @param {(Network|NetworkType)?} network\n   * @returns {HDPublicKey}\n   */\n\n  static fromReader(br, network) {\n    return new this().fromReader(br, network);\n  }\n\n  /**\n   * Instantiate key from serialized data.\n   * @param {Buffer} data\n   * @param {(Network|NetworkType)?} network\n   * @returns {HDPublicKey}\n   */\n\n  static fromRaw(data, network) {\n    return new this().fromRaw(data, network);\n  }\n\n  /**\n   * Test whether an object is a HDPublicKey.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n  static isHDPublicKey(obj) {\n    return obj instanceof HDPublicKey;\n  }\n}\n\n/*\n * Expose\n */\n\nmodule.exports = HDPublicKey;\n"]},"metadata":{},"sourceType":"module"}