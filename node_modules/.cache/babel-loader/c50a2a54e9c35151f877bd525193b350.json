{"ast":null,"code":"/*!\n * schnorr-legacy.js - bip-schnorr for bcrypto\n * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on sipa/bip-schnorr:\n *   Copyright (c) 2018-2019, Pieter Wuille (2-clause BSD License).\n *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/reference.py\n *\n * Parts of this software are based on ElementsProject/secp256k1-zkp:\n *   Copyright (c) 2013, Pieter Wuille.\n *   https://github.com/ElementsProject/secp256k1-zkp\n *\n * Resources:\n *   https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki\n *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/reference.py\n *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/test-vectors.csv\n *   https://github.com/ElementsProject/secp256k1-zkp/tree/11af701/src/modules/schnorrsig\n *   https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md\n *\n * References:\n *\n *   [SCHNORR] Schnorr Signatures for secp256k1\n *     Pieter Wuille\n *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki\n *\n *   [CASH] Schnorr Signature specification\n *     Mark B. Lundeberg\n *     https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst BatchRNG = require('./batch-rng');\n\nconst BN = require('../bn');\n/**\n * Schnorr\n */\n\n\nclass Schnorr {\n  constructor(curve, hash) {\n    this.curve = curve;\n    this.hash = hash;\n    this.rng = new BatchRNG(this.curve, this.encode.bind(this));\n  }\n\n  check() {\n    // [SCHNORR] \"Footnotes\".\n    // Must be congruent to 3 mod 4.\n    if (this.curve.p.andln(3) !== 3) throw new Error(`Schnorr is not supported for ${this.curve.id}.`);\n  }\n\n  encode(key) {\n    // Extra speedy key reserialization.\n    assert(Buffer.isBuffer(key));\n    const {\n      fieldSize\n    } = this.curve;\n    if (key.length === 1 + fieldSize) return key;\n    if (key.length !== 1 + fieldSize * 2) throw new Error('Invalid point.');\n    const out = Buffer.allocUnsafe(1 + fieldSize);\n    out[0] = 0x02 | key[key.length - 1] & 1;\n    key.copy(out, 1, 1, 1 + fieldSize);\n    return out;\n  }\n\n  hashInt() {\n    // [SCHNORR] \"Specification\".\n    // eslint-disable-next-line\n    const h = new this.hash();\n    h.init();\n\n    for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n      items[_key] = arguments[_key];\n    }\n\n    for (const item of items) h.update(item);\n\n    let hash = h.final();\n    if (hash.length > this.curve.scalarSize) hash = hash.slice(0, this.curve.scalarSize);\n    const num = BN.decode(hash, this.curve.endian);\n    return num.imod(this.curve.n);\n  }\n\n  hashNonce(a, m) {\n    return this.hashInt(a, m);\n  }\n\n  hashChallenge(R, A, m) {\n    return this.hashInt(R, this.encode(A), m);\n  }\n\n  sign(msg, key) {\n    assert(Buffer.isBuffer(msg));\n    this.check();\n    return this._sign(msg, key);\n  }\n\n  _sign(msg, key) {\n    // Schnorr Signing.\n    //\n    // [SCHNORR] \"Signing\".\n    // [CASH] \"Recommended practices for secure signature generation\".\n    //\n    // Assumptions:\n    //\n    //   - Let `H` be a cryptographic hash function.\n    //   - Let `m` be a 32-byte array.\n    //   - Let `a` be a secret non-zero scalar.\n    //   - k != 0.\n    //\n    // Computation:\n    //\n    //   A = G * a\n    //   k = H(a, m) mod n\n    //   R = G * k\n    //   k = -k mod n, if y(R) is not square\n    //   r = x(R)\n    //   e = H(r, A, m) mod n\n    //   s = (k + e * a) mod n\n    //   S = (r, s)\n    //\n    // Note that `k` must remain secret,\n    // otherwise an attacker can compute:\n    //\n    //   a = (s - k) / e mod n\n    const {\n      n\n    } = this.curve;\n    const G = this.curve.g;\n    const a = this.curve.decodeScalar(key);\n    if (a.isZero() || a.cmp(n) >= 0) throw new Error('Invalid private key.');\n    const A = G.mulBlind(a);\n    const k = this.hashNonce(key, msg);\n    if (k.isZero()) throw new Error('Signing failed (k\\' = 0).');\n    const R = G.mulBlind(k);\n    if (!R.isSquare()) k.ineg().imod(n);\n    const Rraw = R.encodeX();\n    const Araw = A.encode();\n    const e = this.hashChallenge(Rraw, Araw, msg);\n    const s = k.add(e.mul(a)).imod(n);\n    return Buffer.concat([Rraw, this.curve.encodeScalar(s)]);\n  }\n\n  verify(msg, sig, key) {\n    assert(Buffer.isBuffer(msg));\n    assert(Buffer.isBuffer(sig));\n    assert(Buffer.isBuffer(key));\n    this.check();\n    if (sig.length !== this.curve.fieldSize + this.curve.scalarSize) return false;\n\n    try {\n      return this._verify(msg, sig, key);\n    } catch (e) {\n      return false;\n    }\n  }\n\n  _verify(msg, sig, key) {\n    // Schnorr Verification.\n    //\n    // [SCHNORR] \"Verification\".\n    // [CASH] \"Signature verification algorithm\".\n    //\n    // Assumptions:\n    //\n    //   - Let `H` be a cryptographic hash function.\n    //   - Let `m` be a 32-byte array.\n    //   - Let `r` and `s` be signature elements.\n    //   - Let `A` be a valid group element.\n    //   - r^3 + a * r + b is square in F(p).\n    //   - r < p, s < n.\n    //   - R != O.\n    //\n    // Computation:\n    //\n    //   R = (r, sqrt(r^3 + a * r + b))\n    //   e = H(r, A, m) mod n\n    //   R == G * s - A * e\n    //\n    // We can skip a square root with:\n    //\n    //   e = H(r, A, m) mod n\n    //   R = G * s - A * e\n    //   y(R) is square\n    //   x(R) == r\n    //\n    // We can also avoid affinization by\n    // replacing the two assertions with:\n    //\n    //   (y(R) * z(R) mod p) is square\n    //   x(R) == r * z(R)^2 mod p\n    //\n    // Furthermore, squareness can be calculated\n    // with a variable time Jacobi symbol algorithm.\n    const {\n      p,\n      n\n    } = this.curve;\n    const G = this.curve.g;\n    const Rraw = sig.slice(0, this.curve.fieldSize);\n    const sraw = sig.slice(this.curve.fieldSize);\n    const r = this.curve.decodeField(Rraw);\n    const s = this.curve.decodeScalar(sraw);\n    const A = this.curve.decodePoint(key);\n    if (r.cmp(p) >= 0 || s.cmp(n) >= 0) return false;\n    const e = this.hashChallenge(Rraw, key, msg);\n    const R = G.jmulAdd(s, A, e.ineg().imod(n));\n    if (!R.isSquare()) return false;\n    if (!R.eqX(r)) return false;\n    return true;\n  }\n\n  verifyBatch(batch) {\n    assert(Array.isArray(batch));\n    this.check();\n\n    for (const item of batch) {\n      assert(Array.isArray(item) && item.length === 3);\n      const [msg, sig, key] = item;\n      assert(Buffer.isBuffer(msg));\n      assert(Buffer.isBuffer(sig));\n      assert(Buffer.isBuffer(key));\n      if (sig.length !== this.curve.fieldSize + this.curve.scalarSize) return false;\n    }\n\n    try {\n      return this._verifyBatch(batch);\n    } catch (e) {\n      return false;\n    }\n  }\n\n  _verifyBatch(batch) {\n    // Schnorr Batch Verification.\n    //\n    // [SCHNORR] \"Batch Verification\".\n    //\n    // Assumptions:\n    //\n    //   - Let `H` be a cryptographic hash function.\n    //   - Let `m` be a 32-byte array.\n    //   - Let `r` and `s` be signature elements.\n    //   - Let `A` be a valid group element.\n    //   - Let `i` be the batch item index.\n    //   - r^3 + a * r + b is square in F(p).\n    //   - r < p, s < n.\n    //   - a1 = 1 mod n.\n    //\n    // Computation:\n    //\n    //   Ri = (ri, sqrt(ri^3 + a * ri + b))\n    //   ei = H(ri, Ai, mi) mod n\n    //   ai = random integer in [1,n-1]\n    //   lhs = si * ai + ... mod n\n    //   rhs = Ri * ai + Ai * (ei * ai mod n) + ...\n    //   G * -lhs + rhs == O\n    const {\n      n\n    } = this.curve;\n    const G = this.curve.g;\n    const points = new Array(1 + batch.length * 2);\n    const coeffs = new Array(1 + batch.length * 2);\n    const sum = new BN(0);\n    this.rng.init(batch);\n    points[0] = G;\n    coeffs[0] = sum;\n\n    for (let i = 0; i < batch.length; i++) {\n      const [msg, sig, key] = batch[i];\n      const Rraw = sig.slice(0, this.curve.fieldSize);\n      const sraw = sig.slice(this.curve.fieldSize);\n      const R = this.curve.decodeSquare(Rraw);\n      const s = this.curve.decodeScalar(sraw);\n      const A = this.curve.decodePoint(key);\n      if (s.cmp(n) >= 0) return false;\n      const e = this.hashChallenge(Rraw, key, msg);\n      const a = this.rng.generate(i);\n      const ea = e.mul(a).imod(n);\n      sum.iadd(s.mul(a)).imod(n);\n      points[1 + i * 2 + 0] = R;\n      coeffs[1 + i * 2 + 0] = a;\n      points[1 + i * 2 + 1] = A;\n      coeffs[1 + i * 2 + 1] = ea;\n    }\n\n    sum.ineg().imod(n);\n    return this.curve.jmulAll(points, coeffs).isInfinity();\n  }\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = Schnorr;","map":null,"metadata":{},"sourceType":"script"}