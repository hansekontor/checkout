{"ast":null,"code":"/*!\n * coin.js - coin object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bio = require('bufio');\n\nconst util = require('../utils/util');\n\nconst Amount = require('../btc/amount');\n\nconst Output = require('./output');\n\nconst Network = require('../protocol/network');\n\nconst consensus = require('../protocol/consensus');\n\nconst Outpoint = require('./outpoint');\n\nconst SLP = require('../script/slp');\n\nconst {\n  inspectSymbol\n} = require('../utils');\n/**\n * Coin\n * Represents an unspent output.\n * @alias module:primitives.Coin\n * @extends Output\n * @property {Number} version\n * @property {Number} height\n * @property {Amount} value\n * @property {Script} script\n * @property {Boolean} coinbase\n * @property {Hash} hash\n * @property {Number} index\n */\n\n\nclass Coin extends Output {\n  /**\n   * Create a coin.\n   * @constructor\n   * @param {Object} options\n   */\n  constructor(options) {\n    super();\n    this.version = 1;\n    this.height = -1;\n    this.coinbase = false;\n    this.hash = consensus.ZERO_HASH;\n    this.index = 0;\n    if (options) this.fromOptions(options);\n  }\n  /**\n   * Inject options into coin.\n   * @private\n   * @param {Object} options\n   */\n\n\n  fromOptions(options) {\n    assert(options, 'Coin data is required.');\n\n    if (options.version != null) {\n      assert(options.version >>> 0 === options.version, 'Version must be a uint32.');\n      this.version = options.version;\n    }\n\n    if (options.height != null) {\n      if (options.height !== -1) {\n        assert(options.height >>> 0 === options.height, 'Height must be a uint32.');\n        this.height = options.height;\n      } else {\n        this.height = -1;\n      }\n    }\n\n    if (options.value != null) {\n      assert(Number.isSafeInteger(options.value) && options.value >= 0, 'Value must be a uint64.');\n      this.value = options.value;\n    }\n\n    if (options.script) this.script.fromOptions(options.script);\n\n    if (options.coinbase != null) {\n      assert(typeof options.coinbase === 'boolean', 'Coinbase must be a boolean.');\n      this.coinbase = options.coinbase;\n    }\n\n    if (options.hash != null) {\n      assert(Buffer.isBuffer(options.hash));\n      this.hash = options.hash;\n    }\n\n    if (options.index != null) {\n      assert(options.index >>> 0 === options.index, 'Index must be a uint32.');\n      this.index = options.index;\n    }\n\n    return this;\n  }\n  /**\n   * Instantiate Coin from options object.\n   * @private\n   * @param {Object} options\n   */\n\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n  /**\n   * Clone the coin.\n   * @private\n   * @returns {Coin}\n   */\n\n\n  clone() {\n    assert(false, 'Coins are not cloneable.');\n  }\n  /**\n   * Calculate number of confirmations since coin was created.\n   * @param {Number?} height - Current chain height. Network\n   * height is used if not passed in.\n   * @return {Number}\n   */\n\n\n  getDepth(height) {\n    assert(typeof height === 'number', 'Must pass a height.');\n    if (this.height === -1) return 0;\n    if (height === -1) return 0;\n    if (height < this.height) return 0;\n    return height - this.height + 1;\n  }\n  /**\n   * Serialize coin to a key\n   * suitable for a hash table.\n   * @returns {String}\n   */\n\n\n  toKey() {\n    return Outpoint.toKey(this.hash, this.index);\n  }\n  /**\n   * Inject properties from hash table key.\n   * @private\n   * @param {String} key\n   * @returns {Coin}\n   */\n\n\n  fromKey(key) {\n    const {\n      hash,\n      index\n    } = Outpoint.fromKey(key);\n    this.hash = hash;\n    this.index = index;\n    return this;\n  }\n  /**\n   * Instantiate coin from hash table key.\n   * @param {String} key\n   * @returns {Coin}\n   */\n\n\n  static fromKey(key) {\n    return new this().fromKey(key);\n  }\n  /**\n   * Get little-endian hash.\n   * @returns {Hash}\n   */\n\n\n  rhash() {\n    return util.revHex(this.hash);\n  }\n  /**\n   * Get little-endian hash.\n   * @returns {Hash}\n   */\n\n\n  txid() {\n    return this.rhash();\n  }\n  /**\n   * Convert the coin to a more user-friendly object.\n   * @returns {Object}\n   */\n\n\n  [inspectSymbol]() {\n    const hr = {\n      type: this.getType(),\n      version: this.version,\n      height: this.height,\n      value: Amount.btc(this.value),\n      script: this.script,\n      coinbase: this.coinbase,\n      hash: this.hash ? util.revHex(this.hash) : null,\n      index: this.index,\n      address: this.getAddress()\n    };\n\n    if (this.slp) {\n      return { ...hr,\n        slp: this.slp\n      };\n    }\n\n    return hr;\n  }\n  /**\n   * Convert the coin to an object suitable\n   * for JSON serialization.\n   * @returns {Object}\n   */\n\n\n  toJSON() {\n    return this.getJSON();\n  }\n  /**\n   * Convert the coin to an object suitable\n   * for JSON serialization. Note that the hash\n   * will be reversed to abide by bitcoind's legacy\n   * of little-endian uint256s.\n   * @param {Network} network\n   * @param {Boolean} minimal\n   * @returns {Object}\n   */\n\n\n  getJSON(network, minimal) {\n    let addr = this.getAddress();\n    network = Network.get(network);\n    if (addr) addr = addr.toString(network);\n    const json = {\n      version: this.version,\n      height: this.height,\n      value: this.value,\n      script: this.script.toJSON(),\n      address: addr,\n      coinbase: this.coinbase,\n      hash: !minimal ? this.rhash() : undefined,\n      index: !minimal ? this.index : undefined\n    };\n\n    if (this.slp) {\n      return { ...json,\n        slp: this.slp.getJSON()\n      };\n    }\n\n    return json;\n  }\n  /**\n   * Inject JSON properties into coin.\n   * @private\n   * @param {Object} json\n   */\n\n\n  fromJSON(json) {\n    assert(json, 'Coin data required.');\n    assert(json.version >>> 0 === json.version, 'Version must be a uint32.');\n    assert(json.height === -1 || json.height >>> 0 === json.height, 'Height must be a uint32.');\n    assert(Number.isSafeInteger(json.value) && json.value >= 0, 'Value must be a uint64.');\n    assert(typeof json.coinbase === 'boolean', 'Coinbase must be a boolean.');\n    this.version = json.version;\n    this.height = json.height;\n    this.value = json.value;\n    this.script.fromJSON(json.script);\n    this.coinbase = json.coinbase;\n\n    if (json.hash != null) {\n      assert(typeof json.hash === 'string', 'Hash must be a string.');\n      assert(json.hash.length === 64, 'Hash must be a string.');\n      assert(json.index >>> 0 === json.index, 'Index must be a uint32.');\n      this.hash = util.fromRev(json.hash);\n      this.index = json.index;\n    }\n\n    if (json.slp) {\n      json.slp.hash = json.hash;\n      this.slp = SLP.SlpCoinRecord().fromJSON(json.slp);\n    }\n\n    return this;\n  }\n  /**\n   * Instantiate an Coin from a jsonified coin object.\n   * @param {Object} json - The jsonified coin object.\n   * @returns {Coin}\n   */\n\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n  /**\n   * Calculate size of coin.\n   * @returns {Number}\n   */\n\n\n  getSize() {\n    return 17 + this.script.getVarSize();\n  }\n  /**\n   * Write the coin to a buffer writer.\n   * @param {BufferWriter} bw\n   */\n\n\n  toWriter(bw) {\n    let height = this.height;\n    if (height === -1) height = 0x7fffffff;\n    bw.writeU32(this.version);\n    bw.writeU32(height);\n    bw.writeI64(this.value);\n    bw.writeVarBytes(this.script.toRaw());\n    bw.writeU8(this.coinbase ? 1 : 0);\n    return bw;\n  }\n  /**\n   * Serialize the coin.\n   * @returns {Buffer|String}\n   */\n\n\n  toRaw() {\n    const size = this.getSize();\n    return this.toWriter(bio.write(size)).render();\n  }\n  /**\n   * Inject properties from serialized buffer writer.\n   * @private\n   * @param {BufferReader} br\n   */\n\n\n  fromReader(br) {\n    this.version = br.readU32();\n    this.height = br.readU32();\n    this.value = br.readI64();\n    this.script.fromRaw(br.readVarBytes());\n    this.coinbase = br.readU8() === 1;\n    if (this.height === 0x7fffffff) this.height = -1;\n    return this;\n  }\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   */\n\n\n  fromRaw(data) {\n    return this.fromReader(bio.read(data));\n  }\n  /**\n   * Instantiate a coin from a buffer reader.\n   * @param {BufferReader} br\n   * @returns {Coin}\n   */\n\n\n  static fromReader(br) {\n    return new this().fromReader(br);\n  }\n  /**\n   * Instantiate a coin from a serialized Buffer.\n   * @param {Buffer} data\n   * @param {String?} enc - Encoding, can be `'hex'` or null.\n   * @returns {Coin}\n   */\n\n\n  static fromRaw(data, enc) {\n    if (typeof data === 'string') data = Buffer.from(data, enc);\n    return new this().fromRaw(data);\n  }\n  /**\n   * Inject properties from TX.\n   * @param {TX} tx\n   * @param {Number} index\n   */\n\n\n  fromTX(tx, index, height) {\n    assert(typeof index === 'number');\n    assert(typeof height === 'number');\n    assert(index >= 0 && index < tx.outputs.length);\n    this.version = tx.version;\n    this.height = height;\n    this.value = tx.outputs[index].value;\n    this.script = tx.outputs[index].script;\n    this.coinbase = tx.isCoinbase();\n    this.hash = tx.hash();\n    this.index = index;\n    return this;\n  }\n  /**\n   * Instantiate a coin from a TX\n   * @param {TX} tx\n   * @param {Number} index - Output index.\n   * @returns {Coin}\n   */\n\n\n  static fromTX(tx, index, height) {\n    return new this().fromTX(tx, index, height);\n  }\n  /**\n   * Test an object to see if it is a Coin.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n\n  static isCoin(obj) {\n    return obj instanceof Coin;\n  }\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = Coin;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/primitives/coin.js"],"names":["assert","require","bio","util","Amount","Output","Network","consensus","Outpoint","SLP","inspectSymbol","Coin","constructor","options","version","height","coinbase","hash","ZERO_HASH","index","fromOptions","value","Number","isSafeInteger","script","Buffer","isBuffer","clone","getDepth","toKey","fromKey","key","rhash","revHex","txid","hr","type","getType","btc","address","getAddress","slp","toJSON","getJSON","network","minimal","addr","get","toString","json","undefined","fromJSON","length","fromRev","SlpCoinRecord","getSize","getVarSize","toWriter","bw","writeU32","writeI64","writeVarBytes","toRaw","writeU8","size","write","render","fromReader","br","readU32","readI64","fromRaw","readVarBytes","readU8","data","read","enc","from","fromTX","tx","outputs","isCoinbase","isCoin","obj","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,OAAD,CAAtB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAME,IAAI,GAAGF,OAAO,CAAC,eAAD,CAApB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,eAAD,CAAtB;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMK,OAAO,GAAGL,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMM,SAAS,GAAGN,OAAO,CAAC,uBAAD,CAAzB;;AACA,MAAMO,QAAQ,GAAGP,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAMQ,GAAG,GAAGR,OAAO,CAAC,eAAD,CAAnB;;AACA,MAAM;AAACS,EAAAA;AAAD,IAAkBT,OAAO,CAAC,UAAD,CAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMU,IAAN,SAAmBN,MAAnB,CAA0B;AACxB;AACF;AACA;AACA;AACA;AAEEO,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB;AAEA,SAAKC,OAAL,GAAe,CAAf;AACA,SAAKC,MAAL,GAAc,CAAC,CAAf;AACA,SAAKC,QAAL,GAAgB,KAAhB;AACA,SAAKC,IAAL,GAAYV,SAAS,CAACW,SAAtB;AACA,SAAKC,KAAL,GAAa,CAAb;AAEA,QAAIN,OAAJ,EACE,KAAKO,WAAL,CAAiBP,OAAjB;AACH;AAED;AACF;AACA;AACA;AACA;;;AAEEO,EAAAA,WAAW,CAACP,OAAD,EAAU;AACnBb,IAAAA,MAAM,CAACa,OAAD,EAAU,wBAAV,CAAN;;AAEA,QAAIA,OAAO,CAACC,OAAR,IAAmB,IAAvB,EAA6B;AAC3Bd,MAAAA,MAAM,CAAEa,OAAO,CAACC,OAAR,KAAoB,CAArB,KAA4BD,OAAO,CAACC,OAArC,EACJ,2BADI,CAAN;AAEA,WAAKA,OAAL,GAAeD,OAAO,CAACC,OAAvB;AACD;;AAED,QAAID,OAAO,CAACE,MAAR,IAAkB,IAAtB,EAA4B;AAC1B,UAAIF,OAAO,CAACE,MAAR,KAAmB,CAAC,CAAxB,EAA2B;AACzBf,QAAAA,MAAM,CAAEa,OAAO,CAACE,MAAR,KAAmB,CAApB,KAA2BF,OAAO,CAACE,MAApC,EACJ,0BADI,CAAN;AAEA,aAAKA,MAAL,GAAcF,OAAO,CAACE,MAAtB;AACD,OAJD,MAIO;AACL,aAAKA,MAAL,GAAc,CAAC,CAAf;AACD;AACF;;AAED,QAAIF,OAAO,CAACQ,KAAR,IAAiB,IAArB,EAA2B;AACzBrB,MAAAA,MAAM,CAACsB,MAAM,CAACC,aAAP,CAAqBV,OAAO,CAACQ,KAA7B,KAAuCR,OAAO,CAACQ,KAAR,IAAiB,CAAzD,EACJ,yBADI,CAAN;AAEA,WAAKA,KAAL,GAAaR,OAAO,CAACQ,KAArB;AACD;;AAED,QAAIR,OAAO,CAACW,MAAZ,EACE,KAAKA,MAAL,CAAYJ,WAAZ,CAAwBP,OAAO,CAACW,MAAhC;;AAEF,QAAIX,OAAO,CAACG,QAAR,IAAoB,IAAxB,EAA8B;AAC5BhB,MAAAA,MAAM,CAAC,OAAOa,OAAO,CAACG,QAAf,KAA4B,SAA7B,EACJ,6BADI,CAAN;AAEA,WAAKA,QAAL,GAAgBH,OAAO,CAACG,QAAxB;AACD;;AAED,QAAIH,OAAO,CAACI,IAAR,IAAgB,IAApB,EAA0B;AACxBjB,MAAAA,MAAM,CAACyB,MAAM,CAACC,QAAP,CAAgBb,OAAO,CAACI,IAAxB,CAAD,CAAN;AACA,WAAKA,IAAL,GAAYJ,OAAO,CAACI,IAApB;AACD;;AAED,QAAIJ,OAAO,CAACM,KAAR,IAAiB,IAArB,EAA2B;AACzBnB,MAAAA,MAAM,CAAEa,OAAO,CAACM,KAAR,KAAkB,CAAnB,KAA0BN,OAAO,CAACM,KAAnC,EACJ,yBADI,CAAN;AAEA,WAAKA,KAAL,GAAaN,OAAO,CAACM,KAArB;AACD;;AAED,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEoB,SAAXC,WAAW,CAACP,OAAD,EAAU;AAC1B,WAAO,IAAI,IAAJ,GAAWO,WAAX,CAAuBP,OAAvB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEEc,EAAAA,KAAK,GAAG;AACN3B,IAAAA,MAAM,CAAC,KAAD,EAAQ,0BAAR,CAAN;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AAEE4B,EAAAA,QAAQ,CAACb,MAAD,EAAS;AACff,IAAAA,MAAM,CAAC,OAAOe,MAAP,KAAkB,QAAnB,EAA6B,qBAA7B,CAAN;AAEA,QAAI,KAAKA,MAAL,KAAgB,CAAC,CAArB,EACE,OAAO,CAAP;AAEF,QAAIA,MAAM,KAAK,CAAC,CAAhB,EACE,OAAO,CAAP;AAEF,QAAIA,MAAM,GAAG,KAAKA,MAAlB,EACE,OAAO,CAAP;AAEF,WAAOA,MAAM,GAAG,KAAKA,MAAd,GAAuB,CAA9B;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEEc,EAAAA,KAAK,GAAG;AACN,WAAOrB,QAAQ,CAACqB,KAAT,CAAe,KAAKZ,IAApB,EAA0B,KAAKE,KAA/B,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AAEEW,EAAAA,OAAO,CAACC,GAAD,EAAM;AACX,UAAM;AAACd,MAAAA,IAAD;AAAOE,MAAAA;AAAP,QAAgBX,QAAQ,CAACsB,OAAT,CAAiBC,GAAjB,CAAtB;AACA,SAAKd,IAAL,GAAYA,IAAZ;AACA,SAAKE,KAAL,GAAaA,KAAb;AACA,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEgB,SAAPW,OAAO,CAACC,GAAD,EAAM;AAClB,WAAO,IAAI,IAAJ,GAAWD,OAAX,CAAmBC,GAAnB,CAAP;AACD;AAED;AACF;AACA;AACA;;;AAEEC,EAAAA,KAAK,GAAG;AACN,WAAO7B,IAAI,CAAC8B,MAAL,CAAY,KAAKhB,IAAjB,CAAP;AACD;AAED;AACF;AACA;AACA;;;AAEEiB,EAAAA,IAAI,GAAG;AACL,WAAO,KAAKF,KAAL,EAAP;AACD;AAED;AACF;AACA;AACA;;;AAEgB,GAAbtB,aAAa,IAAI;AAChB,UAAMyB,EAAE,GAAG;AACTC,MAAAA,IAAI,EAAE,KAAKC,OAAL,EADG;AAETvB,MAAAA,OAAO,EAAE,KAAKA,OAFL;AAGTC,MAAAA,MAAM,EAAE,KAAKA,MAHJ;AAITM,MAAAA,KAAK,EAAEjB,MAAM,CAACkC,GAAP,CAAW,KAAKjB,KAAhB,CAJE;AAKTG,MAAAA,MAAM,EAAE,KAAKA,MALJ;AAMTR,MAAAA,QAAQ,EAAE,KAAKA,QANN;AAOTC,MAAAA,IAAI,EAAE,KAAKA,IAAL,GAAYd,IAAI,CAAC8B,MAAL,CAAY,KAAKhB,IAAjB,CAAZ,GAAqC,IAPlC;AAQTE,MAAAA,KAAK,EAAE,KAAKA,KARH;AASToB,MAAAA,OAAO,EAAE,KAAKC,UAAL;AATA,KAAX;;AAWA,QAAI,KAAKC,GAAT,EAAc;AACZ,aAAO,EACL,GAAGN,EADE;AAELM,QAAAA,GAAG,EAAE,KAAKA;AAFL,OAAP;AAID;;AACD,WAAON,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEEO,EAAAA,MAAM,GAAG;AACP,WAAO,KAAKC,OAAL,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEEA,EAAAA,OAAO,CAACC,OAAD,EAAUC,OAAV,EAAmB;AACxB,QAAIC,IAAI,GAAG,KAAKN,UAAL,EAAX;AAEAI,IAAAA,OAAO,GAAGtC,OAAO,CAACyC,GAAR,CAAYH,OAAZ,CAAV;AAEA,QAAIE,IAAJ,EACEA,IAAI,GAAGA,IAAI,CAACE,QAAL,CAAcJ,OAAd,CAAP;AAEF,UAAMK,IAAI,GAAG;AACXnC,MAAAA,OAAO,EAAE,KAAKA,OADH;AAEXC,MAAAA,MAAM,EAAE,KAAKA,MAFF;AAGXM,MAAAA,KAAK,EAAE,KAAKA,KAHD;AAIXG,MAAAA,MAAM,EAAE,KAAKA,MAAL,CAAYkB,MAAZ,EAJG;AAKXH,MAAAA,OAAO,EAAEO,IALE;AAMX9B,MAAAA,QAAQ,EAAE,KAAKA,QANJ;AAOXC,MAAAA,IAAI,EAAE,CAAC4B,OAAD,GAAW,KAAKb,KAAL,EAAX,GAA0BkB,SAPrB;AAQX/B,MAAAA,KAAK,EAAE,CAAC0B,OAAD,GAAW,KAAK1B,KAAhB,GAAwB+B;AARpB,KAAb;;AAWA,QAAI,KAAKT,GAAT,EAAc;AACZ,aAAO,EACL,GAAGQ,IADE;AAELR,QAAAA,GAAG,EAAE,KAAKA,GAAL,CAASE,OAAT;AAFA,OAAP;AAID;;AACD,WAAOM,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEEE,EAAAA,QAAQ,CAACF,IAAD,EAAO;AACbjD,IAAAA,MAAM,CAACiD,IAAD,EAAO,qBAAP,CAAN;AACAjD,IAAAA,MAAM,CAAEiD,IAAI,CAACnC,OAAL,KAAiB,CAAlB,KAAyBmC,IAAI,CAACnC,OAA/B,EAAwC,2BAAxC,CAAN;AACAd,IAAAA,MAAM,CAACiD,IAAI,CAAClC,MAAL,KAAgB,CAAC,CAAjB,IAAuBkC,IAAI,CAAClC,MAAL,KAAgB,CAAjB,KAAwBkC,IAAI,CAAClC,MAApD,EACJ,0BADI,CAAN;AAEAf,IAAAA,MAAM,CAACsB,MAAM,CAACC,aAAP,CAAqB0B,IAAI,CAAC5B,KAA1B,KAAoC4B,IAAI,CAAC5B,KAAL,IAAc,CAAnD,EACJ,yBADI,CAAN;AAEArB,IAAAA,MAAM,CAAC,OAAOiD,IAAI,CAACjC,QAAZ,KAAyB,SAA1B,EAAqC,6BAArC,CAAN;AAEA,SAAKF,OAAL,GAAemC,IAAI,CAACnC,OAApB;AACA,SAAKC,MAAL,GAAckC,IAAI,CAAClC,MAAnB;AACA,SAAKM,KAAL,GAAa4B,IAAI,CAAC5B,KAAlB;AACA,SAAKG,MAAL,CAAY2B,QAAZ,CAAqBF,IAAI,CAACzB,MAA1B;AACA,SAAKR,QAAL,GAAgBiC,IAAI,CAACjC,QAArB;;AAEA,QAAIiC,IAAI,CAAChC,IAAL,IAAa,IAAjB,EAAuB;AACrBjB,MAAAA,MAAM,CAAC,OAAOiD,IAAI,CAAChC,IAAZ,KAAqB,QAAtB,EAAgC,wBAAhC,CAAN;AACAjB,MAAAA,MAAM,CAACiD,IAAI,CAAChC,IAAL,CAAUmC,MAAV,KAAqB,EAAtB,EAA0B,wBAA1B,CAAN;AACApD,MAAAA,MAAM,CAAEiD,IAAI,CAAC9B,KAAL,KAAe,CAAhB,KAAuB8B,IAAI,CAAC9B,KAA7B,EAAoC,yBAApC,CAAN;AACA,WAAKF,IAAL,GAAYd,IAAI,CAACkD,OAAL,CAAaJ,IAAI,CAAChC,IAAlB,CAAZ;AACA,WAAKE,KAAL,GAAa8B,IAAI,CAAC9B,KAAlB;AACD;;AAED,QAAI8B,IAAI,CAACR,GAAT,EAAc;AACZQ,MAAAA,IAAI,CAACR,GAAL,CAASxB,IAAT,GAAgBgC,IAAI,CAAChC,IAArB;AACA,WAAKwB,GAAL,GAAWhC,GAAG,CAAC6C,aAAJ,GAAoBH,QAApB,CAA6BF,IAAI,CAACR,GAAlC,CAAX;AACD;;AAED,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEiB,SAARU,QAAQ,CAACF,IAAD,EAAO;AACpB,WAAO,IAAI,IAAJ,GAAWE,QAAX,CAAoBF,IAApB,CAAP;AACD;AAED;AACF;AACA;AACA;;;AAEEM,EAAAA,OAAO,GAAG;AACR,WAAO,KAAK,KAAK/B,MAAL,CAAYgC,UAAZ,EAAZ;AACD;AAED;AACF;AACA;AACA;;;AAEEC,EAAAA,QAAQ,CAACC,EAAD,EAAK;AACX,QAAI3C,MAAM,GAAG,KAAKA,MAAlB;AAEA,QAAIA,MAAM,KAAK,CAAC,CAAhB,EACEA,MAAM,GAAG,UAAT;AAEF2C,IAAAA,EAAE,CAACC,QAAH,CAAY,KAAK7C,OAAjB;AACA4C,IAAAA,EAAE,CAACC,QAAH,CAAY5C,MAAZ;AACA2C,IAAAA,EAAE,CAACE,QAAH,CAAY,KAAKvC,KAAjB;AACAqC,IAAAA,EAAE,CAACG,aAAH,CAAiB,KAAKrC,MAAL,CAAYsC,KAAZ,EAAjB;AACAJ,IAAAA,EAAE,CAACK,OAAH,CAAW,KAAK/C,QAAL,GAAgB,CAAhB,GAAoB,CAA/B;AAEA,WAAO0C,EAAP;AACD;AAED;AACF;AACA;AACA;;;AAEEI,EAAAA,KAAK,GAAG;AACN,UAAME,IAAI,GAAG,KAAKT,OAAL,EAAb;AACA,WAAO,KAAKE,QAAL,CAAcvD,GAAG,CAAC+D,KAAJ,CAAUD,IAAV,CAAd,EAA+BE,MAA/B,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEEC,EAAAA,UAAU,CAACC,EAAD,EAAK;AACb,SAAKtD,OAAL,GAAesD,EAAE,CAACC,OAAH,EAAf;AACA,SAAKtD,MAAL,GAAcqD,EAAE,CAACC,OAAH,EAAd;AACA,SAAKhD,KAAL,GAAa+C,EAAE,CAACE,OAAH,EAAb;AACA,SAAK9C,MAAL,CAAY+C,OAAZ,CAAoBH,EAAE,CAACI,YAAH,EAApB;AACA,SAAKxD,QAAL,GAAgBoD,EAAE,CAACK,MAAH,OAAgB,CAAhC;AAEA,QAAI,KAAK1D,MAAL,KAAgB,UAApB,EACE,KAAKA,MAAL,GAAc,CAAC,CAAf;AAEF,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEEwD,EAAAA,OAAO,CAACG,IAAD,EAAO;AACZ,WAAO,KAAKP,UAAL,CAAgBjE,GAAG,CAACyE,IAAJ,CAASD,IAAT,CAAhB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEmB,SAAVP,UAAU,CAACC,EAAD,EAAK;AACpB,WAAO,IAAI,IAAJ,GAAWD,UAAX,CAAsBC,EAAtB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AAEgB,SAAPG,OAAO,CAACG,IAAD,EAAOE,GAAP,EAAY;AACxB,QAAI,OAAOF,IAAP,KAAgB,QAApB,EACEA,IAAI,GAAGjD,MAAM,CAACoD,IAAP,CAAYH,IAAZ,EAAkBE,GAAlB,CAAP;AACF,WAAO,IAAI,IAAJ,GAAWL,OAAX,CAAmBG,IAAnB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEEI,EAAAA,MAAM,CAACC,EAAD,EAAK5D,KAAL,EAAYJ,MAAZ,EAAoB;AACxBf,IAAAA,MAAM,CAAC,OAAOmB,KAAP,KAAiB,QAAlB,CAAN;AACAnB,IAAAA,MAAM,CAAC,OAAOe,MAAP,KAAkB,QAAnB,CAAN;AACAf,IAAAA,MAAM,CAACmB,KAAK,IAAI,CAAT,IAAcA,KAAK,GAAG4D,EAAE,CAACC,OAAH,CAAW5B,MAAlC,CAAN;AACA,SAAKtC,OAAL,GAAeiE,EAAE,CAACjE,OAAlB;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKM,KAAL,GAAa0D,EAAE,CAACC,OAAH,CAAW7D,KAAX,EAAkBE,KAA/B;AACA,SAAKG,MAAL,GAAcuD,EAAE,CAACC,OAAH,CAAW7D,KAAX,EAAkBK,MAAhC;AACA,SAAKR,QAAL,GAAgB+D,EAAE,CAACE,UAAH,EAAhB;AACA,SAAKhE,IAAL,GAAY8D,EAAE,CAAC9D,IAAH,EAAZ;AACA,SAAKE,KAAL,GAAaA,KAAb;AACA,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AAEe,SAAN2D,MAAM,CAACC,EAAD,EAAK5D,KAAL,EAAYJ,MAAZ,EAAoB;AAC/B,WAAO,IAAI,IAAJ,GAAW+D,MAAX,CAAkBC,EAAlB,EAAsB5D,KAAtB,EAA6BJ,MAA7B,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEe,SAANmE,MAAM,CAACC,GAAD,EAAM;AACjB,WAAOA,GAAG,YAAYxE,IAAtB;AACD;;AAnauB;AAsa1B;AACA;AACA;;;AAEAyE,MAAM,CAACC,OAAP,GAAiB1E,IAAjB","sourcesContent":["/*!\n * coin.js - coin object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bio = require('bufio');\nconst util = require('../utils/util');\nconst Amount = require('../btc/amount');\nconst Output = require('./output');\nconst Network = require('../protocol/network');\nconst consensus = require('../protocol/consensus');\nconst Outpoint = require('./outpoint');\nconst SLP = require('../script/slp');\nconst {inspectSymbol} = require('../utils');\n\n/**\n * Coin\n * Represents an unspent output.\n * @alias module:primitives.Coin\n * @extends Output\n * @property {Number} version\n * @property {Number} height\n * @property {Amount} value\n * @property {Script} script\n * @property {Boolean} coinbase\n * @property {Hash} hash\n * @property {Number} index\n */\n\nclass Coin extends Output {\n  /**\n   * Create a coin.\n   * @constructor\n   * @param {Object} options\n   */\n\n  constructor(options) {\n    super();\n\n    this.version = 1;\n    this.height = -1;\n    this.coinbase = false;\n    this.hash = consensus.ZERO_HASH;\n    this.index = 0;\n\n    if (options)\n      this.fromOptions(options);\n  }\n\n  /**\n   * Inject options into coin.\n   * @private\n   * @param {Object} options\n   */\n\n  fromOptions(options) {\n    assert(options, 'Coin data is required.');\n\n    if (options.version != null) {\n      assert((options.version >>> 0) === options.version,\n        'Version must be a uint32.');\n      this.version = options.version;\n    }\n\n    if (options.height != null) {\n      if (options.height !== -1) {\n        assert((options.height >>> 0) === options.height,\n          'Height must be a uint32.');\n        this.height = options.height;\n      } else {\n        this.height = -1;\n      }\n    }\n\n    if (options.value != null) {\n      assert(Number.isSafeInteger(options.value) && options.value >= 0,\n        'Value must be a uint64.');\n      this.value = options.value;\n    }\n\n    if (options.script)\n      this.script.fromOptions(options.script);\n\n    if (options.coinbase != null) {\n      assert(typeof options.coinbase === 'boolean',\n        'Coinbase must be a boolean.');\n      this.coinbase = options.coinbase;\n    }\n\n    if (options.hash != null) {\n      assert(Buffer.isBuffer(options.hash));\n      this.hash = options.hash;\n    }\n\n    if (options.index != null) {\n      assert((options.index >>> 0) === options.index,\n        'Index must be a uint32.');\n      this.index = options.index;\n    }\n\n    return this;\n  }\n\n  /**\n   * Instantiate Coin from options object.\n   * @private\n   * @param {Object} options\n   */\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n\n  /**\n   * Clone the coin.\n   * @private\n   * @returns {Coin}\n   */\n\n  clone() {\n    assert(false, 'Coins are not cloneable.');\n  }\n\n  /**\n   * Calculate number of confirmations since coin was created.\n   * @param {Number?} height - Current chain height. Network\n   * height is used if not passed in.\n   * @return {Number}\n   */\n\n  getDepth(height) {\n    assert(typeof height === 'number', 'Must pass a height.');\n\n    if (this.height === -1)\n      return 0;\n\n    if (height === -1)\n      return 0;\n\n    if (height < this.height)\n      return 0;\n\n    return height - this.height + 1;\n  }\n\n  /**\n   * Serialize coin to a key\n   * suitable for a hash table.\n   * @returns {String}\n   */\n\n  toKey() {\n    return Outpoint.toKey(this.hash, this.index);\n  }\n\n  /**\n   * Inject properties from hash table key.\n   * @private\n   * @param {String} key\n   * @returns {Coin}\n   */\n\n  fromKey(key) {\n    const {hash, index} = Outpoint.fromKey(key);\n    this.hash = hash;\n    this.index = index;\n    return this;\n  }\n\n  /**\n   * Instantiate coin from hash table key.\n   * @param {String} key\n   * @returns {Coin}\n   */\n\n  static fromKey(key) {\n    return new this().fromKey(key);\n  }\n\n  /**\n   * Get little-endian hash.\n   * @returns {Hash}\n   */\n\n  rhash() {\n    return util.revHex(this.hash);\n  }\n\n  /**\n   * Get little-endian hash.\n   * @returns {Hash}\n   */\n\n  txid() {\n    return this.rhash();\n  }\n\n  /**\n   * Convert the coin to a more user-friendly object.\n   * @returns {Object}\n   */\n\n  [inspectSymbol]() {\n    const hr = {\n      type: this.getType(),\n      version: this.version,\n      height: this.height,\n      value: Amount.btc(this.value),\n      script: this.script,\n      coinbase: this.coinbase,\n      hash: this.hash ? util.revHex(this.hash) : null,\n      index: this.index,\n      address: this.getAddress()\n    };\n    if (this.slp) {\n      return {\n        ...hr,\n        slp: this.slp\n      }\n    }\n    return hr;\n  }\n\n  /**\n   * Convert the coin to an object suitable\n   * for JSON serialization.\n   * @returns {Object}\n   */\n\n  toJSON() {\n    return this.getJSON();\n  }\n\n  /**\n   * Convert the coin to an object suitable\n   * for JSON serialization. Note that the hash\n   * will be reversed to abide by bitcoind's legacy\n   * of little-endian uint256s.\n   * @param {Network} network\n   * @param {Boolean} minimal\n   * @returns {Object}\n   */\n\n  getJSON(network, minimal) {\n    let addr = this.getAddress();\n\n    network = Network.get(network);\n\n    if (addr)\n      addr = addr.toString(network);\n\n    const json = {\n      version: this.version,\n      height: this.height,\n      value: this.value,\n      script: this.script.toJSON(),\n      address: addr,\n      coinbase: this.coinbase,\n      hash: !minimal ? this.rhash() : undefined,\n      index: !minimal ? this.index : undefined\n    };\n\n    if (this.slp) {\n      return {\n        ...json,\n        slp: this.slp.getJSON()\n      }\n    }\n    return json;\n  }\n\n  /**\n   * Inject JSON properties into coin.\n   * @private\n   * @param {Object} json\n   */\n\n  fromJSON(json) {\n    assert(json, 'Coin data required.');\n    assert((json.version >>> 0) === json.version, 'Version must be a uint32.');\n    assert(json.height === -1 || (json.height >>> 0) === json.height,\n      'Height must be a uint32.');\n    assert(Number.isSafeInteger(json.value) && json.value >= 0,\n      'Value must be a uint64.');\n    assert(typeof json.coinbase === 'boolean', 'Coinbase must be a boolean.');\n\n    this.version = json.version;\n    this.height = json.height;\n    this.value = json.value;\n    this.script.fromJSON(json.script);\n    this.coinbase = json.coinbase;\n\n    if (json.hash != null) {\n      assert(typeof json.hash === 'string', 'Hash must be a string.');\n      assert(json.hash.length === 64, 'Hash must be a string.');\n      assert((json.index >>> 0) === json.index, 'Index must be a uint32.');\n      this.hash = util.fromRev(json.hash);\n      this.index = json.index;\n    }\n\n    if (json.slp) {\n      json.slp.hash = json.hash;\n      this.slp = SLP.SlpCoinRecord().fromJSON(json.slp);\n    }\n\n    return this;\n  }\n\n  /**\n   * Instantiate an Coin from a jsonified coin object.\n   * @param {Object} json - The jsonified coin object.\n   * @returns {Coin}\n   */\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n\n  /**\n   * Calculate size of coin.\n   * @returns {Number}\n   */\n\n  getSize() {\n    return 17 + this.script.getVarSize();\n  }\n\n  /**\n   * Write the coin to a buffer writer.\n   * @param {BufferWriter} bw\n   */\n\n  toWriter(bw) {\n    let height = this.height;\n\n    if (height === -1)\n      height = 0x7fffffff;\n\n    bw.writeU32(this.version);\n    bw.writeU32(height);\n    bw.writeI64(this.value);\n    bw.writeVarBytes(this.script.toRaw());\n    bw.writeU8(this.coinbase ? 1 : 0);\n\n    return bw;\n  }\n\n  /**\n   * Serialize the coin.\n   * @returns {Buffer|String}\n   */\n\n  toRaw() {\n    const size = this.getSize();\n    return this.toWriter(bio.write(size)).render();\n  }\n\n  /**\n   * Inject properties from serialized buffer writer.\n   * @private\n   * @param {BufferReader} br\n   */\n\n  fromReader(br) {\n    this.version = br.readU32();\n    this.height = br.readU32();\n    this.value = br.readI64();\n    this.script.fromRaw(br.readVarBytes());\n    this.coinbase = br.readU8() === 1;\n\n    if (this.height === 0x7fffffff)\n      this.height = -1;\n\n    return this;\n  }\n\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   */\n\n  fromRaw(data) {\n    return this.fromReader(bio.read(data));\n  }\n\n  /**\n   * Instantiate a coin from a buffer reader.\n   * @param {BufferReader} br\n   * @returns {Coin}\n   */\n\n  static fromReader(br) {\n    return new this().fromReader(br);\n  }\n\n  /**\n   * Instantiate a coin from a serialized Buffer.\n   * @param {Buffer} data\n   * @param {String?} enc - Encoding, can be `'hex'` or null.\n   * @returns {Coin}\n   */\n\n  static fromRaw(data, enc) {\n    if (typeof data === 'string')\n      data = Buffer.from(data, enc);\n    return new this().fromRaw(data);\n  }\n\n  /**\n   * Inject properties from TX.\n   * @param {TX} tx\n   * @param {Number} index\n   */\n\n  fromTX(tx, index, height) {\n    assert(typeof index === 'number');\n    assert(typeof height === 'number');\n    assert(index >= 0 && index < tx.outputs.length);\n    this.version = tx.version;\n    this.height = height;\n    this.value = tx.outputs[index].value;\n    this.script = tx.outputs[index].script;\n    this.coinbase = tx.isCoinbase();\n    this.hash = tx.hash();\n    this.index = index;\n    return this;\n  }\n\n  /**\n   * Instantiate a coin from a TX\n   * @param {TX} tx\n   * @param {Number} index - Output index.\n   * @returns {Coin}\n   */\n\n  static fromTX(tx, index, height) {\n    return new this().fromTX(tx, index, height);\n  }\n\n  /**\n   * Test an object to see if it is a Coin.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n  static isCoin(obj) {\n    return obj instanceof Coin;\n  }\n}\n\n/*\n * Expose\n */\n\nmodule.exports = Coin;\n"]},"metadata":{},"sourceType":"module"}