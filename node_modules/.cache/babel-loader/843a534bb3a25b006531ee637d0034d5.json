{"ast":null,"code":"/*!\n * address.js - address object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bio = require('bufio');\n\nconst {\n  base58,\n  cashaddr\n} = require('bstring');\n\nconst ecashaddr = require('ecashaddrjs');\n\nconst hash160 = require('bcrypto/lib/hash160');\n\nconst hash256 = require('bcrypto/lib/hash256');\n\nconst Network = require('../protocol/network');\n\nconst consensus = require('../protocol/consensus');\n\nconst {\n  inspectSymbol\n} = require('../utils');\n/*\n * Constants\n */\n\n\nconst ZERO_HASH160 = Buffer.alloc(20, 0x00);\n/**\n * Address\n * Represents an address.\n * @alias module:primitives.Address\n * @property {Buffer} hash\n * @property {AddressPrefix} type\n */\n\nclass Address {\n  /**\n   * Create an address.\n   * @constructor\n   * @param {Object?} options\n   */\n  constructor(options, network) {\n    this.type = Address.types.PUBKEYHASH;\n    this.hash = ZERO_HASH160;\n    if (options) this.fromOptions(options, network);\n  } //   /**\n  //    * Inject properties from options object.\n  //    * @private\n  //    * @param {Object} options\n  //    */\n  //   fromOptions(options, network) {\n  //     if (typeof options === 'string')\n  //       return this.fromString(options, network);\n  //     assert(options);\n  //     const {hash, type} = options;\n  //     return this.fromHash(hash, type);\n  //   }\n  //   /**\n  //    * Insantiate address from options.\n  //    * @param {Object} options\n  //    * @returns {Address}\n  //    */\n  //   static fromOptions(options, network) {\n  //     return new this().fromOptions(options, network);\n  //   }\n  //   /**\n  //    * Get the address hash.\n  //    * @param {String?} enc - Can be `\"hex\"` or `null`.\n  //    * @returns {Hash|Buffer}\n  //    */\n  //   getHash(enc) {\n  //     if (enc === 'hex')\n  //       return this.hash.toString('hex');\n  //     return this.hash;\n  //   }\n  //   /**\n  //    * Test whether the address is null.\n  //    * @returns {Boolean}\n  //    */\n  //   isNull() {\n  //     if (this.hash.length === 20)\n  //       return this.hash.equals(ZERO_HASH160);\n  //     if (this.hash.length === 32)\n  //       return this.hash.equals(consensus.ZERO_HASH);\n  //     for (let i = 0; i < this.hash.length; i++) {\n  //       if (this.hash[i] !== 0)\n  //         return false;\n  //     }\n  //     return true;\n  //   }\n  //   /**\n  //    * Test equality against another address.\n  //    * @param {Address} addr\n  //    * @returns {Boolean}\n  //    */\n  //   equals(addr) {\n  //     assert(addr instanceof Address);\n  //     return this.type === addr.type\n  //       && this.hash.equals(addr.hash);\n  //   }\n  //   /**\n  //    * Get the address type as a string.\n  //    * @returns {String}\n  //    */\n  //   getType() {\n  //     return Address.typesByVal[this.type].toLowerCase();\n  //   }\n  //   /**\n  //    * Get a network address prefix for the address.\n  //    * @param {Network?} network\n  //    * @returns {Number}\n  //    */\n  //   getPrefix(network) {\n  //     network = Network.get(network);\n  //     const prefixes = network.addressPrefix;\n  //     switch (this.type) {\n  //       case Address.types.PUBKEYHASH:\n  //         return prefixes.pubkeyhash;\n  //       case Address.types.SCRIPTHASH:\n  //         return prefixes.scripthash;\n  //     }\n  //     return -1;\n  //   }\n  //   /**\n  //    * Calculate size of serialized address.\n  //    * @returns {Number}\n  //    */\n  //   getSize() {\n  //     return 5 + this.hash.length;\n  //   }\n  //   /**\n  //    * Compile the address object to its raw serialization.\n  //    * @param {{NetworkType|Network)?} network\n  //    * @returns {Buffer}\n  //    * @throws Error on bad hash/prefix.\n  //    */\n  //   toRaw(network) {\n  //     const size = this.getSize();\n  //     const bw = bio.write(size);\n  //     const prefix = this.getPrefix(network);\n  //     assert(prefix !== -1, 'Not a valid address prefix.');\n  //     bw.writeU8(prefix);\n  //     bw.writeBytes(this.hash);\n  //     bw.writeChecksum(hash256.digest);\n  //     return bw.render();\n  //   }\n  //   /**\n  //    * Compile the address object to a base58 address.\n  //    * @param {{NetworkType|Network)?} network\n  //    * @returns {AddressString}\n  //    * @throws Error on bad hash/prefix.\n  //    */\n  //   toBase58(network) {\n  //     return base58.encode(this.toRaw(network));\n  //   }\n  //   /**\n  //    * Compile the address object to a cashaddr address.\n  //    * @param {{NetworkType|Network)?} network\n  //    * @returns {String}\n  //    * @throws Error on bad hash/prefix.\n  //    */\n  //   toCashAddr(network) {\n  //     const type = this.type;\n  //     const hash = this.hash;\n  //     network = Network.get(network);\n  //     const prefix = network.addressPrefix.cashaddr;\n  //     return cashaddr.encode(prefix, type, hash);\n  //   }\n  //   /**\n  //    * Inject properties from string.\n  //    * @private\n  //    * @param {String} addr\n  //    * @param {(Network|NetworkType)?} network\n  //    * @returns {Address}\n  //    */\n  //   fromString(addr, network) {\n  //     assert(typeof addr === 'string');\n  //     assert(addr.length > 0);\n  //     assert(addr.length <= 100);\n  //     // If the address is mixed case,\n  //     // it can only ever be base58.\n  //     if (isMixedCase(addr))\n  //       return this.fromBase58(addr, network);\n  //     // Otherwise, it's most likely cashaddr.\n  //     try {\n  //       return this.fromCashAddr(addr, network);\n  //     } catch (e) {\n  //       return this.fromBase58(addr, network);\n  //     }\n  //   }\n  //   /**\n  //    * Instantiate address from string.\n  //    * @param {String} addr\n  //    * @param {(Network|NetworkType)?} network\n  //    * @returns {Address}\n  //    */\n  //   static fromString(addr, network) {\n  //     return new this().fromString(addr, network);\n  //   }\n  //   /**\n  //    * Return cashaddr by default\n  //    * @param {(Network|NetworkType)?} network\n  //    * @returns {AddressString}\n  //    */\n  //   toString(network) {\n  //     return this.toCashAddr(network);\n  //   }\n  //   /**\n  //    * Inspect the Address.\n  //    * @returns {Object}\n  //    */\n  //   [inspectSymbol]() {\n  //     return '<Address:'\n  //       + ` type=${this.getType()}`\n  //       + ` str=${this.toString()}`\n  //       + '>';\n  //   }\n  //   /**\n  //    * Inject properties from serialized data.\n  //    * @private\n  //    * @param {Buffer} data\n  //    * @throws Parse error\n  //    */\n  //   fromRaw(data, network) {\n  //     const br = bio.read(data, true);\n  //     const prefix = br.readU8();\n  //     network = Network.fromAddress(prefix, network);\n  //     const type = Address.getType(prefix, network);\n  //     if (data.length !== 25)\n  //       throw new Error('Address is too long.');\n  //     const hash = br.readBytes(br.left() - 4);\n  //     br.verifyChecksum(hash256.digest);\n  //     return this.fromHash(hash, type);\n  //   }\n  //   /**\n  //    * Create an address object from a serialized address.\n  //    * @param {Buffer} data\n  //    * @returns {Address}\n  //    * @throws Parse error.\n  //    */\n  //   static fromRaw(data, network) {\n  //     return new this().fromRaw(data, network);\n  //   }\n  //   /**\n  //    * Inject properties from base58 address.\n  //    * @private\n  //    * @param {AddressString} data\n  //    * @param {Network?} network\n  //    * @throws Parse error\n  //    */\n  //   fromBase58(data, network) {\n  //     assert(typeof data === 'string');\n  //     if (data.length > 55)\n  //       throw new Error('Address is too long.');\n  //     return this.fromRaw(base58.decode(data), network);\n  //   }\n  //   /**\n  //    * Create an address object from a base58 address.\n  //    * @param {AddressString} data\n  //    * @param {Network?} network\n  //    * @returns {Address}\n  //    * @throws Parse error.\n  //    */\n  //   static fromBase58(data, network) {\n  //     return new this().fromBase58(data, network);\n  //   }\n  //   /**\n  //    * Inject properties from cashaddr address.\n  //    * @private\n  //    * @param {String} data\n  //    * @param {Network?} network\n  //    * @throws Parse error\n  //    */\n  //   fromCashAddr(data, network) {\n  //     assert(typeof data === 'string');\n  //     network = Network.get(network);\n  //     const prefix = network.addressPrefix.cashaddr;\n  //     const addr = ecashaddr.decode(data);\n  //     addr.type = addr.type === 'P2PKH' ? 'PUBKEYHASH' : 'SCRIPTHASH';\n  //     Network.fromCashAddr(addr.prefix, network);\n  //     return this.fromHash(Buffer.from(addr.hash), addr.type);\n  //   }\n  //   /**\n  //    * Create an address object from a cashaddr address.\n  //    * @param {String} data\n  //    * @param {Network?} network\n  //    * @returns {Address}\n  //    * @throws Parse error.\n  //    */\n  //   static fromCashAddr(data, network) {\n  //     return new this().fromCashAddr(data, network);\n  //   }\n  //   /**\n  //    * Inject properties from output script.\n  //    * @private\n  //    * @param {Script} script\n  //    */\n  //   fromScript(script) {\n  //     const pk = script.getPubkey();\n  //     if (pk) {\n  //       this.hash = hash160.digest(pk);\n  //       this.type = Address.types.PUBKEYHASH;\n  //       return this;\n  //     }\n  //     const pkh = script.getPubkeyhash();\n  //     if (pkh) {\n  //       this.hash = pkh;\n  //       this.type = Address.types.PUBKEYHASH;\n  //       return this;\n  //     }\n  //     const sh = script.getScripthash();\n  //     if (sh) {\n  //       this.hash = sh;\n  //       this.type = Address.types.SCRIPTHASH;\n  //       return this;\n  //     }\n  //     // Put this last: it's the slowest to check.\n  //     if (script.isMultisig()) {\n  //       this.hash = script.hash160();\n  //       this.type = Address.types.SCRIPTHASH;\n  //       return this;\n  //     }\n  //     return null;\n  //   }\n  //   /**\n  //    * Inject properties from input script.\n  //    * @private\n  //    * @param {Script} script\n  //    */\n  //   fromInputScript(script) {\n  //     const [, pk] = script.getPubkeyhashInput();\n  //     if (pk) {\n  //       this.hash = hash160.digest(pk);\n  //       this.type = Address.types.PUBKEYHASH;\n  //       return this;\n  //     }\n  //     const redeem = script.getScripthashInput();\n  //     if (redeem) {\n  //       this.hash = hash160.digest(redeem);\n  //       this.type = Address.types.SCRIPTHASH;\n  //       return this;\n  //     }\n  //     return null;\n  //   }\n  //   /**\n  //    * Create an Address from an input script.\n  //    * Attempt to extract address\n  //    * properties from an input script.\n  //    * @param {Script}\n  //    * @returns {Address|null}\n  //    */\n  //   static fromInputScript(script) {\n  //     return new this().fromInputScript(script);\n  //   }\n  //   /**\n  //    * Create an Address from an output script.\n  //    * Parse an output script and extract address\n  //    * properties. Converts pubkey and multisig\n  //    * scripts to pubkeyhash and scripthash addresses.\n  //    * @param {Script}\n  //    * @returns {Address|null}\n  //    */\n  //   static fromScript(script) {\n  //     return new this().fromScript(script);\n  //   }\n  //   /**\n  //    * Inject properties from a hash.\n  //    * @private\n  //    * @param {Buffer|Hash} hash\n  //    * @param {AddressPrefix} type\n  //    * @throws on bad hash size\n  //    */\n  //   fromHash(hash, type) {\n  //     if (typeof type === 'string') {\n  //       type = Address.types[type.toUpperCase()];\n  //       assert(type != null, 'Not a valid address type.');\n  //     }\n  //     if (type == null)\n  //       type = Address.types.PUBKEYHASH;\n  //     assert(Buffer.isBuffer(hash));\n  //     assert((type >>> 0) === type);\n  //     assert(type >= Address.types.PUBKEYHASH && type <= Address.types.SCRIPTHASH,\n  //       'Not a valid address type.');\n  //     assert(hash.length === 20, 'Hash is the wrong size.');\n  //     this.hash = hash;\n  //     this.type = type;\n  //     return this;\n  //   }\n  //   /**\n  //    * Create a naked address from hash/type.\n  //    * @param {Hash} hash\n  //    * @param {AddressPrefix} type\n  //    * @returns {Address}\n  //    * @throws on bad hash size\n  //    */\n  //   static fromHash(hash, type) {\n  //     return new this().fromHash(hash, type);\n  //   }\n  //   /**\n  //    * Inject properties from pubkeyhash.\n  //    * @private\n  //    * @param {Buffer} hash\n  //    * @returns {Address}\n  //    */\n  //   fromPubkeyhash(hash) {\n  //     const type = Address.types.PUBKEYHASH;\n  //     assert(hash.length === 20, 'P2PKH must be 20 bytes.');\n  //     return this.fromHash(hash, type, -1);\n  //   }\n  //   /**\n  //    * Instantiate address from pubkeyhash.\n  //    * @param {Buffer} hash\n  //    * @returns {Address}\n  //    */\n  //   static fromPubkeyhash(hash) {\n  //     return new this().fromPubkeyhash(hash);\n  //   }\n\n  /**\n   * Inject properties from scripthash.\n   * @private\n   * @param {Buffer} hash\n   * @returns {Address}\n   */\n\n\n  fromScripthash(hash) {\n    const type = Address.types.SCRIPTHASH;\n    assert(hash && hash.length === 20, 'P2SH must be 20 bytes.');\n    return this.fromHash(hash, type, -1);\n  } //   /**\n  //    * Instantiate address from scripthash.\n  //    * @param {Buffer} hash\n  //    * @returns {Address}\n  //    */\n  //   static fromScripthash(hash) {\n  //     return new this().fromScripthash(hash);\n  //   }\n  //   /**\n  //    * Test whether the address is pubkeyhash.\n  //    * @returns {Boolean}\n  //    */\n  //   isPubkeyhash() {\n  //     return this.type === Address.types.PUBKEYHASH;\n  //   }\n  //   /**\n  //    * Test whether the address is scripthash.\n  //    * @returns {Boolean}\n  //    */\n  //   isScripthash() {\n  //     return this.type === Address.types.SCRIPTHASH;\n  //   }\n  //   /**\n  //    * Get the hash of a base58 address or address-related object.\n  //    * @param {Address|Hash} data\n  //    * @param {String?} enc - Can be `\"hex\"` or `null`.\n  //    * @returns {Hash}\n  //    */\n  //   static getHash(data, enc) {\n  //     if (!data)\n  //       throw new Error('Object is not an address.');\n  //     let hash;\n  //     if (Buffer.isBuffer(data)) {\n  //       if (data.length !== 20)\n  //         throw new Error('Object is not an address.');\n  //       hash = data;\n  //     } else if (data instanceof Address) {\n  //       hash = data.hash;\n  //     } else {\n  //       throw new Error('Object is not an address.');\n  //     }\n  //     if (enc === 'hex')\n  //       return hash.toString('hex');\n  //     return hash;\n  //   }\n  //   /**\n  //    * Get an address type for a specified network address prefix.\n  //    * @param {Number} prefix\n  //    * @param {Network} network\n  //    * @returns {AddressType}\n  //    */\n  //   static getType(prefix, network) {\n  //     const prefixes = network.addressPrefix;\n  //     switch (prefix) {\n  //       case prefixes.pubkeyhash:\n  //         return Address.types.PUBKEYHASH;\n  //       case prefixes.scripthash:\n  //         return Address.types.SCRIPTHASH;\n  //       default:\n  //         throw new Error('Unknown address prefix.');\n  //     }\n  //   }\n\n\n}\n/**\n * Address types.\n * @enum {Number}\n */\n\n\nAddress.types = {\n  PUBKEYHASH: 0,\n  SCRIPTHASH: 1\n};\n/**\n * Address types by value.\n * @const {Object}\n */\n\nAddress.typesByVal = ['PUBKEYHASH', 'SCRIPTHASH']; // /*\n//  * Helpers\n//  */\n// function isMixedCase(str) {\n//   let lower = false;\n//   let upper = false;\n//   for (let i = 0; i < str.length; i++) {\n//     const ch = str.charCodeAt(i);\n//     if (ch >= 0x30 && ch <= 0x39)\n//       continue;\n//     // skip :\n//     if (ch === 0x3a)\n//       continue;\n//     if (ch & 32) {\n//       assert(ch >= 0x61 && ch <= 0x7a);\n//       lower = true;\n//     } else {\n//       assert(ch >= 0x41 && ch <= 0x5a);\n//       upper = true;\n//     }\n//     if (lower && upper)\n//       return true;\n//   }\n//   return false;\n// }\n\n/*\n * Expose\n */\n\nmodule.exports = Address;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/primitives/address.js"],"names":["assert","require","bio","base58","cashaddr","ecashaddr","hash160","hash256","Network","consensus","inspectSymbol","ZERO_HASH160","Buffer","alloc","Address","constructor","options","network","type","types","PUBKEYHASH","hash","fromOptions","fromScripthash","SCRIPTHASH","length","fromHash","typesByVal","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,OAAD,CAAtB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAM;AAACE,EAAAA,MAAD;AAASC,EAAAA;AAAT,IAAqBH,OAAO,CAAC,SAAD,CAAlC;;AACA,MAAMI,SAAS,GAAGJ,OAAO,CAAC,aAAD,CAAzB;;AACA,MAAMK,OAAO,GAAGL,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMM,OAAO,GAAGN,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMO,OAAO,GAAGP,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMQ,SAAS,GAAGR,OAAO,CAAC,uBAAD,CAAzB;;AACA,MAAM;AAACS,EAAAA;AAAD,IAAkBT,OAAO,CAAC,UAAD,CAA/B;AAEA;AACA;AACA;;;AAEA,MAAMU,YAAY,GAAGC,MAAM,CAACC,KAAP,CAAa,EAAb,EAAiB,IAAjB,CAArB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,OAAN,CAAc;AACZ;AACF;AACA;AACA;AACA;AAEEC,EAAAA,WAAW,CAACC,OAAD,EAAUC,OAAV,EAAmB;AAC5B,SAAKC,IAAL,GAAYJ,OAAO,CAACK,KAAR,CAAcC,UAA1B;AACA,SAAKC,IAAL,GAAYV,YAAZ;AAEA,QAAIK,OAAJ,EACE,KAAKM,WAAL,CAAiBN,OAAjB,EAA0BC,OAA1B;AACH,GAbW,CAed;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;;;AAEEM,EAAAA,cAAc,CAACF,IAAD,EAAO;AACnB,UAAMH,IAAI,GAAGJ,OAAO,CAACK,KAAR,CAAcK,UAA3B;AACAxB,IAAAA,MAAM,CAACqB,IAAI,IAAIA,IAAI,CAACI,MAAL,KAAgB,EAAzB,EAA6B,wBAA7B,CAAN;AACA,WAAO,KAAKC,QAAL,CAAcL,IAAd,EAAoBH,IAApB,EAA0B,CAAC,CAA3B,CAAP;AACD,GAxfW,CA0fd;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AArkBc;AAwkBd;AACA;AACA;AACA;;;AAEAJ,OAAO,CAACK,KAAR,GAAgB;AACdC,EAAAA,UAAU,EAAE,CADE;AAEdI,EAAAA,UAAU,EAAE;AAFE,CAAhB;AAKA;AACA;AACA;AACA;;AAEAV,OAAO,CAACa,UAAR,GAAqB,CACnB,YADmB,EAEnB,YAFmB,CAArB,C,CAKA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEAC,MAAM,CAACC,OAAP,GAAiBf,OAAjB","sourcesContent":["/*!\n * address.js - address object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bio = require('bufio');\nconst {base58, cashaddr} = require('bstring');\nconst ecashaddr = require('ecashaddrjs');\nconst hash160 = require('bcrypto/lib/hash160');\nconst hash256 = require('bcrypto/lib/hash256');\nconst Network = require('../protocol/network');\nconst consensus = require('../protocol/consensus');\nconst {inspectSymbol} = require('../utils');\n\n/*\n * Constants\n */\n\nconst ZERO_HASH160 = Buffer.alloc(20, 0x00);\n\n/**\n * Address\n * Represents an address.\n * @alias module:primitives.Address\n * @property {Buffer} hash\n * @property {AddressPrefix} type\n */\n\nclass Address {\n  /**\n   * Create an address.\n   * @constructor\n   * @param {Object?} options\n   */\n\n  constructor(options, network) {\n    this.type = Address.types.PUBKEYHASH;\n    this.hash = ZERO_HASH160;\n\n    if (options)\n      this.fromOptions(options, network);\n  }\n\n//   /**\n//    * Inject properties from options object.\n//    * @private\n//    * @param {Object} options\n//    */\n\n//   fromOptions(options, network) {\n//     if (typeof options === 'string')\n//       return this.fromString(options, network);\n\n//     assert(options);\n\n//     const {hash, type} = options;\n\n//     return this.fromHash(hash, type);\n//   }\n\n//   /**\n//    * Insantiate address from options.\n//    * @param {Object} options\n//    * @returns {Address}\n//    */\n\n//   static fromOptions(options, network) {\n//     return new this().fromOptions(options, network);\n//   }\n\n//   /**\n//    * Get the address hash.\n//    * @param {String?} enc - Can be `\"hex\"` or `null`.\n//    * @returns {Hash|Buffer}\n//    */\n\n//   getHash(enc) {\n//     if (enc === 'hex')\n//       return this.hash.toString('hex');\n//     return this.hash;\n//   }\n\n//   /**\n//    * Test whether the address is null.\n//    * @returns {Boolean}\n//    */\n\n//   isNull() {\n//     if (this.hash.length === 20)\n//       return this.hash.equals(ZERO_HASH160);\n\n//     if (this.hash.length === 32)\n//       return this.hash.equals(consensus.ZERO_HASH);\n\n//     for (let i = 0; i < this.hash.length; i++) {\n//       if (this.hash[i] !== 0)\n//         return false;\n//     }\n\n//     return true;\n//   }\n\n//   /**\n//    * Test equality against another address.\n//    * @param {Address} addr\n//    * @returns {Boolean}\n//    */\n\n//   equals(addr) {\n//     assert(addr instanceof Address);\n\n//     return this.type === addr.type\n//       && this.hash.equals(addr.hash);\n//   }\n\n//   /**\n//    * Get the address type as a string.\n//    * @returns {String}\n//    */\n\n//   getType() {\n//     return Address.typesByVal[this.type].toLowerCase();\n//   }\n\n//   /**\n//    * Get a network address prefix for the address.\n//    * @param {Network?} network\n//    * @returns {Number}\n//    */\n\n//   getPrefix(network) {\n//     network = Network.get(network);\n\n//     const prefixes = network.addressPrefix;\n\n//     switch (this.type) {\n//       case Address.types.PUBKEYHASH:\n//         return prefixes.pubkeyhash;\n//       case Address.types.SCRIPTHASH:\n//         return prefixes.scripthash;\n//     }\n\n//     return -1;\n//   }\n\n//   /**\n//    * Calculate size of serialized address.\n//    * @returns {Number}\n//    */\n\n//   getSize() {\n//     return 5 + this.hash.length;\n//   }\n\n//   /**\n//    * Compile the address object to its raw serialization.\n//    * @param {{NetworkType|Network)?} network\n//    * @returns {Buffer}\n//    * @throws Error on bad hash/prefix.\n//    */\n\n//   toRaw(network) {\n//     const size = this.getSize();\n//     const bw = bio.write(size);\n//     const prefix = this.getPrefix(network);\n\n//     assert(prefix !== -1, 'Not a valid address prefix.');\n\n//     bw.writeU8(prefix);\n\n//     bw.writeBytes(this.hash);\n//     bw.writeChecksum(hash256.digest);\n\n//     return bw.render();\n//   }\n\n//   /**\n//    * Compile the address object to a base58 address.\n//    * @param {{NetworkType|Network)?} network\n//    * @returns {AddressString}\n//    * @throws Error on bad hash/prefix.\n//    */\n\n//   toBase58(network) {\n//     return base58.encode(this.toRaw(network));\n//   }\n\n//   /**\n//    * Compile the address object to a cashaddr address.\n//    * @param {{NetworkType|Network)?} network\n//    * @returns {String}\n//    * @throws Error on bad hash/prefix.\n//    */\n\n//   toCashAddr(network) {\n//     const type = this.type;\n//     const hash = this.hash;\n\n//     network = Network.get(network);\n\n//     const prefix = network.addressPrefix.cashaddr;\n\n//     return cashaddr.encode(prefix, type, hash);\n//   }\n\n//   /**\n//    * Inject properties from string.\n//    * @private\n//    * @param {String} addr\n//    * @param {(Network|NetworkType)?} network\n//    * @returns {Address}\n//    */\n\n//   fromString(addr, network) {\n//     assert(typeof addr === 'string');\n//     assert(addr.length > 0);\n//     assert(addr.length <= 100);\n\n//     // If the address is mixed case,\n//     // it can only ever be base58.\n//     if (isMixedCase(addr))\n//       return this.fromBase58(addr, network);\n\n//     // Otherwise, it's most likely cashaddr.\n//     try {\n//       return this.fromCashAddr(addr, network);\n//     } catch (e) {\n//       return this.fromBase58(addr, network);\n//     }\n//   }\n\n//   /**\n//    * Instantiate address from string.\n//    * @param {String} addr\n//    * @param {(Network|NetworkType)?} network\n//    * @returns {Address}\n//    */\n\n//   static fromString(addr, network) {\n//     return new this().fromString(addr, network);\n//   }\n\n//   /**\n//    * Return cashaddr by default\n//    * @param {(Network|NetworkType)?} network\n//    * @returns {AddressString}\n//    */\n\n//   toString(network) {\n//     return this.toCashAddr(network);\n//   }\n\n//   /**\n//    * Inspect the Address.\n//    * @returns {Object}\n//    */\n\n//   [inspectSymbol]() {\n//     return '<Address:'\n//       + ` type=${this.getType()}`\n//       + ` str=${this.toString()}`\n//       + '>';\n//   }\n\n//   /**\n//    * Inject properties from serialized data.\n//    * @private\n//    * @param {Buffer} data\n//    * @throws Parse error\n//    */\n\n//   fromRaw(data, network) {\n//     const br = bio.read(data, true);\n//     const prefix = br.readU8();\n\n//     network = Network.fromAddress(prefix, network);\n\n//     const type = Address.getType(prefix, network);\n\n//     if (data.length !== 25)\n//       throw new Error('Address is too long.');\n\n//     const hash = br.readBytes(br.left() - 4);\n\n//     br.verifyChecksum(hash256.digest);\n\n//     return this.fromHash(hash, type);\n//   }\n\n//   /**\n//    * Create an address object from a serialized address.\n//    * @param {Buffer} data\n//    * @returns {Address}\n//    * @throws Parse error.\n//    */\n\n//   static fromRaw(data, network) {\n//     return new this().fromRaw(data, network);\n//   }\n\n//   /**\n//    * Inject properties from base58 address.\n//    * @private\n//    * @param {AddressString} data\n//    * @param {Network?} network\n//    * @throws Parse error\n//    */\n\n//   fromBase58(data, network) {\n//     assert(typeof data === 'string');\n\n//     if (data.length > 55)\n//       throw new Error('Address is too long.');\n\n//     return this.fromRaw(base58.decode(data), network);\n//   }\n\n//   /**\n//    * Create an address object from a base58 address.\n//    * @param {AddressString} data\n//    * @param {Network?} network\n//    * @returns {Address}\n//    * @throws Parse error.\n//    */\n\n//   static fromBase58(data, network) {\n//     return new this().fromBase58(data, network);\n//   }\n\n//   /**\n//    * Inject properties from cashaddr address.\n//    * @private\n//    * @param {String} data\n//    * @param {Network?} network\n//    * @throws Parse error\n//    */\n\n//   fromCashAddr(data, network) {\n//     assert(typeof data === 'string');\n\n//     network = Network.get(network);\n\n//     const prefix = network.addressPrefix.cashaddr;\n//     const addr = ecashaddr.decode(data);\n//     addr.type = addr.type === 'P2PKH' ? 'PUBKEYHASH' : 'SCRIPTHASH';\n\n//     Network.fromCashAddr(addr.prefix, network);\n\n//     return this.fromHash(Buffer.from(addr.hash), addr.type);\n//   }\n\n//   /**\n//    * Create an address object from a cashaddr address.\n//    * @param {String} data\n//    * @param {Network?} network\n//    * @returns {Address}\n//    * @throws Parse error.\n//    */\n\n//   static fromCashAddr(data, network) {\n//     return new this().fromCashAddr(data, network);\n//   }\n\n//   /**\n//    * Inject properties from output script.\n//    * @private\n//    * @param {Script} script\n//    */\n\n//   fromScript(script) {\n//     const pk = script.getPubkey();\n\n//     if (pk) {\n//       this.hash = hash160.digest(pk);\n//       this.type = Address.types.PUBKEYHASH;\n//       return this;\n//     }\n\n//     const pkh = script.getPubkeyhash();\n\n//     if (pkh) {\n//       this.hash = pkh;\n//       this.type = Address.types.PUBKEYHASH;\n//       return this;\n//     }\n\n//     const sh = script.getScripthash();\n\n//     if (sh) {\n//       this.hash = sh;\n//       this.type = Address.types.SCRIPTHASH;\n//       return this;\n//     }\n\n//     // Put this last: it's the slowest to check.\n//     if (script.isMultisig()) {\n//       this.hash = script.hash160();\n//       this.type = Address.types.SCRIPTHASH;\n//       return this;\n//     }\n\n//     return null;\n//   }\n\n//   /**\n//    * Inject properties from input script.\n//    * @private\n//    * @param {Script} script\n//    */\n\n//   fromInputScript(script) {\n//     const [, pk] = script.getPubkeyhashInput();\n\n//     if (pk) {\n//       this.hash = hash160.digest(pk);\n//       this.type = Address.types.PUBKEYHASH;\n//       return this;\n//     }\n\n//     const redeem = script.getScripthashInput();\n\n//     if (redeem) {\n//       this.hash = hash160.digest(redeem);\n//       this.type = Address.types.SCRIPTHASH;\n//       return this;\n//     }\n\n//     return null;\n//   }\n\n//   /**\n//    * Create an Address from an input script.\n//    * Attempt to extract address\n//    * properties from an input script.\n//    * @param {Script}\n//    * @returns {Address|null}\n//    */\n\n//   static fromInputScript(script) {\n//     return new this().fromInputScript(script);\n//   }\n\n//   /**\n//    * Create an Address from an output script.\n//    * Parse an output script and extract address\n//    * properties. Converts pubkey and multisig\n//    * scripts to pubkeyhash and scripthash addresses.\n//    * @param {Script}\n//    * @returns {Address|null}\n//    */\n\n//   static fromScript(script) {\n//     return new this().fromScript(script);\n//   }\n\n//   /**\n//    * Inject properties from a hash.\n//    * @private\n//    * @param {Buffer|Hash} hash\n//    * @param {AddressPrefix} type\n//    * @throws on bad hash size\n//    */\n\n//   fromHash(hash, type) {\n//     if (typeof type === 'string') {\n//       type = Address.types[type.toUpperCase()];\n//       assert(type != null, 'Not a valid address type.');\n//     }\n\n//     if (type == null)\n//       type = Address.types.PUBKEYHASH;\n\n//     assert(Buffer.isBuffer(hash));\n//     assert((type >>> 0) === type);\n\n//     assert(type >= Address.types.PUBKEYHASH && type <= Address.types.SCRIPTHASH,\n//       'Not a valid address type.');\n\n//     assert(hash.length === 20, 'Hash is the wrong size.');\n\n//     this.hash = hash;\n//     this.type = type;\n\n//     return this;\n//   }\n\n//   /**\n//    * Create a naked address from hash/type.\n//    * @param {Hash} hash\n//    * @param {AddressPrefix} type\n//    * @returns {Address}\n//    * @throws on bad hash size\n//    */\n\n//   static fromHash(hash, type) {\n//     return new this().fromHash(hash, type);\n//   }\n\n//   /**\n//    * Inject properties from pubkeyhash.\n//    * @private\n//    * @param {Buffer} hash\n//    * @returns {Address}\n//    */\n\n//   fromPubkeyhash(hash) {\n//     const type = Address.types.PUBKEYHASH;\n//     assert(hash.length === 20, 'P2PKH must be 20 bytes.');\n//     return this.fromHash(hash, type, -1);\n//   }\n\n//   /**\n//    * Instantiate address from pubkeyhash.\n//    * @param {Buffer} hash\n//    * @returns {Address}\n//    */\n\n//   static fromPubkeyhash(hash) {\n//     return new this().fromPubkeyhash(hash);\n//   }\n\n  /**\n   * Inject properties from scripthash.\n   * @private\n   * @param {Buffer} hash\n   * @returns {Address}\n   */\n\n  fromScripthash(hash) {\n    const type = Address.types.SCRIPTHASH;\n    assert(hash && hash.length === 20, 'P2SH must be 20 bytes.');\n    return this.fromHash(hash, type, -1);\n  }\n\n//   /**\n//    * Instantiate address from scripthash.\n//    * @param {Buffer} hash\n//    * @returns {Address}\n//    */\n\n//   static fromScripthash(hash) {\n//     return new this().fromScripthash(hash);\n//   }\n\n//   /**\n//    * Test whether the address is pubkeyhash.\n//    * @returns {Boolean}\n//    */\n\n//   isPubkeyhash() {\n//     return this.type === Address.types.PUBKEYHASH;\n//   }\n\n//   /**\n//    * Test whether the address is scripthash.\n//    * @returns {Boolean}\n//    */\n\n//   isScripthash() {\n//     return this.type === Address.types.SCRIPTHASH;\n//   }\n\n//   /**\n//    * Get the hash of a base58 address or address-related object.\n//    * @param {Address|Hash} data\n//    * @param {String?} enc - Can be `\"hex\"` or `null`.\n//    * @returns {Hash}\n//    */\n\n//   static getHash(data, enc) {\n//     if (!data)\n//       throw new Error('Object is not an address.');\n\n//     let hash;\n\n//     if (Buffer.isBuffer(data)) {\n//       if (data.length !== 20)\n//         throw new Error('Object is not an address.');\n//       hash = data;\n//     } else if (data instanceof Address) {\n//       hash = data.hash;\n//     } else {\n//       throw new Error('Object is not an address.');\n//     }\n\n//     if (enc === 'hex')\n//       return hash.toString('hex');\n\n//     return hash;\n//   }\n\n//   /**\n//    * Get an address type for a specified network address prefix.\n//    * @param {Number} prefix\n//    * @param {Network} network\n//    * @returns {AddressType}\n//    */\n\n//   static getType(prefix, network) {\n//     const prefixes = network.addressPrefix;\n\n//     switch (prefix) {\n//       case prefixes.pubkeyhash:\n//         return Address.types.PUBKEYHASH;\n//       case prefixes.scripthash:\n//         return Address.types.SCRIPTHASH;\n//       default:\n//         throw new Error('Unknown address prefix.');\n//     }\n//   }\n}\n\n/**\n * Address types.\n * @enum {Number}\n */\n\nAddress.types = {\n  PUBKEYHASH: 0,\n  SCRIPTHASH: 1\n};\n\n/**\n * Address types by value.\n * @const {Object}\n */\n\nAddress.typesByVal = [\n  'PUBKEYHASH',\n  'SCRIPTHASH'\n];\n\n// /*\n//  * Helpers\n//  */\n\n// function isMixedCase(str) {\n//   let lower = false;\n//   let upper = false;\n\n//   for (let i = 0; i < str.length; i++) {\n//     const ch = str.charCodeAt(i);\n\n//     if (ch >= 0x30 && ch <= 0x39)\n//       continue;\n\n//     // skip :\n//     if (ch === 0x3a)\n//       continue;\n\n//     if (ch & 32) {\n//       assert(ch >= 0x61 && ch <= 0x7a);\n//       lower = true;\n//     } else {\n//       assert(ch >= 0x41 && ch <= 0x5a);\n//       upper = true;\n//     }\n\n//     if (lower && upper)\n//       return true;\n//   }\n\n//   return false;\n// }\n\n/*\n * Expose\n */\n\nmodule.exports = Address;\n"]},"metadata":{},"sourceType":"module"}