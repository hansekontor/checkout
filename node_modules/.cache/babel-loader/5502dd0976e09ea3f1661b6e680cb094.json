{"ast":null,"code":"/*!\n * bech32.js - bech32 for bcoin\n * Copyright (c) 2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n *\n * Parts of this software are based on \"bech32\".\n * https://github.com/sipa/bech32\n *\n * Copyright (c) 2017 Pieter Wuille\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n'use strict';\n\nconst assert = require('bsert');\n/**\n * Constants\n */\n\n\nconst POOL66 = Buffer.allocUnsafe(66);\nconst CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nconst TABLE = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, 10, 17, 21, 20, 26, 30, 7, 5, -1, -1, -1, -1, -1, -1, -1, 29, -1, 24, 13, 25, 9, 8, 23, -1, 18, 22, 31, 27, 19, -1, 1, 0, 3, 16, 11, 28, 12, 14, 6, 4, 2, -1, -1, -1, -1, -1, -1, 29, -1, 24, 13, 25, 9, 8, 23, -1, 18, 22, 31, 27, 19, -1, 1, 0, 3, 16, 11, 28, 12, 14, 6, 4, 2, -1, -1, -1, -1, -1];\n/**\n * Update checksum.\n * @ignore\n * @param {Number} chk\n * @returns {Number}\n */\n\nfunction polymod(pre) {\n  const b = pre >>> 25;\n  return (pre & 0x1ffffff) << 5 ^ -(b >>> 0 & 1) & 0x3b6a57b2 ^ -(b >>> 1 & 1) & 0x26508e6d ^ -(b >>> 2 & 1) & 0x1ea119fa ^ -(b >>> 3 & 1) & 0x3d4233dd ^ -(b >>> 4 & 1) & 0x2a1462b3;\n}\n/**\n * Encode hrp and data as a bech32 string.\n * @ignore\n * @param {String} hrp\n * @param {Buffer} data\n * @returns {String}\n */\n\n\nfunction serialize(hrp, data) {\n  assert(typeof hrp === 'string');\n  assert(Buffer.isBuffer(data));\n  let chk = 1;\n  let i;\n\n  for (i = 0; i < hrp.length; i++) {\n    const ch = hrp.charCodeAt(i);\n    if (ch & 0xff00 || ch >>> 5 === 0) throw new Error('Invalid bech32 character.');\n    chk = polymod(chk) ^ ch >>> 5;\n  }\n\n  if (i + 7 + data.length > 90) throw new Error('Invalid bech32 data length.');\n  chk = polymod(chk);\n  let str = '';\n\n  for (let i = 0; i < hrp.length; i++) {\n    const ch = hrp.charCodeAt(i);\n    chk = polymod(chk) ^ ch & 0x1f;\n    str += hrp[i];\n  }\n\n  str += '1';\n\n  for (let i = 0; i < data.length; i++) {\n    const ch = data[i];\n    if (ch >>> 5 !== 0) throw new Error('Invalid bech32 value.');\n    chk = polymod(chk) ^ ch;\n    str += CHARSET[ch];\n  }\n\n  for (let i = 0; i < 6; i++) chk = polymod(chk);\n\n  chk ^= 1;\n\n  for (let i = 0; i < 6; i++) str += CHARSET[chk >>> (5 - i) * 5 & 0x1f];\n\n  return str;\n}\n/**\n * Decode a bech32 string.\n * @param {String} str\n * @returns {Array} [hrp, data]\n */\n\n\nfunction deserialize(str) {\n  assert(typeof str === 'string');\n  if (str.length < 8 || str.length > 90) throw new Error('Invalid bech32 string length.');\n  let dlen = 0;\n\n  while (dlen < str.length && str[str.length - 1 - dlen] !== '1') dlen += 1;\n\n  const hlen = str.length - (1 + dlen);\n  if (1 + dlen >= str.length || dlen < 6) throw new Error('Invalid bech32 data length.');\n  dlen -= 6;\n  const data = Buffer.allocUnsafe(dlen);\n  let chk = 1;\n  let lower = false;\n  let upper = false;\n  let hrp = '';\n\n  for (let i = 0; i < hlen; i++) {\n    let ch = str.charCodeAt(i);\n    if (ch < 0x21 || ch > 0x7e) throw new Error('Invalid bech32 character.');\n\n    if (ch >= 0x61 && ch <= 0x7a) {\n      lower = true;\n    } else if (ch >= 0x41 && ch <= 0x5a) {\n      upper = true;\n      ch = ch - 0x41 + 0x61;\n    }\n\n    hrp += String.fromCharCode(ch);\n    chk = polymod(chk) ^ ch >>> 5;\n  }\n\n  chk = polymod(chk);\n  let i;\n\n  for (i = 0; i < hlen; i++) chk = polymod(chk) ^ str.charCodeAt(i) & 0x1f;\n\n  i += 1;\n\n  while (i < str.length) {\n    const ch = str.charCodeAt(i);\n    const v = ch & 0xff80 ? -1 : TABLE[ch];\n    if (v === -1) throw new Error('Invalid bech32 character.');\n    if (ch >= 0x61 && ch <= 0x7a) lower = true;else if (ch >= 0x41 && ch <= 0x5a) upper = true;\n    chk = polymod(chk) ^ v;\n    if (i + 6 < str.length) data[i - (1 + hlen)] = v;\n    i += 1;\n  }\n\n  if (lower && upper) throw new Error('Invalid bech32 casing.');\n  if (chk !== 1) throw new Error('Invalid bech32 checksum.');\n  return [hrp, data.slice(0, dlen)];\n}\n/**\n * Test whether a string is a bech32 string.\n * @param {String} str\n * @returns {Boolean}\n */\n\n\nfunction is(str) {\n  if (typeof str !== 'string') return false;\n\n  try {\n    deserialize(str);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Convert serialized data to another base.\n * @param {Buffer} input\n * @param {Number} i\n * @param {Buffer} output\n * @param {Number} j\n * @param {Number} frombits\n * @param {Number} tobits\n * @param {Boolean} pad\n * @returns {Buffer}\n */\n\n\nfunction convert(input, i, output, j, frombits, tobits, pad) {\n  assert(Buffer.isBuffer(input));\n  assert(i >>> 0 === i);\n  assert(Buffer.isBuffer(output));\n  assert(j >>> 0 === j);\n  assert((frombits & 0xff) === frombits);\n  assert((tobits & 0xff) === tobits);\n  assert(typeof pad === 'boolean');\n  const maxv = (1 << tobits) - 1;\n  let acc = 0;\n  let bits = 0;\n\n  for (; i < input.length; i++) {\n    const value = input[i];\n    if (value >>> frombits !== 0) throw new Error('Invalid bits.');\n    acc = acc << frombits | value;\n    bits += frombits;\n\n    while (bits >= tobits) {\n      bits -= tobits;\n      output[j++] = acc >>> bits & maxv;\n    }\n  }\n\n  if (pad) {\n    if (bits) output[j++] = acc << tobits - bits & maxv;\n  } else {\n    if (bits >= frombits || acc << tobits - bits & maxv) throw new Error('Invalid bits.');\n  }\n\n  assert(j <= output.length);\n  return output.slice(0, j);\n}\n/**\n * Calculate size required for bit conversion.\n * @param {Number} len\n * @param {Number} frombits\n * @param {Number} tobits\n * @param {Boolean} pad\n * @returns {Number}\n */\n\n\nfunction convertSize(len, frombits, tobits, pad) {\n  assert(len >>> 0 === len);\n  assert((frombits & 0xff) === frombits);\n  assert((tobits & 0xff) === tobits);\n  assert(typeof pad === 'boolean');\n  assert(tobits !== 0);\n  let size = (len * frombits + (tobits - 1)) / tobits;\n  size >>>= 0;\n  if (pad) size += 1;\n  return size;\n}\n/**\n * Convert serialized data to another base.\n * @param {Buffer} data\n * @param {Number} frombits\n * @param {Number} tobits\n * @param {Boolean} pad\n * @returns {Buffer}\n */\n\n\nfunction convertBits(data, frombits, tobits, pad) {\n  assert(Buffer.isBuffer(data));\n  assert((frombits & 0xff) === frombits);\n  assert((tobits & 0xff) === tobits);\n  assert(typeof pad === 'boolean');\n  const size = convertSize(data.length, frombits, tobits, pad);\n  const out = Buffer.allocUnsafe(size);\n  return convert(data, 0, out, 0, frombits, tobits, pad);\n}\n/**\n * Serialize data to bech32 address.\n * @param {String} hrp\n * @param {Number} version\n * @param {Buffer} hash\n * @returns {String}\n */\n\n\nfunction encode(hrp, version, hash) {\n  assert(typeof hrp === 'string');\n  assert((version & 0xff) === version);\n  assert(Buffer.isBuffer(hash));\n  if (version < 0 || version > 31) throw new Error('Invalid bech32 version.');\n  if (hash.length < 2 || hash.length > 40) throw new Error('Invalid bech32 data length.');\n  const out = POOL66;\n  out[0] = version;\n  const data = convert(hash, 0, out, 1, 8, 5, true);\n  return serialize(hrp, data);\n}\n/**\n * Deserialize data from bech32 address.\n * @param {String} str\n * @returns {Object}\n */\n\n\nfunction decode(str) {\n  assert(typeof str === 'string');\n  const [hrp, data] = deserialize(str);\n  if (data.length === 0 || data.length > 65) throw new Error('Invalid bech32 data length.');\n  const version = data[0];\n  if (version > 31) throw new Error('Invalid bech32 version.');\n  const hash = convert(data, 1, data, 0, 5, 8, false);\n  if (hash.length < 2 || hash.length > 40) throw new Error('Invalid bech32 data length.');\n  return new AddrResult(hrp, version, hash);\n}\n/**\n * Test whether a string is a bech32 string.\n * @param {String} str\n * @returns {Boolean}\n */\n\n\nfunction test(str) {\n  if (typeof str !== 'string') return false;\n  let data;\n\n  try {\n    [, data] = deserialize(str);\n  } catch (e) {\n    return false;\n  }\n\n  if (data.length === 0 || data.length > 65) return false;\n  const version = data[0];\n  if (version > 31) return false;\n  return true;\n}\n/**\n * AddrResult\n * @constructor\n * @private\n * @param {String} hrp\n * @param {Number} version\n * @param {Buffer} hash\n * @property {String} hrp\n * @property {Number} version\n * @property {Buffer} hash\n */\n\n\nclass AddrResult {\n  constructor(hrp, version, hash) {\n    this.hrp = hrp;\n    this.version = version;\n    this.hash = hash;\n  }\n\n}\n/*\n * Expose\n */\n\n\nexports.serialize = serialize;\nexports.deserialize = deserialize;\nexports.is = is;\nexports.convertBits = convertBits;\nexports.encode = encode;\nexports.decode = decode;\nexports.test = test;","map":null,"metadata":{},"sourceType":"script"}