{"ast":null,"code":"/*!\n * eddsa.js - EdDSA for bcrypto\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on indutny/elliptic:\n *   Copyright (c) 2014, Fedor Indutny (MIT License).\n *   https://github.com/indutny/elliptic\n *\n * References:\n *\n *   [EDDSA] High-speed high-security signatures\n *     D. J. Bernstein, N. Duif, T. Lange, P. Schwabe, B. Yang\n *     https://ed25519.cr.yp.to/ed25519-20110926.pdf\n *\n *   [RFC8032] Edwards-Curve Digital Signature Algorithm (EdDSA)\n *     S. Josefsson, I. Liusvaara\n *     https://tools.ietf.org/html/rfc8032\n *\n * Implementation Notes:\n *\n *   - In contrast to the ECDSA backend, we allow points at\n *     infinity (in all functions).\n *\n *   - Mike Hamburg's Ed448-Goldilocks rejects both infinity as\n *     well as the torsion point (0, -1). We do not replicate\n *     this behavior.\n *\n *   - For Ed25519, we do \"cofactor-less\" verification by default.\n *     This means torsion components will affect the result of the\n *     verification.\n *\n *   - For Ed448, we do cofactor verification by default to mimic\n *     OpenSSL and Mike Hamburg's Ed448-Goldilocks implementation.\n *\n *   - `verifySingle`/`verifyBatch` do cofactor verification. Do\n *     not use `verifyBatch` expecting the same results as the\n *     regular `verify` call[1]. This will not be the case for\n *     Ed25519.\n *\n *   - All functions are completely unaware of points of small\n *     order and torsion components (in other words, points will\n *     not be explicitly checked for this, anywhere).\n *\n *   - `deriveWithScalar` and `exchangeWithScalar` automatically\n *     clamp scalars before multiplying (meaning torsion components\n *     are removed from the result and points of small order will\n *     be normalized to infinity).\n *\n *   - The HD function, `publicKeyTweakMul`, _does not_ clamp\n *     automatically. It is possible to end up with a torsion\n *     component in the resulting point (assuming the input\n *     point had one).\n *\n *   - Ed448-Goldilocks is 4-isogenous to Curve448. This means\n *     that when converting to Curve448, small order points will\n *     be normalized to (0, 0). When converting back to Ed448,\n *     any small order points will be normalized to infinity,\n *     and any torsion components will be removed completely.\n *     Also note that when converting back, the implementation\n *     needs to divide the point by 4. This is a major perf hit,\n *     so treat `x448.publicKeyConvert` as if it were a point\n *     multiplication.\n *\n *   - Elligators should not be used with Edwards curves. As\n *     Tibouchi notes[2], regular public keys will map to\n *     _distinguishable_ field elements as they are always in\n *     the primary subgroup. Either the Ristretto Elligator[3],\n *     or a prime order curve with an Elligator Squared[2]\n *     construction are suitable alternatives here.\n *\n *   - These notes also spell out why you should avoid using\n *     Edwards curves on a blockchain[4].\n *\n *   [1] https://moderncrypto.org/mail-archive/curves/2016/000836.html\n *   [2] https://eprint.iacr.org/2014/043.pdf\n *   [3] https://ristretto.group/formulas/elligator.html\n *   [4] https://src.getmonero.org/2017/05/17/disclosure-of-a-major-bug-in-cryptonote-based-currencies.html\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst BatchRNG = require('./batch-rng');\n\nconst BN = require('../bn');\n\nconst elliptic = require('./elliptic');\n\nconst rng = require('../random');\n/*\n * EDDSA\n */\n\n\nclass EDDSA {\n  constructor(id, mid, eid, hash, pre) {\n    assert(typeof id === 'string');\n    assert(!mid || typeof mid === 'string');\n    assert(!eid || typeof eid === 'string');\n    assert(hash);\n    this.id = id;\n    this.type = 'eddsa';\n    this.mid = mid || null;\n    this.eid = eid || null;\n    this.hash = hash;\n    this.native = 0;\n    this._pre = pre || null;\n    this._curve = null;\n    this._mont = null;\n    this._iso = null;\n    this._rng = null;\n  }\n\n  get curve() {\n    if (!this._curve) {\n      this._curve = elliptic.curve(this.id, this._pre);\n\n      this._curve.precompute(rng);\n\n      this._pre = null;\n    }\n\n    return this._curve;\n  }\n\n  get mont() {\n    if (this.mid && !this._mont) this._mont = elliptic.curve(this.mid);\n    return this._mont;\n  }\n\n  get iso() {\n    if (!this.eid) return this.mont;\n    if (!this._iso) this._iso = elliptic.curve(this.eid);\n    return this._iso;\n  }\n\n  get rng() {\n    if (!this._rng) this._rng = new BatchRNG(this.curve);\n    return this._rng;\n  }\n\n  get size() {\n    return this.curve.fieldSize;\n  }\n\n  get bits() {\n    return this.curve.fieldBits;\n  }\n\n  hashNonce(prefix, msg, ph, ctx) {\n    const hash = new Hash(this);\n    hash.init(ph, ctx);\n    hash.update(prefix);\n    hash.update(msg);\n    return hash.final();\n  }\n\n  hashChallenge(R, A, m, ph, ctx) {\n    const hash = new Hash(this);\n    hash.init(ph, ctx);\n    hash.update(R);\n    hash.update(A);\n    hash.update(m);\n    return hash.final();\n  }\n\n  privateKeyGenerate() {\n    return rng.randomBytes(this.curve.fieldSize);\n  }\n\n  scalarGenerate() {\n    const scalar = rng.randomBytes(this.curve.scalarSize);\n    return this.curve.clamp(scalar);\n  }\n\n  privateKeyExpand(secret) {\n    assert(Buffer.isBuffer(secret));\n    assert(secret.length === this.curve.fieldSize);\n    const hash = this.hash.digest(secret, this.curve.fieldSize * 2);\n    return this.curve.splitHash(hash);\n  }\n\n  privateKeyConvert(secret) {\n    const [key] = this.privateKeyExpand(secret);\n    return key;\n  }\n\n  privateKeyVerify(secret) {\n    assert(Buffer.isBuffer(secret));\n    return secret.length === this.curve.fieldSize;\n  }\n\n  scalarVerify(scalar) {\n    assert(Buffer.isBuffer(scalar));\n    return scalar.length === this.curve.scalarSize;\n  }\n\n  scalarIsZero(scalar) {\n    assert(Buffer.isBuffer(scalar));\n    let k;\n\n    try {\n      k = this.curve.decodeScalar(scalar).imod(this.curve.n);\n    } catch (e) {\n      return false;\n    }\n\n    return k.isZero();\n  }\n\n  scalarClamp(scalar) {\n    assert(Buffer.isBuffer(scalar));\n    assert(scalar.length === this.curve.scalarSize);\n    return this.curve.clamp(Buffer.from(scalar));\n  }\n\n  privateKeyExport(secret) {\n    const pub = this.publicKeyCreate(secret);\n    const {\n      x,\n      y\n    } = this.publicKeyExport(pub);\n    return {\n      d: Buffer.from(secret),\n      x,\n      y\n    };\n  }\n\n  privateKeyImport(json) {\n    assert(json && typeof json === 'object');\n    assert(Buffer.isBuffer(json.d));\n    if (json.d.length !== this.curve.fieldSize) throw new Error('Invalid private key.');\n    return Buffer.from(json.d);\n  }\n\n  scalarTweakAdd(scalar, tweak) {\n    const a = this.curve.decodeScalar(scalar);\n    const t = this.curve.decodeScalar(tweak);\n    const k = a.add(t).imod(this.curve.n);\n    return this.curve.encodeScalar(k);\n  }\n\n  scalarTweakMul(scalar, tweak) {\n    const a = this.curve.decodeScalar(scalar);\n    const t = this.curve.decodeScalar(tweak);\n    const k = a.mul(t).imod(this.curve.n);\n    return this.curve.encodeScalar(k);\n  }\n\n  scalarReduce(scalar) {\n    assert(Buffer.isBuffer(scalar));\n    if (scalar.length > this.curve.scalarSize) scalar = scalar.slice(0, this.curve.scalarSize);\n    const k = BN.decode(scalar, this.curve.endian).imod(this.curve.n);\n    return this.curve.encodeScalar(k);\n  }\n\n  scalarNegate(scalar) {\n    const a = this.curve.decodeScalar(scalar).imod(this.curve.n);\n    const k = a.neg().imod(this.curve.n);\n    return this.curve.encodeScalar(k);\n  }\n\n  scalarInvert(scalar) {\n    const a = this.curve.decodeScalar(scalar).imod(this.curve.n);\n    if (a.isZero()) return this.curve.encodeScalar(a);\n    const k = a.invert(this.curve.n);\n    return this.curve.encodeScalar(k);\n  }\n\n  publicKeyCreate(secret) {\n    const key = this.privateKeyConvert(secret);\n    return this.publicKeyFromScalar(key);\n  }\n\n  publicKeyFromScalar(scalar) {\n    const a = this.curve.decodeScalar(scalar).imod(this.curve.n);\n    const A = this.curve.g.mulBlind(a);\n    return A.encode();\n  }\n\n  publicKeyConvert(key) {\n    if (!this.mont) throw new Error('No equivalent montgomery curve.');\n    const A = this.curve.decodePoint(key);\n    const P = this.mont.pointFromEdwards(A);\n    return P.encode();\n  }\n\n  publicKeyFromUniform(bytes) {\n    const u = this.curve.decodeUniform(bytes);\n    const A = this.curve.pointFromUniform(u, this.iso);\n    return A.encode();\n  }\n\n  publicKeyToUniform(key) {\n    let hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : rng.randomInt();\n    const A = this.curve.decodePoint(key);\n    const u = this.curve.pointToUniform(A, hint, this.iso);\n    return this.curve.encodeUniform(u, rng);\n  }\n\n  publicKeyFromHash(bytes) {\n    let pake = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const A = this.curve.pointFromHash(bytes, pake, this.iso);\n    return A.encode();\n  }\n\n  publicKeyToHash(key) {\n    const A = this.curve.decodePoint(key);\n    return this.curve.pointToHash(A, rng, this.iso);\n  }\n\n  publicKeyVerify(key) {\n    assert(Buffer.isBuffer(key));\n\n    try {\n      this.curve.decodePoint(key);\n    } catch (e) {\n      return false;\n    }\n\n    return true;\n  }\n\n  publicKeyIsInfinity(key) {\n    assert(Buffer.isBuffer(key));\n    let A;\n\n    try {\n      A = this.curve.decodePoint(key);\n    } catch (e) {\n      return false;\n    }\n\n    return A.isInfinity();\n  }\n\n  publicKeyIsSmall(key) {\n    assert(Buffer.isBuffer(key));\n    let A;\n\n    try {\n      A = this.curve.decodePoint(key);\n    } catch (e) {\n      return false;\n    }\n\n    return A.isSmall();\n  }\n\n  publicKeyHasTorsion(key) {\n    assert(Buffer.isBuffer(key));\n    let A;\n\n    try {\n      A = this.curve.decodePoint(key);\n    } catch (e) {\n      return false;\n    }\n\n    return A.hasTorsion();\n  }\n\n  publicKeyExport(key) {\n    const size = this.curve.fieldBits + 7 >>> 3;\n    const {\n      x,\n      y\n    } = this.curve.decodePoint(key);\n    return {\n      x: x.fromRed().encode(this.curve.endian, size),\n      y: y.fromRed().encode(this.curve.endian, size)\n    };\n  }\n\n  publicKeyImport(json) {\n    assert(json && typeof json === 'object');\n    let x = null;\n    let y = null;\n    let A;\n\n    if (json.x != null) {\n      x = BN.decode(json.x, this.curve.endian);\n      if (x.cmp(this.curve.p) >= 0) throw new Error('Invalid point.');\n    }\n\n    if (json.y != null) {\n      y = BN.decode(json.y, this.curve.endian);\n      if (y.cmp(this.curve.p) >= 0) throw new Error('Invalid point.');\n    }\n\n    if (x && y) {\n      A = this.curve.point(x, y);\n      if (!A.validate()) throw new Error('Invalid point.');\n    } else if (x) {\n      A = this.curve.pointFromX(x, json.sign);\n    } else if (y) {\n      A = this.curve.pointFromY(y, json.sign);\n    } else {\n      throw new Error('Invalid point.');\n    }\n\n    return A.encode();\n  }\n\n  publicKeyTweakAdd(key, tweak) {\n    const t = this.curve.decodeScalar(tweak).imod(this.curve.n);\n    const A = this.curve.decodePoint(key);\n    const T = this.curve.g.mul(t);\n    const P = T.add(A);\n    return P.encode();\n  }\n\n  publicKeyTweakMul(key, tweak) {\n    const t = this.curve.decodeScalar(tweak);\n    const A = this.curve.decodePoint(key);\n    const P = A.mul(t);\n    return P.encode();\n  }\n\n  publicKeyCombine(keys) {\n    assert(Array.isArray(keys));\n    let P = this.curve.point();\n\n    for (const key of keys) {\n      const A = this.curve.decodePoint(key);\n      P = P.add(A);\n    }\n\n    return P.encode();\n  }\n\n  publicKeyNegate(key) {\n    const A = this.curve.decodePoint(key);\n    const P = A.neg();\n    return P.encode();\n  }\n\n  sign(msg, secret, ph, ctx) {\n    const [key, prefix] = this.privateKeyExpand(secret);\n    return this.signWithScalar(msg, key, prefix, ph, ctx);\n  }\n\n  signWithScalar(msg, scalar, prefix, ph, ctx) {\n    // EdDSA Signing.\n    //\n    // [EDDSA] Page 12, Section 4.\n    // [RFC8032] Page 8, Section 3.3.\n    //\n    // Assumptions:\n    //\n    //   - Let `H` be a cryptographic hash function.\n    //   - Let `m` be a byte array of arbitrary size.\n    //   - Let `a` be a secret scalar.\n    //   - Let `w` be a secret byte array.\n    //\n    // Computation:\n    //\n    //   k = H(w, m) mod n\n    //   R = G * k\n    //   A = G * a\n    //   e = H(R, A, m) mod n\n    //   s = (k + e * a) mod n\n    //   S = (R, s)\n    //\n    // Note that `k` must remain secret,\n    // otherwise an attacker can compute:\n    //\n    //   a = (s - k) / e mod n\n    //\n    // The same is true of `w` as `k`\n    // can be re-derived as `H(w, m)`.\n    if (ctx == null) ctx = Buffer.alloc(0);\n    assert(Buffer.isBuffer(msg));\n    assert(Buffer.isBuffer(prefix));\n    assert(prefix.length === this.curve.fieldSize);\n    const {\n      n\n    } = this.curve;\n    const G = this.curve.g;\n    const k = this.hashNonce(prefix, msg, ph, ctx);\n    const Rraw = G.mulBlind(k).encode();\n    const a = this.curve.decodeScalar(scalar);\n    const Araw = G.mulBlind(a).encode();\n    const e = this.hashChallenge(Rraw, Araw, msg, ph, ctx);\n    const s = k.add(e.mul(a)).imod(n);\n    return Buffer.concat([Rraw, this.curve.encodeField(s)]);\n  }\n\n  signTweakAdd(msg, secret, tweak, ph, ctx) {\n    const [key_, prefix_] = this.privateKeyExpand(secret);\n    const key = this.scalarTweakAdd(key_, tweak);\n    const expanded = this.hash.multi(prefix_, tweak, null, this.curve.fieldSize * 2);\n    const prefix = expanded.slice(0, this.curve.fieldSize);\n    return this.signWithScalar(msg, key, prefix, ph, ctx);\n  }\n\n  signTweakMul(msg, secret, tweak, ph, ctx) {\n    const [key_, prefix_] = this.privateKeyExpand(secret);\n    const key = this.scalarTweakMul(key_, tweak);\n    const expanded = this.hash.multi(prefix_, tweak, null, this.curve.fieldSize * 2);\n    const prefix = expanded.slice(0, this.curve.fieldSize);\n    return this.signWithScalar(msg, key, prefix, ph, ctx);\n  }\n\n  verify(msg, sig, key, ph, ctx) {\n    if (ctx == null) ctx = Buffer.alloc(0);\n    assert(Buffer.isBuffer(msg));\n    assert(Buffer.isBuffer(sig));\n    assert(Buffer.isBuffer(key));\n    assert(ph == null || typeof ph === 'boolean');\n    assert(Buffer.isBuffer(ctx));\n    if (sig.length !== this.curve.fieldSize * 2) return false;\n    if (key.length !== this.curve.fieldSize) return false;\n\n    try {\n      return this._verify(msg, sig, key, ph, ctx);\n    } catch (e) {\n      return false;\n    }\n  }\n\n  _verify(msg, sig, key, ph, ctx) {\n    // EdDSA Verification.\n    //\n    // [EDDSA] Page 15, Section 5.\n    // [RFC8032] Page 8, Section 3.4.\n    //\n    // Assumptions:\n    //\n    //   - Let `H` be a cryptographic hash function.\n    //   - Let `m` be a byte array of arbitrary size.\n    //   - Let `R` and `s` be signature elements.\n    //   - Let `A` be a valid group element.\n    //   - s < n.\n    //\n    // Computation:\n    //\n    //   e = H(R, A, m) mod n\n    //   G * s == R + A * e\n    //\n    // Alternatively, we can compute:\n    //\n    //   R == G * s - A * e\n    //\n    // This allows us to make use of a\n    // multi-exponentiation algorithm.\n    const {\n      n\n    } = this.curve;\n    const G = this.curve.g;\n    const Rraw = sig.slice(0, this.curve.fieldSize);\n    const sraw = sig.slice(this.curve.fieldSize);\n    const R = this.curve.decodePoint(Rraw);\n    const s = this.curve.decodeField(sraw);\n    const A = this.curve.decodePoint(key);\n    if (s.cmp(n) >= 0) return false;\n    const e = this.hashChallenge(Rraw, key, msg, ph, ctx);\n    return G.mulAdd(s, A.neg(), e).eq(R);\n  }\n\n  verifySingle(msg, sig, key, ph, ctx) {\n    if (ctx == null) ctx = Buffer.alloc(0);\n    assert(Buffer.isBuffer(msg));\n    assert(Buffer.isBuffer(sig));\n    assert(Buffer.isBuffer(key));\n    assert(ph == null || typeof ph === 'boolean');\n    assert(Buffer.isBuffer(ctx));\n    if (sig.length !== this.curve.fieldSize * 2) return false;\n    if (key.length !== this.curve.fieldSize) return false;\n\n    try {\n      return this._verifySingle(msg, sig, key, ph, ctx);\n    } catch (e) {\n      return false;\n    }\n  }\n\n  _verifySingle(msg, sig, key, ph, ctx) {\n    // EdDSA Verification (with cofactor multiplication).\n    //\n    // [EDDSA] Page 15, Section 5.\n    // [RFC8032] Page 8, Section 3.4.\n    //\n    // Assumptions:\n    //\n    //   - Let `H` be a cryptographic hash function.\n    //   - Let `m` be a byte array of arbitrary size.\n    //   - Let `R` and `s` be signature elements.\n    //   - Let `A` be a valid group element.\n    //   - s < n.\n    //\n    // Computation:\n    //\n    //   e = H(R, A, m) mod n\n    //   (G * s) * h == (R + A * e) * h\n    //\n    // Alternatively, we can compute:\n    //\n    //   R * h == G * (s * h) - (A * h) * e\n    //\n    // This allows us to make use of a\n    // multi-exponentiation algorithm.\n    const {\n      n\n    } = this.curve;\n    const G = this.curve.g;\n    const Rraw = sig.slice(0, this.curve.fieldSize);\n    const sraw = sig.slice(this.curve.fieldSize);\n    const R = this.curve.decodePoint(Rraw);\n    const s = this.curve.decodeField(sraw);\n    const A = this.curve.decodePoint(key);\n    if (s.cmp(n) >= 0) return false;\n    const e = this.hashChallenge(Rraw, key, msg, ph, ctx);\n    const sh = this.curve.imulH(s);\n    const Ah = A.mulH();\n    const Rh = R.mulH();\n    return G.mulAdd(sh, Ah.neg(), e).eq(Rh);\n  }\n\n  verifyBatch(batch, ph, ctx) {\n    if (ctx == null) ctx = Buffer.alloc(0);\n    assert(Array.isArray(batch));\n    assert(ph == null || typeof ph === 'boolean');\n    assert(Buffer.isBuffer(ctx));\n\n    for (const item of batch) {\n      assert(Array.isArray(item) && item.length === 3);\n      const [msg, sig, key] = item;\n      assert(Buffer.isBuffer(msg));\n      assert(Buffer.isBuffer(sig));\n      assert(Buffer.isBuffer(key));\n      if (sig.length !== this.curve.fieldSize * 2) return false;\n      if (key.length !== this.curve.fieldSize) return false;\n    }\n\n    try {\n      return this._verifyBatch(batch, ph, ctx);\n    } catch (e) {\n      return false;\n    }\n  }\n\n  _verifyBatch(batch, ph, ctx) {\n    // EdDSA Batch Verification.\n    //\n    // [EDDSA] Page 16, Section 5.\n    //\n    // Assumptions:\n    //\n    //   - Let `H` be a cryptographic hash function.\n    //   - Let `R` and `s` be signature elements.\n    //   - Let `A` be a valid group element.\n    //   - Let `i` be the batch item index.\n    //   - s < n.\n    //   - a1 = 1 mod n.\n    //\n    // Computation:\n    //\n    //   ei = H(Ri, Ai, mi) mod n\n    //   ai = random integer in [1,n-1]\n    //   lhs = (si * ai + ...) * h mod n\n    //   rhs = (Ri * h) * ai + (Ai * h) * (ei * ai mod n) + ...\n    //   G * -lhs + rhs == O\n    const {\n      n\n    } = this.curve;\n    const G = this.curve.g;\n    const points = new Array(1 + batch.length * 2);\n    const coeffs = new Array(1 + batch.length * 2);\n    const sum = new BN(0);\n    this.rng.init(batch);\n    points[0] = G;\n    coeffs[0] = sum;\n\n    for (let i = 0; i < batch.length; i++) {\n      const [msg, sig, key] = batch[i];\n      const Rraw = sig.slice(0, this.curve.fieldSize);\n      const sraw = sig.slice(this.curve.fieldSize);\n      const R = this.curve.decodePoint(Rraw);\n      const s = this.curve.decodeField(sraw);\n      const A = this.curve.decodePoint(key);\n      if (s.cmp(n) >= 0) return false;\n      const e = this.hashChallenge(Rraw, key, msg, ph, ctx);\n      const a = this.rng.generate(i);\n      const ea = e.mul(a).imod(n);\n      sum.iadd(s.mul(a)).imod(n);\n      points[1 + i * 2 + 0] = R.mulH();\n      coeffs[1 + i * 2 + 0] = a;\n      points[1 + i * 2 + 1] = A.mulH();\n      coeffs[1 + i * 2 + 1] = ea;\n    }\n\n    this.curve.imulH(sum.ineg());\n    return this.curve.mulAll(points, coeffs).isInfinity();\n  }\n\n  derive(pub, secret) {\n    const scalar = this.privateKeyConvert(secret);\n    return this.deriveWithScalar(pub, scalar);\n  }\n\n  deriveWithScalar(pub, scalar) {\n    const A = this.curve.decodePoint(pub);\n    const a = this.curve.decodeScalar(scalar);\n    const k = this.curve.reduce(a);\n    const P = A.mulConst(k, rng);\n    if (P.isInfinity()) throw new Error('Invalid point.');\n    return P.encode();\n  }\n\n}\n/*\n * Hash\n */\n\n\nclass Hash {\n  constructor(eddsa) {\n    this.curve = eddsa.curve; // eslint-disable-next-line\n\n    this.hash = new eddsa.hash();\n  }\n\n  init(ph, ctx) {\n    assert(ph == null || typeof ph === 'boolean');\n    assert(Buffer.isBuffer(ctx));\n    if (ctx.length > 255) ctx = ctx.slice(0, 255);\n    this.hash.init();\n\n    if (this.curve.context || ph != null || ctx.length > 0) {\n      if (this.curve.prefix) this.hash.update(this.curve.prefix);\n      this.hash.update(byte(ph));\n      this.hash.update(byte(ctx.length));\n      this.hash.update(ctx);\n    }\n\n    return this;\n  }\n\n  update(data) {\n    this.hash.update(data);\n    return this;\n  }\n\n  final() {\n    const hash = this.hash.final(this.curve.fieldSize * 2);\n    const num = BN.decode(hash, this.curve.endian);\n    return num.imod(this.curve.n);\n  }\n\n}\n/*\n * Helpers\n */\n\n\nfunction byte(ch) {\n  const buf = Buffer.alloc(1);\n  buf[0] = ch & 0xff;\n  return buf;\n}\n/*\n * Expose\n */\n\n\nmodule.exports = EDDSA;","map":null,"metadata":{},"sourceType":"script"}