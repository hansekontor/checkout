{"ast":null,"code":"/*!\n * assert.js - assertions for javascript\n * Copyright (c) 2018, Christopher Jeffrey (MIT License).\n * https://github.com/chjj/bsert\n */\n'use strict';\n/**\n * AssertionError\n */\n\nclass AssertionError extends Error {\n  constructor(options) {\n    if (typeof options === 'string') options = {\n      message: options\n    };\n    if (options === null || typeof options !== 'object') options = {};\n    let message = null;\n    let operator = 'fail';\n    let generatedMessage = Boolean(options.generatedMessage);\n    if (options.message != null) message = toString(options.message);\n    if (typeof options.operator === 'string') operator = options.operator;\n\n    if (message == null) {\n      if (operator === 'fail') {\n        message = 'Assertion failed.';\n      } else {\n        const a = stringify(options.actual);\n        const b = stringify(options.expected);\n        message = `${a} ${operator} ${b}`;\n      }\n\n      generatedMessage = true;\n    }\n\n    super(message);\n    let start = this.constructor;\n    if (typeof options.stackStartFunction === 'function') start = options.stackStartFunction;else if (typeof options.stackStartFn === 'function') start = options.stackStartFn;\n    this.type = 'AssertionError';\n    this.name = 'AssertionError [ERR_ASSERTION]';\n    this.code = 'ERR_ASSERTION';\n    this.generatedMessage = generatedMessage;\n    this.actual = options.actual;\n    this.expected = options.expected;\n    this.operator = operator;\n    if (Error.captureStackTrace) Error.captureStackTrace(this, start);\n  }\n\n}\n/*\n * Assert\n */\n\n\nfunction assert(value, message) {\n  if (!value) {\n    let generatedMessage = false;\n\n    if (arguments.length === 0) {\n      message = 'No value argument passed to `assert()`.';\n      generatedMessage = true;\n    } else if (message == null) {\n      message = 'Assertion failed.';\n      generatedMessage = true;\n    } else if (isError(message)) {\n      throw message;\n    }\n\n    throw new AssertionError({\n      message,\n      actual: value,\n      expected: true,\n      operator: '==',\n      generatedMessage,\n      stackStartFn: assert\n    });\n  }\n}\n\nfunction equal(actual, expected, message) {\n  if (!Object.is(actual, expected)) {\n    if (isError(message)) throw message;\n    throw new AssertionError({\n      message,\n      actual,\n      expected,\n      operator: 'strictEqual',\n      stackStartFn: equal\n    });\n  }\n}\n\nfunction notEqual(actual, expected, message) {\n  if (Object.is(actual, expected)) {\n    if (isError(message)) throw message;\n    throw new AssertionError({\n      message,\n      actual,\n      expected,\n      operator: 'notStrictEqual',\n      stackStartFn: notEqual\n    });\n  }\n}\n\nfunction fail(message) {\n  let generatedMessage = false;\n  if (isError(message)) throw message;\n\n  if (message == null) {\n    message = 'Assertion failed.';\n    generatedMessage = true;\n  }\n\n  throw new AssertionError({\n    message,\n    actual: false,\n    expected: true,\n    operator: 'fail',\n    generatedMessage,\n    stackStartFn: fail\n  });\n}\n\nfunction throws(func, expected, message) {\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = undefined;\n  }\n\n  let thrown = false;\n  let err = null;\n  enforce(typeof func === 'function', 'func', 'function');\n\n  try {\n    func();\n  } catch (e) {\n    thrown = true;\n    err = e;\n  }\n\n  if (!thrown) {\n    let generatedMessage = false;\n\n    if (message == null) {\n      message = 'Missing expected exception.';\n      generatedMessage = true;\n    }\n\n    throw new AssertionError({\n      message,\n      actual: undefined,\n      expected,\n      operator: 'throws',\n      generatedMessage,\n      stackStartFn: throws\n    });\n  }\n\n  if (!testError(err, expected, message, throws)) throw err;\n}\n\nfunction doesNotThrow(func, expected, message) {\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = undefined;\n  }\n\n  let thrown = false;\n  let err = null;\n  enforce(typeof func === 'function', 'func', 'function');\n\n  try {\n    func();\n  } catch (e) {\n    thrown = true;\n    err = e;\n  }\n\n  if (!thrown) return;\n\n  if (testError(err, expected, message, doesNotThrow)) {\n    let generatedMessage = false;\n\n    if (message == null) {\n      message = 'Got unwanted exception.';\n      generatedMessage = true;\n    }\n\n    throw new AssertionError({\n      message,\n      actual: err,\n      expected,\n      operator: 'doesNotThrow',\n      generatedMessage,\n      stackStartFn: doesNotThrow\n    });\n  }\n\n  throw err;\n}\n\nasync function rejects(func, expected, message) {\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = undefined;\n  }\n\n  let thrown = false;\n  let err = null;\n  if (typeof func !== 'function') enforce(isPromise(func), 'func', 'promise');\n\n  try {\n    if (isPromise(func)) await func;else await func();\n  } catch (e) {\n    thrown = true;\n    err = e;\n  }\n\n  if (!thrown) {\n    let generatedMessage = false;\n\n    if (message == null) {\n      message = 'Missing expected rejection.';\n      generatedMessage = true;\n    }\n\n    throw new AssertionError({\n      message,\n      actual: undefined,\n      expected,\n      operator: 'rejects',\n      generatedMessage,\n      stackStartFn: rejects\n    });\n  }\n\n  if (!testError(err, expected, message, rejects)) throw err;\n}\n\nasync function doesNotReject(func, expected, message) {\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = undefined;\n  }\n\n  let thrown = false;\n  let err = null;\n  if (typeof func !== 'function') enforce(isPromise(func), 'func', 'promise');\n\n  try {\n    if (isPromise(func)) await func;else await func();\n  } catch (e) {\n    thrown = true;\n    err = e;\n  }\n\n  if (!thrown) return;\n\n  if (testError(err, expected, message, doesNotReject)) {\n    let generatedMessage = false;\n\n    if (message == null) {\n      message = 'Got unwanted rejection.';\n      generatedMessage = true;\n    }\n\n    throw new AssertionError({\n      message,\n      actual: undefined,\n      expected,\n      operator: 'doesNotReject',\n      generatedMessage,\n      stackStartFn: doesNotReject\n    });\n  }\n\n  throw err;\n}\n\nfunction ifError(err) {\n  if (err != null) {\n    let message = 'ifError got unwanted exception: ';\n\n    if (typeof err === 'object' && typeof err.message === 'string') {\n      if (err.message.length === 0 && err.constructor) message += err.constructor.name;else message += err.message;\n    } else {\n      message += stringify(err);\n    }\n\n    throw new AssertionError({\n      message,\n      actual: err,\n      expected: null,\n      operator: 'ifError',\n      generatedMessage: true,\n      stackStartFn: ifError\n    });\n  }\n}\n\nfunction deepEqual(actual, expected, message) {\n  if (!isDeepEqual(actual, expected, false)) {\n    if (isError(message)) throw message;\n    throw new AssertionError({\n      message,\n      actual,\n      expected,\n      operator: 'deepStrictEqual',\n      stackStartFn: deepEqual\n    });\n  }\n}\n\nfunction notDeepEqual(actual, expected, message) {\n  if (isDeepEqual(actual, expected, true)) {\n    if (isError(message)) throw message;\n    throw new AssertionError({\n      message,\n      actual,\n      expected,\n      operator: 'notDeepStrictEqual',\n      stackStartFn: notDeepEqual\n    });\n  }\n}\n\nfunction bufferEqual(actual, expected, enc, message) {\n  if (!isEncoding(enc)) {\n    message = enc;\n    enc = null;\n  }\n\n  if (enc == null) enc = 'hex';\n  expected = bufferize(actual, expected, enc);\n  enforce(isBuffer(actual), 'actual', 'buffer');\n  enforce(isBuffer(expected), 'expected', 'buffer');\n\n  if (actual !== expected && !actual.equals(expected)) {\n    if (isError(message)) throw message;\n    throw new AssertionError({\n      message,\n      actual: actual.toString(enc),\n      expected: expected.toString(enc),\n      operator: 'bufferEqual',\n      stackStartFn: bufferEqual\n    });\n  }\n}\n\nfunction notBufferEqual(actual, expected, enc, message) {\n  if (!isEncoding(enc)) {\n    message = enc;\n    enc = null;\n  }\n\n  if (enc == null) enc = 'hex';\n  expected = bufferize(actual, expected, enc);\n  enforce(isBuffer(actual), 'actual', 'buffer');\n  enforce(isBuffer(expected), 'expected', 'buffer');\n\n  if (actual === expected || actual.equals(expected)) {\n    if (isError(message)) throw message;\n    throw new AssertionError({\n      message,\n      actual: actual.toString(enc),\n      expected: expected.toString(enc),\n      operator: 'notBufferEqual',\n      stackStartFn: notBufferEqual\n    });\n  }\n}\n\nfunction enforce(value, name, type) {\n  if (!value) {\n    let msg;\n\n    if (name == null) {\n      msg = 'Invalid type for parameter.';\n    } else {\n      if (type == null) msg = `Invalid type for \"${name}\".`;else msg = `\"${name}\" must be a(n) ${type}.`;\n    }\n\n    const err = new TypeError(msg);\n    if (Error.captureStackTrace) Error.captureStackTrace(err, enforce);\n    throw err;\n  }\n}\n\nfunction range(value, name) {\n  if (!value) {\n    const msg = name != null ? `\"${name}\" is out of range.` : 'Parameter is out of range.';\n    const err = new RangeError(msg);\n    if (Error.captureStackTrace) Error.captureStackTrace(err, range);\n    throw err;\n  }\n}\n/*\n * Stringification\n */\n\n\nfunction stringify(value) {\n  switch (typeof value) {\n    case 'undefined':\n      return 'undefined';\n\n    case 'object':\n      if (value === null) return 'null';\n      return `[${objectName(value)}]`;\n\n    case 'boolean':\n      return `${value}`;\n\n    case 'number':\n      return `${value}`;\n\n    case 'string':\n      if (value.length > 80) value = `${value.substring(0, 77)}...`;\n      return JSON.stringify(value);\n\n    case 'symbol':\n      return tryString(value);\n\n    case 'function':\n      return `[${funcName(value)}]`;\n\n    case 'bigint':\n      return `${value}n`;\n\n    default:\n      return `[${typeof value}]`;\n  }\n}\n\nfunction toString(value) {\n  if (typeof value === 'string') return value;\n  if (isError(value)) return tryString(value);\n  return stringify(value);\n}\n\nfunction tryString(value) {\n  try {\n    return String(value);\n  } catch (e) {\n    return 'Object';\n  }\n}\n/*\n * Error Testing\n */\n\n\nfunction testError(err, expected, message, func) {\n  if (expected == null) return true;\n  if (isRegExp(expected)) return expected.test(err);\n\n  if (typeof expected !== 'function') {\n    if (func === doesNotThrow || func === doesNotReject) throw new TypeError('\"expected\" must not be an object.');\n    if (typeof expected !== 'object') throw new TypeError('\"expected\" must be an object.');\n    let generatedMessage = false;\n\n    if (message == null) {\n      const name = func === rejects ? 'rejection' : 'exception';\n      message = `Missing expected ${name}.`;\n      generatedMessage = true;\n    }\n\n    if (err == null || typeof err !== 'object') {\n      throw new AssertionError({\n        actual: err,\n        expected,\n        message,\n        operator: func.name,\n        generatedMessage,\n        stackStartFn: func\n      });\n    }\n\n    const keys = Object.keys(expected);\n    if (isError(expected)) keys.push('name', 'message');\n    if (keys.length === 0) throw new TypeError('\"expected\" may not be an empty object.');\n\n    for (const key of keys) {\n      const expect = expected[key];\n      const value = err[key];\n\n      if (typeof value === 'string' && isRegExp(expect) && expect.test(value)) {\n        continue;\n      }\n\n      if (key in err && isDeepEqual(value, expect, false)) continue;\n      throw new AssertionError({\n        actual: err,\n        expected: expected,\n        message,\n        operator: func.name,\n        generatedMessage,\n        stackStartFn: func\n      });\n    }\n\n    return true;\n  }\n\n  if (expected.prototype !== undefined && err instanceof expected) return true;\n  if (Error.isPrototypeOf(expected)) return false;\n  return expected.call({}, err) === true;\n}\n/*\n * Comparisons\n */\n\n\nfunction isDeepEqual(x, y, fail) {\n  try {\n    return compare(x, y, null);\n  } catch (e) {\n    return fail;\n  }\n}\n\nfunction compare(a, b, cache) {\n  // Primitives.\n  if (Object.is(a, b)) return true;\n  if (!isObject(a) || !isObject(b)) return false; // Semi-primitives.\n\n  if (objectString(a) !== objectString(b)) return false;\n  if (Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;\n  if (isBuffer(a) && isBuffer(b)) return a.equals(b);\n  if (isDate(a)) return Object.is(a.getTime(), b.getTime());\n\n  if (isRegExp(a)) {\n    return a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.lastIndex === b.lastIndex && a.ignoreCase === b.ignoreCase;\n  }\n\n  if (isError(a)) {\n    if (a.message !== b.message) return false;\n  }\n\n  if (isArrayBuffer(a)) {\n    a = new Uint8Array(a);\n    b = new Uint8Array(b);\n  }\n\n  if (isView(a) && !isBuffer(a)) {\n    if (isBuffer(b)) return false;\n    const x = new Uint8Array(a.buffer);\n    const y = new Uint8Array(b.buffer);\n    if (x.length !== y.length) return false;\n\n    for (let i = 0; i < x.length; i++) {\n      if (x[i] !== y[i]) return false;\n    }\n\n    return true;\n  }\n\n  if (isSet(a)) {\n    if (a.size !== b.size) return false;\n    const keys = new Set([...a, ...b]);\n    return keys.size === a.size;\n  } // Recursive.\n\n\n  if (!cache) {\n    cache = {\n      a: new Map(),\n      b: new Map(),\n      p: 0\n    };\n  } else {\n    const aa = cache.a.get(a);\n\n    if (aa != null) {\n      const bb = cache.b.get(b);\n      if (bb != null) return aa === bb;\n    }\n\n    cache.p += 1;\n  }\n\n  cache.a.set(a, cache.p);\n  cache.b.set(b, cache.p);\n  const ret = recurse(a, b, cache);\n  cache.a.delete(a);\n  cache.b.delete(b);\n  return ret;\n}\n\nfunction recurse(a, b, cache) {\n  if (isMap(a)) {\n    if (a.size !== b.size) return false;\n    const keys = new Set([...a.keys(), ...b.keys()]);\n    if (keys.size !== a.size) return false;\n\n    for (const key of keys) {\n      if (!compare(a.get(key), b.get(key), cache)) return false;\n    }\n\n    return true;\n  }\n\n  if (isArray(a)) {\n    if (a.length !== b.length) return false;\n\n    for (let i = 0; i < a.length; i++) {\n      if (!compare(a[i], b[i], cache)) return false;\n    }\n\n    return true;\n  }\n\n  const ak = ownKeys(a);\n  const bk = ownKeys(b);\n  if (ak.length !== bk.length) return false;\n  const keys = new Set([...ak, ...bk]);\n  if (keys.size !== ak.length) return false;\n\n  for (const key of keys) {\n    if (!compare(a[key], b[key], cache)) return false;\n  }\n\n  return true;\n}\n\nfunction ownKeys(obj) {\n  const keys = Object.keys(obj);\n  if (!Object.getOwnPropertySymbols) return keys;\n  if (!Object.getOwnPropertyDescriptor) return keys;\n  const symbols = Object.getOwnPropertySymbols(obj);\n\n  for (const symbol of symbols) {\n    const desc = Object.getOwnPropertyDescriptor(obj, symbol);\n    if (desc && desc.enumerable) keys.push(symbol);\n  }\n\n  return keys;\n}\n/*\n * Helpers\n */\n\n\nfunction objectString(obj) {\n  if (obj === undefined) return '[object Undefined]';\n  if (obj === null) return '[object Null]';\n\n  try {\n    return Object.prototype.toString.call(obj);\n  } catch (e) {\n    return '[object Object]';\n  }\n}\n\nfunction objectType(obj) {\n  return objectString(obj).slice(8, -1);\n}\n\nfunction objectName(obj) {\n  const type = objectType(obj);\n  if (obj == null) return type;\n  if (type !== 'Object' && type !== 'Error') return type;\n  let ctor, name;\n\n  try {\n    ctor = obj.constructor;\n  } catch (e) {\n    ;\n  }\n\n  if (ctor == null) return type;\n\n  try {\n    name = ctor.name;\n  } catch (e) {\n    return type;\n  }\n\n  if (typeof name !== 'string' || name.length === 0) return type;\n  return name;\n}\n\nfunction funcName(func) {\n  let name;\n\n  try {\n    name = func.name;\n  } catch (e) {\n    ;\n  }\n\n  if (typeof name !== 'string' || name.length === 0) return 'Function';\n  return `Function: ${name}`;\n}\n\nfunction isArray(obj) {\n  return Array.isArray(obj);\n}\n\nfunction isArrayBuffer(obj) {\n  return obj instanceof ArrayBuffer;\n}\n\nfunction isBuffer(obj) {\n  return isObject(obj) && typeof obj.writeUInt32LE === 'function' && typeof obj.equals === 'function';\n}\n\nfunction isDate(obj) {\n  return obj instanceof Date;\n}\n\nfunction isError(obj) {\n  return obj instanceof Error;\n}\n\nfunction isMap(obj) {\n  return obj instanceof Map;\n}\n\nfunction isObject(obj) {\n  return obj && typeof obj === 'object';\n}\n\nfunction isPromise(obj) {\n  return obj instanceof Promise;\n}\n\nfunction isRegExp(obj) {\n  return obj instanceof RegExp;\n}\n\nfunction isSet(obj) {\n  return obj instanceof Set;\n}\n\nfunction isView(obj) {\n  return ArrayBuffer.isView(obj);\n}\n\nfunction isEncoding(enc) {\n  if (typeof enc !== 'string') return false;\n\n  switch (enc) {\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'hex':\n    case 'latin1':\n    case 'ucs2':\n    case 'utf8':\n    case 'utf16le':\n      return true;\n  }\n\n  return false;\n}\n\nfunction bufferize(actual, expected, enc) {\n  if (typeof expected === 'string') {\n    if (!isBuffer(actual)) return null;\n    const {\n      constructor\n    } = actual;\n    if (!constructor || typeof constructor.from !== 'function') return null;\n    if (!isEncoding(enc)) return null;\n    if (enc === 'hex' && expected.length & 1) return null;\n    const raw = constructor.from(expected, enc);\n    if (enc === 'hex' && raw.length !== expected.length >>> 1) return null;\n    return raw;\n  }\n\n  return expected;\n}\n/*\n * API\n */\n\n\nassert.AssertionError = AssertionError;\nassert.assert = assert;\nassert.strict = assert;\nassert.ok = assert;\nassert.equal = equal;\nassert.notEqual = notEqual;\nassert.strictEqual = equal;\nassert.notStrictEqual = notEqual;\nassert.fail = fail;\nassert.throws = throws;\nassert.doesNotThrow = doesNotThrow;\nassert.rejects = rejects;\nassert.doesNotReject = doesNotReject;\nassert.ifError = ifError;\nassert.deepEqual = deepEqual;\nassert.notDeepEqual = notDeepEqual;\nassert.deepStrictEqual = deepEqual;\nassert.notDeepStrictEqual = notDeepEqual;\nassert.bufferEqual = bufferEqual;\nassert.notBufferEqual = notBufferEqual;\nassert.enforce = enforce;\nassert.range = range;\n/*\n * Expose\n */\n\nmodule.exports = assert;","map":null,"metadata":{},"sourceType":"script"}