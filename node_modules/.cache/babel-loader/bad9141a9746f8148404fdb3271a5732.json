{"ast":null,"code":"/*!\n * cashaddr.js - cashaddr for bcash\n * Copyright (c) 2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n *\n * Implementation of CashAddr\n * https://github.com/bitcoincashorg/spec/blob/master/cashaddr.md\n *\n * Parts of this software are based on \"bitcoin-abc\".\n * https://github.com/Bitcoin-ABC/bitcoin-abc\n *\n * Parts of this software are based on \"bech32\".\n * https://github.com/sipa/bech32\n *\n * Copyright (c) 2017 Pieter Wuille\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n'use strict';\n\nconst assert = require('bsert');\n/**\n * U64\n */\n\n\nclass U64 {\n  constructor(hi, lo) {\n    this.hi = hi | 0;\n    this.lo = lo | 0;\n  }\n\n  ushrn32(bits) {\n    bits &= 63;\n    let lo = this.lo;\n    if (bits === 0) return lo;\n\n    if (bits < 32) {\n      lo >>>= bits;\n      lo |= this.hi << 32 - bits;\n    } else {\n      lo = this.hi >>> bits - 32;\n    }\n\n    return lo;\n  }\n\n}\n/**\n * Constants\n */\n\n\nconst POOL105 = Buffer.allocUnsafe(105);\nconst CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nconst TABLE = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, 10, 17, 21, 20, 26, 30, 7, 5, -1, -1, -1, -1, -1, -1, -1, 29, -1, 24, 13, 25, 9, 8, 23, -1, 18, 22, 31, 27, 19, -1, 1, 0, 3, 16, 11, 28, 12, 14, 6, 4, 2, -1, -1, -1, -1, -1, -1, 29, -1, 24, 13, 25, 9, 8, 23, -1, 18, 22, 31, 27, 19, -1, 1, 0, 3, 16, 11, 28, 12, 14, 6, 4, 2, -1, -1, -1, -1, -1];\nconst CHECKSUM_MASK = new U64(0x00000007, 0xffffffff);\nconst GENERATOR = [new U64(0x00000098, 0xf2bc8e61), new U64(0x00000079, 0xb76d99e2), new U64(0x000000f3, 0x3e5fb3c4), new U64(0x000000ae, 0x2eabe2a8), new U64(0x0000001e, 0x4f43e470)];\n/**\n * Update checksum\n * @ignore\n * @param {U64} chk\n * @param {Number} x\n * @returns {U64} -- new checksum\n */\n\nfunction polymod(pre, x) {\n  const c = pre; // b = c >> 35\n\n  const b = c.hi >>> 3; // c = (c & CHECKSUM_MASK) << 5\n\n  c.hi &= CHECKSUM_MASK.hi;\n  c.lo &= CHECKSUM_MASK.lo;\n  c.hi <<= 5;\n  c.hi |= c.lo >>> 27;\n  c.lo <<= 5;\n\n  for (let i = 0; i < GENERATOR.length; i++) {\n    if (b >>> i & 1) {\n      // c ^= GENERATOR[i]\n      c.hi ^= GENERATOR[i].hi;\n      c.lo ^= GENERATOR[i].lo;\n    }\n  } // c ^= x\n\n\n  c.lo ^= x;\n  return c;\n}\n/**\n * Serialize data to cashaddr.\n * @param {String} prefix\n * @param {Buffer} data - 5bit serialized\n * @returns {String}\n */\n\n\nfunction serialize(prefix, data) {\n  assert(typeof prefix === 'string');\n  assert(Buffer.isBuffer(data));\n  const chk = new U64(0, 1);\n  let str = '';\n  let upper = false;\n  let lower = false;\n\n  for (let i = 0; i < prefix.length; i++) {\n    let ch = prefix.charCodeAt(i);\n    if (ch & 0xff00 || ch >>> 5 === 0) throw new Error('Invalid cashaddr character.');\n\n    if (ch >= 0x61 && ch <= 0x7a) {\n      lower = true;\n    } else if (ch >= 0x41 && ch <= 0x5a) {\n      upper = true;\n      ch = ch - 0x41 + 0x61;\n    } else if (ch >= 0x30 && ch <= 0x39) {\n      throw new Error('Invalid cashaddr prefix.');\n    }\n\n    polymod(chk, ch & 0x1f);\n    str += String.fromCharCode(ch);\n  }\n\n  if (lower && upper) throw new Error('Invalid cashaddr prefix.');\n  polymod(chk, 0);\n  str += ':';\n\n  for (let i = 0; i < data.length; i++) {\n    const ch = data[i];\n    if (ch >>> 5 !== 0) throw new Error('Invalid cashaddr value.');\n    polymod(chk, ch);\n    str += CHARSET[ch];\n  }\n\n  for (let i = 0; i < 8; i++) polymod(chk, 0);\n\n  chk.lo ^= 1;\n\n  for (let i = 0; i < 8; i++) {\n    const v = chk.ushrn32((7 - i) * 5) & 0x1f;\n    str += CHARSET[v];\n  }\n\n  return str;\n}\n/**\n * Decode CashAddr string.\n * @param {String} str\n * @param {String} defaultPrefix (lowercase and w/o numbers)\n * @returns {Array} [prefix, data]\n */\n\n\nfunction deserialize(str, defaultPrefix) {\n  assert(typeof str === 'string');\n  if (str.length < 8 || str.length > 196) // 83 + 1 + 112\n    throw new Error('Invalid cashaddr data length.');\n  let lower = false;\n  let upper = false;\n  let number = false;\n  let plen = 0; // Process lower/upper, make sure we have prefix.\n\n  for (let i = 0; i < str.length; i++) {\n    const ch = str.charCodeAt(i);\n\n    if (ch >= 0x61 && ch <= 0x7a) {\n      lower = true;\n      continue;\n    }\n\n    if (ch >= 0x41 && ch <= 0x5a) {\n      upper = true;\n      continue;\n    }\n\n    if (ch >= 0x30 && ch <= 0x39) {\n      number = true;\n      continue;\n    }\n\n    if (ch === 0x3a) {\n      // :\n      if (number || i === 0 || i > 83) throw new Error('Invalid cashaddr prefix.');\n      if (plen !== 0) throw new Error('Invalid cashaddr separators.');\n      plen = i;\n      continue;\n    }\n\n    throw new Error('Invalid cashaddr character.');\n  }\n\n  if (upper && lower) throw new Error('Invalid cashaddr casing.'); // Process checksum.\n\n  const chk = new U64(0, 1);\n  let prefix;\n\n  if (plen === 0) {\n    prefix = defaultPrefix.toLowerCase();\n  } else {\n    prefix = str.substring(0, plen).toLowerCase();\n    plen += 1;\n  } // Process prefix.\n\n\n  for (let i = 0; i < prefix.length; i++) {\n    const ch = prefix.charCodeAt(i);\n    polymod(chk, (ch | 0x20) & 0x1f);\n  }\n\n  polymod(chk, 0);\n  const dlen = str.length - plen;\n  if (dlen <= 8 || dlen > 112) throw new Error('Invalid cashaddr data length.');\n  const data = Buffer.allocUnsafe(dlen);\n\n  for (let i = plen; i < str.length; i++) {\n    const ch = str.charCodeAt(i);\n    const v = ch & 0xff80 ? -1 : TABLE[ch];\n    if (v === -1) throw new Error('Invalid cashaddr character.');\n    polymod(chk, v);\n    if (i + 8 < str.length) data[i - plen] = v;\n  }\n\n  const valid = chk.hi === 0 && chk.lo === 1 && prefix === defaultPrefix;\n  if (!valid) throw new Error('Invalid cashaddr checksum.');\n  return [prefix, data.slice(0, -8)];\n}\n/**\n * Convert serialized data to another base.\n * @param {Buffer} input\n * @param {Number} i\n * @param {Buffer} output\n * @param {Number} j\n * @param {Number} frombits\n * @param {Number} tobits\n * @param {Boolean} pad\n * @returns {Buffer}\n */\n\n\nfunction convert(input, i, output, j, frombits, tobits, pad) {\n  assert(Buffer.isBuffer(input));\n  assert(i >>> 0 === i);\n  assert(Buffer.isBuffer(output));\n  assert(j >>> 0 === j);\n  assert((frombits & 0xff) === frombits);\n  assert((tobits & 0xff) === tobits);\n  assert(typeof pad === 'boolean');\n  const maxv = (1 << tobits) - 1;\n  let acc = 0;\n  let bits = 0;\n\n  for (; i < input.length; i++) {\n    const value = input[i];\n    if (value >>> frombits !== 0) throw new Error('Invalid bits.');\n    acc = acc << frombits | value;\n    bits += frombits;\n\n    while (bits >= tobits) {\n      bits -= tobits;\n      output[j++] = acc >>> bits & maxv;\n    }\n  }\n\n  if (pad) {\n    if (bits) output[j++] = acc << tobits - bits & maxv;\n  } else {\n    if (bits >= frombits || acc << tobits - bits & maxv) throw new Error('Invalid bits.');\n  }\n\n  assert(j <= output.length);\n  return output.slice(0, j);\n}\n/**\n * Calculate size required for bit conversion.\n * @param {Number} len\n * @param {Number} frombits\n * @param {Number} tobits\n * @param {Boolean} pad\n * @returns {Number}\n */\n\n\nfunction convertSize(len, frombits, tobits, pad) {\n  assert(len >>> 0 === len);\n  assert((frombits & 0xff) === frombits);\n  assert((tobits & 0xff) === tobits);\n  assert(typeof pad === 'boolean');\n  assert(tobits !== 0);\n  let size = (len * frombits + (tobits - 1)) / tobits;\n  size >>>= 0;\n  if (pad) size += 1;\n  return size;\n}\n/**\n * Convert serialized data to another base.\n * @param {Buffer} data\n * @param {Number} frombits\n * @param {Number} tobits\n * @param {Boolean} pad\n * @returns {Buffer}\n */\n\n\nfunction convertBits(data, frombits, tobits, pad) {\n  assert(Buffer.isBuffer(data));\n  assert((frombits & 0xff) === frombits);\n  assert((tobits & 0xff) === tobits);\n  assert(typeof pad === 'boolean');\n  const size = convertSize(data.length, frombits, tobits, pad);\n  const out = Buffer.allocUnsafe(size);\n  return convert(data, 0, out, 0, frombits, tobits, pad);\n}\n/**\n * Get cashaddr encoded size.\n * @param {Number} size\n * @returns {Number}\n */\n\n\nfunction encodedSize(size) {\n  assert(size >>> 0 === size);\n\n  switch (size) {\n    case 20:\n      return 0;\n\n    case 24:\n      return 1;\n\n    case 28:\n      return 2;\n\n    case 32:\n      return 3;\n\n    case 40:\n      return 4;\n\n    case 48:\n      return 5;\n\n    case 56:\n      return 6;\n\n    case 64:\n      return 7;\n\n    default:\n      throw new Error('Non standard length.');\n  }\n}\n/**\n * Serialize data to cashaddr\n * @param {String} prefix\n * @param {Number} type - (0 = P2PKH, 1 = P2SH)\n * @param {Buffer} hash\n * @returns {String}\n */\n\n\nfunction encode(prefix, type, hash) {\n  assert(typeof prefix === 'string'); // There are 4 bits available for the version (2 ^ 4 = 16)\n\n  assert((type & 0x0f) === type, 'Invalid cashaddr type.');\n  assert(Buffer.isBuffer(hash));\n  if (prefix.length === 0 || prefix.length > 83) throw new Error('Invalid cashaddr prefix.');\n  const size = encodedSize(hash.length);\n  const data = Buffer.allocUnsafe(hash.length + 1);\n  data[0] = type << 3 | size;\n  hash.copy(data, 1);\n  const output = POOL105;\n  const converted = convert(data, 0, output, 0, 8, 5, true);\n  return serialize(prefix, converted);\n}\n/**\n * Deserialize data from CashAddr address.\n * @param {String} str\n * @param {String} defaultPrefix (lowercase and w/o numbers)\n * @returns {Object}\n */\n\n\nfunction decode(str) {\n  let defaultPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bitcoincash';\n  assert(typeof str === 'string');\n  assert(typeof defaultPrefix === 'string');\n  const [prefix, data] = deserialize(str, defaultPrefix);\n  const extrabits = data.length * 5 & 7;\n  if (extrabits >= 5) throw new Error('Invalid padding in data.');\n  const last = data[data.length - 1];\n  const mask = (1 << extrabits) - 1;\n  if (last & mask) throw new Error('Non zero padding.');\n  const output = data;\n  const converted = convert(data, 0, output, 0, 5, 8, false);\n  const type = converted[0] >>> 3 & 0x1f;\n  const hash = converted.slice(1);\n  let size = 20 + 4 * (converted[0] & 0x03);\n  if (converted[0] & 0x04) size *= 2;\n  if (size !== hash.length) throw new Error('Invalid cashaddr data length.');\n  return new AddrResult(prefix, type, hash);\n}\n/**\n * Test whether a string is a cashaddr string.\n * @param {String} str\n * @param {String} defaultPrefix (lowercase and w/o numbers)\n * @returns {Boolean}\n */\n\n\nfunction test(str) {\n  let defaultPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bitcoincash';\n\n  try {\n    decode(str, defaultPrefix);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * AddrResult\n * @private\n * @property {String} prefix\n * @property {Number} type (0 = P2PKH, 1 = P2SH)\n * @property {Buffer} hash\n */\n\n\nclass AddrResult {\n  constructor(prefix, type, hash) {\n    this.prefix = prefix;\n    this.type = type;\n    this.hash = hash;\n  }\n\n}\n/*\n * Expose\n */\n\n\nconvertBits;\nexports.encode = encode;\nexports.decode = decode;\nexports.test = test;","map":null,"metadata":{},"sourceType":"script"}