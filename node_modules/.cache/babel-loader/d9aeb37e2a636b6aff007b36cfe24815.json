{"ast":null,"code":"!function (root, factory) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = factory() : \"function\" == typeof define && define.amd ? define(\"zoid\", [], factory) : \"object\" == typeof exports ? exports.zoid = factory() : root.zoid = factory();\n}(\"undefined\" != typeof self ? self : this, function () {\n  return function (modules) {\n    var installedModules = {};\n\n    function __webpack_require__(moduleId) {\n      if (installedModules[moduleId]) return installedModules[moduleId].exports;\n      var module = installedModules[moduleId] = {\n        i: moduleId,\n        l: !1,\n        exports: {}\n      };\n      modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n      module.l = !0;\n      return module.exports;\n    }\n\n    __webpack_require__.m = modules;\n    __webpack_require__.c = installedModules;\n\n    __webpack_require__.d = function (exports, name, getter) {\n      __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {\n        enumerable: !0,\n        get: getter\n      });\n    };\n\n    __webpack_require__.r = function (exports) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {\n        value: \"Module\"\n      });\n      Object.defineProperty(exports, \"__esModule\", {\n        value: !0\n      });\n    };\n\n    __webpack_require__.t = function (value, mode) {\n      1 & mode && (value = __webpack_require__(value));\n      if (8 & mode) return value;\n      if (4 & mode && \"object\" == typeof value && value && value.__esModule) return value;\n      var ns = Object.create(null);\n\n      __webpack_require__.r(ns);\n\n      Object.defineProperty(ns, \"default\", {\n        enumerable: !0,\n        value: value\n      });\n      if (2 & mode && \"string\" != typeof value) for (var key in value) __webpack_require__.d(ns, key, function (key) {\n        return value[key];\n      }.bind(null, key));\n      return ns;\n    };\n\n    __webpack_require__.n = function (module) {\n      var getter = module && module.__esModule ? function () {\n        return module.default;\n      } : function () {\n        return module;\n      };\n\n      __webpack_require__.d(getter, \"a\", getter);\n\n      return getter;\n    };\n\n    __webpack_require__.o = function (object, property) {\n      return {}.hasOwnProperty.call(object, property);\n    };\n\n    __webpack_require__.p = \"\";\n    return __webpack_require__(__webpack_require__.s = 0);\n  }([function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n\n    __webpack_require__.d(__webpack_exports__, \"PopupOpenError\", function () {\n      return dom_PopupOpenError;\n    });\n\n    __webpack_require__.d(__webpack_exports__, \"create\", function () {\n      return component_create;\n    });\n\n    __webpack_require__.d(__webpack_exports__, \"destroy\", function () {\n      return component_destroy;\n    });\n\n    __webpack_require__.d(__webpack_exports__, \"destroyComponents\", function () {\n      return destroyComponents;\n    });\n\n    __webpack_require__.d(__webpack_exports__, \"destroyAll\", function () {\n      return destroyAll;\n    });\n\n    __webpack_require__.d(__webpack_exports__, \"PROP_TYPE\", function () {\n      return PROP_TYPE;\n    });\n\n    __webpack_require__.d(__webpack_exports__, \"PROP_SERIALIZATION\", function () {\n      return PROP_SERIALIZATION;\n    });\n\n    __webpack_require__.d(__webpack_exports__, \"CONTEXT\", function () {\n      return CONTEXT;\n    });\n\n    __webpack_require__.d(__webpack_exports__, \"EVENT\", function () {\n      return EVENT;\n    });\n\n    function _setPrototypeOf(o, p) {\n      return (_setPrototypeOf = Object.setPrototypeOf || function (o, p) {\n        o.__proto__ = p;\n        return o;\n      })(o, p);\n    }\n\n    function _inheritsLoose(subClass, superClass) {\n      subClass.prototype = Object.create(superClass.prototype);\n      subClass.prototype.constructor = subClass;\n\n      _setPrototypeOf(subClass, superClass);\n    }\n\n    function _extends() {\n      return (_extends = Object.assign || function (target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n\n          for (var key in source) ({}).hasOwnProperty.call(source, key) && (target[key] = source[key]);\n        }\n\n        return target;\n      }).apply(this, arguments);\n    }\n\n    function utils_isPromise(item) {\n      try {\n        if (!item) return !1;\n        if (\"undefined\" != typeof Promise && item instanceof Promise) return !0;\n        if (\"undefined\" != typeof window && \"function\" == typeof window.Window && item instanceof window.Window) return !1;\n        if (\"undefined\" != typeof window && \"function\" == typeof window.constructor && item instanceof window.constructor) return !1;\n        var _toString = {}.toString;\n\n        if (_toString) {\n          var name = _toString.call(item);\n\n          if (\"[object Window]\" === name || \"[object global]\" === name || \"[object DOMWindow]\" === name) return !1;\n        }\n\n        if (\"function\" == typeof item.then) return !0;\n      } catch (err) {\n        return !1;\n      }\n\n      return !1;\n    }\n\n    var dispatchedErrors = [];\n    var possiblyUnhandledPromiseHandlers = [];\n    var activeCount = 0;\n    var flushPromise;\n\n    function flushActive() {\n      if (!activeCount && flushPromise) {\n        var promise = flushPromise;\n        flushPromise = null;\n        promise.resolve();\n      }\n    }\n\n    function startActive() {\n      activeCount += 1;\n    }\n\n    function endActive() {\n      activeCount -= 1;\n      flushActive();\n    }\n\n    var promise_ZalgoPromise = function () {\n      function ZalgoPromise(handler) {\n        var _this = this;\n\n        this.resolved = void 0;\n        this.rejected = void 0;\n        this.errorHandled = void 0;\n        this.value = void 0;\n        this.error = void 0;\n        this.handlers = void 0;\n        this.dispatching = void 0;\n        this.stack = void 0;\n        this.resolved = !1;\n        this.rejected = !1;\n        this.errorHandled = !1;\n        this.handlers = [];\n\n        if (handler) {\n          var _result;\n\n          var _error;\n\n          var resolved = !1;\n          var rejected = !1;\n          var isAsync = !1;\n          startActive();\n\n          try {\n            handler(function (res) {\n              if (isAsync) _this.resolve(res);else {\n                resolved = !0;\n                _result = res;\n              }\n            }, function (err) {\n              if (isAsync) _this.reject(err);else {\n                rejected = !0;\n                _error = err;\n              }\n            });\n          } catch (err) {\n            endActive();\n            this.reject(err);\n            return;\n          }\n\n          endActive();\n          isAsync = !0;\n          resolved ? this.resolve(_result) : rejected && this.reject(_error);\n        }\n      }\n\n      var _proto = ZalgoPromise.prototype;\n\n      _proto.resolve = function (result) {\n        if (this.resolved || this.rejected) return this;\n        if (utils_isPromise(result)) throw new Error(\"Can not resolve promise with another promise\");\n        this.resolved = !0;\n        this.value = result;\n        this.dispatch();\n        return this;\n      };\n\n      _proto.reject = function (error) {\n        var _this2 = this;\n\n        if (this.resolved || this.rejected) return this;\n        if (utils_isPromise(error)) throw new Error(\"Can not reject promise with another promise\");\n\n        if (!error) {\n          var _err = error && \"function\" == typeof error.toString ? error.toString() : {}.toString.call(error);\n\n          error = new Error(\"Expected reject to be called with Error, got \" + _err);\n        }\n\n        this.rejected = !0;\n        this.error = error;\n        this.errorHandled || setTimeout(function () {\n          _this2.errorHandled || function (err, promise) {\n            if (-1 === dispatchedErrors.indexOf(err)) {\n              dispatchedErrors.push(err);\n              setTimeout(function () {\n                throw err;\n              }, 1);\n\n              for (var j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) possiblyUnhandledPromiseHandlers[j](err, promise);\n            }\n          }(error, _this2);\n        }, 1);\n        this.dispatch();\n        return this;\n      };\n\n      _proto.asyncReject = function (error) {\n        this.errorHandled = !0;\n        this.reject(error);\n        return this;\n      };\n\n      _proto.dispatch = function () {\n        var resolved = this.resolved,\n            rejected = this.rejected,\n            handlers = this.handlers;\n\n        if (!this.dispatching && (resolved || rejected)) {\n          this.dispatching = !0;\n          startActive();\n\n          var chain = function (firstPromise, secondPromise) {\n            return firstPromise.then(function (res) {\n              secondPromise.resolve(res);\n            }, function (err) {\n              secondPromise.reject(err);\n            });\n          };\n\n          for (var i = 0; i < handlers.length; i++) {\n            var _handlers$i = handlers[i],\n                onSuccess = _handlers$i.onSuccess,\n                onError = _handlers$i.onError,\n                promise = _handlers$i.promise;\n\n            var _result2 = void 0;\n\n            if (resolved) try {\n              _result2 = onSuccess ? onSuccess(this.value) : this.value;\n            } catch (err) {\n              promise.reject(err);\n              continue;\n            } else if (rejected) {\n              if (!onError) {\n                promise.reject(this.error);\n                continue;\n              }\n\n              try {\n                _result2 = onError(this.error);\n              } catch (err) {\n                promise.reject(err);\n                continue;\n              }\n            }\n\n            if (_result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected)) {\n              var promiseResult = _result2;\n              promiseResult.resolved ? promise.resolve(promiseResult.value) : promise.reject(promiseResult.error);\n              promiseResult.errorHandled = !0;\n            } else utils_isPromise(_result2) ? _result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected) ? _result2.resolved ? promise.resolve(_result2.value) : promise.reject(_result2.error) : chain(_result2, promise) : promise.resolve(_result2);\n          }\n\n          handlers.length = 0;\n          this.dispatching = !1;\n          endActive();\n        }\n      };\n\n      _proto.then = function (onSuccess, onError) {\n        if (onSuccess && \"function\" != typeof onSuccess && !onSuccess.call) throw new Error(\"Promise.then expected a function for success handler\");\n        if (onError && \"function\" != typeof onError && !onError.call) throw new Error(\"Promise.then expected a function for error handler\");\n        var promise = new ZalgoPromise();\n        this.handlers.push({\n          promise: promise,\n          onSuccess: onSuccess,\n          onError: onError\n        });\n        this.errorHandled = !0;\n        this.dispatch();\n        return promise;\n      };\n\n      _proto.catch = function (onError) {\n        return this.then(void 0, onError);\n      };\n\n      _proto.finally = function (onFinally) {\n        if (onFinally && \"function\" != typeof onFinally && !onFinally.call) throw new Error(\"Promise.finally expected a function\");\n        return this.then(function (result) {\n          return ZalgoPromise.try(onFinally).then(function () {\n            return result;\n          });\n        }, function (err) {\n          return ZalgoPromise.try(onFinally).then(function () {\n            throw err;\n          });\n        });\n      };\n\n      _proto.timeout = function (time, err) {\n        var _this3 = this;\n\n        if (this.resolved || this.rejected) return this;\n        var timeout = setTimeout(function () {\n          _this3.resolved || _this3.rejected || _this3.reject(err || new Error(\"Promise timed out after \" + time + \"ms\"));\n        }, time);\n        return this.then(function (result) {\n          clearTimeout(timeout);\n          return result;\n        });\n      };\n\n      _proto.toPromise = function () {\n        if (\"undefined\" == typeof Promise) throw new TypeError(\"Could not find Promise\");\n        return Promise.resolve(this);\n      };\n\n      _proto.lazy = function () {\n        this.errorHandled = !0;\n        return this;\n      };\n\n      ZalgoPromise.resolve = function (value) {\n        return value instanceof ZalgoPromise ? value : utils_isPromise(value) ? new ZalgoPromise(function (resolve, reject) {\n          return value.then(resolve, reject);\n        }) : new ZalgoPromise().resolve(value);\n      };\n\n      ZalgoPromise.reject = function (error) {\n        return new ZalgoPromise().reject(error);\n      };\n\n      ZalgoPromise.asyncReject = function (error) {\n        return new ZalgoPromise().asyncReject(error);\n      };\n\n      ZalgoPromise.all = function (promises) {\n        var promise = new ZalgoPromise();\n        var count = promises.length;\n        var results = [].slice();\n\n        if (!count) {\n          promise.resolve(results);\n          return promise;\n        }\n\n        var chain = function (i, firstPromise, secondPromise) {\n          return firstPromise.then(function (res) {\n            results[i] = res;\n            0 == (count -= 1) && promise.resolve(results);\n          }, function (err) {\n            secondPromise.reject(err);\n          });\n        };\n\n        for (var i = 0; i < promises.length; i++) {\n          var prom = promises[i];\n\n          if (prom instanceof ZalgoPromise) {\n            if (prom.resolved) {\n              results[i] = prom.value;\n              count -= 1;\n              continue;\n            }\n          } else if (!utils_isPromise(prom)) {\n            results[i] = prom;\n            count -= 1;\n            continue;\n          }\n\n          chain(i, ZalgoPromise.resolve(prom), promise);\n        }\n\n        0 === count && promise.resolve(results);\n        return promise;\n      };\n\n      ZalgoPromise.hash = function (promises) {\n        var result = {};\n        var awaitPromises = [];\n\n        var _loop = function (key) {\n          if (promises.hasOwnProperty(key)) {\n            var value = promises[key];\n            utils_isPromise(value) ? awaitPromises.push(value.then(function (res) {\n              result[key] = res;\n            })) : result[key] = value;\n          }\n        };\n\n        for (var key in promises) _loop(key);\n\n        return ZalgoPromise.all(awaitPromises).then(function () {\n          return result;\n        });\n      };\n\n      ZalgoPromise.map = function (items, method) {\n        return ZalgoPromise.all(items.map(method));\n      };\n\n      ZalgoPromise.onPossiblyUnhandledException = function (handler) {\n        return function (handler) {\n          possiblyUnhandledPromiseHandlers.push(handler);\n          return {\n            cancel: function () {\n              possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n            }\n          };\n        }(handler);\n      };\n\n      ZalgoPromise.try = function (method, context, args) {\n        if (method && \"function\" != typeof method && !method.call) throw new Error(\"Promise.try expected a function\");\n        var result;\n        startActive();\n\n        try {\n          result = method.apply(context, args || []);\n        } catch (err) {\n          endActive();\n          return ZalgoPromise.reject(err);\n        }\n\n        endActive();\n        return ZalgoPromise.resolve(result);\n      };\n\n      ZalgoPromise.delay = function (_delay) {\n        return new ZalgoPromise(function (resolve) {\n          setTimeout(resolve, _delay);\n        });\n      };\n\n      ZalgoPromise.isPromise = function (value) {\n        return !!(value && value instanceof ZalgoPromise) || utils_isPromise(value);\n      };\n\n      ZalgoPromise.flush = function () {\n        return function (Zalgo) {\n          var promise = flushPromise = flushPromise || new Zalgo();\n          flushActive();\n          return promise;\n        }(ZalgoPromise);\n      };\n\n      return ZalgoPromise;\n    }();\n\n    function isRegex(item) {\n      return \"[object RegExp]\" === {}.toString.call(item);\n    }\n\n    var WINDOW_TYPE = {\n      IFRAME: \"iframe\",\n      POPUP: \"popup\"\n    };\n    var IE_WIN_ACCESS_ERROR = \"Call was rejected by callee.\\r\\n\";\n\n    function getActualProtocol(win) {\n      void 0 === win && (win = window);\n      return win.location.protocol;\n    }\n\n    function getProtocol(win) {\n      void 0 === win && (win = window);\n\n      if (win.mockDomain) {\n        var protocol = win.mockDomain.split(\"//\")[0];\n        if (protocol) return protocol;\n      }\n\n      return getActualProtocol(win);\n    }\n\n    function isAboutProtocol(win) {\n      void 0 === win && (win = window);\n      return \"about:\" === getProtocol(win);\n    }\n\n    function utils_getParent(win) {\n      void 0 === win && (win = window);\n      if (win) try {\n        if (win.parent && win.parent !== win) return win.parent;\n      } catch (err) {}\n    }\n\n    function getOpener(win) {\n      void 0 === win && (win = window);\n      if (win && !utils_getParent(win)) try {\n        return win.opener;\n      } catch (err) {}\n    }\n\n    function canReadFromWindow(win) {\n      try {\n        return !0;\n      } catch (err) {}\n\n      return !1;\n    }\n\n    function getActualDomain(win) {\n      void 0 === win && (win = window);\n      var location = win.location;\n      if (!location) throw new Error(\"Can not read window location\");\n      var protocol = getActualProtocol(win);\n      if (!protocol) throw new Error(\"Can not read window protocol\");\n      if (\"file:\" === protocol) return \"file://\";\n\n      if (\"about:\" === protocol) {\n        var parent = utils_getParent(win);\n        return parent && canReadFromWindow() ? getActualDomain(parent) : \"about://\";\n      }\n\n      var host = location.host;\n      if (!host) throw new Error(\"Can not read window host\");\n      return protocol + \"//\" + host;\n    }\n\n    function getDomain(win) {\n      void 0 === win && (win = window);\n      var domain = getActualDomain(win);\n      return domain && win.mockDomain && 0 === win.mockDomain.indexOf(\"mock:\") ? win.mockDomain : domain;\n    }\n\n    function isSameDomain(win) {\n      if (!function (win) {\n        try {\n          if (win === window) return !0;\n        } catch (err) {}\n\n        try {\n          var desc = Object.getOwnPropertyDescriptor(win, \"location\");\n          if (desc && !1 === desc.enumerable) return !1;\n        } catch (err) {}\n\n        try {\n          if (isAboutProtocol(win) && canReadFromWindow()) return !0;\n        } catch (err) {}\n\n        try {\n          if (function (win) {\n            void 0 === win && (win = window);\n            return \"mock:\" === getProtocol(win);\n          }(win) && canReadFromWindow()) return !0;\n        } catch (err) {}\n\n        try {\n          if (getActualDomain(win) === getActualDomain(window)) return !0;\n        } catch (err) {}\n\n        return !1;\n      }(win)) return !1;\n\n      try {\n        if (win === window) return !0;\n        if (isAboutProtocol(win) && canReadFromWindow()) return !0;\n        if (getDomain(window) === getDomain(win)) return !0;\n      } catch (err) {}\n\n      return !1;\n    }\n\n    function assertSameDomain(win) {\n      if (!isSameDomain(win)) throw new Error(\"Expected window to be same domain\");\n      return win;\n    }\n\n    function isAncestorParent(parent, child) {\n      if (!parent || !child) return !1;\n      var childParent = utils_getParent(child);\n      return childParent ? childParent === parent : -1 !== function (win) {\n        var result = [];\n\n        try {\n          for (; win.parent !== win;) {\n            result.push(win.parent);\n            win = win.parent;\n          }\n        } catch (err) {}\n\n        return result;\n      }(child).indexOf(parent);\n    }\n\n    function getFrames(win) {\n      var result = [];\n      var frames;\n\n      try {\n        frames = win.frames;\n      } catch (err) {\n        frames = win;\n      }\n\n      var len;\n\n      try {\n        len = frames.length;\n      } catch (err) {}\n\n      if (0 === len) return result;\n\n      if (len) {\n        for (var i = 0; i < len; i++) {\n          var frame = void 0;\n\n          try {\n            frame = frames[i];\n          } catch (err) {\n            continue;\n          }\n\n          result.push(frame);\n        }\n\n        return result;\n      }\n\n      for (var _i = 0; _i < 100; _i++) {\n        var _frame = void 0;\n\n        try {\n          _frame = frames[_i];\n        } catch (err) {\n          return result;\n        }\n\n        if (!_frame) return result;\n        result.push(_frame);\n      }\n\n      return result;\n    }\n\n    function getAllChildFrames(win) {\n      var result = [];\n\n      for (var _i3 = 0, _getFrames2 = getFrames(win); _i3 < _getFrames2.length; _i3++) {\n        var frame = _getFrames2[_i3];\n        result.push(frame);\n\n        for (var _i5 = 0, _getAllChildFrames2 = getAllChildFrames(frame); _i5 < _getAllChildFrames2.length; _i5++) result.push(_getAllChildFrames2[_i5]);\n      }\n\n      return result;\n    }\n\n    function getTop(win) {\n      void 0 === win && (win = window);\n\n      try {\n        if (win.top) return win.top;\n      } catch (err) {}\n\n      if (utils_getParent(win) === win) return win;\n\n      try {\n        if (isAncestorParent(window, win) && window.top) return window.top;\n      } catch (err) {}\n\n      try {\n        if (isAncestorParent(win, window) && window.top) return window.top;\n      } catch (err) {}\n\n      for (var _i7 = 0, _getAllChildFrames4 = getAllChildFrames(win); _i7 < _getAllChildFrames4.length; _i7++) {\n        var frame = _getAllChildFrames4[_i7];\n\n        try {\n          if (frame.top) return frame.top;\n        } catch (err) {}\n\n        if (utils_getParent(frame) === frame) return frame;\n      }\n    }\n\n    function getAllFramesInWindow(win) {\n      var top = getTop(win);\n      if (!top) throw new Error(\"Can not determine top window\");\n      var result = [].concat(getAllChildFrames(top), [top]);\n      -1 === result.indexOf(win) && (result = [].concat(result, [win], getAllChildFrames(win)));\n      return result;\n    }\n\n    var iframeWindows = [];\n    var iframeFrames = [];\n\n    function isWindowClosed(win, allowMock) {\n      void 0 === allowMock && (allowMock = !0);\n\n      try {\n        if (win === window) return !1;\n      } catch (err) {\n        return !0;\n      }\n\n      try {\n        if (!win) return !0;\n      } catch (err) {\n        return !0;\n      }\n\n      try {\n        if (win.closed) return !0;\n      } catch (err) {\n        return !err || err.message !== IE_WIN_ACCESS_ERROR;\n      }\n\n      if (allowMock && isSameDomain(win)) try {\n        if (win.mockclosed) return !0;\n      } catch (err) {}\n\n      try {\n        if (!win.parent || !win.top) return !0;\n      } catch (err) {}\n\n      var iframeIndex = function (collection, item) {\n        for (var i = 0; i < collection.length; i++) try {\n          if (collection[i] === item) return i;\n        } catch (err) {}\n\n        return -1;\n      }(iframeWindows, win);\n\n      if (-1 !== iframeIndex) {\n        var frame = iframeFrames[iframeIndex];\n        if (frame && function (frame) {\n          if (!frame.contentWindow) return !0;\n          if (!frame.parentNode) return !0;\n          var doc = frame.ownerDocument;\n\n          if (doc && doc.documentElement && !doc.documentElement.contains(frame)) {\n            var parent = frame;\n\n            for (; parent.parentNode && parent.parentNode !== parent;) parent = parent.parentNode;\n\n            if (!parent.host || !doc.documentElement.contains(parent.host)) return !0;\n          }\n\n          return !1;\n        }(frame)) return !0;\n      }\n\n      return !1;\n    }\n\n    function utils_getUserAgent(win) {\n      return (win = win || window).navigator.mockUserAgent || win.navigator.userAgent;\n    }\n\n    function getFrameByName(win, name) {\n      var winFrames = getFrames(win);\n\n      for (var _i9 = 0; _i9 < winFrames.length; _i9++) {\n        var childFrame = winFrames[_i9];\n\n        try {\n          if (isSameDomain(childFrame) && childFrame.name === name && -1 !== winFrames.indexOf(childFrame)) return childFrame;\n        } catch (err) {}\n      }\n\n      try {\n        if (-1 !== winFrames.indexOf(win.frames[name])) return win.frames[name];\n      } catch (err) {}\n\n      try {\n        if (-1 !== winFrames.indexOf(win[name])) return win[name];\n      } catch (err) {}\n    }\n\n    function isOpener(parent, child) {\n      return parent === getOpener(child);\n    }\n\n    function getAncestor(win) {\n      void 0 === win && (win = window);\n      return getOpener(win = win || window) || utils_getParent(win) || void 0;\n    }\n\n    function anyMatch(collection1, collection2) {\n      for (var _i17 = 0; _i17 < collection1.length; _i17++) {\n        var item1 = collection1[_i17];\n\n        for (var _i19 = 0; _i19 < collection2.length; _i19++) if (item1 === collection2[_i19]) return !0;\n      }\n\n      return !1;\n    }\n\n    function getDistanceFromTop(win) {\n      void 0 === win && (win = window);\n      var distance = 0;\n      var parent = win;\n\n      for (; parent;) (parent = utils_getParent(parent)) && (distance += 1);\n\n      return distance;\n    }\n\n    function isSameTopWindow(win1, win2) {\n      var top1 = getTop(win1) || win1;\n      var top2 = getTop(win2) || win2;\n\n      try {\n        if (top1 && top2) return top1 === top2;\n      } catch (err) {}\n\n      var allFrames1 = getAllFramesInWindow(win1);\n      var allFrames2 = getAllFramesInWindow(win2);\n      if (anyMatch(allFrames1, allFrames2)) return !0;\n      var opener1 = getOpener(top1);\n      var opener2 = getOpener(top2);\n      return opener1 && anyMatch(getAllFramesInWindow(opener1), allFrames2) || opener2 && anyMatch(getAllFramesInWindow(opener2), allFrames1), !1;\n    }\n\n    function matchDomain(pattern, origin) {\n      if (\"string\" == typeof pattern) {\n        if (\"string\" == typeof origin) return \"*\" === pattern || origin === pattern;\n        if (isRegex(origin)) return !1;\n        if (Array.isArray(origin)) return !1;\n      }\n\n      return isRegex(pattern) ? isRegex(origin) ? pattern.toString() === origin.toString() : !Array.isArray(origin) && Boolean(origin.match(pattern)) : !!Array.isArray(pattern) && (Array.isArray(origin) ? JSON.stringify(pattern) === JSON.stringify(origin) : !isRegex(origin) && pattern.some(function (subpattern) {\n        return matchDomain(subpattern, origin);\n      }));\n    }\n\n    function getDomainFromUrl(url) {\n      return url.match(/^(https?|mock|file):\\/\\//) ? url.split(\"/\").slice(0, 3).join(\"/\") : getDomain();\n    }\n\n    function onCloseWindow(win, callback, delay, maxtime) {\n      void 0 === delay && (delay = 1e3);\n      void 0 === maxtime && (maxtime = 1 / 0);\n      var timeout;\n      !function check() {\n        if (isWindowClosed(win)) {\n          timeout && clearTimeout(timeout);\n          return callback();\n        }\n\n        if (maxtime <= 0) clearTimeout(timeout);else {\n          maxtime -= delay;\n          timeout = setTimeout(check, delay);\n        }\n      }();\n      return {\n        cancel: function () {\n          timeout && clearTimeout(timeout);\n        }\n      };\n    }\n\n    function isWindow(obj) {\n      try {\n        if (obj === window) return !0;\n      } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n      }\n\n      try {\n        if (\"[object Window]\" === {}.toString.call(obj)) return !0;\n      } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n      }\n\n      try {\n        if (window.Window && obj instanceof window.Window) return !0;\n      } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n      }\n\n      try {\n        if (obj && obj.self === obj) return !0;\n      } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n      }\n\n      try {\n        if (obj && obj.parent === obj) return !0;\n      } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n      }\n\n      try {\n        if (obj && obj.top === obj) return !0;\n      } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n      }\n\n      try {\n        if (obj && \"__unlikely_value__\" === obj.__cross_domain_utils_window_check__) return !1;\n      } catch (err) {\n        return !0;\n      }\n\n      try {\n        if (\"postMessage\" in obj && \"self\" in obj && \"location\" in obj) return !0;\n      } catch (err) {}\n\n      return !1;\n    }\n\n    function normalizeMockUrl(url) {\n      if (!(domain = getDomainFromUrl(url), 0 === domain.indexOf(\"mock:\"))) return url;\n      var domain;\n      throw new Error(\"Mock urls not supported out of test mode\");\n    }\n\n    function getFrameForWindow(win) {\n      if (isSameDomain(win)) return assertSameDomain(win).frameElement;\n\n      for (var _i21 = 0, _document$querySelect2 = document.querySelectorAll(\"iframe\"); _i21 < _document$querySelect2.length; _i21++) {\n        var frame = _document$querySelect2[_i21];\n        if (frame && frame.contentWindow && frame.contentWindow === win) return frame;\n      }\n    }\n\n    function closeWindow(win) {\n      if (function (win) {\n        void 0 === win && (win = window);\n        return Boolean(utils_getParent(win));\n      }(win)) {\n        var frame = getFrameForWindow(win);\n\n        if (frame && frame.parentElement) {\n          frame.parentElement.removeChild(frame);\n          return;\n        }\n      }\n\n      try {\n        win.close();\n      } catch (err) {}\n    }\n\n    function util_safeIndexOf(collection, item) {\n      for (var i = 0; i < collection.length; i++) try {\n        if (collection[i] === item) return i;\n      } catch (err) {}\n\n      return -1;\n    }\n\n    var weakmap_CrossDomainSafeWeakMap = function () {\n      function CrossDomainSafeWeakMap() {\n        this.name = void 0;\n        this.weakmap = void 0;\n        this.keys = void 0;\n        this.values = void 0;\n        this.name = \"__weakmap_\" + (1e9 * Math.random() >>> 0) + \"__\";\n        if (function () {\n          if (\"undefined\" == typeof WeakMap) return !1;\n          if (void 0 === Object.freeze) return !1;\n\n          try {\n            var testWeakMap = new WeakMap();\n            var testKey = {};\n            Object.freeze(testKey);\n            testWeakMap.set(testKey, \"__testvalue__\");\n            return \"__testvalue__\" === testWeakMap.get(testKey);\n          } catch (err) {\n            return !1;\n          }\n        }()) try {\n          this.weakmap = new WeakMap();\n        } catch (err) {}\n        this.keys = [];\n        this.values = [];\n      }\n\n      var _proto = CrossDomainSafeWeakMap.prototype;\n\n      _proto._cleanupClosedWindows = function () {\n        var weakmap = this.weakmap;\n        var keys = this.keys;\n\n        for (var i = 0; i < keys.length; i++) {\n          var value = keys[i];\n\n          if (isWindow(value) && isWindowClosed(value)) {\n            if (weakmap) try {\n              weakmap.delete(value);\n            } catch (err) {}\n            keys.splice(i, 1);\n            this.values.splice(i, 1);\n            i -= 1;\n          }\n        }\n      };\n\n      _proto.isSafeToReadWrite = function (key) {\n        return !isWindow(key);\n      };\n\n      _proto.set = function (key, value) {\n        if (!key) throw new Error(\"WeakMap expected key\");\n        var weakmap = this.weakmap;\n        if (weakmap) try {\n          weakmap.set(key, value);\n        } catch (err) {\n          delete this.weakmap;\n        }\n        if (this.isSafeToReadWrite(key)) try {\n          var name = this.name;\n          var entry = key[name];\n          entry && entry[0] === key ? entry[1] = value : Object.defineProperty(key, name, {\n            value: [key, value],\n            writable: !0\n          });\n          return;\n        } catch (err) {}\n\n        this._cleanupClosedWindows();\n\n        var keys = this.keys;\n        var values = this.values;\n        var index = util_safeIndexOf(keys, key);\n\n        if (-1 === index) {\n          keys.push(key);\n          values.push(value);\n        } else values[index] = value;\n      };\n\n      _proto.get = function (key) {\n        if (!key) throw new Error(\"WeakMap expected key\");\n        var weakmap = this.weakmap;\n        if (weakmap) try {\n          if (weakmap.has(key)) return weakmap.get(key);\n        } catch (err) {\n          delete this.weakmap;\n        }\n        if (this.isSafeToReadWrite(key)) try {\n          var entry = key[this.name];\n          return entry && entry[0] === key ? entry[1] : void 0;\n        } catch (err) {}\n\n        this._cleanupClosedWindows();\n\n        var index = util_safeIndexOf(this.keys, key);\n        if (-1 !== index) return this.values[index];\n      };\n\n      _proto.delete = function (key) {\n        if (!key) throw new Error(\"WeakMap expected key\");\n        var weakmap = this.weakmap;\n        if (weakmap) try {\n          weakmap.delete(key);\n        } catch (err) {\n          delete this.weakmap;\n        }\n        if (this.isSafeToReadWrite(key)) try {\n          var entry = key[this.name];\n          entry && entry[0] === key && (entry[0] = entry[1] = void 0);\n        } catch (err) {}\n\n        this._cleanupClosedWindows();\n\n        var keys = this.keys;\n        var index = util_safeIndexOf(keys, key);\n\n        if (-1 !== index) {\n          keys.splice(index, 1);\n          this.values.splice(index, 1);\n        }\n      };\n\n      _proto.has = function (key) {\n        if (!key) throw new Error(\"WeakMap expected key\");\n        var weakmap = this.weakmap;\n        if (weakmap) try {\n          if (weakmap.has(key)) return !0;\n        } catch (err) {\n          delete this.weakmap;\n        }\n        if (this.isSafeToReadWrite(key)) try {\n          var entry = key[this.name];\n          return !(!entry || entry[0] !== key);\n        } catch (err) {}\n\n        this._cleanupClosedWindows();\n\n        return -1 !== util_safeIndexOf(this.keys, key);\n      };\n\n      _proto.getOrSet = function (key, getter) {\n        if (this.has(key)) return this.get(key);\n        var value = getter();\n        this.set(key, value);\n        return value;\n      };\n\n      return CrossDomainSafeWeakMap;\n    }();\n\n    function _getPrototypeOf(o) {\n      return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function (o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n      })(o);\n    }\n\n    function _isNativeReflectConstruct() {\n      if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n      if (Reflect.construct.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n        return !0;\n      } catch (e) {\n        return !1;\n      }\n    }\n\n    function construct_construct(Parent, args, Class) {\n      return (construct_construct = _isNativeReflectConstruct() ? Reflect.construct : function (Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var instance = new (Function.bind.apply(Parent, a))();\n        Class && _setPrototypeOf(instance, Class.prototype);\n        return instance;\n      }).apply(null, arguments);\n    }\n\n    function wrapNativeSuper_wrapNativeSuper(Class) {\n      var _cache = \"function\" == typeof Map ? new Map() : void 0;\n\n      return (wrapNativeSuper_wrapNativeSuper = function (Class) {\n        if (null === Class || !(fn = Class, -1 !== Function.toString.call(fn).indexOf(\"[native code]\"))) return Class;\n        var fn;\n        if (\"function\" != typeof Class) throw new TypeError(\"Super expression must either be null or a function\");\n\n        if (void 0 !== _cache) {\n          if (_cache.has(Class)) return _cache.get(Class);\n\n          _cache.set(Class, Wrapper);\n        }\n\n        function Wrapper() {\n          return construct_construct(Class, arguments, _getPrototypeOf(this).constructor);\n        }\n\n        Wrapper.prototype = Object.create(Class.prototype, {\n          constructor: {\n            value: Wrapper,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        });\n        return _setPrototypeOf(Wrapper, Class);\n      })(Class);\n    }\n\n    function getFunctionName(fn) {\n      return fn.name || fn.__name__ || fn.displayName || \"anonymous\";\n    }\n\n    function setFunctionName(fn, name) {\n      try {\n        delete fn.name;\n        fn.name = name;\n      } catch (err) {}\n\n      fn.__name__ = fn.displayName = name;\n      return fn;\n    }\n\n    function base64encode(str) {\n      if (\"function\" == typeof btoa) return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (m, p1) {\n        return String.fromCharCode(parseInt(p1, 16));\n      })).replace(/[=]/g, \"\");\n      if (\"undefined\" != typeof Buffer) return Buffer.from(str, \"utf8\").toString(\"base64\").replace(/[=]/g, \"\");\n      throw new Error(\"Can not find window.btoa or Buffer\");\n    }\n\n    function uniqueID() {\n      var chars = \"0123456789abcdef\";\n      return \"uid_\" + \"xxxxxxxxxx\".replace(/./g, function () {\n        return chars.charAt(Math.floor(Math.random() * chars.length));\n      }) + \"_\" + base64encode(new Date().toISOString().slice(11, 19).replace(\"T\", \".\")).replace(/[^a-zA-Z0-9]/g, \"\").toLowerCase();\n    }\n\n    var objectIDs;\n\n    function serializeArgs(args) {\n      try {\n        return JSON.stringify([].slice.call(args), function (subkey, val) {\n          return \"function\" == typeof val ? \"memoize[\" + function (obj) {\n            objectIDs = objectIDs || new weakmap_CrossDomainSafeWeakMap();\n            if (null == obj || \"object\" != typeof obj && \"function\" != typeof obj) throw new Error(\"Invalid object\");\n            var uid = objectIDs.get(obj);\n\n            if (!uid) {\n              uid = typeof obj + \":\" + uniqueID();\n              objectIDs.set(obj, uid);\n            }\n\n            return uid;\n          }(val) + \"]\" : val;\n        });\n      } catch (err) {\n        throw new Error(\"Arguments not serializable -- can not be used to memoize\");\n      }\n    }\n\n    function getEmptyObject() {\n      return {};\n    }\n\n    var memoizeGlobalIndex = 0;\n    var memoizeGlobalIndexValidFrom = 0;\n\n    function memoize(method, options) {\n      void 0 === options && (options = {});\n      var _options$thisNamespac = options.thisNamespace,\n          thisNamespace = void 0 !== _options$thisNamespac && _options$thisNamespac,\n          cacheTime = options.time;\n      var simpleCache;\n      var thisCache;\n      var memoizeIndex = memoizeGlobalIndex;\n      memoizeGlobalIndex += 1;\n\n      var memoizedFunction = function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];\n\n        if (memoizeIndex < memoizeGlobalIndexValidFrom) {\n          simpleCache = null;\n          thisCache = null;\n          memoizeIndex = memoizeGlobalIndex;\n          memoizeGlobalIndex += 1;\n        }\n\n        var cache;\n        cache = thisNamespace ? (thisCache = thisCache || new weakmap_CrossDomainSafeWeakMap()).getOrSet(this, getEmptyObject) : simpleCache = simpleCache || {};\n        var cacheKey = serializeArgs(args);\n        var cacheResult = cache[cacheKey];\n\n        if (cacheResult && cacheTime && Date.now() - cacheResult.time < cacheTime) {\n          delete cache[cacheKey];\n          cacheResult = null;\n        }\n\n        if (cacheResult) return cacheResult.value;\n        var time = Date.now();\n        var value = method.apply(this, arguments);\n        cache[cacheKey] = {\n          time: time,\n          value: value\n        };\n        return value;\n      };\n\n      memoizedFunction.reset = function () {\n        simpleCache = null;\n        thisCache = null;\n      };\n\n      return setFunctionName(memoizedFunction, (options.name || getFunctionName(method)) + \"::memoized\");\n    }\n\n    memoize.clear = function () {\n      memoizeGlobalIndexValidFrom = memoizeGlobalIndex;\n    };\n\n    function memoizePromise(method) {\n      var cache = {};\n\n      function memoizedPromiseFunction() {\n        var _arguments = arguments,\n            _this = this;\n\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];\n\n        var key = serializeArgs(args);\n        if (cache.hasOwnProperty(key)) return cache[key];\n        cache[key] = promise_ZalgoPromise.try(function () {\n          return method.apply(_this, _arguments);\n        }).finally(function () {\n          delete cache[key];\n        });\n        return cache[key];\n      }\n\n      memoizedPromiseFunction.reset = function () {\n        cache = {};\n      };\n\n      return setFunctionName(memoizedPromiseFunction, getFunctionName(method) + \"::promiseMemoized\");\n    }\n\n    function src_util_noop() {}\n\n    function once(method) {\n      var called = !1;\n      return setFunctionName(function () {\n        if (!called) {\n          called = !0;\n          return method.apply(this, arguments);\n        }\n      }, getFunctionName(method) + \"::once\");\n    }\n\n    function stringifyError(err, level) {\n      void 0 === level && (level = 1);\n      if (level >= 3) return \"stringifyError stack overflow\";\n\n      try {\n        if (!err) return \"<unknown error: \" + {}.toString.call(err) + \">\";\n        if (\"string\" == typeof err) return err;\n\n        if (err instanceof Error) {\n          var stack = err && err.stack;\n          var message = err && err.message;\n          if (stack && message) return -1 !== stack.indexOf(message) ? stack : message + \"\\n\" + stack;\n          if (stack) return stack;\n          if (message) return message;\n        }\n\n        return err && err.toString && \"function\" == typeof err.toString ? err.toString() : {}.toString.call(err);\n      } catch (newErr) {\n        return \"Error while stringifying error: \" + stringifyError(newErr, level + 1);\n      }\n    }\n\n    function stringify(item) {\n      return \"string\" == typeof item ? item : item && item.toString && \"function\" == typeof item.toString ? item.toString() : {}.toString.call(item);\n    }\n\n    function extend(obj, source) {\n      if (!source) return obj;\n      if (Object.assign) return Object.assign(obj, source);\n\n      for (var key in source) source.hasOwnProperty(key) && (obj[key] = source[key]);\n\n      return obj;\n    }\n\n    memoize(function (obj) {\n      if (Object.values) return Object.values(obj);\n      var result = [];\n\n      for (var key in obj) obj.hasOwnProperty(key) && result.push(obj[key]);\n\n      return result;\n    });\n\n    function identity(item) {\n      return item;\n    }\n\n    function safeInterval(method, time) {\n      var timeout;\n      !function loop() {\n        timeout = setTimeout(function () {\n          method();\n          loop();\n        }, time);\n      }();\n      return {\n        cancel: function () {\n          clearTimeout(timeout);\n        }\n      };\n    }\n\n    function dasherizeToCamel(string) {\n      return string.replace(/-([a-z])/g, function (g) {\n        return g[1].toUpperCase();\n      });\n    }\n\n    function defineLazyProp(obj, key, getter) {\n      if (Array.isArray(obj)) {\n        if (\"number\" != typeof key) throw new TypeError(\"Array key must be number\");\n      } else if (\"object\" == typeof obj && null !== obj && \"string\" != typeof key) throw new TypeError(\"Object key must be string\");\n\n      Object.defineProperty(obj, key, {\n        configurable: !0,\n        enumerable: !0,\n        get: function () {\n          delete obj[key];\n          var value = getter();\n          obj[key] = value;\n          return value;\n        },\n        set: function (value) {\n          delete obj[key];\n          obj[key] = value;\n        }\n      });\n    }\n\n    function arrayFrom(item) {\n      return [].slice.call(item);\n    }\n\n    function isObjectObject(obj) {\n      return \"object\" == typeof (item = obj) && null !== item && \"[object Object]\" === {}.toString.call(obj);\n      var item;\n    }\n\n    function isPlainObject(obj) {\n      if (!isObjectObject(obj)) return !1;\n      var constructor = obj.constructor;\n      if (\"function\" != typeof constructor) return !1;\n      var prototype = constructor.prototype;\n      return !!isObjectObject(prototype) && !!prototype.hasOwnProperty(\"isPrototypeOf\");\n    }\n\n    function replaceObject(item, replacer, fullKey) {\n      void 0 === fullKey && (fullKey = \"\");\n\n      if (Array.isArray(item)) {\n        var length = item.length;\n        var result = [];\n\n        var _loop2 = function (i) {\n          defineLazyProp(result, i, function () {\n            var itemKey = fullKey ? fullKey + \".\" + i : \"\" + i;\n            var child = replacer(item[i], i, itemKey);\n            (isPlainObject(child) || Array.isArray(child)) && (child = replaceObject(child, replacer, itemKey));\n            return child;\n          });\n        };\n\n        for (var i = 0; i < length; i++) _loop2(i);\n\n        return result;\n      }\n\n      if (isPlainObject(item)) {\n        var _result = {};\n\n        var _loop3 = function (key) {\n          if (!item.hasOwnProperty(key)) return \"continue\";\n          defineLazyProp(_result, key, function () {\n            var itemKey = fullKey ? fullKey + \".\" + key : \"\" + key;\n            var child = replacer(item[key], key, itemKey);\n            (isPlainObject(child) || Array.isArray(child)) && (child = replaceObject(child, replacer, itemKey));\n            return child;\n          });\n        };\n\n        for (var key in item) _loop3(key);\n\n        return _result;\n      }\n\n      throw new Error(\"Pass an object or array\");\n    }\n\n    function isDefined(value) {\n      return null != value;\n    }\n\n    function util_isRegex(item) {\n      return \"[object RegExp]\" === {}.toString.call(item);\n    }\n\n    function util_getOrSet(obj, key, getter) {\n      if (obj.hasOwnProperty(key)) return obj[key];\n      var val = getter();\n      obj[key] = val;\n      return val;\n    }\n\n    function cleanup(obj) {\n      var tasks = [];\n      var cleaned = !1;\n      var cleanErr;\n      var cleaner = {\n        set: function (name, item) {\n          if (!cleaned) {\n            obj[name] = item;\n            cleaner.register(function () {\n              delete obj[name];\n            });\n          }\n\n          return item;\n        },\n        register: function (method) {\n          var task = once(function () {\n            return method(cleanErr);\n          });\n          cleaned ? method(cleanErr) : tasks.push(task);\n          return {\n            cancel: function () {\n              var index = tasks.indexOf(task);\n              -1 !== index && tasks.splice(index, 1);\n            }\n          };\n        },\n        all: function (err) {\n          cleanErr = err;\n          var results = [];\n          cleaned = !0;\n\n          for (; tasks.length;) {\n            var task = tasks.shift();\n            results.push(task());\n          }\n\n          return promise_ZalgoPromise.all(results).then(src_util_noop);\n        }\n      };\n      return cleaner;\n    }\n\n    function assertExists(name, thing) {\n      if (null == thing) throw new Error(\"Expected \" + name + \" to be present\");\n      return thing;\n    }\n\n    var util_ExtendableError = function (_Error) {\n      _inheritsLoose(ExtendableError, _Error);\n\n      function ExtendableError(message) {\n        var _this6;\n\n        (_this6 = _Error.call(this, message) || this).name = _this6.constructor.name;\n        \"function\" == typeof Error.captureStackTrace ? Error.captureStackTrace(function (self) {\n          if (void 0 === self) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          return self;\n        }(_this6), _this6.constructor) : _this6.stack = new Error(message).stack;\n        return _this6;\n      }\n\n      return ExtendableError;\n    }(wrapNativeSuper_wrapNativeSuper(Error));\n\n    function getBody() {\n      var body = document.body;\n      if (!body) throw new Error(\"Body element not found\");\n      return body;\n    }\n\n    function isDocumentReady() {\n      return Boolean(document.body) && \"complete\" === document.readyState;\n    }\n\n    function isDocumentInteractive() {\n      return Boolean(document.body) && \"interactive\" === document.readyState;\n    }\n\n    function urlEncode(str) {\n      return encodeURIComponent(str);\n    }\n\n    memoize(function () {\n      return new promise_ZalgoPromise(function (resolve) {\n        if (isDocumentReady() || isDocumentInteractive()) return resolve();\n        var interval = setInterval(function () {\n          if (isDocumentReady() || isDocumentInteractive()) {\n            clearInterval(interval);\n            return resolve();\n          }\n        }, 10);\n      });\n    });\n\n    function parseQuery(queryString) {\n      return function (method, logic, args) {\n        void 0 === args && (args = []);\n        var cache = method.__inline_memoize_cache__ = method.__inline_memoize_cache__ || {};\n        var key = serializeArgs(args);\n        return cache.hasOwnProperty(key) ? cache[key] : cache[key] = function () {\n          var params = {};\n          if (!queryString) return params;\n          if (-1 === queryString.indexOf(\"=\")) return params;\n\n          for (var _i2 = 0, _queryString$split2 = queryString.split(\"&\"); _i2 < _queryString$split2.length; _i2++) {\n            var pair = _queryString$split2[_i2];\n            (pair = pair.split(\"=\"))[0] && pair[1] && (params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]));\n          }\n\n          return params;\n        }.apply(void 0, args);\n      }(parseQuery, 0, [queryString]);\n    }\n\n    function extendQuery(originalQuery, props) {\n      void 0 === props && (props = {});\n      return props && Object.keys(props).length ? function (obj) {\n        void 0 === obj && (obj = {});\n        return Object.keys(obj).filter(function (key) {\n          return \"string\" == typeof obj[key] || \"boolean\" == typeof obj[key];\n        }).map(function (key) {\n          var val = obj[key];\n          if (\"string\" != typeof val && \"boolean\" != typeof val) throw new TypeError(\"Invalid type for query\");\n          return urlEncode(key) + \"=\" + urlEncode(val.toString());\n        }).join(\"&\");\n      }(_extends({}, parseQuery(originalQuery), props)) : originalQuery;\n    }\n\n    function appendChild(container, child) {\n      container.appendChild(child);\n    }\n\n    function isElement(element) {\n      return element instanceof window.Element || null !== element && \"object\" == typeof element && 1 === element.nodeType && \"object\" == typeof element.style && \"object\" == typeof element.ownerDocument;\n    }\n\n    function getElementSafe(id, doc) {\n      void 0 === doc && (doc = document);\n      return isElement(id) ? id : \"string\" == typeof id ? doc.querySelector(id) : void 0;\n    }\n\n    function elementReady(id) {\n      return new promise_ZalgoPromise(function (resolve, reject) {\n        var name = stringify(id);\n        var el = getElementSafe(id);\n        if (el) return resolve(el);\n        if (isDocumentReady()) return reject(new Error(\"Document is ready and element \" + name + \" does not exist\"));\n        var interval = setInterval(function () {\n          if (el = getElementSafe(id)) {\n            resolve(el);\n            clearInterval(interval);\n          } else if (isDocumentReady()) {\n            clearInterval(interval);\n            return reject(new Error(\"Document is ready and element \" + name + \" does not exist\"));\n          }\n        }, 10);\n      });\n    }\n\n    var dom_PopupOpenError = function (_ExtendableError) {\n      _inheritsLoose(PopupOpenError, _ExtendableError);\n\n      function PopupOpenError() {\n        return _ExtendableError.apply(this, arguments) || this;\n      }\n\n      return PopupOpenError;\n    }(util_ExtendableError);\n\n    var awaitFrameLoadPromises;\n\n    function awaitFrameLoad(frame) {\n      if ((awaitFrameLoadPromises = awaitFrameLoadPromises || new weakmap_CrossDomainSafeWeakMap()).has(frame)) {\n        var _promise = awaitFrameLoadPromises.get(frame);\n\n        if (_promise) return _promise;\n      }\n\n      var promise = new promise_ZalgoPromise(function (resolve, reject) {\n        frame.addEventListener(\"load\", function () {\n          !function (frame) {\n            !function () {\n              for (var i = 0; i < iframeWindows.length; i++) {\n                var closed = !1;\n\n                try {\n                  closed = iframeWindows[i].closed;\n                } catch (err) {}\n\n                if (closed) {\n                  iframeFrames.splice(i, 1);\n                  iframeWindows.splice(i, 1);\n                }\n              }\n            }();\n            if (frame && frame.contentWindow) try {\n              iframeWindows.push(frame.contentWindow);\n              iframeFrames.push(frame);\n            } catch (err) {}\n          }(frame);\n          resolve(frame);\n        });\n        frame.addEventListener(\"error\", function (err) {\n          frame.contentWindow ? resolve(frame) : reject(err);\n        });\n      });\n      awaitFrameLoadPromises.set(frame, promise);\n      return promise;\n    }\n\n    function awaitFrameWindow(frame) {\n      return awaitFrameLoad(frame).then(function (loadedFrame) {\n        if (!loadedFrame.contentWindow) throw new Error(\"Could not find window in iframe\");\n        return loadedFrame.contentWindow;\n      });\n    }\n\n    function dom_iframe(options, container) {\n      void 0 === options && (options = {});\n      var style = options.style || {};\n\n      var frame = function (tag, options, container) {\n        void 0 === tag && (tag = \"div\");\n        void 0 === options && (options = {});\n        tag = tag.toLowerCase();\n        var element = document.createElement(tag);\n        options.style && extend(element.style, options.style);\n        options.class && (element.className = options.class.join(\" \"));\n        options.id && element.setAttribute(\"id\", options.id);\n        if (options.attributes) for (var _i10 = 0, _Object$keys2 = Object.keys(options.attributes); _i10 < _Object$keys2.length; _i10++) {\n          var key = _Object$keys2[_i10];\n          element.setAttribute(key, options.attributes[key]);\n        }\n        options.styleSheet && function (el, styleText, doc) {\n          void 0 === doc && (doc = window.document);\n          el.styleSheet ? el.styleSheet.cssText = styleText : el.appendChild(doc.createTextNode(styleText));\n        }(element, options.styleSheet);\n\n        if (options.html) {\n          if (\"iframe\" === tag) throw new Error(\"Iframe html can not be written unless container provided and iframe in DOM\");\n          element.innerHTML = options.html;\n        }\n\n        return element;\n      }(\"iframe\", {\n        attributes: _extends({\n          allowTransparency: \"true\"\n        }, options.attributes || {}),\n        style: _extends({\n          backgroundColor: \"transparent\",\n          border: \"none\"\n        }, style),\n        html: options.html,\n        class: options.class\n      });\n\n      var isIE = window.navigator.userAgent.match(/MSIE|Edge/i);\n      frame.hasAttribute(\"id\") || frame.setAttribute(\"id\", uniqueID());\n      awaitFrameLoad(frame);\n      container && function (id, doc) {\n        void 0 === doc && (doc = document);\n        var element = getElementSafe(id, doc);\n        if (element) return element;\n        throw new Error(\"Can not find element: \" + stringify(id));\n      }(container).appendChild(frame);\n      (options.url || isIE) && frame.setAttribute(\"src\", options.url || \"about:blank\");\n      return frame;\n    }\n\n    function addEventListener(obj, event, handler) {\n      obj.addEventListener(event, handler);\n      return {\n        cancel: function () {\n          obj.removeEventListener(event, handler);\n        }\n      };\n    }\n\n    function showElement(element) {\n      element.style.setProperty(\"display\", \"\");\n    }\n\n    function hideElement(element) {\n      element.style.setProperty(\"display\", \"none\", \"important\");\n    }\n\n    function destroyElement(element) {\n      element && element.parentNode && element.parentNode.removeChild(element);\n    }\n\n    function isElementClosed(el) {\n      return !(el && el.parentNode && el.ownerDocument && el.ownerDocument.documentElement && el.ownerDocument.documentElement.contains(el));\n    }\n\n    function onResize(el, handler, _temp) {\n      var _ref2 = void 0 === _temp ? {} : _temp,\n          _ref2$width = _ref2.width,\n          width = void 0 === _ref2$width || _ref2$width,\n          _ref2$height = _ref2.height,\n          height = void 0 === _ref2$height || _ref2$height,\n          _ref2$interval = _ref2.interval,\n          interval = void 0 === _ref2$interval ? 100 : _ref2$interval,\n          _ref2$win = _ref2.win,\n          win = void 0 === _ref2$win ? window : _ref2$win;\n\n      var currentWidth = el.offsetWidth;\n      var currentHeight = el.offsetHeight;\n      var canceled = !1;\n      handler({\n        width: currentWidth,\n        height: currentHeight\n      });\n\n      var check = function () {\n        if (!canceled && function (el) {\n          return Boolean(el.offsetWidth || el.offsetHeight || el.getClientRects().length);\n        }(el)) {\n          var newWidth = el.offsetWidth;\n          var newHeight = el.offsetHeight;\n          (width && newWidth !== currentWidth || height && newHeight !== currentHeight) && handler({\n            width: newWidth,\n            height: newHeight\n          });\n          currentWidth = newWidth;\n          currentHeight = newHeight;\n        }\n      };\n\n      var observer;\n      var timeout;\n      win.addEventListener(\"resize\", check);\n\n      if (void 0 !== win.ResizeObserver) {\n        (observer = new win.ResizeObserver(check)).observe(el);\n        timeout = safeInterval(check, 10 * interval);\n      } else if (void 0 !== win.MutationObserver) {\n        (observer = new win.MutationObserver(check)).observe(el, {\n          attributes: !0,\n          childList: !0,\n          subtree: !0,\n          characterData: !1\n        });\n        timeout = safeInterval(check, 10 * interval);\n      } else timeout = safeInterval(check, interval);\n\n      return {\n        cancel: function () {\n          canceled = !0;\n          observer.disconnect();\n          window.removeEventListener(\"resize\", check);\n          timeout.cancel();\n        }\n      };\n    }\n\n    function isShadowElement(element) {\n      for (; element.parentNode;) element = element.parentNode;\n\n      return \"[object ShadowRoot]\" === element.toString();\n    }\n\n    var currentScript = \"undefined\" != typeof document ? document.currentScript : null;\n    var getCurrentScript = memoize(function () {\n      if (currentScript) return currentScript;\n      if (currentScript = function () {\n        try {\n          var stack = function () {\n            try {\n              throw new Error(\"_\");\n            } catch (err) {\n              return err.stack || \"\";\n            }\n          }();\n\n          var stackDetails = /.*at [^(]*\\((.*):(.+):(.+)\\)$/gi.exec(stack);\n          var scriptLocation = stackDetails && stackDetails[1];\n          if (!scriptLocation) return;\n\n          for (var _i22 = 0, _Array$prototype$slic2 = [].slice.call(document.getElementsByTagName(\"script\")).reverse(); _i22 < _Array$prototype$slic2.length; _i22++) {\n            var script = _Array$prototype$slic2[_i22];\n            if (script.src && script.src === scriptLocation) return script;\n          }\n        } catch (err) {}\n      }()) return currentScript;\n      throw new Error(\"Can not determine current script\");\n    });\n    var currentUID = uniqueID();\n    memoize(function () {\n      var script;\n\n      try {\n        script = getCurrentScript();\n      } catch (err) {\n        return currentUID;\n      }\n\n      var uid = script.getAttribute(\"data-uid\");\n      if (uid && \"string\" == typeof uid) return uid;\n      if ((uid = script.getAttribute(\"data-uid-auto\")) && \"string\" == typeof uid) return uid;\n\n      if (script.src) {\n        var hashedString = function (str) {\n          var hash = \"\";\n\n          for (var i = 0; i < str.length; i++) {\n            var total = str[i].charCodeAt(0) * i;\n            str[i + 1] && (total += str[i + 1].charCodeAt(0) * (i - 1));\n            hash += String.fromCharCode(97 + Math.abs(total) % 26);\n          }\n\n          return hash;\n        }(JSON.stringify({\n          src: script.src,\n          dataset: script.dataset\n        }));\n\n        uid = \"uid_\" + hashedString.slice(hashedString.length - 30);\n      } else uid = uniqueID();\n\n      script.setAttribute(\"data-uid-auto\", uid);\n      return uid;\n    });\n\n    function isPerc(str) {\n      return \"string\" == typeof str && /^[0-9]+%$/.test(str);\n    }\n\n    function toNum(val) {\n      if (\"number\" == typeof val) return val;\n      var match = val.match(/^([0-9]+)(px|%)$/);\n      if (!match) throw new Error(\"Could not match css value from \" + val);\n      return parseInt(match[1], 10);\n    }\n\n    function toPx(val) {\n      return toNum(val) + \"px\";\n    }\n\n    function toCSS(val) {\n      return \"number\" == typeof val ? toPx(val) : isPerc(val) ? val : toPx(val);\n    }\n\n    function normalizeDimension(dim, max) {\n      if (\"number\" == typeof dim) return dim;\n      if (isPerc(dim)) return parseInt(max * toNum(dim) / 100, 10);\n      if (\"string\" == typeof (str = dim) && /^[0-9]+px$/.test(str)) return toNum(dim);\n      var str;\n      throw new Error(\"Can not normalize dimension: \" + dim);\n    }\n\n    function global_getGlobal(win) {\n      void 0 === win && (win = window);\n      var globalKey = \"__post_robot_10_0_44__\";\n      return win !== window ? win[globalKey] : win[globalKey] = win[globalKey] || {};\n    }\n\n    var getObj = function () {\n      return {};\n    };\n\n    function globalStore(key, defStore) {\n      void 0 === key && (key = \"store\");\n      void 0 === defStore && (defStore = getObj);\n      return util_getOrSet(global_getGlobal(), key, function () {\n        var store = defStore();\n        return {\n          has: function (storeKey) {\n            return store.hasOwnProperty(storeKey);\n          },\n          get: function (storeKey, defVal) {\n            return store.hasOwnProperty(storeKey) ? store[storeKey] : defVal;\n          },\n          set: function (storeKey, val) {\n            store[storeKey] = val;\n            return val;\n          },\n          del: function (storeKey) {\n            delete store[storeKey];\n          },\n          getOrSet: function (storeKey, getter) {\n            return util_getOrSet(store, storeKey, getter);\n          },\n          reset: function () {\n            store = defStore();\n          },\n          keys: function () {\n            return Object.keys(store);\n          }\n        };\n      });\n    }\n\n    var WildCard = function () {};\n\n    function getWildcard() {\n      var global = global_getGlobal();\n      global.WINDOW_WILDCARD = global.WINDOW_WILDCARD || new WildCard();\n      return global.WINDOW_WILDCARD;\n    }\n\n    function windowStore(key, defStore) {\n      void 0 === key && (key = \"store\");\n      void 0 === defStore && (defStore = getObj);\n      return globalStore(\"windowStore\").getOrSet(key, function () {\n        var winStore = new weakmap_CrossDomainSafeWeakMap();\n\n        var getStore = function (win) {\n          return winStore.getOrSet(win, defStore);\n        };\n\n        return {\n          has: function (win) {\n            return getStore(win).hasOwnProperty(key);\n          },\n          get: function (win, defVal) {\n            var store = getStore(win);\n            return store.hasOwnProperty(key) ? store[key] : defVal;\n          },\n          set: function (win, val) {\n            getStore(win)[key] = val;\n            return val;\n          },\n          del: function (win) {\n            delete getStore(win)[key];\n          },\n          getOrSet: function (win, getter) {\n            return util_getOrSet(getStore(win), key, getter);\n          }\n        };\n      });\n    }\n\n    function getInstanceID() {\n      return globalStore(\"instance\").getOrSet(\"instanceID\", uniqueID);\n    }\n\n    function resolveHelloPromise(win, _ref) {\n      var domain = _ref.domain;\n      var helloPromises = windowStore(\"helloPromises\");\n      var existingPromise = helloPromises.get(win);\n      existingPromise && existingPromise.resolve({\n        domain: domain\n      });\n      var newPromise = promise_ZalgoPromise.resolve({\n        domain: domain\n      });\n      helloPromises.set(win, newPromise);\n      return newPromise;\n    }\n\n    function sayHello(win, _ref4) {\n      return (0, _ref4.send)(win, \"postrobot_hello\", {\n        instanceID: getInstanceID()\n      }, {\n        domain: \"*\",\n        timeout: -1\n      }).then(function (_ref5) {\n        var origin = _ref5.origin,\n            instanceID = _ref5.data.instanceID;\n        resolveHelloPromise(win, {\n          domain: origin\n        });\n        return {\n          win: win,\n          domain: origin,\n          instanceID: instanceID\n        };\n      });\n    }\n\n    function getWindowInstanceID(win, _ref6) {\n      var send = _ref6.send;\n      return windowStore(\"windowInstanceIDPromises\").getOrSet(win, function () {\n        return sayHello(win, {\n          send: send\n        }).then(function (_ref7) {\n          return _ref7.instanceID;\n        });\n      });\n    }\n\n    function awaitWindowHello(win, timeout, name) {\n      void 0 === timeout && (timeout = 5e3);\n      void 0 === name && (name = \"Window\");\n\n      var promise = function (win) {\n        return windowStore(\"helloPromises\").getOrSet(win, function () {\n          return new promise_ZalgoPromise();\n        });\n      }(win);\n\n      -1 !== timeout && (promise = promise.timeout(timeout, new Error(name + \" did not load after \" + timeout + \"ms\")));\n      return promise;\n    }\n\n    function markWindowKnown(win) {\n      windowStore(\"knownWindows\").set(win, !0);\n    }\n\n    function isSerializedType(item) {\n      return \"object\" == typeof item && null !== item && \"string\" == typeof item.__type__;\n    }\n\n    function determineType(val) {\n      return void 0 === val ? \"undefined\" : null === val ? \"null\" : Array.isArray(val) ? \"array\" : \"function\" == typeof val ? \"function\" : \"object\" == typeof val ? val instanceof Error ? \"error\" : \"function\" == typeof val.then ? \"promise\" : \"[object RegExp]\" === {}.toString.call(val) ? \"regex\" : \"[object Date]\" === {}.toString.call(val) ? \"date\" : \"object\" : \"string\" == typeof val ? \"string\" : \"number\" == typeof val ? \"number\" : \"boolean\" == typeof val ? \"boolean\" : void 0;\n    }\n\n    function serializeType(type, val) {\n      return {\n        __type__: type,\n        __val__: val\n      };\n    }\n\n    var _SERIALIZER;\n\n    var SERIALIZER = ((_SERIALIZER = {}).function = function () {}, _SERIALIZER.error = function (_ref) {\n      return serializeType(\"error\", {\n        message: _ref.message,\n        stack: _ref.stack,\n        code: _ref.code,\n        data: _ref.data\n      });\n    }, _SERIALIZER.promise = function () {}, _SERIALIZER.regex = function (val) {\n      return serializeType(\"regex\", val.source);\n    }, _SERIALIZER.date = function (val) {\n      return serializeType(\"date\", val.toJSON());\n    }, _SERIALIZER.array = function (val) {\n      return val;\n    }, _SERIALIZER.object = function (val) {\n      return val;\n    }, _SERIALIZER.string = function (val) {\n      return val;\n    }, _SERIALIZER.number = function (val) {\n      return val;\n    }, _SERIALIZER.boolean = function (val) {\n      return val;\n    }, _SERIALIZER.null = function (val) {\n      return val;\n    }, _SERIALIZER[void 0] = function (val) {\n      return serializeType(\"undefined\", val);\n    }, _SERIALIZER);\n    var defaultSerializers = {};\n\n    var _DESERIALIZER;\n\n    var DESERIALIZER = ((_DESERIALIZER = {}).function = function () {\n      throw new Error(\"Function serialization is not implemented; nothing to deserialize\");\n    }, _DESERIALIZER.error = function (_ref2) {\n      var stack = _ref2.stack,\n          code = _ref2.code,\n          data = _ref2.data;\n      var error = new Error(_ref2.message);\n      error.code = code;\n      data && (error.data = data);\n      error.stack = stack + \"\\n\\n\" + error.stack;\n      return error;\n    }, _DESERIALIZER.promise = function () {\n      throw new Error(\"Promise serialization is not implemented; nothing to deserialize\");\n    }, _DESERIALIZER.regex = function (val) {\n      return new RegExp(val);\n    }, _DESERIALIZER.date = function (val) {\n      return new Date(val);\n    }, _DESERIALIZER.array = function (val) {\n      return val;\n    }, _DESERIALIZER.object = function (val) {\n      return val;\n    }, _DESERIALIZER.string = function (val) {\n      return val;\n    }, _DESERIALIZER.number = function (val) {\n      return val;\n    }, _DESERIALIZER.boolean = function (val) {\n      return val;\n    }, _DESERIALIZER.null = function (val) {\n      return val;\n    }, _DESERIALIZER[void 0] = function () {}, _DESERIALIZER);\n    var defaultDeserializers = {};\n\n    function needsBridgeForBrowser() {\n      return !!utils_getUserAgent(window).match(/MSIE|trident|edge\\/12|edge\\/13/i);\n    }\n\n    function needsBridgeForWin(win) {\n      return !isSameTopWindow(window, win);\n    }\n\n    function needsBridgeForDomain(domain, win) {\n      if (domain) {\n        if (getDomain() !== getDomainFromUrl(domain)) return !0;\n      } else if (win && !isSameDomain(win)) return !0;\n\n      return !1;\n    }\n\n    function needsBridge(_ref) {\n      var win = _ref.win,\n          domain = _ref.domain;\n      return !(!needsBridgeForBrowser() || domain && !needsBridgeForDomain(domain, win) || win && !needsBridgeForWin(win));\n    }\n\n    function getBridgeName(domain) {\n      return \"__postrobot_bridge___\" + (domain = domain || getDomainFromUrl(domain)).replace(/[^a-zA-Z0-9]+/g, \"_\");\n    }\n\n    function isBridge() {\n      return Boolean(window.name && window.name === getBridgeName(getDomain()));\n    }\n\n    var documentBodyReady = new promise_ZalgoPromise(function (resolve) {\n      if (window.document && window.document.body) return resolve(window.document.body);\n      var interval = setInterval(function () {\n        if (window.document && window.document.body) {\n          clearInterval(interval);\n          return resolve(window.document.body);\n        }\n      }, 10);\n    });\n\n    function registerRemoteWindow(win) {\n      windowStore(\"remoteWindowPromises\").getOrSet(win, function () {\n        return new promise_ZalgoPromise();\n      });\n    }\n\n    function findRemoteWindow(win) {\n      var remoteWinPromise = windowStore(\"remoteWindowPromises\").get(win);\n      if (!remoteWinPromise) throw new Error(\"Remote window promise not found\");\n      return remoteWinPromise;\n    }\n\n    function registerRemoteSendMessage(win, domain, sendMessage) {\n      findRemoteWindow(win).resolve(function (remoteWin, remoteDomain, message) {\n        if (remoteWin !== win) throw new Error(\"Remote window does not match window\");\n        if (!matchDomain(remoteDomain, domain)) throw new Error(\"Remote domain \" + remoteDomain + \" does not match domain \" + domain);\n        sendMessage.fireAndForget(message);\n      });\n    }\n\n    function rejectRemoteSendMessage(win, err) {\n      findRemoteWindow(win).reject(err).catch(src_util_noop);\n    }\n\n    function linkWindow(_ref3) {\n      var win = _ref3.win,\n          name = _ref3.name,\n          domain = _ref3.domain;\n      var popupWindowsByName = globalStore(\"popupWindowsByName\");\n      var popupWindowsByWin = windowStore(\"popupWindowsByWin\");\n\n      for (var _i2 = 0, _popupWindowsByName$k2 = popupWindowsByName.keys(); _i2 < _popupWindowsByName$k2.length; _i2++) {\n        var winName = _popupWindowsByName$k2[_i2];\n\n        var _details = popupWindowsByName.get(winName);\n\n        _details && !isWindowClosed(_details.win) || popupWindowsByName.del(winName);\n      }\n\n      if (isWindowClosed(win)) return {\n        win: win,\n        name: name,\n        domain: domain\n      };\n      var details = popupWindowsByWin.getOrSet(win, function () {\n        return name ? popupWindowsByName.getOrSet(name, function () {\n          return {\n            win: win,\n            name: name\n          };\n        }) : {\n          win: win\n        };\n      });\n      if (details.win && details.win !== win) throw new Error(\"Different window already linked for window: \" + (name || \"undefined\"));\n\n      if (name) {\n        details.name = name;\n        popupWindowsByName.set(name, details);\n      }\n\n      if (domain) {\n        details.domain = domain;\n        registerRemoteWindow(win);\n      }\n\n      popupWindowsByWin.set(win, details);\n      return details;\n    }\n\n    function setupBridge(_ref) {\n      var on = _ref.on,\n          send = _ref.send,\n          receiveMessage = _ref.receiveMessage;\n      windowOpen = window.open, window.open = function (url, name, options, last) {\n        var win = windowOpen.call(this, normalizeMockUrl(url), name, options, last);\n        if (!win) return win;\n        linkWindow({\n          win: win,\n          name: name,\n          domain: url ? getDomainFromUrl(url) : null\n        });\n        return win;\n      };\n      var windowOpen;\n      !function (_ref) {\n        var on = _ref.on,\n            send = _ref.send,\n            receiveMessage = _ref.receiveMessage;\n        var popupWindowsByName = globalStore(\"popupWindowsByName\");\n        on(\"postrobot_open_tunnel\", function (_ref2) {\n          var source = _ref2.source,\n              origin = _ref2.origin,\n              data = _ref2.data;\n          var bridgePromise = globalStore(\"bridges\").get(origin);\n          if (!bridgePromise) throw new Error(\"Can not find bridge promise for domain \" + origin);\n          return bridgePromise.then(function (bridge) {\n            if (source !== bridge) throw new Error(\"Message source does not matched registered bridge for domain \" + origin);\n            if (!data.name) throw new Error(\"Register window expected to be passed window name\");\n            if (!data.sendMessage) throw new Error(\"Register window expected to be passed sendMessage method\");\n            if (!popupWindowsByName.has(data.name)) throw new Error(\"Window with name \" + data.name + \" does not exist, or was not opened by this window\");\n\n            var getWindowDetails = function () {\n              return popupWindowsByName.get(data.name);\n            };\n\n            if (!getWindowDetails().domain) throw new Error(\"We do not have a registered domain for window \" + data.name);\n            if (getWindowDetails().domain !== origin) throw new Error(\"Message origin \" + origin + \" does not matched registered window origin \" + (getWindowDetails().domain || \"unknown\"));\n            registerRemoteSendMessage(getWindowDetails().win, origin, data.sendMessage);\n            return {\n              sendMessage: function (message) {\n                if (window && !window.closed && getWindowDetails()) {\n                  var domain = getWindowDetails().domain;\n                  if (domain) try {\n                    receiveMessage({\n                      data: message,\n                      origin: domain,\n                      source: getWindowDetails().win\n                    }, {\n                      on: on,\n                      send: send\n                    });\n                  } catch (err) {\n                    promise_ZalgoPromise.reject(err);\n                  }\n                }\n              }\n            };\n          });\n        });\n      }({\n        on: on,\n        send: send,\n        receiveMessage: receiveMessage\n      });\n      !function (_ref2) {\n        var send = _ref2.send;\n\n        global_getGlobal(window).openTunnelToParent = function (_ref3) {\n          var name = _ref3.name,\n              source = _ref3.source,\n              canary = _ref3.canary,\n              sendMessage = _ref3.sendMessage;\n          var tunnelWindows = globalStore(\"tunnelWindows\");\n          var parentWindow = utils_getParent(window);\n          if (!parentWindow) throw new Error(\"No parent window found to open tunnel to\");\n\n          var id = function (_ref) {\n            var name = _ref.name,\n                source = _ref.source,\n                canary = _ref.canary,\n                sendMessage = _ref.sendMessage;\n            !function () {\n              var tunnelWindows = globalStore(\"tunnelWindows\");\n\n              for (var _i2 = 0, _tunnelWindows$keys2 = tunnelWindows.keys(); _i2 < _tunnelWindows$keys2.length; _i2++) {\n                var key = _tunnelWindows$keys2[_i2];\n                isWindowClosed(tunnelWindows[key].source) && tunnelWindows.del(key);\n              }\n            }();\n            var id = uniqueID();\n            globalStore(\"tunnelWindows\").set(id, {\n              name: name,\n              source: source,\n              canary: canary,\n              sendMessage: sendMessage\n            });\n            return id;\n          }({\n            name: name,\n            source: source,\n            canary: canary,\n            sendMessage: sendMessage\n          });\n\n          return send(parentWindow, \"postrobot_open_tunnel\", {\n            name: name,\n            sendMessage: function () {\n              var tunnelWindow = tunnelWindows.get(id);\n\n              if (tunnelWindow && tunnelWindow.source && !isWindowClosed(tunnelWindow.source)) {\n                try {\n                  tunnelWindow.canary();\n                } catch (err) {\n                  return;\n                }\n\n                tunnelWindow.sendMessage.apply(this, arguments);\n              }\n            }\n          }, {\n            domain: \"*\"\n          });\n        };\n      }({\n        send: send\n      });\n      !function (_ref) {\n        var on = _ref.on,\n            send = _ref.send,\n            receiveMessage = _ref.receiveMessage;\n        promise_ZalgoPromise.try(function () {\n          var opener = getOpener(window);\n\n          if (opener && needsBridge({\n            win: opener\n          })) {\n            registerRemoteWindow(opener);\n            return (win = opener, windowStore(\"remoteBridgeAwaiters\").getOrSet(win, function () {\n              return promise_ZalgoPromise.try(function () {\n                var frame = getFrameByName(win, getBridgeName(getDomain()));\n                if (frame) return isSameDomain(frame) && global_getGlobal(assertSameDomain(frame)) ? frame : new promise_ZalgoPromise(function (resolve) {\n                  var interval;\n                  var timeout;\n                  interval = setInterval(function () {\n                    if (frame && isSameDomain(frame) && global_getGlobal(assertSameDomain(frame))) {\n                      clearInterval(interval);\n                      clearTimeout(timeout);\n                      return resolve(frame);\n                    }\n                  }, 100);\n                  timeout = setTimeout(function () {\n                    clearInterval(interval);\n                    return resolve();\n                  }, 2e3);\n                });\n              });\n            })).then(function (bridge) {\n              return bridge ? window.name ? global_getGlobal(assertSameDomain(bridge)).openTunnelToParent({\n                name: window.name,\n                source: window,\n                canary: function () {},\n                sendMessage: function (message) {\n                  try {\n                    window;\n                  } catch (err) {\n                    return;\n                  }\n\n                  if (window && !window.closed) try {\n                    receiveMessage({\n                      data: message,\n                      origin: this.origin,\n                      source: this.source\n                    }, {\n                      on: on,\n                      send: send\n                    });\n                  } catch (err) {\n                    promise_ZalgoPromise.reject(err);\n                  }\n                }\n              }).then(function (_ref2) {\n                var source = _ref2.source,\n                    origin = _ref2.origin,\n                    data = _ref2.data;\n                if (source !== opener) throw new Error(\"Source does not match opener\");\n                registerRemoteSendMessage(source, origin, data.sendMessage);\n              }).catch(function (err) {\n                rejectRemoteSendMessage(opener, err);\n                throw err;\n              }) : rejectRemoteSendMessage(opener, new Error(\"Can not register with opener: window does not have a name\")) : rejectRemoteSendMessage(opener, new Error(\"Can not register with opener: no bridge found in opener\"));\n            });\n            var win;\n          }\n        });\n      }({\n        on: on,\n        send: send,\n        receiveMessage: receiveMessage\n      });\n    }\n\n    function cleanupProxyWindows() {\n      var idToProxyWindow = globalStore(\"idToProxyWindow\");\n\n      for (var _i2 = 0, _idToProxyWindow$keys2 = idToProxyWindow.keys(); _i2 < _idToProxyWindow$keys2.length; _i2++) {\n        var id = _idToProxyWindow$keys2[_i2];\n        idToProxyWindow.get(id).shouldClean() && idToProxyWindow.del(id);\n      }\n    }\n\n    function getSerializedWindow(winPromise, _ref) {\n      var send = _ref.send,\n          _ref$id = _ref.id,\n          id = void 0 === _ref$id ? uniqueID() : _ref$id;\n      var windowNamePromise = winPromise.then(function (win) {\n        if (isSameDomain(win)) return assertSameDomain(win).name;\n      });\n      var windowTypePromise = winPromise.then(function (window) {\n        if (isWindowClosed(window)) throw new Error(\"Window is closed, can not determine type\");\n        return getOpener(window) ? WINDOW_TYPE.POPUP : WINDOW_TYPE.IFRAME;\n      });\n      windowNamePromise.catch(src_util_noop);\n      windowTypePromise.catch(src_util_noop);\n\n      var getName = function () {\n        return winPromise.then(function (win) {\n          if (!isWindowClosed(win)) return isSameDomain(win) ? assertSameDomain(win).name : windowNamePromise;\n        });\n      };\n\n      return {\n        id: id,\n        getType: function () {\n          return windowTypePromise;\n        },\n        getInstanceID: memoizePromise(function () {\n          return winPromise.then(function (win) {\n            return getWindowInstanceID(win, {\n              send: send\n            });\n          });\n        }),\n        close: function () {\n          return winPromise.then(closeWindow);\n        },\n        getName: getName,\n        focus: function () {\n          return winPromise.then(function (win) {\n            win.focus();\n          });\n        },\n        isClosed: function () {\n          return winPromise.then(function (win) {\n            return isWindowClosed(win);\n          });\n        },\n        setLocation: function (href, opts) {\n          void 0 === opts && (opts = {});\n          return winPromise.then(function (win) {\n            var domain = window.location.protocol + \"//\" + window.location.host;\n            var _opts$method = opts.method,\n                method = void 0 === _opts$method ? \"get\" : _opts$method,\n                body = opts.body;\n            if (0 === href.indexOf(\"/\")) href = \"\" + domain + href;else if (!href.match(/^https?:\\/\\//) && 0 !== href.indexOf(domain)) throw new Error(\"Expected url to be http or https url, or absolute path, got \" + JSON.stringify(href));\n            if (\"post\" === method) return getName().then(function (name) {\n              if (!name) throw new Error(\"Can not post to window without target name\");\n              !function (_ref3) {\n                var url = _ref3.url,\n                    target = _ref3.target,\n                    body = _ref3.body,\n                    _ref3$method = _ref3.method,\n                    method = void 0 === _ref3$method ? \"post\" : _ref3$method;\n                var form = document.createElement(\"form\");\n                form.setAttribute(\"target\", target);\n                form.setAttribute(\"method\", method);\n                form.setAttribute(\"action\", url);\n                form.style.display = \"none\";\n                if (body) for (var _i24 = 0, _Object$keys4 = Object.keys(body); _i24 < _Object$keys4.length; _i24++) {\n                  var _body$key;\n\n                  var key = _Object$keys4[_i24];\n                  var input = document.createElement(\"input\");\n                  input.setAttribute(\"name\", key);\n                  input.setAttribute(\"value\", null == (_body$key = body[key]) ? void 0 : _body$key.toString());\n                  form.appendChild(input);\n                }\n                getBody().appendChild(form);\n                form.submit();\n                getBody().removeChild(form);\n              }({\n                url: href,\n                target: name,\n                method: method,\n                body: body\n              });\n            });\n            if (\"get\" !== method) throw new Error(\"Unsupported method: \" + method);\n            if (isSameDomain(win)) try {\n              if (win.location && \"function\" == typeof win.location.replace) {\n                win.location.replace(href);\n                return;\n              }\n            } catch (err) {}\n            win.location = href;\n          });\n        },\n        setName: function (name) {\n          return winPromise.then(function (win) {\n            linkWindow({\n              win: win,\n              name: name\n            });\n            var sameDomain = isSameDomain(win);\n            var frame = getFrameForWindow(win);\n            if (!sameDomain) throw new Error(\"Can not set name for cross-domain window: \" + name);\n            assertSameDomain(win).name = name;\n            frame && frame.setAttribute(\"name\", name);\n            windowNamePromise = promise_ZalgoPromise.resolve(name);\n          });\n        }\n      };\n    }\n\n    var window_ProxyWindow = function () {\n      function ProxyWindow(_ref2) {\n        var send = _ref2.send,\n            win = _ref2.win,\n            serializedWindow = _ref2.serializedWindow;\n        this.id = void 0;\n        this.isProxyWindow = !0;\n        this.serializedWindow = void 0;\n        this.actualWindow = void 0;\n        this.actualWindowPromise = void 0;\n        this.send = void 0;\n        this.name = void 0;\n        this.actualWindowPromise = new promise_ZalgoPromise();\n        this.serializedWindow = serializedWindow || getSerializedWindow(this.actualWindowPromise, {\n          send: send\n        });\n        globalStore(\"idToProxyWindow\").set(this.getID(), this);\n        win && this.setWindow(win, {\n          send: send\n        });\n      }\n\n      var _proto = ProxyWindow.prototype;\n\n      _proto.getID = function () {\n        return this.serializedWindow.id;\n      };\n\n      _proto.getType = function () {\n        return this.serializedWindow.getType();\n      };\n\n      _proto.isPopup = function () {\n        return this.getType().then(function (type) {\n          return type === WINDOW_TYPE.POPUP;\n        });\n      };\n\n      _proto.setLocation = function (href, opts) {\n        var _this = this;\n\n        return this.serializedWindow.setLocation(href, opts).then(function () {\n          return _this;\n        });\n      };\n\n      _proto.getName = function () {\n        return this.serializedWindow.getName();\n      };\n\n      _proto.setName = function (name) {\n        var _this2 = this;\n\n        return this.serializedWindow.setName(name).then(function () {\n          return _this2;\n        });\n      };\n\n      _proto.close = function () {\n        var _this3 = this;\n\n        return this.serializedWindow.close().then(function () {\n          return _this3;\n        });\n      };\n\n      _proto.focus = function () {\n        var _this4 = this;\n\n        var isPopupPromise = this.isPopup();\n        var getNamePromise = this.getName();\n        var reopenPromise = promise_ZalgoPromise.hash({\n          isPopup: isPopupPromise,\n          name: getNamePromise\n        }).then(function (_ref3) {\n          var name = _ref3.name;\n          _ref3.isPopup && name && window.open(\"\", name);\n        });\n        var focusPromise = this.serializedWindow.focus();\n        return promise_ZalgoPromise.all([reopenPromise, focusPromise]).then(function () {\n          return _this4;\n        });\n      };\n\n      _proto.isClosed = function () {\n        return this.serializedWindow.isClosed();\n      };\n\n      _proto.getWindow = function () {\n        return this.actualWindow;\n      };\n\n      _proto.setWindow = function (win, _ref4) {\n        var send = _ref4.send;\n        this.actualWindow = win;\n        this.actualWindowPromise.resolve(this.actualWindow);\n        this.serializedWindow = getSerializedWindow(this.actualWindowPromise, {\n          send: send,\n          id: this.getID()\n        });\n        windowStore(\"winToProxyWindow\").set(win, this);\n      };\n\n      _proto.awaitWindow = function () {\n        return this.actualWindowPromise;\n      };\n\n      _proto.matchWindow = function (win, _ref5) {\n        var _this5 = this;\n\n        var send = _ref5.send;\n        return promise_ZalgoPromise.try(function () {\n          return _this5.actualWindow ? win === _this5.actualWindow : promise_ZalgoPromise.hash({\n            proxyInstanceID: _this5.getInstanceID(),\n            knownWindowInstanceID: getWindowInstanceID(win, {\n              send: send\n            })\n          }).then(function (_ref6) {\n            var match = _ref6.proxyInstanceID === _ref6.knownWindowInstanceID;\n            match && _this5.setWindow(win, {\n              send: send\n            });\n            return match;\n          });\n        });\n      };\n\n      _proto.unwrap = function () {\n        return this.actualWindow || this;\n      };\n\n      _proto.getInstanceID = function () {\n        return this.serializedWindow.getInstanceID();\n      };\n\n      _proto.shouldClean = function () {\n        return Boolean(this.actualWindow && isWindowClosed(this.actualWindow));\n      };\n\n      _proto.serialize = function () {\n        return this.serializedWindow;\n      };\n\n      ProxyWindow.unwrap = function (win) {\n        return ProxyWindow.isProxyWindow(win) ? win.unwrap() : win;\n      };\n\n      ProxyWindow.serialize = function (win, _ref7) {\n        var send = _ref7.send;\n        cleanupProxyWindows();\n        return ProxyWindow.toProxyWindow(win, {\n          send: send\n        }).serialize();\n      };\n\n      ProxyWindow.deserialize = function (serializedWindow, _ref8) {\n        var send = _ref8.send;\n        cleanupProxyWindows();\n        return globalStore(\"idToProxyWindow\").get(serializedWindow.id) || new ProxyWindow({\n          serializedWindow: serializedWindow,\n          send: send\n        });\n      };\n\n      ProxyWindow.isProxyWindow = function (obj) {\n        return Boolean(obj && !isWindow(obj) && obj.isProxyWindow);\n      };\n\n      ProxyWindow.toProxyWindow = function (win, _ref9) {\n        var send = _ref9.send;\n        cleanupProxyWindows();\n        if (ProxyWindow.isProxyWindow(win)) return win;\n        var actualWindow = win;\n        return windowStore(\"winToProxyWindow\").get(actualWindow) || new ProxyWindow({\n          win: actualWindow,\n          send: send\n        });\n      };\n\n      return ProxyWindow;\n    }();\n\n    function addMethod(id, val, name, source, domain) {\n      var methodStore = windowStore(\"methodStore\");\n      var proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n      if (window_ProxyWindow.isProxyWindow(source)) proxyWindowMethods.set(id, {\n        val: val,\n        name: name,\n        domain: domain,\n        source: source\n      });else {\n        proxyWindowMethods.del(id);\n        methodStore.getOrSet(source, function () {\n          return {};\n        })[id] = {\n          domain: domain,\n          name: name,\n          val: val,\n          source: source\n        };\n      }\n    }\n\n    function lookupMethod(source, id) {\n      var methodStore = windowStore(\"methodStore\");\n      var proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n      return methodStore.getOrSet(source, function () {\n        return {};\n      })[id] || proxyWindowMethods.get(id);\n    }\n\n    function function_serializeFunction(destination, domain, val, key, _ref3) {\n      on = (_ref = {\n        on: _ref3.on,\n        send: _ref3.send\n      }).on, send = _ref.send, globalStore(\"builtinListeners\").getOrSet(\"functionCalls\", function () {\n        return on(\"postrobot_method\", {\n          domain: \"*\"\n        }, function (_ref2) {\n          var source = _ref2.source,\n              origin = _ref2.origin,\n              data = _ref2.data;\n          var id = data.id,\n              name = data.name;\n          var meth = lookupMethod(source, id);\n          if (!meth) throw new Error(\"Could not find method '\" + name + \"' with id: \" + data.id + \" in \" + getDomain(window));\n          var methodSource = meth.source,\n              domain = meth.domain,\n              val = meth.val;\n          return promise_ZalgoPromise.try(function () {\n            if (!matchDomain(domain, origin)) throw new Error(\"Method '\" + data.name + \"' domain \" + JSON.stringify(util_isRegex(meth.domain) ? meth.domain.source : meth.domain) + \" does not match origin \" + origin + \" in \" + getDomain(window));\n            if (window_ProxyWindow.isProxyWindow(methodSource)) return methodSource.matchWindow(source, {\n              send: send\n            }).then(function (match) {\n              if (!match) throw new Error(\"Method call '\" + data.name + \"' failed - proxy window does not match source in \" + getDomain(window));\n            });\n          }).then(function () {\n            return val.apply({\n              source: source,\n              origin: origin\n            }, data.args);\n          }, function (err) {\n            return promise_ZalgoPromise.try(function () {\n              if (val.onError) return val.onError(err);\n            }).then(function () {\n              err.stack && (err.stack = \"Remote call to \" + name + \"(\" + function (args) {\n                void 0 === args && (args = []);\n                return arrayFrom(args).map(function (arg) {\n                  return \"string\" == typeof arg ? \"'\" + arg + \"'\" : void 0 === arg ? \"undefined\" : null === arg ? \"null\" : \"boolean\" == typeof arg ? arg.toString() : Array.isArray(arg) ? \"[ ... ]\" : \"object\" == typeof arg ? \"{ ... }\" : \"function\" == typeof arg ? \"() => { ... }\" : \"<\" + typeof arg + \">\";\n                }).join(\", \");\n              }(data.args) + \") failed\\n\\n\" + err.stack);\n              throw err;\n            });\n          }).then(function (result) {\n            return {\n              result: result,\n              id: id,\n              name: name\n            };\n          });\n        });\n      });\n\n      var _ref, on, send;\n\n      var id = val.__id__ || uniqueID();\n      destination = window_ProxyWindow.unwrap(destination);\n      var name = val.__name__ || val.name || key;\n      \"string\" == typeof name && \"function\" == typeof name.indexOf && 0 === name.indexOf(\"anonymous::\") && (name = name.replace(\"anonymous::\", key + \"::\"));\n\n      if (window_ProxyWindow.isProxyWindow(destination)) {\n        addMethod(id, val, name, destination, domain);\n        destination.awaitWindow().then(function (win) {\n          addMethod(id, val, name, win, domain);\n        });\n      } else addMethod(id, val, name, destination, domain);\n\n      return serializeType(\"cross_domain_function\", {\n        id: id,\n        name: name\n      });\n    }\n\n    function serializeMessage(destination, domain, obj, _ref) {\n      var _serialize;\n\n      var on = _ref.on,\n          send = _ref.send;\n      return function (obj, serializers) {\n        void 0 === serializers && (serializers = defaultSerializers);\n        var result = JSON.stringify(obj, function (key) {\n          var val = this[key];\n          if (isSerializedType(this)) return val;\n          var type = determineType(val);\n          if (!type) return val;\n          var serializer = serializers[type] || SERIALIZER[type];\n          return serializer ? serializer(val, key) : val;\n        });\n        return void 0 === result ? \"undefined\" : result;\n      }(obj, ((_serialize = {}).promise = function (val, key) {\n        return function (destination, domain, val, key, _ref) {\n          return serializeType(\"cross_domain_zalgo_promise\", {\n            then: function_serializeFunction(destination, domain, function (resolve, reject) {\n              return val.then(resolve, reject);\n            }, key, {\n              on: _ref.on,\n              send: _ref.send\n            })\n          });\n        }(destination, domain, val, key, {\n          on: on,\n          send: send\n        });\n      }, _serialize.function = function (val, key) {\n        return function_serializeFunction(destination, domain, val, key, {\n          on: on,\n          send: send\n        });\n      }, _serialize.object = function (val) {\n        return isWindow(val) || window_ProxyWindow.isProxyWindow(val) ? serializeType(\"cross_domain_window\", window_ProxyWindow.serialize(val, {\n          send: send\n        })) : val;\n      }, _serialize));\n    }\n\n    function deserializeMessage(source, origin, message, _ref2) {\n      var _deserialize;\n\n      var send = _ref2.send;\n      return function (str, deserializers) {\n        void 0 === deserializers && (deserializers = defaultDeserializers);\n        if (\"undefined\" !== str) return JSON.parse(str, function (key, val) {\n          if (isSerializedType(this)) return val;\n          var type;\n          var value;\n\n          if (isSerializedType(val)) {\n            type = val.__type__;\n            value = val.__val__;\n          } else {\n            type = determineType(val);\n            value = val;\n          }\n\n          if (!type) return value;\n          var deserializer = deserializers[type] || DESERIALIZER[type];\n          return deserializer ? deserializer(value, key) : value;\n        });\n      }(message, ((_deserialize = {}).cross_domain_zalgo_promise = function (serializedPromise) {\n        return function (source, origin, _ref2) {\n          return new promise_ZalgoPromise(_ref2.then);\n        }(0, 0, serializedPromise);\n      }, _deserialize.cross_domain_function = function (serializedFunction) {\n        return function (source, origin, _ref4, _ref5) {\n          var id = _ref4.id,\n              name = _ref4.name;\n          var send = _ref5.send;\n\n          var getDeserializedFunction = function (opts) {\n            void 0 === opts && (opts = {});\n\n            function crossDomainFunctionWrapper() {\n              var _arguments = arguments;\n              return window_ProxyWindow.toProxyWindow(source, {\n                send: send\n              }).awaitWindow().then(function (win) {\n                var meth = lookupMethod(win, id);\n                if (meth && meth.val !== crossDomainFunctionWrapper) return meth.val.apply({\n                  source: window,\n                  origin: getDomain()\n                }, _arguments);\n\n                var _args = [].slice.call(_arguments);\n\n                return opts.fireAndForget ? send(win, \"postrobot_method\", {\n                  id: id,\n                  name: name,\n                  args: _args\n                }, {\n                  domain: origin,\n                  fireAndForget: !0\n                }) : send(win, \"postrobot_method\", {\n                  id: id,\n                  name: name,\n                  args: _args\n                }, {\n                  domain: origin,\n                  fireAndForget: !1\n                }).then(function (res) {\n                  return res.data.result;\n                });\n              }).catch(function (err) {\n                throw err;\n              });\n            }\n\n            crossDomainFunctionWrapper.__name__ = name;\n            crossDomainFunctionWrapper.__origin__ = origin;\n            crossDomainFunctionWrapper.__source__ = source;\n            crossDomainFunctionWrapper.__id__ = id;\n            crossDomainFunctionWrapper.origin = origin;\n            return crossDomainFunctionWrapper;\n          };\n\n          var crossDomainFunctionWrapper = getDeserializedFunction();\n          crossDomainFunctionWrapper.fireAndForget = getDeserializedFunction({\n            fireAndForget: !0\n          });\n          return crossDomainFunctionWrapper;\n        }(source, origin, serializedFunction, {\n          send: send\n        });\n      }, _deserialize.cross_domain_window = function (serializedWindow) {\n        return window_ProxyWindow.deserialize(serializedWindow, {\n          send: send\n        });\n      }, _deserialize));\n    }\n\n    var SEND_MESSAGE_STRATEGIES = {};\n\n    SEND_MESSAGE_STRATEGIES.postrobot_post_message = function (win, serializedMessage, domain) {\n      0 === domain.indexOf(\"file:\") && (domain = \"*\");\n      win.postMessage(serializedMessage, domain);\n    };\n\n    SEND_MESSAGE_STRATEGIES.postrobot_bridge = function (win, serializedMessage, domain) {\n      if (!needsBridgeForBrowser() && !isBridge()) throw new Error(\"Bridge not needed for browser\");\n      if (isSameDomain(win)) throw new Error(\"Post message through bridge disabled between same domain windows\");\n      if (!1 !== isSameTopWindow(window, win)) throw new Error(\"Can only use bridge to communicate between two different windows, not between frames\");\n      !function (win, domain, message) {\n        var messagingChild = isOpener(window, win);\n        var messagingParent = isOpener(win, window);\n        if (!messagingChild && !messagingParent) throw new Error(\"Can only send messages to and from parent and popup windows\");\n        findRemoteWindow(win).then(function (sendMessage) {\n          return sendMessage(win, domain, message);\n        });\n      }(win, domain, serializedMessage);\n    };\n\n    SEND_MESSAGE_STRATEGIES.postrobot_global = function (win, serializedMessage) {\n      if (!utils_getUserAgent(window).match(/MSIE|rv:11|trident|edge\\/12|edge\\/13/i)) throw new Error(\"Global messaging not needed for browser\");\n      if (!isSameDomain(win)) throw new Error(\"Post message through global disabled between different domain windows\");\n      if (!1 !== isSameTopWindow(window, win)) throw new Error(\"Can only use global to communicate between two different windows, not between frames\");\n      var foreignGlobal = global_getGlobal(win);\n      if (!foreignGlobal) throw new Error(\"Can not find postRobot global on foreign window\");\n      foreignGlobal.receiveMessage({\n        source: window,\n        origin: getDomain(),\n        data: serializedMessage\n      });\n    };\n\n    function send_sendMessage(win, domain, message, _ref2) {\n      var on = _ref2.on,\n          send = _ref2.send;\n      return promise_ZalgoPromise.try(function () {\n        var domainBuffer = windowStore().getOrSet(win, function () {\n          return {};\n        });\n        domainBuffer.buffer = domainBuffer.buffer || [];\n        domainBuffer.buffer.push(message);\n        domainBuffer.flush = domainBuffer.flush || promise_ZalgoPromise.flush().then(function () {\n          if (isWindowClosed(win)) throw new Error(\"Window is closed\");\n          var serializedMessage = serializeMessage(win, domain, ((_ref = {}).__post_robot_10_0_44__ = domainBuffer.buffer || [], _ref), {\n            on: on,\n            send: send\n          });\n\n          var _ref;\n\n          delete domainBuffer.buffer;\n          var strategies = Object.keys(SEND_MESSAGE_STRATEGIES);\n          var errors = [];\n\n          for (var _i2 = 0; _i2 < strategies.length; _i2++) {\n            var strategyName = strategies[_i2];\n\n            try {\n              SEND_MESSAGE_STRATEGIES[strategyName](win, serializedMessage, domain);\n            } catch (err) {\n              errors.push(err);\n            }\n          }\n\n          if (errors.length === strategies.length) throw new Error(\"All post-robot messaging strategies failed:\\n\\n\" + errors.map(function (err, i) {\n            return i + \". \" + stringifyError(err);\n          }).join(\"\\n\\n\"));\n        });\n        return domainBuffer.flush.then(function () {\n          delete domainBuffer.flush;\n        });\n      }).then(src_util_noop);\n    }\n\n    function getResponseListener(hash) {\n      return globalStore(\"responseListeners\").get(hash);\n    }\n\n    function deleteResponseListener(hash) {\n      globalStore(\"responseListeners\").del(hash);\n    }\n\n    function isResponseListenerErrored(hash) {\n      return globalStore(\"erroredResponseListeners\").has(hash);\n    }\n\n    function getRequestListener(_ref) {\n      var name = _ref.name,\n          win = _ref.win,\n          domain = _ref.domain;\n      var requestListeners = windowStore(\"requestListeners\");\n      \"*\" === win && (win = null);\n      \"*\" === domain && (domain = null);\n      if (!name) throw new Error(\"Name required to get request listener\");\n\n      for (var _i4 = 0, _ref3 = [win, getWildcard()]; _i4 < _ref3.length; _i4++) {\n        var winQualifier = _ref3[_i4];\n\n        if (winQualifier) {\n          var nameListeners = requestListeners.get(winQualifier);\n\n          if (nameListeners) {\n            var domainListeners = nameListeners[name];\n\n            if (domainListeners) {\n              if (domain && \"string\" == typeof domain) {\n                if (domainListeners[domain]) return domainListeners[domain];\n                if (domainListeners.__domain_regex__) for (var _i6 = 0, _domainListeners$__DO2 = domainListeners.__domain_regex__; _i6 < _domainListeners$__DO2.length; _i6++) {\n                  var _domainListeners$__DO3 = _domainListeners$__DO2[_i6],\n                      listener = _domainListeners$__DO3.listener;\n                  if (matchDomain(_domainListeners$__DO3.regex, domain)) return listener;\n                }\n              }\n\n              if (domainListeners[\"*\"]) return domainListeners[\"*\"];\n            }\n          }\n        }\n      }\n    }\n\n    function handleRequest(source, origin, message, _ref) {\n      var on = _ref.on,\n          send = _ref.send;\n      var options = getRequestListener({\n        name: message.name,\n        win: source,\n        domain: origin\n      });\n      var logName = \"postrobot_method\" === message.name && message.data && \"string\" == typeof message.data.name ? message.data.name + \"()\" : message.name;\n\n      function sendResponse(ack, data, error) {\n        return promise_ZalgoPromise.flush().then(function () {\n          if (!message.fireAndForget && !isWindowClosed(source)) try {\n            return send_sendMessage(source, origin, {\n              id: uniqueID(),\n              origin: getDomain(window),\n              type: \"postrobot_message_response\",\n              hash: message.hash,\n              name: message.name,\n              ack: ack,\n              data: data,\n              error: error\n            }, {\n              on: on,\n              send: send\n            });\n          } catch (err) {\n            throw new Error(\"Send response message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n          }\n        });\n      }\n\n      return promise_ZalgoPromise.all([promise_ZalgoPromise.flush().then(function () {\n        if (!message.fireAndForget && !isWindowClosed(source)) try {\n          return send_sendMessage(source, origin, {\n            id: uniqueID(),\n            origin: getDomain(window),\n            type: \"postrobot_message_ack\",\n            hash: message.hash,\n            name: message.name\n          }, {\n            on: on,\n            send: send\n          });\n        } catch (err) {\n          throw new Error(\"Send ack message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n        }\n      }), promise_ZalgoPromise.try(function () {\n        if (!options) throw new Error(\"No handler found for post message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n        if (!matchDomain(options.domain, origin)) throw new Error(\"Request origin \" + origin + \" does not match domain \" + options.domain.toString());\n        return options.handler({\n          source: source,\n          origin: origin,\n          data: message.data\n        });\n      }).then(function (data) {\n        return sendResponse(\"success\", data);\n      }, function (error) {\n        return sendResponse(\"error\", null, error);\n      })]).then(src_util_noop).catch(function (err) {\n        if (options && options.handleError) return options.handleError(err);\n        throw err;\n      });\n    }\n\n    function handleAck(source, origin, message) {\n      if (!isResponseListenerErrored(message.hash)) {\n        var options = getResponseListener(message.hash);\n        if (!options) throw new Error(\"No handler found for post message ack for message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\n        try {\n          if (!matchDomain(options.domain, origin)) throw new Error(\"Ack origin \" + origin + \" does not match domain \" + options.domain.toString());\n          if (source !== options.win) throw new Error(\"Ack source does not match registered window\");\n        } catch (err) {\n          options.promise.reject(err);\n        }\n\n        options.ack = !0;\n      }\n    }\n\n    function handleResponse(source, origin, message) {\n      if (!isResponseListenerErrored(message.hash)) {\n        var options = getResponseListener(message.hash);\n        if (!options) throw new Error(\"No handler found for post message response for message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n        if (!matchDomain(options.domain, origin)) throw new Error(\"Response origin \" + origin + \" does not match domain \" + (pattern = options.domain, Array.isArray(pattern) ? \"(\" + pattern.join(\" | \") + \")\" : isRegex(pattern) ? \"RegExp(\" + pattern.toString() + \")\" : pattern.toString()));\n        var pattern;\n        if (source !== options.win) throw new Error(\"Response source does not match registered window\");\n        deleteResponseListener(message.hash);\n        \"error\" === message.ack ? options.promise.reject(message.error) : \"success\" === message.ack && options.promise.resolve({\n          source: source,\n          origin: origin,\n          data: message.data\n        });\n      }\n    }\n\n    function receive_receiveMessage(event, _ref2) {\n      var on = _ref2.on,\n          send = _ref2.send;\n      var receivedMessages = globalStore(\"receivedMessages\");\n\n      try {\n        if (!window || window.closed || !event.source) return;\n      } catch (err) {\n        return;\n      }\n\n      var source = event.source,\n          origin = event.origin;\n\n      var messages = function (message, source, origin, _ref) {\n        var on = _ref.on,\n            send = _ref.send;\n        var parsedMessage;\n\n        try {\n          parsedMessage = deserializeMessage(source, origin, message, {\n            on: on,\n            send: send\n          });\n        } catch (err) {\n          return;\n        }\n\n        if (parsedMessage && \"object\" == typeof parsedMessage && null !== parsedMessage) {\n          var parseMessages = parsedMessage.__post_robot_10_0_44__;\n          if (Array.isArray(parseMessages)) return parseMessages;\n        }\n      }(event.data, source, origin, {\n        on: on,\n        send: send\n      });\n\n      if (messages) {\n        markWindowKnown(source);\n\n        for (var _i2 = 0; _i2 < messages.length; _i2++) {\n          var message = messages[_i2];\n          if (receivedMessages.has(message.id)) return;\n          receivedMessages.set(message.id, !0);\n          if (isWindowClosed(source) && !message.fireAndForget) return;\n          0 === message.origin.indexOf(\"file:\") && (origin = \"file://\");\n\n          try {\n            \"postrobot_message_request\" === message.type ? handleRequest(source, origin, message, {\n              on: on,\n              send: send\n            }) : \"postrobot_message_response\" === message.type ? handleResponse(source, origin, message) : \"postrobot_message_ack\" === message.type && handleAck(source, origin, message);\n          } catch (err) {\n            setTimeout(function () {\n              throw err;\n            }, 0);\n          }\n        }\n      }\n    }\n\n    function on_on(name, options, handler) {\n      if (!name) throw new Error(\"Expected name\");\n\n      if (\"function\" == typeof (options = options || {})) {\n        handler = options;\n        options = {};\n      }\n\n      if (!handler) throw new Error(\"Expected handler\");\n      (options = options || {}).name = name;\n      options.handler = handler || options.handler;\n      var win = options.window;\n      var domain = options.domain;\n\n      var requestListener = function addRequestListener(_ref4, listener) {\n        var name = _ref4.name,\n            win = _ref4.win,\n            domain = _ref4.domain;\n        var requestListeners = windowStore(\"requestListeners\");\n        if (!name || \"string\" != typeof name) throw new Error(\"Name required to add request listener\");\n\n        if (Array.isArray(win)) {\n          var listenersCollection = [];\n\n          for (var _i8 = 0, _win2 = win; _i8 < _win2.length; _i8++) listenersCollection.push(addRequestListener({\n            name: name,\n            domain: domain,\n            win: _win2[_i8]\n          }, listener));\n\n          return {\n            cancel: function () {\n              for (var _i10 = 0; _i10 < listenersCollection.length; _i10++) listenersCollection[_i10].cancel();\n            }\n          };\n        }\n\n        if (Array.isArray(domain)) {\n          var _listenersCollection = [];\n\n          for (var _i12 = 0, _domain2 = domain; _i12 < _domain2.length; _i12++) _listenersCollection.push(addRequestListener({\n            name: name,\n            win: win,\n            domain: _domain2[_i12]\n          }, listener));\n\n          return {\n            cancel: function () {\n              for (var _i14 = 0; _i14 < _listenersCollection.length; _i14++) _listenersCollection[_i14].cancel();\n            }\n          };\n        }\n\n        var existingListener = getRequestListener({\n          name: name,\n          win: win,\n          domain: domain\n        });\n        win && \"*\" !== win || (win = getWildcard());\n        domain = domain || \"*\";\n        if (existingListener) throw win && domain ? new Error(\"Request listener already exists for \" + name + \" on domain \" + domain.toString() + \" for \" + (win === getWildcard() ? \"wildcard\" : \"specified\") + \" window\") : win ? new Error(\"Request listener already exists for \" + name + \" for \" + (win === getWildcard() ? \"wildcard\" : \"specified\") + \" window\") : domain ? new Error(\"Request listener already exists for \" + name + \" on domain \" + domain.toString()) : new Error(\"Request listener already exists for \" + name);\n        var nameListeners = requestListeners.getOrSet(win, function () {\n          return {};\n        });\n        var domainListeners = util_getOrSet(nameListeners, name, function () {\n          return {};\n        });\n        var strDomain = domain.toString();\n        var regexListeners;\n        var regexListener;\n        util_isRegex(domain) ? (regexListeners = util_getOrSet(domainListeners, \"__domain_regex__\", function () {\n          return [];\n        })).push(regexListener = {\n          regex: domain,\n          listener: listener\n        }) : domainListeners[strDomain] = listener;\n        return {\n          cancel: function () {\n            delete domainListeners[strDomain];\n\n            if (regexListener) {\n              regexListeners.splice(regexListeners.indexOf(regexListener, 1));\n              regexListeners.length || delete domainListeners.__domain_regex__;\n            }\n\n            Object.keys(domainListeners).length || delete nameListeners[name];\n            win && !Object.keys(nameListeners).length && requestListeners.del(win);\n          }\n        };\n      }({\n        name: name,\n        win: win,\n        domain: domain\n      }, {\n        handler: options.handler,\n        handleError: options.errorHandler || function (err) {\n          throw err;\n        },\n        window: win,\n        domain: domain || \"*\",\n        name: name\n      });\n\n      return {\n        cancel: function () {\n          requestListener.cancel();\n        }\n      };\n    }\n\n    var send_send = function send(win, name, data, options) {\n      var domainMatcher = (options = options || {}).domain || \"*\";\n      var responseTimeout = options.timeout || -1;\n      var childTimeout = options.timeout || 5e3;\n      var fireAndForget = options.fireAndForget || !1;\n      return promise_ZalgoPromise.try(function () {\n        !function (name, win, domain) {\n          if (!name) throw new Error(\"Expected name\");\n          if (domain && \"string\" != typeof domain && !Array.isArray(domain) && !util_isRegex(domain)) throw new TypeError(\"Can not send \" + name + \". Expected domain \" + JSON.stringify(domain) + \" to be a string, array, or regex\");\n          if (isWindowClosed(win)) throw new Error(\"Can not send \" + name + \". Target window is closed\");\n        }(name, win, domainMatcher);\n        if (function (parent, child) {\n          var actualParent = getAncestor(child);\n          if (actualParent) return actualParent === parent;\n          if (child === parent) return !1;\n          if (getTop(child) === child) return !1;\n\n          for (var _i15 = 0, _getFrames8 = getFrames(parent); _i15 < _getFrames8.length; _i15++) if (_getFrames8[_i15] === child) return !0;\n\n          return !1;\n        }(window, win)) return awaitWindowHello(win, childTimeout);\n      }).then(function (_temp) {\n        return function (win, targetDomain, actualDomain, _ref) {\n          var send = _ref.send;\n          return promise_ZalgoPromise.try(function () {\n            return \"string\" == typeof targetDomain ? targetDomain : promise_ZalgoPromise.try(function () {\n              return actualDomain || sayHello(win, {\n                send: send\n              }).then(function (_ref2) {\n                return _ref2.domain;\n              });\n            }).then(function (normalizedDomain) {\n              if (!matchDomain(targetDomain, targetDomain)) throw new Error(\"Domain \" + stringify(targetDomain) + \" does not match \" + stringify(targetDomain));\n              return normalizedDomain;\n            });\n          });\n        }(win, domainMatcher, (void 0 === _temp ? {} : _temp).domain, {\n          send: send\n        });\n      }).then(function (targetDomain) {\n        var domain = targetDomain;\n        var logName = \"postrobot_method\" === name && data && \"string\" == typeof data.name ? data.name + \"()\" : name;\n        var promise = new promise_ZalgoPromise();\n        var hash = name + \"_\" + uniqueID();\n\n        if (!fireAndForget) {\n          var responseListener = {\n            name: name,\n            win: win,\n            domain: domain,\n            promise: promise\n          };\n          !function (hash, listener) {\n            globalStore(\"responseListeners\").set(hash, listener);\n          }(hash, responseListener);\n          var reqPromises = windowStore(\"requestPromises\").getOrSet(win, function () {\n            return [];\n          });\n          reqPromises.push(promise);\n          promise.catch(function () {\n            !function (hash) {\n              globalStore(\"erroredResponseListeners\").set(hash, !0);\n            }(hash);\n            deleteResponseListener(hash);\n          });\n          var totalAckTimeout = function (win) {\n            return windowStore(\"knownWindows\").get(win, !1);\n          }(win) ? 1e4 : 2e3;\n          var totalResTimeout = responseTimeout;\n          var ackTimeout = totalAckTimeout;\n          var resTimeout = totalResTimeout;\n          var interval = safeInterval(function () {\n            if (isWindowClosed(win)) return promise.reject(new Error(\"Window closed for \" + name + \" before \" + (responseListener.ack ? \"response\" : \"ack\")));\n            if (responseListener.cancelled) return promise.reject(new Error(\"Response listener was cancelled for \" + name));\n            ackTimeout = Math.max(ackTimeout - 500, 0);\n            -1 !== resTimeout && (resTimeout = Math.max(resTimeout - 500, 0));\n            return responseListener.ack || 0 !== ackTimeout ? 0 === resTimeout ? promise.reject(new Error(\"No response for postMessage \" + logName + \" in \" + getDomain() + \" in \" + totalResTimeout + \"ms\")) : void 0 : promise.reject(new Error(\"No ack for postMessage \" + logName + \" in \" + getDomain() + \" in \" + totalAckTimeout + \"ms\"));\n          }, 500);\n          promise.finally(function () {\n            interval.cancel();\n            reqPromises.splice(reqPromises.indexOf(promise, 1));\n          }).catch(src_util_noop);\n        }\n\n        return send_sendMessage(win, domain, {\n          id: uniqueID(),\n          origin: getDomain(window),\n          type: \"postrobot_message_request\",\n          hash: hash,\n          name: name,\n          data: data,\n          fireAndForget: fireAndForget\n        }, {\n          on: on_on,\n          send: send\n        }).then(function () {\n          return fireAndForget ? promise.resolve() : promise;\n        }, function (err) {\n          throw new Error(\"Send request message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n        });\n      });\n    };\n\n    function setup_toProxyWindow(win) {\n      return window_ProxyWindow.toProxyWindow(win, {\n        send: send_send\n      });\n    }\n\n    function cleanUpWindow(win) {\n      for (var _i2 = 0, _requestPromises$get2 = windowStore(\"requestPromises\").get(win, []); _i2 < _requestPromises$get2.length; _i2++) _requestPromises$get2[_i2].reject(new Error(\"Window \" + (isWindowClosed(win) ? \"closed\" : \"cleaned up\") + \" before response\")).catch(src_util_noop);\n    }\n\n    var src_bridge;\n    src_bridge = {\n      setupBridge: setupBridge,\n      openBridge: function (url, domain) {\n        var bridges = globalStore(\"bridges\");\n        var bridgeFrames = globalStore(\"bridgeFrames\");\n        domain = domain || getDomainFromUrl(url);\n        return bridges.getOrSet(domain, function () {\n          return promise_ZalgoPromise.try(function () {\n            if (getDomain() === domain) throw new Error(\"Can not open bridge on the same domain as current domain: \" + domain);\n            var name = getBridgeName(domain);\n            if (getFrameByName(window, name)) throw new Error(\"Frame with name \" + name + \" already exists on page\");\n\n            var iframe = function (name, url) {\n              var iframe = document.createElement(\"iframe\");\n              iframe.setAttribute(\"name\", name);\n              iframe.setAttribute(\"id\", name);\n              iframe.setAttribute(\"style\", \"display: none; margin: 0; padding: 0; border: 0px none; overflow: hidden;\");\n              iframe.setAttribute(\"frameborder\", \"0\");\n              iframe.setAttribute(\"border\", \"0\");\n              iframe.setAttribute(\"scrolling\", \"no\");\n              iframe.setAttribute(\"allowTransparency\", \"true\");\n              iframe.setAttribute(\"tabindex\", \"-1\");\n              iframe.setAttribute(\"hidden\", \"true\");\n              iframe.setAttribute(\"title\", \"\");\n              iframe.setAttribute(\"role\", \"presentation\");\n              iframe.src = url;\n              return iframe;\n            }(name, url);\n\n            bridgeFrames.set(domain, iframe);\n            return documentBodyReady.then(function (body) {\n              body.appendChild(iframe);\n              var bridge = iframe.contentWindow;\n              return new promise_ZalgoPromise(function (resolve, reject) {\n                iframe.addEventListener(\"load\", resolve);\n                iframe.addEventListener(\"error\", reject);\n              }).then(function () {\n                return awaitWindowHello(bridge, 5e3, \"Bridge \" + url);\n              }).then(function () {\n                return bridge;\n              });\n            });\n          });\n        });\n      },\n      linkWindow: linkWindow,\n      linkUrl: function (win, url) {\n        linkWindow({\n          win: win,\n          domain: getDomainFromUrl(url)\n        });\n      },\n      isBridge: isBridge,\n      needsBridge: needsBridge,\n      needsBridgeForBrowser: needsBridgeForBrowser,\n      hasBridge: function (url, domain) {\n        return globalStore(\"bridges\").has(domain || getDomainFromUrl(url));\n      },\n      needsBridgeForWin: needsBridgeForWin,\n      needsBridgeForDomain: needsBridgeForDomain,\n      destroyBridges: function () {\n        var bridges = globalStore(\"bridges\");\n        var bridgeFrames = globalStore(\"bridgeFrames\");\n\n        for (var _i4 = 0, _bridgeFrames$keys2 = bridgeFrames.keys(); _i4 < _bridgeFrames$keys2.length; _i4++) {\n          var frame = bridgeFrames.get(_bridgeFrames$keys2[_i4]);\n          frame && frame.parentNode && frame.parentNode.removeChild(frame);\n        }\n\n        bridgeFrames.reset();\n        bridges.reset();\n      }\n    };\n\n    function lib_global_getGlobal(win) {\n      if (!isSameDomain(win)) throw new Error(\"Can not get global for window on different domain\");\n      win.__zoid_9_0_86__ || (win.__zoid_9_0_86__ = {});\n      return win.__zoid_9_0_86__;\n    }\n\n    function tryGlobal(win, handler) {\n      try {\n        return handler(lib_global_getGlobal(win));\n      } catch (err) {}\n    }\n\n    function getProxyObject(obj) {\n      return {\n        get: function () {\n          var _this = this;\n\n          return promise_ZalgoPromise.try(function () {\n            if (_this.source && _this.source !== window) throw new Error(\"Can not call get on proxy object from a remote window\");\n            return obj;\n          });\n        }\n      };\n    }\n\n    function basicSerialize(data) {\n      return base64encode(JSON.stringify(data));\n    }\n\n    function getUIDRefStore(win) {\n      var global = lib_global_getGlobal(win);\n      global.references = global.references || {};\n      return global.references;\n    }\n\n    function crossDomainSerialize(_ref) {\n      var data = _ref.data,\n          metaData = _ref.metaData,\n          sender = _ref.sender,\n          receiver = _ref.receiver,\n          _ref$passByReference = _ref.passByReference,\n          passByReference = void 0 !== _ref$passByReference && _ref$passByReference,\n          _ref$basic = _ref.basic,\n          basic = void 0 !== _ref$basic && _ref$basic;\n      var proxyWin = setup_toProxyWindow(receiver.win);\n      var serializedMessage = basic ? JSON.stringify(data) : serializeMessage(proxyWin, receiver.domain, data, {\n        on: on_on,\n        send: send_send\n      });\n      var reference = passByReference ? function (val) {\n        var uid = uniqueID();\n        getUIDRefStore(window)[uid] = val;\n        return {\n          type: \"uid\",\n          uid: uid\n        };\n      }(serializedMessage) : {\n        type: \"raw\",\n        val: serializedMessage\n      };\n      return {\n        serializedData: basicSerialize({\n          sender: {\n            domain: sender.domain\n          },\n          metaData: metaData,\n          reference: reference\n        }),\n        cleanReference: function () {\n          win = window, \"uid\" === (ref = reference).type && delete getUIDRefStore(win)[ref.uid];\n          var win, ref;\n        }\n      };\n    }\n\n    function crossDomainDeserialize(_ref2) {\n      var sender = _ref2.sender,\n          _ref2$basic = _ref2.basic,\n          basic = void 0 !== _ref2$basic && _ref2$basic;\n\n      var message = function (serializedData) {\n        return JSON.parse(function (str) {\n          if (\"function\" == typeof atob) return decodeURIComponent([].map.call(atob(str), function (c) {\n            return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n          }).join(\"\"));\n          if (\"undefined\" != typeof Buffer) return Buffer.from(str, \"base64\").toString(\"utf8\");\n          throw new Error(\"Can not find window.atob or Buffer\");\n        }(serializedData));\n      }(_ref2.data);\n\n      var reference = message.reference,\n          metaData = message.metaData;\n      var win;\n      win = \"function\" == typeof sender.win ? sender.win({\n        metaData: metaData\n      }) : sender.win;\n      var domain;\n      domain = \"function\" == typeof sender.domain ? sender.domain({\n        metaData: metaData\n      }) : \"string\" == typeof sender.domain ? sender.domain : message.sender.domain;\n\n      var serializedData = function (win, ref) {\n        if (\"raw\" === ref.type) return ref.val;\n        if (\"uid\" === ref.type) return getUIDRefStore(win)[ref.uid];\n        throw new Error(\"Unsupported ref type: \" + ref.type);\n      }(win, reference);\n\n      return {\n        data: basic ? JSON.parse(serializedData) : function (source, origin, message) {\n          return deserializeMessage(source, origin, message, {\n            on: on_on,\n            send: send_send\n          });\n        }(win, domain, serializedData),\n        metaData: metaData,\n        sender: {\n          win: win,\n          domain: domain\n        },\n        reference: reference\n      };\n    }\n\n    var PROP_TYPE = {\n      STRING: \"string\",\n      OBJECT: \"object\",\n      FUNCTION: \"function\",\n      BOOLEAN: \"boolean\",\n      NUMBER: \"number\",\n      ARRAY: \"array\"\n    };\n    var PROP_SERIALIZATION = {\n      JSON: \"json\",\n      DOTIFY: \"dotify\",\n      BASE64: \"base64\"\n    };\n    var CONTEXT = WINDOW_TYPE;\n    var EVENT = {\n      RENDER: \"zoid-render\",\n      RENDERED: \"zoid-rendered\",\n      DISPLAY: \"zoid-display\",\n      ERROR: \"zoid-error\",\n      CLOSE: \"zoid-close\",\n      DESTROY: \"zoid-destroy\",\n      PROPS: \"zoid-props\",\n      RESIZE: \"zoid-resize\",\n      FOCUS: \"zoid-focus\"\n    };\n\n    function buildChildWindowName(_ref) {\n      return \"__zoid__\" + _ref.name + \"__\" + _ref.serializedPayload + \"__\";\n    }\n\n    function parseWindowName(windowName) {\n      if (!windowName) throw new Error(\"No window name\");\n\n      var _windowName$split = windowName.split(\"__\"),\n          zoidcomp = _windowName$split[1],\n          name = _windowName$split[2],\n          serializedInitialPayload = _windowName$split[3];\n\n      if (\"zoid\" !== zoidcomp) throw new Error(\"Window not rendered by zoid - got \" + zoidcomp);\n      if (!name) throw new Error(\"Expected component name\");\n      if (!serializedInitialPayload) throw new Error(\"Expected serialized payload ref\");\n      return {\n        name: name,\n        serializedInitialPayload: serializedInitialPayload\n      };\n    }\n\n    var parseInitialParentPayload = memoize(function (windowName) {\n      var _crossDomainDeseriali = crossDomainDeserialize({\n        data: parseWindowName(windowName).serializedInitialPayload,\n        sender: {\n          win: function (_ref2) {\n            return function (windowRef) {\n              if (\"opener\" === windowRef.type) return assertExists(\"opener\", getOpener(window));\n              if (\"parent\" === windowRef.type && \"number\" == typeof windowRef.distance) return assertExists(\"parent\", function (win, n) {\n                void 0 === n && (n = 1);\n                return function (win, n) {\n                  void 0 === n && (n = 1);\n                  var parent = win;\n\n                  for (var i = 0; i < n; i++) {\n                    if (!parent) return;\n                    parent = utils_getParent(parent);\n                  }\n\n                  return parent;\n                }(win, getDistanceFromTop(win) - n);\n              }(window, windowRef.distance));\n\n              if (\"global\" === windowRef.type && windowRef.uid && \"string\" == typeof windowRef.uid) {\n                var _ret = function () {\n                  var uid = windowRef.uid;\n                  var ancestor = getAncestor(window);\n                  if (!ancestor) throw new Error(\"Can not find ancestor window\");\n\n                  for (var _i2 = 0, _getAllFramesInWindow2 = getAllFramesInWindow(ancestor); _i2 < _getAllFramesInWindow2.length; _i2++) {\n                    var frame = _getAllFramesInWindow2[_i2];\n\n                    if (isSameDomain(frame)) {\n                      var win = tryGlobal(frame, function (global) {\n                        return global.windows && global.windows[uid];\n                      });\n                      if (win) return {\n                        v: win\n                      };\n                    }\n                  }\n                }();\n\n                if (\"object\" == typeof _ret) return _ret.v;\n              } else if (\"name\" === windowRef.type) {\n                var name = windowRef.name;\n                return assertExists(\"namedWindow\", function (win, name) {\n                  return getFrameByName(win, name) || function findChildFrameByName(win, name) {\n                    var frame = getFrameByName(win, name);\n                    if (frame) return frame;\n\n                    for (var _i11 = 0, _getFrames4 = getFrames(win); _i11 < _getFrames4.length; _i11++) {\n                      var namedFrame = findChildFrameByName(_getFrames4[_i11], name);\n                      if (namedFrame) return namedFrame;\n                    }\n                  }(getTop(win) || win, name);\n                }(assertExists(\"ancestor\", getAncestor(window)), name));\n              }\n\n              throw new Error(\"Unable to find \" + windowRef.type + \" parent component window\");\n            }(_ref2.metaData.windowRef);\n          }\n        }\n      });\n\n      return {\n        parent: _crossDomainDeseriali.sender,\n        payload: _crossDomainDeseriali.data,\n        reference: _crossDomainDeseriali.reference\n      };\n    });\n\n    function getInitialParentPayload() {\n      return parseInitialParentPayload(window.name);\n    }\n\n    function window_getWindowRef(targetWindow, currentWindow) {\n      void 0 === currentWindow && (currentWindow = window);\n      if (targetWindow === utils_getParent(currentWindow)) return {\n        type: \"parent\",\n        distance: getDistanceFromTop(targetWindow)\n      };\n      if (targetWindow === getOpener(currentWindow)) return {\n        type: \"opener\"\n      };\n\n      if (isSameDomain(targetWindow) && !(win = targetWindow, win === getTop(win))) {\n        var windowName = assertSameDomain(targetWindow).name;\n        if (windowName) return {\n          type: \"name\",\n          name: windowName\n        };\n      }\n\n      var win;\n    }\n\n    function normalizeChildProp(propsDef, props, key, value, helpers) {\n      if (!propsDef.hasOwnProperty(key)) return value;\n      var prop = propsDef[key];\n      return \"function\" == typeof prop.childDecorate ? prop.childDecorate({\n        value: value,\n        uid: helpers.uid,\n        tag: helpers.tag,\n        close: helpers.close,\n        focus: helpers.focus,\n        onError: helpers.onError,\n        onProps: helpers.onProps,\n        resize: helpers.resize,\n        getParent: helpers.getParent,\n        getParentDomain: helpers.getParentDomain,\n        show: helpers.show,\n        hide: helpers.hide,\n        export: helpers.export,\n        getSiblings: helpers.getSiblings\n      }) : value;\n    }\n\n    function child_focus() {\n      return promise_ZalgoPromise.try(function () {\n        window.focus();\n      });\n    }\n\n    function child_destroy() {\n      return promise_ZalgoPromise.try(function () {\n        window.close();\n      });\n    }\n\n    var props_defaultNoop = function () {\n      return src_util_noop;\n    };\n\n    var props_decorateOnce = function (_ref) {\n      return once(_ref.value);\n    };\n\n    function eachProp(props, propsDef, handler) {\n      for (var _i2 = 0, _Object$keys2 = Object.keys(_extends({}, props, propsDef)); _i2 < _Object$keys2.length; _i2++) {\n        var key = _Object$keys2[_i2];\n        handler(key, propsDef[key], props[key]);\n      }\n    }\n\n    function serializeProps(propsDef, props, method) {\n      var params = {};\n      return promise_ZalgoPromise.all(function (props, propsDef, handler) {\n        var results = [];\n        eachProp(props, propsDef, function (key, propDef, value) {\n          var result = function (key, propDef, value) {\n            return promise_ZalgoPromise.resolve().then(function () {\n              var _METHOD$GET$METHOD$PO, _METHOD$GET$METHOD$PO2;\n\n              if (null != value && propDef) {\n                var getParam = (_METHOD$GET$METHOD$PO = {}, _METHOD$GET$METHOD$PO.get = propDef.queryParam, _METHOD$GET$METHOD$PO.post = propDef.bodyParam, _METHOD$GET$METHOD$PO)[method];\n                var getValue = (_METHOD$GET$METHOD$PO2 = {}, _METHOD$GET$METHOD$PO2.get = propDef.queryValue, _METHOD$GET$METHOD$PO2.post = propDef.bodyValue, _METHOD$GET$METHOD$PO2)[method];\n                if (getParam) return promise_ZalgoPromise.hash({\n                  finalParam: promise_ZalgoPromise.try(function () {\n                    return \"function\" == typeof getParam ? getParam({\n                      value: value\n                    }) : \"string\" == typeof getParam ? getParam : key;\n                  }),\n                  finalValue: promise_ZalgoPromise.try(function () {\n                    return \"function\" == typeof getValue && isDefined(value) ? getValue({\n                      value: value\n                    }) : value;\n                  })\n                }).then(function (_ref) {\n                  var finalParam = _ref.finalParam,\n                      finalValue = _ref.finalValue;\n                  var result;\n                  if (\"boolean\" == typeof finalValue) result = finalValue.toString();else if (\"string\" == typeof finalValue) result = finalValue.toString();else if (\"object\" == typeof finalValue && null !== finalValue) {\n                    if (propDef.serialization === PROP_SERIALIZATION.JSON) result = JSON.stringify(finalValue);else if (propDef.serialization === PROP_SERIALIZATION.BASE64) result = base64encode(JSON.stringify(finalValue));else if (propDef.serialization === PROP_SERIALIZATION.DOTIFY || !propDef.serialization) {\n                      result = function dotify(obj, prefix, newobj) {\n                        void 0 === prefix && (prefix = \"\");\n                        void 0 === newobj && (newobj = {});\n                        prefix = prefix ? prefix + \".\" : prefix;\n\n                        for (var key in obj) obj.hasOwnProperty(key) && null != obj[key] && \"function\" != typeof obj[key] && (obj[key] && Array.isArray(obj[key]) && obj[key].length && obj[key].every(function (val) {\n                          return \"object\" != typeof val;\n                        }) ? newobj[\"\" + prefix + key + \"[]\"] = obj[key].join(\",\") : obj[key] && \"object\" == typeof obj[key] ? newobj = dotify(obj[key], \"\" + prefix + key, newobj) : newobj[\"\" + prefix + key] = obj[key].toString());\n\n                        return newobj;\n                      }(finalValue, key);\n\n                      for (var _i2 = 0, _Object$keys2 = Object.keys(result); _i2 < _Object$keys2.length; _i2++) {\n                        var dotkey = _Object$keys2[_i2];\n                        params[dotkey] = result[dotkey];\n                      }\n\n                      return;\n                    }\n                  } else \"number\" == typeof finalValue && (result = finalValue.toString());\n                  params[finalParam] = result;\n                });\n              }\n            });\n          }(key, propDef, value);\n\n          results.push(result);\n        });\n        return results;\n      }(props, propsDef)).then(function () {\n        return params;\n      });\n    }\n\n    function parentComponent(_ref) {\n      var uid = _ref.uid,\n          options = _ref.options,\n          _ref$overrides = _ref.overrides,\n          overrides = void 0 === _ref$overrides ? {} : _ref$overrides,\n          _ref$parentWin = _ref.parentWin,\n          parentWin = void 0 === _ref$parentWin ? window : _ref$parentWin;\n      var propsDef = options.propsDef,\n          containerTemplate = options.containerTemplate,\n          prerenderTemplate = options.prerenderTemplate,\n          tag = options.tag,\n          name = options.name,\n          attributes = options.attributes,\n          dimensions = options.dimensions,\n          autoResize = options.autoResize,\n          url = options.url,\n          domainMatch = options.domain,\n          xports = options.exports;\n      var initPromise = new promise_ZalgoPromise();\n      var handledErrors = [];\n      var clean = cleanup();\n      var state = {};\n      var inputProps = {};\n      var internalState = {\n        visible: !0\n      };\n      var event = overrides.event ? overrides.event : (triggered = {}, handlers = {}, emitter = {\n        on: function (eventName, handler) {\n          var handlerList = handlers[eventName] = handlers[eventName] || [];\n          handlerList.push(handler);\n          var cancelled = !1;\n          return {\n            cancel: function () {\n              if (!cancelled) {\n                cancelled = !0;\n                handlerList.splice(handlerList.indexOf(handler), 1);\n              }\n            }\n          };\n        },\n        once: function (eventName, handler) {\n          var listener = emitter.on(eventName, function () {\n            listener.cancel();\n            handler();\n          });\n          return listener;\n        },\n        trigger: function (eventName) {\n          for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) args[_key3 - 1] = arguments[_key3];\n\n          var handlerList = handlers[eventName];\n          var promises = [];\n\n          if (handlerList) {\n            var _loop = function (_i2) {\n              var handler = handlerList[_i2];\n              promises.push(promise_ZalgoPromise.try(function () {\n                return handler.apply(void 0, args);\n              }));\n            };\n\n            for (var _i2 = 0; _i2 < handlerList.length; _i2++) _loop(_i2);\n          }\n\n          return promise_ZalgoPromise.all(promises).then(src_util_noop);\n        },\n        triggerOnce: function (eventName) {\n          if (triggered[eventName]) return promise_ZalgoPromise.resolve();\n          triggered[eventName] = !0;\n\n          for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) args[_key4 - 1] = arguments[_key4];\n\n          return emitter.trigger.apply(emitter, [eventName].concat(args));\n        },\n        reset: function () {\n          handlers = {};\n        }\n      });\n      var triggered, handlers, emitter;\n      var props = overrides.props ? overrides.props : {};\n      var currentProxyWin;\n      var currentProxyContainer;\n      var childComponent;\n      var currentChildDomain;\n      var currentContainer;\n      var onErrorOverride = overrides.onError;\n      var getProxyContainerOverride = overrides.getProxyContainer;\n      var showOverride = overrides.show;\n      var hideOverride = overrides.hide;\n      var closeOverride = overrides.close;\n      var renderContainerOverride = overrides.renderContainer;\n      var getProxyWindowOverride = overrides.getProxyWindow;\n      var setProxyWinOverride = overrides.setProxyWin;\n      var openFrameOverride = overrides.openFrame;\n      var openPrerenderFrameOverride = overrides.openPrerenderFrame;\n      var prerenderOverride = overrides.prerender;\n      var openOverride = overrides.open;\n      var openPrerenderOverride = overrides.openPrerender;\n      var watchForUnloadOverride = overrides.watchForUnload;\n      var getInternalStateOverride = overrides.getInternalState;\n      var setInternalStateOverride = overrides.setInternalState;\n\n      var getDimensions = function () {\n        return \"function\" == typeof dimensions ? dimensions({\n          props: props\n        }) : dimensions;\n      };\n\n      var resolveInitPromise = function () {\n        return promise_ZalgoPromise.try(function () {\n          return overrides.resolveInitPromise ? overrides.resolveInitPromise() : initPromise.resolve();\n        });\n      };\n\n      var rejectInitPromise = function (err) {\n        return promise_ZalgoPromise.try(function () {\n          return overrides.rejectInitPromise ? overrides.rejectInitPromise(err) : initPromise.reject(err);\n        });\n      };\n\n      var getPropsForChild = function (initialChildDomain) {\n        var result = {};\n\n        for (var _i2 = 0, _Object$keys2 = Object.keys(props); _i2 < _Object$keys2.length; _i2++) {\n          var key = _Object$keys2[_i2];\n          var prop = propsDef[key];\n          prop && !1 === prop.sendToChild || prop && prop.sameDomain && !matchDomain(initialChildDomain, getDomain(window)) || (result[key] = props[key]);\n        }\n\n        return promise_ZalgoPromise.hash(result);\n      };\n\n      var getInternalState = function () {\n        return promise_ZalgoPromise.try(function () {\n          return getInternalStateOverride ? getInternalStateOverride() : internalState;\n        });\n      };\n\n      var setInternalState = function (newInternalState) {\n        return promise_ZalgoPromise.try(function () {\n          return setInternalStateOverride ? setInternalStateOverride(newInternalState) : internalState = _extends({}, internalState, newInternalState);\n        });\n      };\n\n      var getProxyWindow = function () {\n        return getProxyWindowOverride ? getProxyWindowOverride() : promise_ZalgoPromise.try(function () {\n          var windowProp = props.window;\n\n          if (windowProp) {\n            var _proxyWin = setup_toProxyWindow(windowProp);\n\n            clean.register(function () {\n              return windowProp.close();\n            });\n            return _proxyWin;\n          }\n\n          return new window_ProxyWindow({\n            send: send_send\n          });\n        });\n      };\n\n      var setProxyWin = function (proxyWin) {\n        return setProxyWinOverride ? setProxyWinOverride(proxyWin) : promise_ZalgoPromise.try(function () {\n          currentProxyWin = proxyWin;\n        });\n      };\n\n      var show = function () {\n        return showOverride ? showOverride() : promise_ZalgoPromise.hash({\n          setState: setInternalState({\n            visible: !0\n          }),\n          showElement: currentProxyContainer ? currentProxyContainer.get().then(showElement) : null\n        }).then(src_util_noop);\n      };\n\n      var hide = function () {\n        return hideOverride ? hideOverride() : promise_ZalgoPromise.hash({\n          setState: setInternalState({\n            visible: !1\n          }),\n          showElement: currentProxyContainer ? currentProxyContainer.get().then(hideElement) : null\n        }).then(src_util_noop);\n      };\n\n      var getUrl = function () {\n        return \"function\" == typeof url ? url({\n          props: props\n        }) : url;\n      };\n\n      var getAttributes = function () {\n        return \"function\" == typeof attributes ? attributes({\n          props: props\n        }) : attributes;\n      };\n\n      var getInitialChildDomain = function () {\n        return getDomainFromUrl(getUrl());\n      };\n\n      var openFrame = function (context, _ref2) {\n        var windowName = _ref2.windowName;\n        return openFrameOverride ? openFrameOverride(context, {\n          windowName: windowName\n        }) : promise_ZalgoPromise.try(function () {\n          if (context === CONTEXT.IFRAME) return getProxyObject(dom_iframe({\n            attributes: _extends({\n              name: windowName,\n              title: name\n            }, getAttributes().iframe)\n          }));\n        });\n      };\n\n      var openPrerenderFrame = function (context) {\n        return openPrerenderFrameOverride ? openPrerenderFrameOverride(context) : promise_ZalgoPromise.try(function () {\n          if (context === CONTEXT.IFRAME) return getProxyObject(dom_iframe({\n            attributes: _extends({\n              name: \"__zoid_prerender_frame__\" + name + \"_\" + uniqueID() + \"__\",\n              title: \"prerender__\" + name\n            }, getAttributes().iframe)\n          }));\n        });\n      };\n\n      var openPrerender = function (context, proxyWin, proxyPrerenderFrame) {\n        return openPrerenderOverride ? openPrerenderOverride(context, proxyWin, proxyPrerenderFrame) : promise_ZalgoPromise.try(function () {\n          if (context === CONTEXT.IFRAME) {\n            if (!proxyPrerenderFrame) throw new Error(\"Expected proxy frame to be passed\");\n            return proxyPrerenderFrame.get().then(function (prerenderFrame) {\n              clean.register(function () {\n                return destroyElement(prerenderFrame);\n              });\n              return awaitFrameWindow(prerenderFrame).then(function (prerenderFrameWindow) {\n                return assertSameDomain(prerenderFrameWindow);\n              }).then(function (win) {\n                return setup_toProxyWindow(win);\n              });\n            });\n          }\n\n          if (context === CONTEXT.POPUP) return proxyWin;\n          throw new Error(\"No render context available for \" + context);\n        });\n      };\n\n      var focus = function () {\n        return promise_ZalgoPromise.try(function () {\n          if (currentProxyWin) return promise_ZalgoPromise.all([event.trigger(EVENT.FOCUS), currentProxyWin.focus()]).then(src_util_noop);\n        });\n      };\n\n      var getCurrentWindowReferenceUID = function () {\n        var global = lib_global_getGlobal(window);\n        global.windows = global.windows || {};\n        global.windows[uid] = window;\n        clean.register(function () {\n          delete global.windows[uid];\n        });\n        return uid;\n      };\n\n      var getWindowRef = function (target, initialChildDomain, context, proxyWin) {\n        if (initialChildDomain === getDomain(window)) return {\n          type: \"global\",\n          uid: getCurrentWindowReferenceUID()\n        };\n        if (target !== window) throw new Error(\"Can not construct cross-domain window reference for different target window\");\n\n        if (props.window) {\n          var actualComponentWindow = proxyWin.getWindow();\n          if (!actualComponentWindow) throw new Error(\"Can not construct cross-domain window reference for lazy window prop\");\n          if (getAncestor(actualComponentWindow) !== window) throw new Error(\"Can not construct cross-domain window reference for window prop with different ancestor\");\n        }\n\n        if (context === CONTEXT.POPUP) return {\n          type: \"opener\"\n        };\n        if (context === CONTEXT.IFRAME) return {\n          type: \"parent\",\n          distance: getDistanceFromTop(window)\n        };\n        throw new Error(\"Can not construct window reference for child\");\n      };\n\n      var initChild = function (childDomain, childExports) {\n        return promise_ZalgoPromise.try(function () {\n          currentChildDomain = childDomain;\n          childComponent = childExports;\n          resolveInitPromise();\n          clean.register(function () {\n            return childExports.close.fireAndForget().catch(src_util_noop);\n          });\n        });\n      };\n\n      var resize = function (_ref3) {\n        var width = _ref3.width,\n            height = _ref3.height;\n        return promise_ZalgoPromise.try(function () {\n          event.trigger(EVENT.RESIZE, {\n            width: width,\n            height: height\n          });\n        });\n      };\n\n      var destroy = function (err) {\n        return promise_ZalgoPromise.try(function () {\n          return event.trigger(EVENT.DESTROY);\n        }).catch(src_util_noop).then(function () {\n          return clean.all(err);\n        }).then(function () {\n          initPromise.asyncReject(err || new Error(\"Component destroyed\"));\n        });\n      };\n\n      var close = memoize(function (err) {\n        return promise_ZalgoPromise.try(function () {\n          if (closeOverride) {\n            if (isWindowClosed(closeOverride.__source__)) return;\n            return closeOverride();\n          }\n\n          return promise_ZalgoPromise.try(function () {\n            return event.trigger(EVENT.CLOSE);\n          }).then(function () {\n            return destroy(err || new Error(\"Component closed\"));\n          });\n        });\n      });\n\n      var open = function (context, _ref4) {\n        var proxyWin = _ref4.proxyWin,\n            proxyFrame = _ref4.proxyFrame,\n            windowName = _ref4.windowName;\n        return openOverride ? openOverride(context, {\n          proxyWin: proxyWin,\n          proxyFrame: proxyFrame,\n          windowName: windowName\n        }) : promise_ZalgoPromise.try(function () {\n          if (context === CONTEXT.IFRAME) {\n            if (!proxyFrame) throw new Error(\"Expected proxy frame to be passed\");\n            return proxyFrame.get().then(function (frame) {\n              return awaitFrameWindow(frame).then(function (win) {\n                clean.register(function () {\n                  return destroyElement(frame);\n                });\n                clean.register(function () {\n                  return cleanUpWindow(win);\n                });\n                return win;\n              });\n            });\n          }\n\n          if (context === CONTEXT.POPUP) {\n            var _getDimensions = getDimensions(),\n                _getDimensions$width = _getDimensions.width,\n                width = void 0 === _getDimensions$width ? \"300px\" : _getDimensions$width,\n                _getDimensions$height = _getDimensions.height,\n                height = void 0 === _getDimensions$height ? \"150px\" : _getDimensions$height;\n\n            width = normalizeDimension(width, window.outerWidth);\n            height = normalizeDimension(height, window.outerWidth);\n\n            var win = function (url, options) {\n              var _options$closeOnUnloa = (options = options || {}).closeOnUnload,\n                  closeOnUnload = void 0 === _options$closeOnUnloa ? 1 : _options$closeOnUnloa,\n                  _options$name = options.name,\n                  name = void 0 === _options$name ? \"\" : _options$name,\n                  width = options.width,\n                  height = options.height;\n              var top = 0;\n              var left = 0;\n              width && (window.outerWidth ? left = Math.round((window.outerWidth - width) / 2) + window.screenX : window.screen.width && (left = Math.round((window.screen.width - width) / 2)));\n              height && (window.outerHeight ? top = Math.round((window.outerHeight - height) / 2) + window.screenY : window.screen.height && (top = Math.round((window.screen.height - height) / 2)));\n              delete options.closeOnUnload;\n              delete options.name;\n              width && height && (options = _extends({\n                top: top,\n                left: left,\n                width: width,\n                height: height,\n                status: 1,\n                toolbar: 0,\n                menubar: 0,\n                resizable: 1,\n                scrollbars: 1\n              }, options));\n              var params = Object.keys(options).map(function (key) {\n                if (null != options[key]) return key + \"=\" + stringify(options[key]);\n              }).filter(Boolean).join(\",\");\n              var win;\n\n              try {\n                win = window.open(\"\", name, params);\n              } catch (err) {\n                throw new dom_PopupOpenError(\"Can not open popup window - \" + (err.stack || err.message));\n              }\n\n              if (isWindowClosed(win)) {\n                var err;\n                throw new dom_PopupOpenError(\"Can not open popup window - blocked\");\n              }\n\n              closeOnUnload && window.addEventListener(\"unload\", function () {\n                return win.close();\n              });\n              return win;\n            }(0, _extends({\n              name: windowName,\n              width: width,\n              height: height\n            }, getAttributes().popup));\n\n            clean.register(function () {\n              return closeWindow(win);\n            });\n            clean.register(function () {\n              return cleanUpWindow(win);\n            });\n            return win;\n          }\n\n          throw new Error(\"No render context available for \" + context);\n        }).then(function (win) {\n          proxyWin.setWindow(win, {\n            send: send_send\n          });\n          return proxyWin.setName(windowName).then(function () {\n            return proxyWin;\n          });\n        });\n      };\n\n      var watchForUnload = function () {\n        return promise_ZalgoPromise.try(function () {\n          var unloadWindowListener = addEventListener(window, \"unload\", once(function () {\n            destroy(new Error(\"Window navigated away\"));\n          }));\n          var closeParentWindowListener = onCloseWindow(parentWin, destroy, 3e3);\n          clean.register(closeParentWindowListener.cancel);\n          clean.register(unloadWindowListener.cancel);\n          if (watchForUnloadOverride) return watchForUnloadOverride();\n        });\n      };\n\n      var checkWindowClose = function (proxyWin) {\n        var closed = !1;\n        return proxyWin.isClosed().then(function (isClosed) {\n          if (isClosed) {\n            closed = !0;\n            return close(new Error(\"Detected component window close\"));\n          }\n\n          return promise_ZalgoPromise.delay(200).then(function () {\n            return proxyWin.isClosed();\n          }).then(function (secondIsClosed) {\n            if (secondIsClosed) {\n              closed = !0;\n              return close(new Error(\"Detected component window close\"));\n            }\n          });\n        }).then(function () {\n          return closed;\n        });\n      };\n\n      var onError = function (err) {\n        return onErrorOverride ? onErrorOverride(err) : promise_ZalgoPromise.try(function () {\n          if (-1 === handledErrors.indexOf(err)) {\n            handledErrors.push(err);\n            initPromise.asyncReject(err);\n            return event.trigger(EVENT.ERROR, err);\n          }\n        });\n      };\n\n      var exportsPromise = new promise_ZalgoPromise();\n\n      var xport = function (actualExports) {\n        return promise_ZalgoPromise.try(function () {\n          exportsPromise.resolve(actualExports);\n        });\n      };\n\n      initChild.onError = onError;\n\n      var renderTemplate = function (renderer, _ref8) {\n        return renderer({\n          uid: uid,\n          container: _ref8.container,\n          context: _ref8.context,\n          doc: _ref8.doc,\n          frame: _ref8.frame,\n          prerenderFrame: _ref8.prerenderFrame,\n          focus: focus,\n          close: close,\n          state: state,\n          props: props,\n          tag: tag,\n          dimensions: getDimensions(),\n          event: event\n        });\n      };\n\n      var prerender = function (proxyPrerenderWin, _ref9) {\n        var context = _ref9.context;\n        return prerenderOverride ? prerenderOverride(proxyPrerenderWin, {\n          context: context\n        }) : promise_ZalgoPromise.try(function () {\n          if (prerenderTemplate) {\n            var prerenderWindow = proxyPrerenderWin.getWindow();\n\n            if (prerenderWindow && isSameDomain(prerenderWindow) && function (win) {\n              try {\n                if (!win.location.href) return !0;\n                if (\"about:blank\" === win.location.href) return !0;\n              } catch (err) {}\n\n              return !1;\n            }(prerenderWindow)) {\n              var doc = (prerenderWindow = assertSameDomain(prerenderWindow)).document;\n              var el = renderTemplate(prerenderTemplate, {\n                context: context,\n                doc: doc\n              });\n\n              if (el) {\n                if (el.ownerDocument !== doc) throw new Error(\"Expected prerender template to have been created with document from child window\");\n                !function (win, el) {\n                  var tag = el.tagName.toLowerCase();\n                  if (\"html\" !== tag) throw new Error(\"Expected element to be html, got \" + tag);\n                  var documentElement = win.document.documentElement;\n\n                  for (var _i6 = 0, _arrayFrom2 = arrayFrom(documentElement.children); _i6 < _arrayFrom2.length; _i6++) documentElement.removeChild(_arrayFrom2[_i6]);\n\n                  for (var _i8 = 0, _arrayFrom4 = arrayFrom(el.children); _i8 < _arrayFrom4.length; _i8++) documentElement.appendChild(_arrayFrom4[_i8]);\n                }(prerenderWindow, el);\n                var _autoResize$width = autoResize.width,\n                    width = void 0 !== _autoResize$width && _autoResize$width,\n                    _autoResize$height = autoResize.height,\n                    height = void 0 !== _autoResize$height && _autoResize$height,\n                    _autoResize$element = autoResize.element,\n                    element = void 0 === _autoResize$element ? \"body\" : _autoResize$element;\n\n                if ((element = getElementSafe(element, doc)) && (width || height)) {\n                  var prerenderResizeListener = onResize(element, function (_ref10) {\n                    resize({\n                      width: width ? _ref10.width : void 0,\n                      height: height ? _ref10.height : void 0\n                    });\n                  }, {\n                    width: width,\n                    height: height,\n                    win: prerenderWindow\n                  });\n                  event.on(EVENT.RENDERED, prerenderResizeListener.cancel);\n                }\n              }\n            }\n          }\n        });\n      };\n\n      var renderContainer = function (proxyContainer, _ref11) {\n        var proxyFrame = _ref11.proxyFrame,\n            proxyPrerenderFrame = _ref11.proxyPrerenderFrame,\n            context = _ref11.context,\n            rerender = _ref11.rerender;\n        return renderContainerOverride ? renderContainerOverride(proxyContainer, {\n          proxyFrame: proxyFrame,\n          proxyPrerenderFrame: proxyPrerenderFrame,\n          context: context,\n          rerender: rerender\n        }) : promise_ZalgoPromise.hash({\n          container: proxyContainer.get(),\n          frame: proxyFrame ? proxyFrame.get() : null,\n          prerenderFrame: proxyPrerenderFrame ? proxyPrerenderFrame.get() : null,\n          internalState: getInternalState()\n        }).then(function (_ref12) {\n          var container = _ref12.container,\n              visible = _ref12.internalState.visible;\n          var innerContainer = renderTemplate(containerTemplate, {\n            context: context,\n            container: container,\n            frame: _ref12.frame,\n            prerenderFrame: _ref12.prerenderFrame,\n            doc: document\n          });\n\n          if (innerContainer) {\n            visible || hideElement(innerContainer);\n            appendChild(container, innerContainer);\n\n            var containerWatcher = function (element, handler) {\n              handler = once(handler);\n              var cancelled = !1;\n              var mutationObservers = [];\n              var interval;\n              var sacrificialFrame;\n              var sacrificialFrameWin;\n\n              var cancel = function () {\n                cancelled = !0;\n\n                for (var _i18 = 0; _i18 < mutationObservers.length; _i18++) mutationObservers[_i18].disconnect();\n\n                interval && interval.cancel();\n                sacrificialFrameWin && sacrificialFrameWin.removeEventListener(\"unload\", elementClosed);\n                sacrificialFrame && destroyElement(sacrificialFrame);\n              };\n\n              var elementClosed = function () {\n                if (!cancelled) {\n                  handler();\n                  cancel();\n                }\n              };\n\n              if (isElementClosed(element)) {\n                elementClosed();\n                return {\n                  cancel: cancel\n                };\n              }\n\n              if (window.MutationObserver) {\n                var mutationElement = element.parentElement;\n\n                for (; mutationElement;) {\n                  var mutationObserver = new window.MutationObserver(function () {\n                    isElementClosed(element) && elementClosed();\n                  });\n                  mutationObserver.observe(mutationElement, {\n                    childList: !0\n                  });\n                  mutationObservers.push(mutationObserver);\n                  mutationElement = mutationElement.parentElement;\n                }\n              }\n\n              (sacrificialFrame = document.createElement(\"iframe\")).setAttribute(\"name\", \"__detect_close_\" + uniqueID() + \"__\");\n              sacrificialFrame.style.display = \"none\";\n              awaitFrameWindow(sacrificialFrame).then(function (frameWin) {\n                (sacrificialFrameWin = assertSameDomain(frameWin)).addEventListener(\"unload\", elementClosed);\n              });\n              element.appendChild(sacrificialFrame);\n              interval = safeInterval(function () {\n                isElementClosed(element) && elementClosed();\n              }, 1e3);\n              return {\n                cancel: cancel\n              };\n            }(innerContainer, function () {\n              var removeError = new Error(\"Detected container element removed from DOM\");\n              return promise_ZalgoPromise.delay(1).then(function () {\n                if (!isElementClosed(innerContainer)) {\n                  clean.all(removeError);\n                  return rerender().then(resolveInitPromise, rejectInitPromise);\n                }\n\n                close(removeError);\n              });\n            });\n\n            clean.register(function () {\n              return containerWatcher.cancel();\n            });\n            clean.register(function () {\n              return destroyElement(innerContainer);\n            });\n            return currentProxyContainer = getProxyObject(innerContainer);\n          }\n        });\n      };\n\n      var getHelpers = function () {\n        return {\n          state: state,\n          event: event,\n          close: close,\n          focus: focus,\n          resize: resize,\n          onError: onError,\n          updateProps: updateProps,\n          show: show,\n          hide: hide\n        };\n      };\n\n      var setProps = function (newInputProps) {\n        void 0 === newInputProps && (newInputProps = {});\n        var container = currentContainer;\n        var helpers = getHelpers();\n        extend(inputProps, newInputProps);\n        !function (propsDef, existingProps, inputProps, helpers, container) {\n          var state = helpers.state,\n              close = helpers.close,\n              focus = helpers.focus,\n              event = helpers.event,\n              onError = helpers.onError;\n          eachProp(inputProps, propsDef, function (key, propDef, val) {\n            var valueDetermined = !1;\n            var value = val;\n            Object.defineProperty(existingProps, key, {\n              configurable: !0,\n              enumerable: !0,\n              get: function () {\n                if (valueDetermined) return value;\n                valueDetermined = !0;\n                return function () {\n                  if (!propDef) return value;\n                  var alias = propDef.alias;\n                  alias && !isDefined(val) && isDefined(inputProps[alias]) && (value = inputProps[alias]);\n                  propDef.value && (value = propDef.value({\n                    props: existingProps,\n                    state: state,\n                    close: close,\n                    focus: focus,\n                    event: event,\n                    onError: onError,\n                    container: container\n                  }));\n                  !propDef.default || isDefined(value) || isDefined(inputProps[key]) || (value = propDef.default({\n                    props: existingProps,\n                    state: state,\n                    close: close,\n                    focus: focus,\n                    event: event,\n                    onError: onError,\n                    container: container\n                  }));\n\n                  if (isDefined(value)) {\n                    if (propDef.type === PROP_TYPE.ARRAY ? !Array.isArray(value) : typeof value !== propDef.type) throw new TypeError(\"Prop is not of type \" + propDef.type + \": \" + key);\n                  } else if (!1 !== propDef.required && !isDefined(inputProps[key])) throw new Error('Expected prop \"' + key + '\" to be defined');\n\n                  isDefined(value) && propDef.decorate && (value = propDef.decorate({\n                    value: value,\n                    props: existingProps,\n                    state: state,\n                    close: close,\n                    focus: focus,\n                    event: event,\n                    onError: onError,\n                    container: container\n                  }));\n                  return value;\n                }();\n              }\n            });\n          });\n          eachProp(existingProps, propsDef, src_util_noop);\n        }(propsDef, props, inputProps, helpers, container);\n      };\n\n      var updateProps = function (newProps) {\n        setProps(newProps);\n        return initPromise.then(function () {\n          var child = childComponent;\n          var proxyWin = currentProxyWin;\n          if (child && proxyWin && currentChildDomain) return getPropsForChild(currentChildDomain).then(function (childProps) {\n            return child.updateProps(childProps).catch(function (err) {\n              return checkWindowClose(proxyWin).then(function (closed) {\n                if (!closed) throw err;\n              });\n            });\n          });\n        });\n      };\n\n      var getProxyContainer = function (container) {\n        return getProxyContainerOverride ? getProxyContainerOverride(container) : promise_ZalgoPromise.try(function () {\n          return elementReady(container);\n        }).then(function (containerElement) {\n          isShadowElement(containerElement) && (containerElement = function insertShadowSlot(element) {\n            var shadowHost = function (element) {\n              var shadowRoot = function (element) {\n                for (; element.parentNode;) element = element.parentNode;\n\n                if (isShadowElement(element)) return element;\n              }(element);\n\n              if (shadowRoot && shadowRoot.host) return shadowRoot.host;\n            }(element);\n\n            if (!shadowHost) throw new Error(\"Element is not in shadow dom\");\n            var slotName = \"shadow-slot-\" + uniqueID();\n            var slot = document.createElement(\"slot\");\n            slot.setAttribute(\"name\", slotName);\n            element.appendChild(slot);\n            var slotProvider = document.createElement(\"div\");\n            slotProvider.setAttribute(\"slot\", slotName);\n            shadowHost.appendChild(slotProvider);\n            return isShadowElement(shadowHost) ? insertShadowSlot(slotProvider) : slotProvider;\n          }(containerElement));\n          currentContainer = containerElement;\n          return getProxyObject(containerElement);\n        });\n      };\n\n      return {\n        init: function () {\n          !function () {\n            event.on(EVENT.RENDER, function () {\n              return props.onRender();\n            });\n            event.on(EVENT.DISPLAY, function () {\n              return props.onDisplay();\n            });\n            event.on(EVENT.RENDERED, function () {\n              return props.onRendered();\n            });\n            event.on(EVENT.CLOSE, function () {\n              return props.onClose();\n            });\n            event.on(EVENT.DESTROY, function () {\n              return props.onDestroy();\n            });\n            event.on(EVENT.RESIZE, function () {\n              return props.onResize();\n            });\n            event.on(EVENT.FOCUS, function () {\n              return props.onFocus();\n            });\n            event.on(EVENT.PROPS, function (newProps) {\n              return props.onProps(newProps);\n            });\n            event.on(EVENT.ERROR, function (err) {\n              return props && props.onError ? props.onError(err) : rejectInitPromise(err).then(function () {\n                setTimeout(function () {\n                  throw err;\n                }, 1);\n              });\n            });\n            clean.register(event.reset);\n          }();\n        },\n        render: function (_ref14) {\n          var target = _ref14.target,\n              container = _ref14.container,\n              context = _ref14.context,\n              rerender = _ref14.rerender;\n          return promise_ZalgoPromise.try(function () {\n            var initialChildDomain = getInitialChildDomain();\n            var childDomainMatch = domainMatch || getInitialChildDomain();\n            !function (target, childDomainMatch, container) {\n              if (target !== window) {\n                if (!isSameTopWindow(window, target)) throw new Error(\"Can only renderTo an adjacent frame\");\n                var origin = getDomain();\n                if (!matchDomain(childDomainMatch, origin) && !isSameDomain(target)) throw new Error(\"Can not render remotely to \" + childDomainMatch.toString() + \" - can only render to \" + origin);\n                if (container && \"string\" != typeof container) throw new Error(\"Container passed to renderTo must be a string selector, got \" + typeof container + \" }\");\n              }\n            }(target, childDomainMatch, container);\n            var delegatePromise = promise_ZalgoPromise.try(function () {\n              if (target !== window) return function (context, target) {\n                var delegateProps = {};\n\n                for (var _i4 = 0, _Object$keys4 = Object.keys(props); _i4 < _Object$keys4.length; _i4++) {\n                  var propName = _Object$keys4[_i4];\n                  var propDef = propsDef[propName];\n                  propDef && propDef.allowDelegate && (delegateProps[propName] = props[propName]);\n                }\n\n                var childOverridesPromise = send_send(target, \"zoid_delegate_\" + name, {\n                  uid: uid,\n                  overrides: {\n                    props: delegateProps,\n                    event: event,\n                    close: close,\n                    onError: onError,\n                    getInternalState: getInternalState,\n                    setInternalState: setInternalState,\n                    resolveInitPromise: resolveInitPromise,\n                    rejectInitPromise: rejectInitPromise\n                  }\n                }).then(function (_ref13) {\n                  var parentComp = _ref13.data.parent;\n                  clean.register(function (err) {\n                    if (!isWindowClosed(target)) return parentComp.destroy(err);\n                  });\n                  return parentComp.getDelegateOverrides();\n                }).catch(function (err) {\n                  throw new Error(\"Unable to delegate rendering. Possibly the component is not loaded in the target window.\\n\\n\" + stringifyError(err));\n                });\n\n                getProxyContainerOverride = function () {\n                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];\n\n                  return childOverridesPromise.then(function (childOverrides) {\n                    return childOverrides.getProxyContainer.apply(childOverrides, args);\n                  });\n                };\n\n                renderContainerOverride = function () {\n                  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];\n\n                  return childOverridesPromise.then(function (childOverrides) {\n                    return childOverrides.renderContainer.apply(childOverrides, args);\n                  });\n                };\n\n                showOverride = function () {\n                  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];\n\n                  return childOverridesPromise.then(function (childOverrides) {\n                    return childOverrides.show.apply(childOverrides, args);\n                  });\n                };\n\n                hideOverride = function () {\n                  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args[_key4] = arguments[_key4];\n\n                  return childOverridesPromise.then(function (childOverrides) {\n                    return childOverrides.hide.apply(childOverrides, args);\n                  });\n                };\n\n                watchForUnloadOverride = function () {\n                  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) args[_key5] = arguments[_key5];\n\n                  return childOverridesPromise.then(function (childOverrides) {\n                    return childOverrides.watchForUnload.apply(childOverrides, args);\n                  });\n                };\n\n                if (context === CONTEXT.IFRAME) {\n                  getProxyWindowOverride = function () {\n                    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) args[_key6] = arguments[_key6];\n\n                    return childOverridesPromise.then(function (childOverrides) {\n                      return childOverrides.getProxyWindow.apply(childOverrides, args);\n                    });\n                  };\n\n                  openFrameOverride = function () {\n                    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) args[_key7] = arguments[_key7];\n\n                    return childOverridesPromise.then(function (childOverrides) {\n                      return childOverrides.openFrame.apply(childOverrides, args);\n                    });\n                  };\n\n                  openPrerenderFrameOverride = function () {\n                    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) args[_key8] = arguments[_key8];\n\n                    return childOverridesPromise.then(function (childOverrides) {\n                      return childOverrides.openPrerenderFrame.apply(childOverrides, args);\n                    });\n                  };\n\n                  prerenderOverride = function () {\n                    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) args[_key9] = arguments[_key9];\n\n                    return childOverridesPromise.then(function (childOverrides) {\n                      return childOverrides.prerender.apply(childOverrides, args);\n                    });\n                  };\n\n                  openOverride = function () {\n                    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) args[_key10] = arguments[_key10];\n\n                    return childOverridesPromise.then(function (childOverrides) {\n                      return childOverrides.open.apply(childOverrides, args);\n                    });\n                  };\n\n                  openPrerenderOverride = function () {\n                    for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) args[_key11] = arguments[_key11];\n\n                    return childOverridesPromise.then(function (childOverrides) {\n                      return childOverrides.openPrerender.apply(childOverrides, args);\n                    });\n                  };\n                } else context === CONTEXT.POPUP && (setProxyWinOverride = function () {\n                  for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) args[_key12] = arguments[_key12];\n\n                  return childOverridesPromise.then(function (childOverrides) {\n                    return childOverrides.setProxyWin.apply(childOverrides, args);\n                  });\n                });\n\n                return childOverridesPromise;\n              }(context, target);\n            });\n            var windowProp = props.window;\n            var watchForUnloadPromise = watchForUnload();\n            var buildBodyPromise = serializeProps(propsDef, props, \"post\");\n            var onRenderPromise = event.trigger(EVENT.RENDER);\n            var getProxyContainerPromise = getProxyContainer(container);\n            var getProxyWindowPromise = getProxyWindow();\n            var finalSetPropsPromise = getProxyContainerPromise.then(function () {\n              return setProps();\n            });\n            var buildUrlPromise = finalSetPropsPromise.then(function () {\n              return serializeProps(propsDef, props, \"get\").then(function (query) {\n                return function (url, options) {\n                  var query = options.query || {};\n                  var hash = options.hash || {};\n                  var originalUrl;\n                  var originalHash;\n\n                  var _url$split = url.split(\"#\");\n\n                  originalHash = _url$split[1];\n\n                  var _originalUrl$split = (originalUrl = _url$split[0]).split(\"?\");\n\n                  originalUrl = _originalUrl$split[0];\n                  var queryString = extendQuery(_originalUrl$split[1], query);\n                  var hashString = extendQuery(originalHash, hash);\n                  queryString && (originalUrl = originalUrl + \"?\" + queryString);\n                  hashString && (originalUrl = originalUrl + \"#\" + hashString);\n                  return originalUrl;\n                }(normalizeMockUrl(getUrl()), {\n                  query: query\n                });\n              });\n            });\n            var buildWindowNamePromise = getProxyWindowPromise.then(function (proxyWin) {\n              return function (_temp2) {\n                var _ref6 = void 0 === _temp2 ? {} : _temp2,\n                    proxyWin = _ref6.proxyWin,\n                    initialChildDomain = _ref6.initialChildDomain,\n                    childDomainMatch = _ref6.childDomainMatch,\n                    _ref6$target = _ref6.target,\n                    target = void 0 === _ref6$target ? window : _ref6$target,\n                    context = _ref6.context;\n\n                return function (_temp) {\n                  var _ref5 = void 0 === _temp ? {} : _temp,\n                      proxyWin = _ref5.proxyWin,\n                      childDomainMatch = _ref5.childDomainMatch,\n                      context = _ref5.context;\n\n                  return getPropsForChild(_ref5.initialChildDomain).then(function (childProps) {\n                    return {\n                      uid: uid,\n                      context: context,\n                      tag: tag,\n                      childDomainMatch: childDomainMatch,\n                      version: \"9_0_86\",\n                      props: childProps,\n                      exports: (win = proxyWin, {\n                        init: function (childExports) {\n                          return initChild(this.origin, childExports);\n                        },\n                        close: close,\n                        checkClose: function () {\n                          return checkWindowClose(win);\n                        },\n                        resize: resize,\n                        onError: onError,\n                        show: show,\n                        hide: hide,\n                        export: xport\n                      })\n                    };\n                    var win;\n                  });\n                }({\n                  proxyWin: proxyWin,\n                  initialChildDomain: initialChildDomain,\n                  childDomainMatch: childDomainMatch,\n                  context: context\n                }).then(function (childPayload) {\n                  var _crossDomainSerialize = crossDomainSerialize({\n                    data: childPayload,\n                    metaData: {\n                      windowRef: getWindowRef(target, initialChildDomain, context, proxyWin)\n                    },\n                    sender: {\n                      domain: getDomain(window)\n                    },\n                    receiver: {\n                      win: proxyWin,\n                      domain: childDomainMatch\n                    },\n                    passByReference: initialChildDomain === getDomain()\n                  }),\n                      serializedData = _crossDomainSerialize.serializedData;\n\n                  clean.register(_crossDomainSerialize.cleanReference);\n                  return serializedData;\n                });\n              }({\n                proxyWin: (_ref7 = {\n                  proxyWin: proxyWin,\n                  initialChildDomain: initialChildDomain,\n                  childDomainMatch: childDomainMatch,\n                  target: target,\n                  context: context\n                }).proxyWin,\n                initialChildDomain: _ref7.initialChildDomain,\n                childDomainMatch: _ref7.childDomainMatch,\n                target: _ref7.target,\n                context: _ref7.context\n              }).then(function (serializedPayload) {\n                return buildChildWindowName({\n                  name: name,\n                  serializedPayload: serializedPayload\n                });\n              });\n\n              var _ref7;\n            });\n            var openFramePromise = buildWindowNamePromise.then(function (windowName) {\n              return openFrame(context, {\n                windowName: windowName\n              });\n            });\n            var openPrerenderFramePromise = openPrerenderFrame(context);\n            var renderContainerPromise = promise_ZalgoPromise.hash({\n              proxyContainer: getProxyContainerPromise,\n              proxyFrame: openFramePromise,\n              proxyPrerenderFrame: openPrerenderFramePromise\n            }).then(function (_ref15) {\n              return renderContainer(_ref15.proxyContainer, {\n                context: context,\n                proxyFrame: _ref15.proxyFrame,\n                proxyPrerenderFrame: _ref15.proxyPrerenderFrame,\n                rerender: rerender\n              });\n            }).then(function (proxyContainer) {\n              return proxyContainer;\n            });\n            var openPromise = promise_ZalgoPromise.hash({\n              windowName: buildWindowNamePromise,\n              proxyFrame: openFramePromise,\n              proxyWin: getProxyWindowPromise\n            }).then(function (_ref16) {\n              var proxyWin = _ref16.proxyWin;\n              return windowProp ? proxyWin : open(context, {\n                windowName: _ref16.windowName,\n                proxyWin: proxyWin,\n                proxyFrame: _ref16.proxyFrame\n              });\n            });\n            var openPrerenderPromise = promise_ZalgoPromise.hash({\n              proxyWin: openPromise,\n              proxyPrerenderFrame: openPrerenderFramePromise\n            }).then(function (_ref17) {\n              return openPrerender(context, _ref17.proxyWin, _ref17.proxyPrerenderFrame);\n            });\n            var setStatePromise = openPromise.then(function (proxyWin) {\n              currentProxyWin = proxyWin;\n              return setProxyWin(proxyWin);\n            });\n            var prerenderPromise = promise_ZalgoPromise.hash({\n              proxyPrerenderWin: openPrerenderPromise,\n              state: setStatePromise\n            }).then(function (_ref18) {\n              return prerender(_ref18.proxyPrerenderWin, {\n                context: context\n              });\n            });\n            var setWindowNamePromise = promise_ZalgoPromise.hash({\n              proxyWin: openPromise,\n              windowName: buildWindowNamePromise\n            }).then(function (_ref19) {\n              if (windowProp) return _ref19.proxyWin.setName(_ref19.windowName);\n            });\n            var getMethodPromise = promise_ZalgoPromise.hash({\n              body: buildBodyPromise\n            }).then(function (_ref20) {\n              return options.method ? options.method : Object.keys(_ref20.body).length ? \"post\" : \"get\";\n            });\n            var loadUrlPromise = promise_ZalgoPromise.hash({\n              proxyWin: openPromise,\n              windowUrl: buildUrlPromise,\n              body: buildBodyPromise,\n              method: getMethodPromise,\n              windowName: setWindowNamePromise,\n              prerender: prerenderPromise\n            }).then(function (_ref21) {\n              return _ref21.proxyWin.setLocation(_ref21.windowUrl, {\n                method: _ref21.method,\n                body: _ref21.body\n              });\n            });\n            var watchForClosePromise = openPromise.then(function (proxyWin) {\n              !function watchForClose(proxyWin, context) {\n                var cancelled = !1;\n                clean.register(function () {\n                  cancelled = !0;\n                });\n                return promise_ZalgoPromise.delay(2e3).then(function () {\n                  return proxyWin.isClosed();\n                }).then(function (isClosed) {\n                  if (!cancelled) return isClosed ? close(new Error(\"Detected \" + context + \" close\")) : watchForClose(proxyWin, context);\n                });\n              }(proxyWin, context);\n            });\n            var onDisplayPromise = promise_ZalgoPromise.hash({\n              container: renderContainerPromise,\n              prerender: prerenderPromise\n            }).then(function () {\n              return event.trigger(EVENT.DISPLAY);\n            });\n            var openBridgePromise = openPromise.then(function (proxyWin) {\n              return function (proxyWin, initialChildDomain, context) {\n                return promise_ZalgoPromise.try(function () {\n                  return proxyWin.awaitWindow();\n                }).then(function (win) {\n                  if (src_bridge && src_bridge.needsBridge({\n                    win: win,\n                    domain: initialChildDomain\n                  }) && !src_bridge.hasBridge(initialChildDomain, initialChildDomain)) {\n                    var bridgeUrl = \"function\" == typeof options.bridgeUrl ? options.bridgeUrl({\n                      props: props\n                    }) : options.bridgeUrl;\n                    if (!bridgeUrl) throw new Error(\"Bridge needed to render \" + context);\n                    var bridgeDomain = getDomainFromUrl(bridgeUrl);\n                    src_bridge.linkUrl(win, initialChildDomain);\n                    return src_bridge.openBridge(normalizeMockUrl(bridgeUrl), bridgeDomain);\n                  }\n                });\n              }(proxyWin, initialChildDomain, context);\n            });\n            var runTimeoutPromise = loadUrlPromise.then(function () {\n              return promise_ZalgoPromise.try(function () {\n                var timeout = props.timeout;\n                if (timeout) return initPromise.timeout(timeout, new Error(\"Loading component timed out after \" + timeout + \" milliseconds\"));\n              });\n            });\n            var onRenderedPromise = initPromise.then(function () {\n              return event.trigger(EVENT.RENDERED);\n            });\n            return promise_ZalgoPromise.hash({\n              initPromise: initPromise,\n              buildUrlPromise: buildUrlPromise,\n              onRenderPromise: onRenderPromise,\n              getProxyContainerPromise: getProxyContainerPromise,\n              openFramePromise: openFramePromise,\n              openPrerenderFramePromise: openPrerenderFramePromise,\n              renderContainerPromise: renderContainerPromise,\n              openPromise: openPromise,\n              openPrerenderPromise: openPrerenderPromise,\n              setStatePromise: setStatePromise,\n              prerenderPromise: prerenderPromise,\n              loadUrlPromise: loadUrlPromise,\n              buildWindowNamePromise: buildWindowNamePromise,\n              setWindowNamePromise: setWindowNamePromise,\n              watchForClosePromise: watchForClosePromise,\n              onDisplayPromise: onDisplayPromise,\n              openBridgePromise: openBridgePromise,\n              runTimeoutPromise: runTimeoutPromise,\n              onRenderedPromise: onRenderedPromise,\n              delegatePromise: delegatePromise,\n              watchForUnloadPromise: watchForUnloadPromise,\n              finalSetPropsPromise: finalSetPropsPromise\n            });\n          }).catch(function (err) {\n            return promise_ZalgoPromise.all([onError(err), destroy(err)]).then(function () {\n              throw err;\n            }, function () {\n              throw err;\n            });\n          }).then(src_util_noop);\n        },\n        destroy: destroy,\n        getProps: function () {\n          return props;\n        },\n        setProps: setProps,\n        export: xport,\n        getHelpers: getHelpers,\n        getDelegateOverrides: function () {\n          return promise_ZalgoPromise.try(function () {\n            return {\n              getProxyContainer: getProxyContainer,\n              show: show,\n              hide: hide,\n              renderContainer: renderContainer,\n              getProxyWindow: getProxyWindow,\n              watchForUnload: watchForUnload,\n              openFrame: openFrame,\n              openPrerenderFrame: openPrerenderFrame,\n              prerender: prerender,\n              open: open,\n              openPrerender: openPrerender,\n              setProxyWin: setProxyWin\n            };\n          });\n        },\n        getExports: function () {\n          return xports({\n            getExports: function () {\n              return exportsPromise;\n            }\n          });\n        }\n      };\n    }\n\n    var react = {\n      register: function (tag, propsDef, init, _ref) {\n        var React = _ref.React,\n            ReactDOM = _ref.ReactDOM;\n        return function (_React$Component) {\n          _inheritsLoose(_class, _React$Component);\n\n          function _class() {\n            return _React$Component.apply(this, arguments) || this;\n          }\n\n          var _proto = _class.prototype;\n\n          _proto.render = function () {\n            return React.createElement(\"div\", null);\n          };\n\n          _proto.componentDidMount = function () {\n            var el = ReactDOM.findDOMNode(this);\n            var parent = init(extend({}, this.props));\n            parent.render(el, CONTEXT.IFRAME);\n            this.setState({\n              parent: parent\n            });\n          };\n\n          _proto.componentDidUpdate = function () {\n            this.state && this.state.parent && this.state.parent.updateProps(extend({}, this.props)).catch(src_util_noop);\n          };\n\n          return _class;\n        }(React.Component);\n      }\n    };\n    var vue = {\n      register: function (tag, propsDef, init, Vue) {\n        return Vue.component(tag, {\n          render: function (createElement) {\n            return createElement(\"div\");\n          },\n          inheritAttrs: !1,\n          mounted: function () {\n            var el = this.$el;\n            this.parent = init(_extends({}, (props = this.$attrs, Object.keys(props).reduce(function (acc, key) {\n              var value = props[key];\n\n              if (\"style-object\" === key || \"styleObject\" === key) {\n                acc.style = value;\n                acc.styleObject = value;\n              } else key.includes(\"-\") ? acc[dasherizeToCamel(key)] = value : acc[key] = value;\n\n              return acc;\n            }, {}))));\n            var props;\n            this.parent.render(el, CONTEXT.IFRAME);\n          },\n          watch: {\n            $attrs: {\n              handler: function () {\n                this.parent && this.$attrs && this.parent.updateProps(_extends({}, this.$attrs)).catch(src_util_noop);\n              },\n              deep: !0\n            }\n          }\n        });\n      }\n    };\n    var vue3 = {\n      register: function (tag, propsDef, init) {\n        return {\n          template: \"<div></div>\",\n          inheritAttrs: !1,\n          mounted: function () {\n            var el = this.$el;\n            this.parent = init(_extends({}, (props = this.$attrs, Object.keys(props).reduce(function (acc, key) {\n              var value = props[key];\n\n              if (\"style-object\" === key || \"styleObject\" === key) {\n                acc.style = value;\n                acc.styleObject = value;\n              } else key.includes(\"-\") ? acc[dasherizeToCamel(key)] = value : acc[key] = value;\n\n              return acc;\n            }, {}))));\n            var props;\n            this.parent.render(el, CONTEXT.IFRAME);\n          },\n          watch: {\n            $attrs: {\n              handler: function () {\n                this.parent && this.$attrs && this.parent.updateProps(_extends({}, this.$attrs)).catch(src_util_noop);\n              },\n              deep: !0\n            }\n          }\n        };\n      }\n    };\n    var angular = {\n      register: function (tag, propsDef, init, ng) {\n        return ng.module(tag, []).directive(dasherizeToCamel(tag), function () {\n          var scope = {};\n\n          for (var _i2 = 0, _Object$keys2 = Object.keys(propsDef); _i2 < _Object$keys2.length; _i2++) scope[_Object$keys2[_i2]] = \"=\";\n\n          scope.props = \"=\";\n          return {\n            scope: scope,\n            restrict: \"E\",\n            controller: [\"$scope\", \"$element\", function ($scope, $element) {\n              function safeApply() {\n                if (\"$apply\" !== $scope.$root.$$phase && \"$digest\" !== $scope.$root.$$phase) try {\n                  $scope.$apply();\n                } catch (err) {}\n              }\n\n              var getProps = function () {\n                return replaceObject($scope.props, function (item) {\n                  return \"function\" == typeof item ? function () {\n                    var result = item.apply(this, arguments);\n                    safeApply();\n                    return result;\n                  } : item;\n                });\n              };\n\n              var instance = init(getProps());\n              instance.render($element[0], CONTEXT.IFRAME);\n              $scope.$watch(function () {\n                instance.updateProps(getProps()).catch(src_util_noop);\n              });\n            }]\n          };\n        });\n      }\n    };\n    var angular2 = {\n      register: function (tag, propsDef, init, _ref) {\n        var AngularComponent = _ref.Component,\n            NgModule = _ref.NgModule,\n            ElementRef = _ref.ElementRef,\n            NgZone = _ref.NgZone,\n            Inject = _ref.Inject;\n\n        var ComponentInstance = function () {\n          function ComponentInstance(elementRef, zone) {\n            this.elementRef = void 0;\n            this.internalProps = void 0;\n            this.parent = void 0;\n            this.props = void 0;\n            this.zone = void 0;\n            this._props = void 0;\n            this._props = {};\n            this.elementRef = elementRef;\n            this.zone = zone;\n          }\n\n          var _proto = ComponentInstance.prototype;\n\n          _proto.getProps = function () {\n            var _this = this;\n\n            return replaceObject(_extends({}, this.internalProps, this.props), function (item) {\n              if (\"function\" == typeof item) {\n                var zone = _this.zone;\n                return function () {\n                  var _arguments = arguments,\n                      _this2 = this;\n\n                  return zone.run(function () {\n                    return item.apply(_this2, _arguments);\n                  });\n                };\n              }\n\n              return item;\n            });\n          };\n\n          _proto.ngOnInit = function () {\n            var targetElement = this.elementRef.nativeElement;\n            this.parent = init(this.getProps());\n            this.parent.render(targetElement, CONTEXT.IFRAME);\n          };\n\n          _proto.ngDoCheck = function () {\n            if (this.parent && !function (obj1, obj2) {\n              var checked = {};\n\n              for (var key in obj1) if (obj1.hasOwnProperty(key)) {\n                checked[key] = !0;\n                if (obj1[key] !== obj2[key]) return !1;\n              }\n\n              for (var _key in obj2) if (!checked[_key]) return !1;\n\n              return !0;\n            }(this._props, this.props)) {\n              this._props = _extends({}, this.props);\n              this.parent.updateProps(this.getProps());\n            }\n          };\n\n          return ComponentInstance;\n        }();\n\n        ComponentInstance.annotations = void 0;\n        ComponentInstance.parameters = void 0;\n        ComponentInstance.parameters = [[new Inject(ElementRef)], [new Inject(NgZone)]];\n        ComponentInstance.annotations = [new AngularComponent({\n          selector: tag,\n          template: \"<div></div>\",\n          inputs: [\"props\"]\n        })];\n\n        var ModuleInstance = function () {};\n\n        ModuleInstance.annotations = void 0;\n        ModuleInstance.annotations = [new NgModule({\n          declarations: [ComponentInstance],\n          exports: [ComponentInstance]\n        })];\n        return ModuleInstance;\n      }\n    };\n\n    function defaultContainerTemplate(_ref) {\n      var uid = _ref.uid,\n          frame = _ref.frame,\n          prerenderFrame = _ref.prerenderFrame,\n          doc = _ref.doc,\n          props = _ref.props,\n          event = _ref.event,\n          dimensions = _ref.dimensions;\n      var width = dimensions.width,\n          height = dimensions.height;\n\n      if (frame && prerenderFrame) {\n        var div = doc.createElement(\"div\");\n        div.setAttribute(\"id\", uid);\n        var style = doc.createElement(\"style\");\n        props.cspNonce && style.setAttribute(\"nonce\", props.cspNonce);\n        style.appendChild(doc.createTextNode(\"\\n            #\" + uid + \" {\\n                display: inline-block;\\n                position: relative;\\n                width: \" + width + \";\\n                height: \" + height + \";\\n            }\\n\\n            #\" + uid + \" > iframe {\\n                display: inline-block;\\n                position: absolute;\\n                width: 100%;\\n                height: 100%;\\n                top: 0;\\n                left: 0;\\n                transition: opacity .2s ease-in-out;\\n            }\\n\\n            #\" + uid + \" > iframe.zoid-invisible {\\n                opacity: 0;\\n            }\\n\\n            #\" + uid + \" > iframe.zoid-visible {\\n                opacity: 1;\\n        }\\n        \"));\n        div.appendChild(frame);\n        div.appendChild(prerenderFrame);\n        div.appendChild(style);\n        prerenderFrame.classList.add(\"zoid-visible\");\n        frame.classList.add(\"zoid-invisible\");\n        event.on(EVENT.RENDERED, function () {\n          prerenderFrame.classList.remove(\"zoid-visible\");\n          prerenderFrame.classList.add(\"zoid-invisible\");\n          frame.classList.remove(\"zoid-invisible\");\n          frame.classList.add(\"zoid-visible\");\n          setTimeout(function () {\n            destroyElement(prerenderFrame);\n          }, 1);\n        });\n        event.on(EVENT.RESIZE, function (_ref2) {\n          var newWidth = _ref2.width,\n              newHeight = _ref2.height;\n          \"number\" == typeof newWidth && (div.style.width = toCSS(newWidth));\n          \"number\" == typeof newHeight && (div.style.height = toCSS(newHeight));\n        });\n        return div;\n      }\n    }\n\n    function defaultPrerenderTemplate(_ref) {\n      var doc = _ref.doc,\n          props = _ref.props;\n      var html = doc.createElement(\"html\");\n      var body = doc.createElement(\"body\");\n      var style = doc.createElement(\"style\");\n      var spinner = doc.createElement(\"div\");\n      spinner.classList.add(\"spinner\");\n      props.cspNonce && style.setAttribute(\"nonce\", props.cspNonce);\n      html.appendChild(body);\n      body.appendChild(spinner);\n      body.appendChild(style);\n      style.appendChild(doc.createTextNode(\"\\n            html, body {\\n                width: 100%;\\n                height: 100%;\\n            }\\n\\n            .spinner {\\n                position: fixed;\\n                max-height: 60vmin;\\n                max-width: 60vmin;\\n                height: 40px;\\n                width: 40px;\\n                top: 50%;\\n                left: 50%;\\n                box-sizing: border-box;\\n                border: 3px solid rgba(0, 0, 0, .2);\\n                border-top-color: rgba(33, 128, 192, 0.8);\\n                border-radius: 100%;\\n                animation: rotation .7s infinite linear;\\n            }\\n\\n            @keyframes rotation {\\n                from {\\n                    transform: translateX(-50%) translateY(-50%) rotate(0deg);\\n                }\\n                to {\\n                    transform: translateX(-50%) translateY(-50%) rotate(359deg);\\n                }\\n            }\\n        \"));\n      return html;\n    }\n\n    var cleanInstances = cleanup();\n    var cleanZoid = cleanup();\n\n    function component(opts) {\n      var options = function (options) {\n        var tag = options.tag,\n            url = options.url,\n            domain = options.domain,\n            bridgeUrl = options.bridgeUrl,\n            _options$props = options.props,\n            props = void 0 === _options$props ? {} : _options$props,\n            _options$dimensions = options.dimensions,\n            dimensions = void 0 === _options$dimensions ? {} : _options$dimensions,\n            _options$autoResize = options.autoResize,\n            autoResize = void 0 === _options$autoResize ? {} : _options$autoResize,\n            _options$allowedParen = options.allowedParentDomains,\n            allowedParentDomains = void 0 === _options$allowedParen ? \"*\" : _options$allowedParen,\n            _options$attributes = options.attributes,\n            attributes = void 0 === _options$attributes ? {} : _options$attributes,\n            _options$defaultConte = options.defaultContext,\n            defaultContext = void 0 === _options$defaultConte ? CONTEXT.IFRAME : _options$defaultConte,\n            _options$containerTem = options.containerTemplate,\n            containerTemplate = void 0 === _options$containerTem ? defaultContainerTemplate : _options$containerTem,\n            _options$prerenderTem = options.prerenderTemplate,\n            prerenderTemplate = void 0 === _options$prerenderTem ? defaultPrerenderTemplate : _options$prerenderTem,\n            validate = options.validate,\n            _options$eligible = options.eligible,\n            eligible = void 0 === _options$eligible ? function () {\n          return {\n            eligible: !0\n          };\n        } : _options$eligible,\n            _options$logger = options.logger,\n            logger = void 0 === _options$logger ? {\n          info: src_util_noop\n        } : _options$logger,\n            _options$exports = options.exports,\n            xportsDefinition = void 0 === _options$exports ? src_util_noop : _options$exports,\n            method = options.method,\n            _options$children = options.children,\n            children = void 0 === _options$children ? function () {\n          return {};\n        } : _options$children;\n        var name = tag.replace(/-/g, \"_\");\n\n        var propsDef = _extends({}, {\n          window: {\n            type: PROP_TYPE.OBJECT,\n            sendToChild: !1,\n            required: !1,\n            allowDelegate: !0,\n            validate: function (_ref2) {\n              var value = _ref2.value;\n              if (!isWindow(value) && !window_ProxyWindow.isProxyWindow(value)) throw new Error(\"Expected Window or ProxyWindow\");\n\n              if (isWindow(value)) {\n                if (isWindowClosed(value)) throw new Error(\"Window is closed\");\n                if (!isSameDomain(value)) throw new Error(\"Window is not same domain\");\n              }\n            },\n            decorate: function (_ref3) {\n              return setup_toProxyWindow(_ref3.value);\n            }\n          },\n          timeout: {\n            type: PROP_TYPE.NUMBER,\n            required: !1,\n            sendToChild: !1\n          },\n          cspNonce: {\n            type: PROP_TYPE.STRING,\n            required: !1\n          },\n          onDisplay: {\n            type: PROP_TYPE.FUNCTION,\n            required: !1,\n            sendToChild: !1,\n            allowDelegate: !0,\n            default: props_defaultNoop,\n            decorate: props_decorateOnce\n          },\n          onRendered: {\n            type: PROP_TYPE.FUNCTION,\n            required: !1,\n            sendToChild: !1,\n            default: props_defaultNoop,\n            decorate: props_decorateOnce\n          },\n          onRender: {\n            type: PROP_TYPE.FUNCTION,\n            required: !1,\n            sendToChild: !1,\n            default: props_defaultNoop,\n            decorate: props_decorateOnce\n          },\n          onClose: {\n            type: PROP_TYPE.FUNCTION,\n            required: !1,\n            sendToChild: !1,\n            allowDelegate: !0,\n            default: props_defaultNoop,\n            decorate: props_decorateOnce\n          },\n          onDestroy: {\n            type: PROP_TYPE.FUNCTION,\n            required: !1,\n            sendToChild: !1,\n            allowDelegate: !0,\n            default: props_defaultNoop,\n            decorate: props_decorateOnce\n          },\n          onResize: {\n            type: PROP_TYPE.FUNCTION,\n            required: !1,\n            sendToChild: !1,\n            allowDelegate: !0,\n            default: props_defaultNoop\n          },\n          onFocus: {\n            type: PROP_TYPE.FUNCTION,\n            required: !1,\n            sendToChild: !1,\n            allowDelegate: !0,\n            default: props_defaultNoop\n          },\n          close: {\n            type: PROP_TYPE.FUNCTION,\n            required: !1,\n            sendToChild: !1,\n            childDecorate: function (_ref4) {\n              return _ref4.close;\n            }\n          },\n          focus: {\n            type: PROP_TYPE.FUNCTION,\n            required: !1,\n            sendToChild: !1,\n            childDecorate: function (_ref5) {\n              return _ref5.focus;\n            }\n          },\n          resize: {\n            type: PROP_TYPE.FUNCTION,\n            required: !1,\n            sendToChild: !1,\n            childDecorate: function (_ref6) {\n              return _ref6.resize;\n            }\n          },\n          uid: {\n            type: PROP_TYPE.STRING,\n            required: !1,\n            sendToChild: !1,\n            childDecorate: function (_ref7) {\n              return _ref7.uid;\n            }\n          },\n          tag: {\n            type: PROP_TYPE.STRING,\n            required: !1,\n            sendToChild: !1,\n            childDecorate: function (_ref8) {\n              return _ref8.tag;\n            }\n          },\n          getParent: {\n            type: PROP_TYPE.FUNCTION,\n            required: !1,\n            sendToChild: !1,\n            childDecorate: function (_ref9) {\n              return _ref9.getParent;\n            }\n          },\n          getParentDomain: {\n            type: PROP_TYPE.FUNCTION,\n            required: !1,\n            sendToChild: !1,\n            childDecorate: function (_ref10) {\n              return _ref10.getParentDomain;\n            }\n          },\n          show: {\n            type: PROP_TYPE.FUNCTION,\n            required: !1,\n            sendToChild: !1,\n            childDecorate: function (_ref11) {\n              return _ref11.show;\n            }\n          },\n          hide: {\n            type: PROP_TYPE.FUNCTION,\n            required: !1,\n            sendToChild: !1,\n            childDecorate: function (_ref12) {\n              return _ref12.hide;\n            }\n          },\n          export: {\n            type: PROP_TYPE.FUNCTION,\n            required: !1,\n            sendToChild: !1,\n            childDecorate: function (_ref13) {\n              return _ref13.export;\n            }\n          },\n          onError: {\n            type: PROP_TYPE.FUNCTION,\n            required: !1,\n            sendToChild: !1,\n            childDecorate: function (_ref14) {\n              return _ref14.onError;\n            }\n          },\n          onProps: {\n            type: PROP_TYPE.FUNCTION,\n            required: !1,\n            sendToChild: !1,\n            childDecorate: function (_ref15) {\n              return _ref15.onProps;\n            }\n          },\n          getSiblings: {\n            type: PROP_TYPE.FUNCTION,\n            required: !1,\n            sendToChild: !1,\n            childDecorate: function (_ref16) {\n              return _ref16.getSiblings;\n            }\n          }\n        }, props);\n\n        if (!containerTemplate) throw new Error(\"Container template required\");\n        return {\n          name: name,\n          tag: tag,\n          url: url,\n          domain: domain,\n          bridgeUrl: bridgeUrl,\n          method: method,\n          propsDef: propsDef,\n          dimensions: dimensions,\n          autoResize: autoResize,\n          allowedParentDomains: allowedParentDomains,\n          attributes: attributes,\n          defaultContext: defaultContext,\n          containerTemplate: containerTemplate,\n          prerenderTemplate: prerenderTemplate,\n          validate: validate,\n          logger: logger,\n          eligible: eligible,\n          children: children,\n          exports: \"function\" == typeof xportsDefinition ? xportsDefinition : function (_ref) {\n            var getExports = _ref.getExports;\n            var result = {};\n\n            var _loop = function (_i2, _Object$keys2) {\n              var key = _Object$keys2[_i2];\n              var type = xportsDefinition[key].type;\n              var valuePromise = getExports().then(function (res) {\n                return res[key];\n              });\n              result[key] = type === PROP_TYPE.FUNCTION ? function () {\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];\n\n                return valuePromise.then(function (value) {\n                  return value.apply(void 0, args);\n                });\n              } : valuePromise;\n            };\n\n            for (var _i2 = 0, _Object$keys2 = Object.keys(xportsDefinition); _i2 < _Object$keys2.length; _i2++) _loop(_i2, _Object$keys2);\n\n            return result;\n          }\n        };\n      }(opts);\n\n      var name = options.name,\n          tag = options.tag,\n          defaultContext = options.defaultContext,\n          propsDef = options.propsDef,\n          eligible = options.eligible,\n          children = options.children;\n      var global = lib_global_getGlobal(window);\n      var driverCache = {};\n      var instances = [];\n\n      var isChild = function () {\n        if (function (name) {\n          try {\n            return parseWindowName(window.name).name === name;\n          } catch (err) {}\n\n          return !1;\n        }(name)) {\n          var _payload = getInitialParentPayload().payload;\n          if (_payload.tag === tag && matchDomain(_payload.childDomainMatch, getDomain())) return !0;\n        }\n\n        return !1;\n      };\n\n      var registerChild = memoize(function () {\n        if (isChild()) {\n          if (window.xprops) {\n            delete global.components[tag];\n            throw new Error(\"Can not register \" + name + \" as child - child already registered\");\n          }\n\n          var child = function (options) {\n            var tag = options.tag,\n                propsDef = options.propsDef,\n                autoResize = options.autoResize,\n                allowedParentDomains = options.allowedParentDomains;\n            var onPropHandlers = [];\n\n            var _getInitialParentPayl = getInitialParentPayload(),\n                parent = _getInitialParentPayl.parent,\n                payload = _getInitialParentPayl.payload;\n\n            var parentComponentWindow = parent.win,\n                parentDomain = parent.domain;\n            var props;\n            var exportsPromise = new promise_ZalgoPromise();\n            var version = payload.version,\n                uid = payload.uid,\n                parentExports = payload.exports,\n                context = payload.context,\n                initialProps = payload.props;\n            if (\"9_0_86\" !== version) throw new Error(\"Parent window has zoid version \" + version + \", child window has version 9_0_86\");\n            var show = parentExports.show,\n                hide = parentExports.hide,\n                close = parentExports.close,\n                onError = parentExports.onError,\n                checkClose = parentExports.checkClose,\n                parentExport = parentExports.export,\n                parentResize = parentExports.resize,\n                parentInit = parentExports.init;\n\n            var getParent = function () {\n              return parentComponentWindow;\n            };\n\n            var getParentDomain = function () {\n              return parentDomain;\n            };\n\n            var onProps = function (handler) {\n              onPropHandlers.push(handler);\n              return {\n                cancel: function () {\n                  onPropHandlers.splice(onPropHandlers.indexOf(handler), 1);\n                }\n              };\n            };\n\n            var resize = function (_ref) {\n              return parentResize.fireAndForget({\n                width: _ref.width,\n                height: _ref.height\n              });\n            };\n\n            var xport = function (xports) {\n              exportsPromise.resolve(xports);\n              return parentExport(xports);\n            };\n\n            var getSiblings = function (_temp) {\n              var anyParent = (void 0 === _temp ? {} : _temp).anyParent;\n              var result = [];\n              var currentParent = props.parent;\n              void 0 === anyParent && (anyParent = !currentParent);\n              if (!anyParent && !currentParent) throw new Error(\"No parent found for \" + tag + \" child\");\n\n              for (var _i2 = 0, _getAllFramesInWindow2 = getAllFramesInWindow(window); _i2 < _getAllFramesInWindow2.length; _i2++) {\n                var win = _getAllFramesInWindow2[_i2];\n\n                if (isSameDomain(win)) {\n                  var xprops = assertSameDomain(win).xprops;\n\n                  if (xprops && getParent() === xprops.getParent()) {\n                    var winParent = xprops.parent;\n\n                    if (anyParent || !currentParent || winParent && winParent.uid === currentParent.uid) {\n                      var xports = tryGlobal(win, function (global) {\n                        return global.exports;\n                      });\n                      result.push({\n                        props: xprops,\n                        exports: xports\n                      });\n                    }\n                  }\n                }\n              }\n\n              return result;\n            };\n\n            var setProps = function (newProps, origin, isUpdate) {\n              void 0 === isUpdate && (isUpdate = !1);\n\n              var normalizedProps = function (parentComponentWindow, propsDef, props, origin, helpers, isUpdate) {\n                void 0 === isUpdate && (isUpdate = !1);\n                var result = {};\n\n                for (var _i2 = 0, _Object$keys2 = Object.keys(props); _i2 < _Object$keys2.length; _i2++) {\n                  var key = _Object$keys2[_i2];\n                  var prop = propsDef[key];\n\n                  if (!prop || !prop.sameDomain || origin === getDomain(window) && isSameDomain(parentComponentWindow)) {\n                    var value = normalizeChildProp(propsDef, 0, key, props[key], helpers);\n                    result[key] = value;\n                    prop && prop.alias && !result[prop.alias] && (result[prop.alias] = value);\n                  }\n                }\n\n                if (!isUpdate) for (var _i4 = 0, _Object$keys4 = Object.keys(propsDef); _i4 < _Object$keys4.length; _i4++) {\n                  var _key = _Object$keys4[_i4];\n                  props.hasOwnProperty(_key) || (result[_key] = normalizeChildProp(propsDef, 0, _key, void 0, helpers));\n                }\n                return result;\n              }(parentComponentWindow, propsDef, newProps, origin, {\n                tag: tag,\n                show: show,\n                hide: hide,\n                close: close,\n                focus: child_focus,\n                onError: onError,\n                resize: resize,\n                getSiblings: getSiblings,\n                onProps: onProps,\n                getParent: getParent,\n                getParentDomain: getParentDomain,\n                uid: uid,\n                export: xport\n              }, isUpdate);\n\n              props ? extend(props, normalizedProps) : props = normalizedProps;\n\n              for (var _i4 = 0; _i4 < onPropHandlers.length; _i4++) (0, onPropHandlers[_i4])(props);\n            };\n\n            var updateProps = function (newProps) {\n              return promise_ZalgoPromise.try(function () {\n                return setProps(newProps, parentDomain, !0);\n              });\n            };\n\n            return {\n              init: function () {\n                return promise_ZalgoPromise.try(function () {\n                  isSameDomain(parentComponentWindow) && function (_ref3) {\n                    var componentName = _ref3.componentName,\n                        parentComponentWindow = _ref3.parentComponentWindow;\n\n                    var _crossDomainDeseriali2 = crossDomainDeserialize({\n                      data: parseWindowName(window.name).serializedInitialPayload,\n                      sender: {\n                        win: parentComponentWindow\n                      },\n                      basic: !0\n                    }),\n                        sender = _crossDomainDeseriali2.sender;\n\n                    if (\"uid\" === _crossDomainDeseriali2.reference.type || \"global\" === _crossDomainDeseriali2.metaData.windowRef.type) {\n                      var _crossDomainSerialize = crossDomainSerialize({\n                        data: _crossDomainDeseriali2.data,\n                        metaData: {\n                          windowRef: window_getWindowRef(parentComponentWindow)\n                        },\n                        sender: {\n                          domain: sender.domain\n                        },\n                        receiver: {\n                          win: window,\n                          domain: getDomain()\n                        },\n                        basic: !0\n                      });\n\n                      window.name = buildChildWindowName({\n                        name: componentName,\n                        serializedPayload: _crossDomainSerialize.serializedData\n                      });\n                    }\n                  }({\n                    componentName: options.name,\n                    parentComponentWindow: parentComponentWindow\n                  });\n                  lib_global_getGlobal(window).exports = options.exports({\n                    getExports: function () {\n                      return exportsPromise;\n                    }\n                  });\n                  !function (allowedParentDomains, domain) {\n                    if (!matchDomain(allowedParentDomains, domain)) throw new Error(\"Can not be rendered by domain: \" + domain);\n                  }(allowedParentDomains, parentDomain);\n                  markWindowKnown(parentComponentWindow);\n                  !function () {\n                    window.addEventListener(\"beforeunload\", function () {\n                      checkClose.fireAndForget();\n                    });\n                    window.addEventListener(\"unload\", function () {\n                      checkClose.fireAndForget();\n                    });\n                    onCloseWindow(parentComponentWindow, function () {\n                      child_destroy();\n                    });\n                  }();\n                  return parentInit({\n                    updateProps: updateProps,\n                    close: child_destroy\n                  });\n                }).then(function () {\n                  return (_autoResize$width = autoResize.width, width = void 0 !== _autoResize$width && _autoResize$width, _autoResize$height = autoResize.height, height = void 0 !== _autoResize$height && _autoResize$height, _autoResize$element = autoResize.element, elementReady(void 0 === _autoResize$element ? \"body\" : _autoResize$element).catch(src_util_noop).then(function (element) {\n                    return {\n                      width: width,\n                      height: height,\n                      element: element\n                    };\n                  })).then(function (_ref3) {\n                    var width = _ref3.width,\n                        height = _ref3.height,\n                        element = _ref3.element;\n                    element && (width || height) && context !== CONTEXT.POPUP && onResize(element, function (_ref4) {\n                      resize({\n                        width: width ? _ref4.width : void 0,\n                        height: height ? _ref4.height : void 0\n                      });\n                    }, {\n                      width: width,\n                      height: height\n                    });\n                  });\n\n                  var _autoResize$width, width, _autoResize$height, height, _autoResize$element;\n                }).catch(function (err) {\n                  onError(err);\n                });\n              },\n              getProps: function () {\n                if (props) return props;\n                setProps(initialProps, parentDomain);\n                return props;\n              }\n            };\n          }(options);\n\n          child.init();\n          return child;\n        }\n      });\n\n      var init = function init(inputProps) {\n        var instance;\n        var uid = \"zoid-\" + tag + \"-\" + uniqueID();\n        var props = inputProps || {};\n\n        var _eligible = eligible({\n          props: props\n        }),\n            eligibility = _eligible.eligible,\n            reason = _eligible.reason;\n\n        var onDestroy = props.onDestroy;\n\n        props.onDestroy = function () {\n          instance && eligibility && instances.splice(instances.indexOf(instance), 1);\n          if (onDestroy) return onDestroy.apply(void 0, arguments);\n        };\n\n        var parent = parentComponent({\n          uid: uid,\n          options: options\n        });\n        parent.init();\n        eligibility ? parent.setProps(props) : props.onDestroy && props.onDestroy();\n        cleanInstances.register(function (err) {\n          return parent.destroy(err || new Error(\"zoid destroyed all components\"));\n        });\n\n        var clone = function (_temp) {\n          var _ref4$decorate = (void 0 === _temp ? {} : _temp).decorate;\n          return init((void 0 === _ref4$decorate ? identity : _ref4$decorate)(props));\n        };\n\n        var _render = function (target, container, context) {\n          return promise_ZalgoPromise.try(function () {\n            if (!eligibility) {\n              var err = new Error(reason || name + \" component is not eligible\");\n              return parent.destroy(err).then(function () {\n                throw err;\n              });\n            }\n\n            if (!isWindow(target)) throw new Error(\"Must pass window to renderTo\");\n            return function (props, context) {\n              return promise_ZalgoPromise.try(function () {\n                if (props.window) return setup_toProxyWindow(props.window).getType();\n\n                if (context) {\n                  if (context !== CONTEXT.IFRAME && context !== CONTEXT.POPUP) throw new Error(\"Unrecognized context: \" + context);\n                  return context;\n                }\n\n                return defaultContext;\n              });\n            }(props, context);\n          }).then(function (finalContext) {\n            container = function (context, container) {\n              if (container) {\n                if (\"string\" != typeof container && !isElement(container)) throw new TypeError(\"Expected string or element selector to be passed\");\n                return container;\n              }\n\n              if (context === CONTEXT.POPUP) return \"body\";\n              throw new Error(\"Expected element to be passed to render iframe\");\n            }(finalContext, container);\n\n            if (target !== window && \"string\" != typeof container) throw new Error(\"Must pass string element when rendering to another window\");\n            return parent.render({\n              target: target,\n              container: container,\n              context: finalContext,\n              rerender: function () {\n                var newInstance = clone();\n                extend(instance, newInstance);\n                return newInstance.renderTo(target, container, context);\n              }\n            });\n          }).catch(function (err) {\n            return parent.destroy(err).then(function () {\n              throw err;\n            });\n          });\n        };\n\n        instance = _extends({}, parent.getExports(), parent.getHelpers(), function () {\n          var childComponents = children();\n          var result = {};\n\n          var _loop2 = function (_i4, _Object$keys4) {\n            var childName = _Object$keys4[_i4];\n            var Child = childComponents[childName];\n\n            result[childName] = function (childInputProps) {\n              var parentProps = parent.getProps();\n\n              var childProps = _extends({}, childInputProps, {\n                parent: {\n                  uid: uid,\n                  props: parentProps,\n                  export: parent.export\n                }\n              });\n\n              return Child(childProps);\n            };\n          };\n\n          for (var _i4 = 0, _Object$keys4 = Object.keys(childComponents); _i4 < _Object$keys4.length; _i4++) _loop2(_i4, _Object$keys4);\n\n          return result;\n        }(), {\n          isEligible: function () {\n            return eligibility;\n          },\n          clone: clone,\n          render: function (container, context) {\n            return _render(window, container, context);\n          },\n          renderTo: function (target, container, context) {\n            return _render(target, container, context);\n          }\n        });\n        eligibility && instances.push(instance);\n        return instance;\n      };\n\n      registerChild();\n      !function () {\n        var allowDelegateListener = on_on(\"zoid_allow_delegate_\" + name, function () {\n          return !0;\n        });\n        var delegateListener = on_on(\"zoid_delegate_\" + name, function (_ref2) {\n          var _ref2$data = _ref2.data;\n          return {\n            parent: parentComponent({\n              uid: _ref2$data.uid,\n              options: options,\n              overrides: _ref2$data.overrides,\n              parentWin: _ref2.source\n            })\n          };\n        });\n        cleanZoid.register(allowDelegateListener.cancel);\n        cleanZoid.register(delegateListener.cancel);\n      }();\n      global.components = global.components || {};\n      if (global.components[tag]) throw new Error(\"Can not register multiple components with the same tag: \" + tag);\n      global.components[tag] = !0;\n      return {\n        init: init,\n        instances: instances,\n        driver: function (driverName, dep) {\n          var drivers = {\n            react: react,\n            angular: angular,\n            vue: vue,\n            vue3: vue3,\n            angular2: angular2\n          };\n          if (!drivers[driverName]) throw new Error(\"Could not find driver for framework: \" + driverName);\n          driverCache[driverName] || (driverCache[driverName] = drivers[driverName].register(tag, propsDef, init, dep));\n          return driverCache[driverName];\n        },\n        isChild: isChild,\n        canRenderTo: function (win) {\n          return send_send(win, \"zoid_allow_delegate_\" + name).then(function (_ref3) {\n            return _ref3.data;\n          }).catch(function () {\n            return !1;\n          });\n        },\n        registerChild: registerChild\n      };\n    }\n\n    var component_create = function (options) {\n      !function () {\n        if (!global_getGlobal().initialized) {\n          global_getGlobal().initialized = !0;\n          on = (_ref3 = {\n            on: on_on,\n            send: send_send\n          }).on, send = _ref3.send, (global = global_getGlobal()).receiveMessage = global.receiveMessage || function (message) {\n            return receive_receiveMessage(message, {\n              on: on,\n              send: send\n            });\n          };\n          !function (_ref5) {\n            var on = _ref5.on,\n                send = _ref5.send;\n            globalStore().getOrSet(\"postMessageListener\", function () {\n              return addEventListener(window, \"message\", function (event) {\n                !function (event, _ref4) {\n                  var on = _ref4.on,\n                      send = _ref4.send;\n                  promise_ZalgoPromise.try(function () {\n                    var source = event.source || event.sourceElement;\n                    var origin = event.origin || event.originalEvent && event.originalEvent.origin;\n                    var data = event.data;\n                    \"null\" === origin && (origin = \"file://\");\n\n                    if (source) {\n                      if (!origin) throw new Error(\"Post message did not have origin domain\");\n                      receive_receiveMessage({\n                        source: source,\n                        origin: origin,\n                        data: data\n                      }, {\n                        on: on,\n                        send: send\n                      });\n                    }\n                  });\n                }(event, {\n                  on: on,\n                  send: send\n                });\n              });\n            });\n          }({\n            on: on_on,\n            send: send_send\n          });\n          setupBridge({\n            on: on_on,\n            send: send_send,\n            receiveMessage: receive_receiveMessage\n          });\n          !function (_ref8) {\n            var on = _ref8.on,\n                send = _ref8.send;\n            globalStore(\"builtinListeners\").getOrSet(\"helloListener\", function () {\n              var listener = on(\"postrobot_hello\", {\n                domain: \"*\"\n              }, function (_ref3) {\n                resolveHelloPromise(_ref3.source, {\n                  domain: _ref3.origin\n                });\n                return {\n                  instanceID: getInstanceID()\n                };\n              });\n              var parent = getAncestor();\n              parent && sayHello(parent, {\n                send: send\n              }).catch(function (err) {});\n              return listener;\n            });\n          }({\n            on: on_on,\n            send: send_send\n          });\n        }\n\n        var _ref3, on, send, global;\n      }();\n      var comp = component(options);\n\n      var init = function (props) {\n        return comp.init(props);\n      };\n\n      init.driver = function (name, dep) {\n        return comp.driver(name, dep);\n      };\n\n      init.isChild = function () {\n        return comp.isChild();\n      };\n\n      init.canRenderTo = function (win) {\n        return comp.canRenderTo(win);\n      };\n\n      init.instances = comp.instances;\n      var child = comp.registerChild();\n      child && (window.xprops = init.xprops = child.getProps());\n      return init;\n    };\n\n    function destroyComponents(err) {\n      src_bridge && src_bridge.destroyBridges();\n      var destroyPromise = cleanInstances.all(err);\n      cleanInstances = cleanup();\n      return destroyPromise;\n    }\n\n    var destroyAll = destroyComponents;\n\n    function component_destroy(err) {\n      destroyAll();\n      delete window.__zoid_9_0_86__;\n      !function () {\n        !function () {\n          var responseListeners = globalStore(\"responseListeners\");\n\n          for (var _i2 = 0, _responseListeners$ke2 = responseListeners.keys(); _i2 < _responseListeners$ke2.length; _i2++) {\n            var hash = _responseListeners$ke2[_i2];\n            var listener = responseListeners.get(hash);\n            listener && (listener.cancelled = !0);\n            responseListeners.del(hash);\n          }\n        }();\n        (listener = globalStore().get(\"postMessageListener\")) && listener.cancel();\n        var listener;\n        delete window.__post_robot_10_0_44__;\n      }();\n      return cleanZoid.all(err);\n    }\n  }]);\n});","map":null,"metadata":{},"sourceType":"script"}