{"ast":null,"code":"/*!\n * keyring.js - keyring object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst {\n  base58\n} = require('bstring');\n\nconst bio = require('bufio');\n\nconst hash160 = require('bcrypto/lib/hash160');\n\nconst hash256 = require('bcrypto/lib/hash256');\n\nconst Network = require('../protocol/network');\n\nconst Script = require('../script/script');\n\nconst Address = require('./address');\n\nconst Output = require('./output');\n\nconst secp256k1 = require('bcrypto/lib/secp256k1');\n\nconst {\n  encoding\n} = bio;\n\nconst {\n  inspectSymbol\n} = require('../utils');\n/*\n * Constants\n */\n\n\nconst ZERO_KEY = Buffer.alloc(33, 0x00);\n/**\n * Key Ring\n * Represents a key ring which amounts to an address.\n * @alias module:primitives.KeyRing\n */\n\nclass KeyRing {\n  /**\n   * Create a key ring.\n   * @constructor\n   * @param {Object} options\n   */\n  constructor(options) {\n    this.nested = false;\n    this.publicKey = ZERO_KEY;\n    this.privateKey = null;\n    this.script = null;\n    this._keyHash = null;\n    this._keyAddress = null;\n    this._scriptHash160 = null;\n    this._scriptAddress = null;\n    if (options) this.fromOptions(options);\n  }\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n\n  fromOptions(options) {\n    let key = toKey(options);\n    if (Buffer.isBuffer(key)) return this.fromKey(key);\n    key = toKey(options.key);\n    if (options.publicKey) key = toKey(options.publicKey);\n    if (options.privateKey) key = toKey(options.privateKey);\n    const script = options.script;\n    const compress = options.compressed;\n    if (script) return this.fromScript(key, script, compress);\n    return this.fromKey(key, compress);\n  }\n  /**\n   * Instantiate key ring from options.\n   * @param {Object} options\n   * @returns {KeyRing}\n   */\n\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n  /**\n   * Clear cached key/script hashes.\n   */\n\n\n  refresh() {\n    this._keyHash = null;\n    this._keyAddress = null;\n    this._scriptHash160 = null;\n    this._scriptAddress = null;\n  }\n  /**\n   * Inject data from private key.\n   * @private\n   * @param {Buffer} key\n   * @param {Boolean?} compress\n   */\n\n\n  fromPrivate(key, compress) {\n    assert(Buffer.isBuffer(key), 'Private key must be a buffer.');\n    assert(secp256k1.privateKeyVerify(key), 'Not a valid private key.');\n    this.privateKey = key;\n    this.publicKey = secp256k1.publicKeyCreate(key, compress !== false);\n    return this;\n  }\n  /**\n   * Instantiate keyring from a private key.\n   * @param {Buffer} key\n   * @param {Boolean?} compress\n   * @returns {KeyRing}\n   */\n\n\n  static fromPrivate(key, compress) {\n    return new this().fromPrivate(key, compress);\n  }\n  /**\n   * Inject data from public key.\n   * @private\n   * @param {Buffer} key\n   */\n\n\n  fromPublic(key) {\n    assert(Buffer.isBuffer(key), 'Public key must be a buffer.');\n    assert(secp256k1.publicKeyVerify(key), 'Not a valid public key.');\n    this.publicKey = key;\n    return this;\n  }\n  /**\n   * Generate a keyring.\n   * @private\n   * @param {Boolean?} compress\n   * @returns {KeyRing}\n   */\n\n\n  generate(compress) {\n    const key = secp256k1.privateKeyGenerate();\n    return this.fromKey(key, compress);\n  }\n  /**\n   * Generate a keyring.\n   * @param {Boolean?} compress\n   * @returns {KeyRing}\n   */\n\n\n  static generate(compress) {\n    return new this().generate(compress);\n  }\n  /**\n   * Instantiate keyring from a public key.\n   * @param {Buffer} publicKey\n   * @returns {KeyRing}\n   */\n\n\n  static fromPublic(key) {\n    return new this().fromPublic(key);\n  }\n  /**\n   * Inject data from public key.\n   * @private\n   * @param {Buffer} privateKey\n   * @param {Boolean?} compress\n   */\n\n\n  fromKey(key, compress) {\n    assert(Buffer.isBuffer(key), 'Key must be a buffer.');\n    if (key.length === 32) return this.fromPrivate(key, compress !== false);\n    return this.fromPublic(key);\n  }\n  /**\n   * Instantiate keyring from a public key.\n   * @param {Buffer} publicKey\n   * @param {Boolean?} compress\n   * @returns {KeyRing}\n   */\n\n\n  static fromKey(key, compress) {\n    return new this().fromKey(key, compress);\n  }\n  /**\n   * Inject data from script.\n   * @private\n   * @param {Buffer} key\n   * @param {Script} script\n   * @param {Boolean?} compress\n   */\n\n\n  fromScript(key, script, compress) {\n    assert(script instanceof Script, 'Non-script passed into KeyRing.');\n    this.fromKey(key, compress);\n    this.script = script;\n    return this;\n  }\n  /**\n   * Instantiate keyring from script.\n   * @param {Buffer} key\n   * @param {Script} script\n   * @param {Boolean?} compress\n   * @returns {KeyRing}\n   */\n\n\n  static fromScript(key, script, compress) {\n    return new this().fromScript(key, script, compress);\n  }\n  /**\n   * Get ith public key from multisig script.\n   * @private\n   * @param {Script} script\n   * @param {Number} i\n   * @returns {KeyRing}\n   */\n\n\n  fromMultisigScript(script, i) {\n    assert(script instanceof Script, 'Non-script passed.');\n    assert(script.isMultisig(), 'Script must be multisig');\n    const n = script.getSmall(-2);\n    assert(i >= 1 && i <= n, 'Requested `i`th key, `n` available');\n    this.fromKey(script.code[i].toData());\n    return this;\n  }\n  /**\n   * Instantiate keyring from ith key in multisig script.\n   * @param {Script} script\n   * @param {Number} i\n   * @returns {KeyRing}\n   */\n\n\n  static fromMultisigScript(script, i) {\n    return new this().fromMultisigScript(script, i);\n  }\n  /**\n   * Calculate WIF serialization size.\n   * @returns {Number}\n   */\n\n\n  getSecretSize() {\n    let size = 0;\n    size += 1;\n    size += this.privateKey.length;\n    if (this.publicKey.length === 33) size += 1;\n    size += 4;\n    return size;\n  }\n  /**\n   * Convert key to a CBitcoinSecret.\n   * @param {(Network|NetworkType)?} network\n   * @returns {Base58String}\n   */\n\n\n  toSecret(network) {\n    const size = this.getSecretSize();\n    const bw = bio.write(size);\n    assert(this.privateKey, 'Cannot serialize without private key.');\n    network = Network.get(network);\n    bw.writeU8(network.keyPrefix.privkey);\n    bw.writeBytes(this.privateKey);\n    if (this.publicKey.length === 33) bw.writeU8(1);\n    bw.writeChecksum(hash256.digest);\n    return base58.encode(bw.render());\n  }\n  /**\n   * Inject properties from serialized CBitcoinSecret.\n   * @private\n   * @param {Base58String} secret\n   * @param {(Network|NetworkType)?} network\n   */\n\n\n  fromSecret(data, network) {\n    const br = bio.read(base58.decode(data), true);\n    const version = br.readU8();\n    Network.fromWIF(version, network);\n    const key = br.readBytes(32);\n    let compress = false;\n\n    if (br.left() > 4) {\n      assert(br.readU8() === 1, 'Bad compression flag.');\n      compress = true;\n    }\n\n    br.verifyChecksum(hash256.digest);\n    return this.fromPrivate(key, compress);\n  }\n  /**\n   * Instantiate a keyring from a serialized CBitcoinSecret.\n   * @param {Base58String} secret\n   * @param {(Network|NetworkType)?} network\n   * @returns {KeyRing}\n   */\n\n\n  static fromSecret(data, network) {\n    return new this().fromSecret(data, network);\n  }\n  /**\n   * Get private key.\n   * @param {String?} enc - Can be `\"hex\"`, `\"base58\"`, or `null`.\n   * @returns {Buffer} Private key.\n   */\n\n\n  getPrivateKey(enc, network) {\n    if (!this.privateKey) return null;\n    if (enc === 'base58') return this.toSecret(network);\n    if (enc === 'hex') return this.privateKey.toString('hex');\n    return this.privateKey;\n  }\n  /**\n   * Get public key.\n   * @param {String?} enc - `\"hex\"` or `null`.\n   * @returns {Buffer}\n   */\n\n\n  getPublicKey(enc) {\n    if (enc === 'base58') return base58.encode(this.publicKey);\n    if (enc === 'hex') return this.publicKey.toString('hex');\n    return this.publicKey;\n  }\n  /**\n   * Get redeem script.\n   * @returns {Script}\n   */\n\n\n  getScript() {\n    return this.script;\n  }\n  /**\n   * Get scripthash.\n   * @param {String?} enc - `\"hex\"` or `null`.\n   * @returns {Buffer}\n   */\n\n\n  getScriptHash(enc) {\n    return this.getScriptHash160(enc);\n  }\n  /**\n   * Get ripemd160 scripthash.\n   * @param {String?} enc - `\"hex\"` or `null`.\n   * @returns {Buffer}\n   */\n\n\n  getScriptHash160(enc) {\n    if (!this.script) return null;\n    if (!this._scriptHash160) this._scriptHash160 = this.script.hash160();\n    return enc === 'hex' ? this._scriptHash160.toString('hex') : this._scriptHash160;\n  }\n  /**\n   * Get scripthash address.\n   * @param {String?} enc - `\"base58\"` or `null`.\n   * @returns {Address|AddressString}\n   */\n\n\n  getScriptAddress(enc, network) {\n    if (!this.script) return null;\n\n    if (!this._scriptAddress) {\n      const hash = this.getScriptHash160();\n      const addr = Address.fromScripthash(hash);\n      this._scriptAddress = addr;\n    }\n\n    if (enc === 'base58') return this._scriptAddress.toBase58(network);\n    if (enc === 'string') return this._scriptAddress.toString(network);\n    return this._scriptAddress;\n  }\n  /**\n   * Get public key hash.\n   * @param {String?} enc - `\"hex\"` or `null`.\n   * @returns {Buffer}\n   */\n\n\n  getKeyHash(enc) {\n    if (!this._keyHash) this._keyHash = hash160.digest(this.publicKey);\n    return enc === 'hex' ? this._keyHash.toString('hex') : this._keyHash;\n  }\n  /**\n   * Get pubkeyhash address.\n   * @param {String?} enc - `\"base58\"` or `null`.\n   * @returns {Address|AddressString}\n   */\n\n\n  getKeyAddress(enc, network) {\n    if (!this._keyAddress) {\n      const hash = this.getKeyHash();\n      const addr = Address.fromPubkeyhash(hash);\n      this._keyAddress = addr;\n    }\n\n    if (enc === 'base58') return this._keyAddress.toBase58(network);\n    if (enc === 'string') return this._keyAddress.toString(network);\n    return this._keyAddress;\n  }\n  /**\n   * Get hash.\n   * @param {String?} enc - `\"hex\"` or `null`.\n   * @returns {Buffer}\n   */\n\n\n  getHash(enc) {\n    if (this.script) return this.getScriptHash(enc);\n    return this.getKeyHash(enc);\n  }\n  /**\n   * Get base58 address.\n   * @param {String?} enc - `\"base58\"` or `null`.\n   * @returns {Address|AddressString}\n   */\n\n\n  getAddress(enc, network) {\n    if (this.script) return this.getScriptAddress(enc, network);\n    return this.getKeyAddress(enc, network);\n  }\n  /**\n   * Test an address hash against hash.\n   * @param {Buffer} hash\n   * @returns {Boolean}\n   */\n\n\n  ownHash(hash) {\n    if (!hash) return false;\n    if (hash.equals(this.getKeyHash())) return true;\n\n    if (this.script) {\n      if (hash.equals(this.getScriptHash())) return true;\n    }\n\n    return false;\n  }\n  /**\n   * Check whether transaction output belongs to this address.\n   * @param {TX|Output} tx - Transaction or Output.\n   * @param {Number?} index - Output index.\n   * @returns {Boolean}\n   */\n\n\n  ownOutput(tx, index) {\n    let output;\n\n    if (tx instanceof Output) {\n      output = tx;\n    } else {\n      output = tx.outputs[index];\n      assert(output, 'Output does not exist.');\n    }\n\n    return this.ownHash(output.getHash());\n  }\n  /**\n   * Test a hash against script hashes to\n   * find the correct redeem script, if any.\n   * @param {Buffer} hash\n   * @returns {Script|null}\n   */\n\n\n  getRedeem(hash) {\n    if (this.script) {\n      if (hash.equals(this.getScriptHash160())) return this.script;\n    }\n\n    return null;\n  }\n  /**\n   * Sign a message.\n   * @param {Buffer} msg\n   * @returns {Buffer} Signature in DER format.\n   */\n\n\n  sign(msg) {\n    assert(this.privateKey, 'Cannot sign without private key.');\n    return secp256k1.signDER(msg, this.privateKey);\n  }\n  /**\n   * Sign a message.\n   * @param {Buffer} msg\n   * @returns {Buffer} Signature in Schnorr format.\n   */\n\n\n  signSchnorr(msg) {\n    assert(this.privateKey, 'Cannot sign without private key.');\n    return secp256k1.schnorrSign(msg, this.privateKey);\n  }\n  /**\n   * Verify a message.\n   * @param {Buffer} msg\n   * @param {Buffer} sig - Signature in DER format.\n   * @returns {Boolean}\n   */\n\n\n  verify(msg, sig) {\n    return secp256k1.verifyDER(msg, sig, this.publicKey);\n  }\n  /**\n   * Verify a message.\n   * @param {Buffer} msg\n   * @param {Buffer} sig - Signature in Schnorr format.\n   * @returns {Boolean}\n   */\n\n\n  verifySchnorr(msg, sig) {\n    return secp256k1.schnorrVerify(msg, sig, this.publicKey);\n  }\n  /**\n   * Get witness program version.\n   * @returns {Number}\n   */\n\n\n  getVersion() {\n    return -1;\n  }\n  /**\n   * Get address type.\n   * @returns {ScriptType}\n   */\n\n\n  getType() {\n    if (this.script) return Address.types.SCRIPTHASH;\n    return Address.types.PUBKEYHASH;\n  }\n  /**\n   * Inspect keyring.\n   * @returns {Object}\n   */\n\n\n  [inspectSymbol]() {\n    return this.toJSON();\n  }\n  /**\n   * Convert an KeyRing to a more json-friendly object.\n   * @returns {Object}\n   */\n\n\n  toJSON(network) {\n    return {\n      publicKey: this.publicKey.toString('hex'),\n      script: this.script ? this.script.toRaw().toString('hex') : null,\n      type: Address.typesByVal[this.getType()].toLowerCase(),\n      address: this.getAddress('string', network)\n    };\n  }\n  /**\n   * Inject properties from json object.\n   * @private\n   * @param {Object} json\n   */\n\n\n  fromJSON(json) {\n    assert(json);\n    assert(typeof json.publicKey === 'string');\n    assert(!json.script || typeof json.script === 'string');\n    this.publicKey = Buffer.from(json.publicKey, 'hex');\n    if (json.script) this.script = Buffer.from(json.script, 'hex');\n    return this;\n  }\n  /**\n   * Instantiate an KeyRing from a jsonified transaction object.\n   * @param {Object} json - The jsonified transaction object.\n   * @returns {KeyRing}\n   */\n\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n  /**\n   * Calculate serialization size.\n   * @returns {Number}\n   */\n\n\n  getSize() {\n    let size = 0;\n    size += 1;\n\n    if (this.privateKey) {\n      size += encoding.sizeVarBytes(this.privateKey);\n      size += 1;\n    } else {\n      size += encoding.sizeVarBytes(this.publicKey);\n    }\n\n    size += this.script ? this.script.getVarSize() : 1;\n    return size;\n  }\n  /**\n   * Write the keyring to a buffer writer.\n   * @param {BufferWriter} bw\n   */\n\n\n  toWriter(bw) {\n    const field = 0; // we don't use field for now,\n    // we can use this for flags different\n    // flags in the future.\n\n    bw.writeU8(field);\n\n    if (this.privateKey) {\n      bw.writeVarBytes(this.privateKey);\n      bw.writeU8(this.publicKey.length === 33 ? 1 : 0);\n    } else {\n      bw.writeVarBytes(this.publicKey);\n    }\n\n    if (this.script) bw.writeVarBytes(this.script.toRaw());else bw.writeVarint(0);\n    return bw;\n  }\n  /**\n   * Serialize the keyring.\n   * @returns {Buffer}\n   */\n\n\n  toRaw() {\n    const size = this.getSize();\n    return this.toWriter(bio.write(size)).render();\n  }\n  /**\n   * Inject properties from buffer reader.\n   * @private\n   * @param {BufferReader} br\n   */\n\n\n  fromReader(br) {\n    // we are not interested in flags.\n    br.readU8();\n    const key = br.readVarBytes();\n\n    if (key.length === 32) {\n      const compress = br.readU8() === 1;\n      this.privateKey = key;\n      this.publicKey = secp256k1.publicKeyCreate(key, compress);\n    } else {\n      this.publicKey = key;\n      assert(secp256k1.publicKeyVerify(key), 'Invalid public key.');\n    }\n\n    const script = br.readVarBytes();\n    if (script.length > 0) this.script = Script.fromRaw(script);\n    return this;\n  }\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   */\n\n\n  fromRaw(data) {\n    return this.fromReader(bio.read(data));\n  }\n  /**\n   * Instantiate a keyring from buffer reader.\n   * @param {BufferReader} br\n   * @returns {KeyRing}\n   */\n\n\n  static fromReader(br) {\n    return new this().fromReader(br);\n  }\n  /**\n   * Instantiate a keyring from serialized data.\n   * @param {Buffer} data\n   * @returns {KeyRing}\n   */\n\n\n  static fromRaw(data) {\n    return new this().fromRaw(data);\n  }\n  /**\n   * Test whether an object is a KeyRing.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n\n  static isKeyRing(obj) {\n    return obj instanceof KeyRing;\n  }\n\n}\n/*\n * Helpers\n */\n\n\nfunction toKey(opt) {\n  if (!opt) return opt;\n  if (opt.privateKey) return opt.privateKey;\n  if (opt.publicKey) return opt.publicKey;\n  return opt;\n}\n/*\n * Expose\n */\n\n\nmodule.exports = KeyRing;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/primitives/keyring.js"],"names":["assert","require","base58","bio","hash160","hash256","Network","Script","Address","Output","secp256k1","encoding","inspectSymbol","ZERO_KEY","Buffer","alloc","KeyRing","constructor","options","nested","publicKey","privateKey","script","_keyHash","_keyAddress","_scriptHash160","_scriptAddress","fromOptions","key","toKey","isBuffer","fromKey","compress","compressed","fromScript","refresh","fromPrivate","privateKeyVerify","publicKeyCreate","fromPublic","publicKeyVerify","generate","privateKeyGenerate","length","fromMultisigScript","i","isMultisig","n","getSmall","code","toData","getSecretSize","size","toSecret","network","bw","write","get","writeU8","keyPrefix","privkey","writeBytes","writeChecksum","digest","encode","render","fromSecret","data","br","read","decode","version","readU8","fromWIF","readBytes","left","verifyChecksum","getPrivateKey","enc","toString","getPublicKey","getScript","getScriptHash","getScriptHash160","getScriptAddress","hash","addr","fromScripthash","toBase58","getKeyHash","getKeyAddress","fromPubkeyhash","getHash","getAddress","ownHash","equals","ownOutput","tx","index","output","outputs","getRedeem","sign","msg","signDER","signSchnorr","schnorrSign","verify","sig","verifyDER","verifySchnorr","schnorrVerify","getVersion","getType","types","SCRIPTHASH","PUBKEYHASH","toJSON","toRaw","type","typesByVal","toLowerCase","address","fromJSON","json","from","getSize","sizeVarBytes","getVarSize","toWriter","field","writeVarBytes","writeVarint","fromReader","readVarBytes","fromRaw","isKeyRing","obj","opt","module","exports"],"mappings":"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","sourcesContent":["/*!\n * keyring.js - keyring object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst {base58} = require('bstring');\nconst bio = require('bufio');\nconst hash160 = require('bcrypto/lib/hash160');\nconst hash256 = require('bcrypto/lib/hash256');\nconst Network = require('../protocol/network');\nconst Script = require('../script/script');\nconst Address = require('./address');\nconst Output = require('./output');\nconst secp256k1 = require('bcrypto/lib/secp256k1');\nconst {encoding} = bio;\nconst {inspectSymbol} = require('../utils');\n\n/*\n * Constants\n */\n\nconst ZERO_KEY = Buffer.alloc(33, 0x00);\n\n/**\n * Key Ring\n * Represents a key ring which amounts to an address.\n * @alias module:primitives.KeyRing\n */\n\nclass KeyRing {\n  /**\n   * Create a key ring.\n   * @constructor\n   * @param {Object} options\n   */\n\n  constructor(options) {\n    this.nested = false;\n    this.publicKey = ZERO_KEY;\n    this.privateKey = null;\n    this.script = null;\n\n    this._keyHash = null;\n    this._keyAddress = null;\n    this._scriptHash160 = null;\n    this._scriptAddress = null;\n\n    if (options)\n      this.fromOptions(options);\n  }\n\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n  fromOptions(options) {\n    let key = toKey(options);\n\n    if (Buffer.isBuffer(key))\n      return this.fromKey(key);\n\n    key = toKey(options.key);\n\n    if (options.publicKey)\n      key = toKey(options.publicKey);\n\n    if (options.privateKey)\n      key = toKey(options.privateKey);\n\n    const script = options.script;\n    const compress = options.compressed;\n\n    if (script)\n      return this.fromScript(key, script, compress);\n\n    return this.fromKey(key, compress);\n  }\n\n  /**\n   * Instantiate key ring from options.\n   * @param {Object} options\n   * @returns {KeyRing}\n   */\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n\n  /**\n   * Clear cached key/script hashes.\n   */\n\n  refresh() {\n    this._keyHash = null;\n    this._keyAddress = null;\n    this._scriptHash160 = null;\n    this._scriptAddress = null;\n  }\n\n  /**\n   * Inject data from private key.\n   * @private\n   * @param {Buffer} key\n   * @param {Boolean?} compress\n   */\n\n  fromPrivate(key, compress) {\n    assert(Buffer.isBuffer(key), 'Private key must be a buffer.');\n    assert(secp256k1.privateKeyVerify(key), 'Not a valid private key.');\n\n    this.privateKey = key;\n    this.publicKey = secp256k1.publicKeyCreate(key, compress !== false);\n\n    return this;\n  }\n\n  /**\n   * Instantiate keyring from a private key.\n   * @param {Buffer} key\n   * @param {Boolean?} compress\n   * @returns {KeyRing}\n   */\n\n  static fromPrivate(key, compress) {\n    return new this().fromPrivate(key, compress);\n  }\n\n  /**\n   * Inject data from public key.\n   * @private\n   * @param {Buffer} key\n   */\n\n  fromPublic(key) {\n    assert(Buffer.isBuffer(key), 'Public key must be a buffer.');\n    assert(secp256k1.publicKeyVerify(key), 'Not a valid public key.');\n    this.publicKey = key;\n    return this;\n  }\n\n  /**\n   * Generate a keyring.\n   * @private\n   * @param {Boolean?} compress\n   * @returns {KeyRing}\n   */\n\n  generate(compress) {\n    const key = secp256k1.privateKeyGenerate();\n    return this.fromKey(key, compress);\n  }\n\n  /**\n   * Generate a keyring.\n   * @param {Boolean?} compress\n   * @returns {KeyRing}\n   */\n\n  static generate(compress) {\n    return new this().generate(compress);\n  }\n\n  /**\n   * Instantiate keyring from a public key.\n   * @param {Buffer} publicKey\n   * @returns {KeyRing}\n   */\n\n  static fromPublic(key) {\n    return new this().fromPublic(key);\n  }\n\n  /**\n   * Inject data from public key.\n   * @private\n   * @param {Buffer} privateKey\n   * @param {Boolean?} compress\n   */\n\n  fromKey(key, compress) {\n    assert(Buffer.isBuffer(key), 'Key must be a buffer.');\n\n    if (key.length === 32)\n      return this.fromPrivate(key, compress !== false);\n\n    return this.fromPublic(key);\n  }\n\n  /**\n   * Instantiate keyring from a public key.\n   * @param {Buffer} publicKey\n   * @param {Boolean?} compress\n   * @returns {KeyRing}\n   */\n\n  static fromKey(key, compress) {\n    return new this().fromKey(key, compress);\n  }\n\n  /**\n   * Inject data from script.\n   * @private\n   * @param {Buffer} key\n   * @param {Script} script\n   * @param {Boolean?} compress\n   */\n\n  fromScript(key, script, compress) {\n    assert(script instanceof Script, 'Non-script passed into KeyRing.');\n\n    this.fromKey(key, compress);\n    this.script = script;\n\n    return this;\n  }\n\n  /**\n   * Instantiate keyring from script.\n   * @param {Buffer} key\n   * @param {Script} script\n   * @param {Boolean?} compress\n   * @returns {KeyRing}\n   */\n\n  static fromScript(key, script, compress) {\n    return new this().fromScript(key, script, compress);\n  }\n\n  /**\n   * Get ith public key from multisig script.\n   * @private\n   * @param {Script} script\n   * @param {Number} i\n   * @returns {KeyRing}\n   */\n\n  fromMultisigScript(script, i) {\n    assert(script instanceof Script, 'Non-script passed.');\n    assert(script.isMultisig(), 'Script must be multisig');\n\n    const n = script.getSmall(-2);\n    assert(i >= 1 && i <= n, 'Requested `i`th key, `n` available');\n\n    this.fromKey(script.code[i].toData());\n\n    return this;\n  }\n\n  /**\n   * Instantiate keyring from ith key in multisig script.\n   * @param {Script} script\n   * @param {Number} i\n   * @returns {KeyRing}\n   */\n\n  static fromMultisigScript(script, i) {\n    return new this().fromMultisigScript(script, i);\n  }\n\n  /**\n   * Calculate WIF serialization size.\n   * @returns {Number}\n   */\n\n  getSecretSize() {\n    let size = 0;\n\n    size += 1;\n    size += this.privateKey.length;\n\n    if (this.publicKey.length === 33)\n      size += 1;\n\n    size += 4;\n\n    return size;\n  }\n\n  /**\n   * Convert key to a CBitcoinSecret.\n   * @param {(Network|NetworkType)?} network\n   * @returns {Base58String}\n   */\n\n  toSecret(network) {\n    const size = this.getSecretSize();\n    const bw = bio.write(size);\n\n    assert(this.privateKey, 'Cannot serialize without private key.');\n\n    network = Network.get(network);\n\n    bw.writeU8(network.keyPrefix.privkey);\n    bw.writeBytes(this.privateKey);\n\n    if (this.publicKey.length === 33)\n      bw.writeU8(1);\n\n    bw.writeChecksum(hash256.digest);\n\n    return base58.encode(bw.render());\n  }\n\n  /**\n   * Inject properties from serialized CBitcoinSecret.\n   * @private\n   * @param {Base58String} secret\n   * @param {(Network|NetworkType)?} network\n   */\n\n  fromSecret(data, network) {\n    const br = bio.read(base58.decode(data), true);\n\n    const version = br.readU8();\n\n    Network.fromWIF(version, network);\n\n    const key = br.readBytes(32);\n\n    let compress = false;\n\n    if (br.left() > 4) {\n      assert(br.readU8() === 1, 'Bad compression flag.');\n      compress = true;\n    }\n\n    br.verifyChecksum(hash256.digest);\n\n    return this.fromPrivate(key, compress);\n  }\n\n  /**\n   * Instantiate a keyring from a serialized CBitcoinSecret.\n   * @param {Base58String} secret\n   * @param {(Network|NetworkType)?} network\n   * @returns {KeyRing}\n   */\n\n  static fromSecret(data, network) {\n    return new this().fromSecret(data, network);\n  }\n\n  /**\n   * Get private key.\n   * @param {String?} enc - Can be `\"hex\"`, `\"base58\"`, or `null`.\n   * @returns {Buffer} Private key.\n   */\n\n  getPrivateKey(enc, network) {\n    if (!this.privateKey)\n      return null;\n\n    if (enc === 'base58')\n      return this.toSecret(network);\n\n    if (enc === 'hex')\n      return this.privateKey.toString('hex');\n\n    return this.privateKey;\n  }\n\n  /**\n   * Get public key.\n   * @param {String?} enc - `\"hex\"` or `null`.\n   * @returns {Buffer}\n   */\n\n  getPublicKey(enc) {\n    if (enc === 'base58')\n      return base58.encode(this.publicKey);\n\n    if (enc === 'hex')\n      return this.publicKey.toString('hex');\n\n    return this.publicKey;\n  }\n\n  /**\n   * Get redeem script.\n   * @returns {Script}\n   */\n\n  getScript() {\n    return this.script;\n  }\n\n  /**\n   * Get scripthash.\n   * @param {String?} enc - `\"hex\"` or `null`.\n   * @returns {Buffer}\n   */\n\n  getScriptHash(enc) {\n    return this.getScriptHash160(enc);\n  }\n\n  /**\n   * Get ripemd160 scripthash.\n   * @param {String?} enc - `\"hex\"` or `null`.\n   * @returns {Buffer}\n   */\n\n  getScriptHash160(enc) {\n    if (!this.script)\n      return null;\n\n    if (!this._scriptHash160)\n      this._scriptHash160 = this.script.hash160();\n\n    return enc === 'hex'\n      ? this._scriptHash160.toString('hex')\n      : this._scriptHash160;\n  }\n\n  /**\n   * Get scripthash address.\n   * @param {String?} enc - `\"base58\"` or `null`.\n   * @returns {Address|AddressString}\n   */\n\n  getScriptAddress(enc, network) {\n    if (!this.script)\n      return null;\n\n    if (!this._scriptAddress) {\n      const hash = this.getScriptHash160();\n      const addr = Address.fromScripthash(hash);\n\n      this._scriptAddress = addr;\n    }\n\n    if (enc === 'base58')\n      return this._scriptAddress.toBase58(network);\n\n    if (enc === 'string')\n      return this._scriptAddress.toString(network);\n\n    return this._scriptAddress;\n  }\n\n  /**\n   * Get public key hash.\n   * @param {String?} enc - `\"hex\"` or `null`.\n   * @returns {Buffer}\n   */\n\n  getKeyHash(enc) {\n    if (!this._keyHash)\n      this._keyHash = hash160.digest(this.publicKey);\n\n    return enc === 'hex'\n      ? this._keyHash.toString('hex')\n      : this._keyHash;\n  }\n\n  /**\n   * Get pubkeyhash address.\n   * @param {String?} enc - `\"base58\"` or `null`.\n   * @returns {Address|AddressString}\n   */\n\n  getKeyAddress(enc, network) {\n    if (!this._keyAddress) {\n      const hash = this.getKeyHash();\n      const addr = Address.fromPubkeyhash(hash);\n\n      this._keyAddress = addr;\n    }\n\n    if (enc === 'base58')\n      return this._keyAddress.toBase58(network);\n\n    if (enc === 'string')\n      return this._keyAddress.toString(network);\n\n    return this._keyAddress;\n  }\n\n  /**\n   * Get hash.\n   * @param {String?} enc - `\"hex\"` or `null`.\n   * @returns {Buffer}\n   */\n\n  getHash(enc) {\n    if (this.script)\n      return this.getScriptHash(enc);\n\n    return this.getKeyHash(enc);\n  }\n\n  /**\n   * Get base58 address.\n   * @param {String?} enc - `\"base58\"` or `null`.\n   * @returns {Address|AddressString}\n   */\n\n  getAddress(enc, network) {\n    if (this.script)\n      return this.getScriptAddress(enc, network);\n\n    return this.getKeyAddress(enc, network);\n  }\n\n  /**\n   * Test an address hash against hash.\n   * @param {Buffer} hash\n   * @returns {Boolean}\n   */\n\n  ownHash(hash) {\n    if (!hash)\n      return false;\n\n    if (hash.equals(this.getKeyHash()))\n      return true;\n\n    if (this.script) {\n      if (hash.equals(this.getScriptHash()))\n        return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Check whether transaction output belongs to this address.\n   * @param {TX|Output} tx - Transaction or Output.\n   * @param {Number?} index - Output index.\n   * @returns {Boolean}\n   */\n\n  ownOutput(tx, index) {\n    let output;\n\n    if (tx instanceof Output) {\n      output = tx;\n    } else {\n      output = tx.outputs[index];\n      assert(output, 'Output does not exist.');\n    }\n\n    return this.ownHash(output.getHash());\n  }\n\n  /**\n   * Test a hash against script hashes to\n   * find the correct redeem script, if any.\n   * @param {Buffer} hash\n   * @returns {Script|null}\n   */\n\n  getRedeem(hash) {\n    if (this.script) {\n      if (hash.equals(this.getScriptHash160()))\n        return this.script;\n    }\n\n    return null;\n  }\n\n  /**\n   * Sign a message.\n   * @param {Buffer} msg\n   * @returns {Buffer} Signature in DER format.\n   */\n\n  sign(msg) {\n    assert(this.privateKey, 'Cannot sign without private key.');\n    return secp256k1.signDER(msg, this.privateKey);\n  }\n\n  /**\n   * Sign a message.\n   * @param {Buffer} msg\n   * @returns {Buffer} Signature in Schnorr format.\n   */\n\n  signSchnorr(msg) {\n    assert(this.privateKey, 'Cannot sign without private key.');\n    return secp256k1.schnorrSign(msg, this.privateKey);\n  }\n\n  /**\n   * Verify a message.\n   * @param {Buffer} msg\n   * @param {Buffer} sig - Signature in DER format.\n   * @returns {Boolean}\n   */\n\n  verify(msg, sig) {\n    return secp256k1.verifyDER(msg, sig, this.publicKey);\n  }\n\n  /**\n   * Verify a message.\n   * @param {Buffer} msg\n   * @param {Buffer} sig - Signature in Schnorr format.\n   * @returns {Boolean}\n   */\n\n  verifySchnorr(msg, sig) {\n    return secp256k1.schnorrVerify(msg, sig, this.publicKey);\n  }\n\n  /**\n   * Get witness program version.\n   * @returns {Number}\n   */\n\n  getVersion() {\n    return -1;\n  }\n\n  /**\n   * Get address type.\n   * @returns {ScriptType}\n   */\n\n  getType() {\n    if (this.script)\n      return Address.types.SCRIPTHASH;\n\n    return Address.types.PUBKEYHASH;\n  }\n\n  /**\n   * Inspect keyring.\n   * @returns {Object}\n   */\n\n  [inspectSymbol]() {\n    return this.toJSON();\n  }\n\n  /**\n   * Convert an KeyRing to a more json-friendly object.\n   * @returns {Object}\n   */\n\n  toJSON(network) {\n    return {\n      publicKey: this.publicKey.toString('hex'),\n      script: this.script ? this.script.toRaw().toString('hex') : null,\n      type: Address.typesByVal[this.getType()].toLowerCase(),\n      address: this.getAddress('string', network)\n    };\n  }\n\n  /**\n   * Inject properties from json object.\n   * @private\n   * @param {Object} json\n   */\n\n  fromJSON(json) {\n    assert(json);\n    assert(typeof json.publicKey === 'string');\n    assert(!json.script || typeof json.script === 'string');\n\n    this.publicKey = Buffer.from(json.publicKey, 'hex');\n\n    if (json.script)\n      this.script = Buffer.from(json.script, 'hex');\n\n    return this;\n  }\n\n  /**\n   * Instantiate an KeyRing from a jsonified transaction object.\n   * @param {Object} json - The jsonified transaction object.\n   * @returns {KeyRing}\n   */\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n\n  /**\n   * Calculate serialization size.\n   * @returns {Number}\n   */\n\n  getSize() {\n    let size = 0;\n    size += 1;\n    if (this.privateKey) {\n      size += encoding.sizeVarBytes(this.privateKey);\n      size += 1;\n    } else {\n      size += encoding.sizeVarBytes(this.publicKey);\n    }\n    size += this.script ? this.script.getVarSize() : 1;\n    return size;\n  }\n\n  /**\n   * Write the keyring to a buffer writer.\n   * @param {BufferWriter} bw\n   */\n\n  toWriter(bw) {\n    const field = 0;\n\n    // we don't use field for now,\n    // we can use this for flags different\n    // flags in the future.\n    bw.writeU8(field);\n\n    if (this.privateKey) {\n      bw.writeVarBytes(this.privateKey);\n      bw.writeU8(this.publicKey.length === 33 ? 1 : 0);\n    } else {\n      bw.writeVarBytes(this.publicKey);\n    }\n\n    if (this.script)\n      bw.writeVarBytes(this.script.toRaw());\n    else\n      bw.writeVarint(0);\n\n    return bw;\n  }\n\n  /**\n   * Serialize the keyring.\n   * @returns {Buffer}\n   */\n\n  toRaw() {\n    const size = this.getSize();\n    return this.toWriter(bio.write(size)).render();\n  }\n\n  /**\n   * Inject properties from buffer reader.\n   * @private\n   * @param {BufferReader} br\n   */\n\n  fromReader(br) {\n    // we are not interested in flags.\n    br.readU8();\n\n    const key = br.readVarBytes();\n\n    if (key.length === 32) {\n      const compress = br.readU8() === 1;\n      this.privateKey = key;\n      this.publicKey = secp256k1.publicKeyCreate(key, compress);\n    } else {\n      this.publicKey = key;\n      assert(secp256k1.publicKeyVerify(key), 'Invalid public key.');\n    }\n\n    const script = br.readVarBytes();\n\n    if (script.length > 0)\n      this.script = Script.fromRaw(script);\n\n    return this;\n  }\n\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   */\n\n  fromRaw(data) {\n    return this.fromReader(bio.read(data));\n  }\n\n  /**\n   * Instantiate a keyring from buffer reader.\n   * @param {BufferReader} br\n   * @returns {KeyRing}\n   */\n\n  static fromReader(br) {\n    return new this().fromReader(br);\n  }\n\n  /**\n   * Instantiate a keyring from serialized data.\n   * @param {Buffer} data\n   * @returns {KeyRing}\n   */\n\n  static fromRaw(data) {\n    return new this().fromRaw(data);\n  }\n\n  /**\n   * Test whether an object is a KeyRing.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n  static isKeyRing(obj) {\n    return obj instanceof KeyRing;\n  }\n}\n\n/*\n * Helpers\n */\n\nfunction toKey(opt) {\n  if (!opt)\n    return opt;\n\n  if (opt.privateKey)\n    return opt.privateKey;\n\n  if (opt.publicKey)\n    return opt.publicKey;\n\n  return opt;\n}\n\n/*\n * Expose\n */\n\nmodule.exports = KeyRing;\n"]},"metadata":{},"sourceType":"module"}