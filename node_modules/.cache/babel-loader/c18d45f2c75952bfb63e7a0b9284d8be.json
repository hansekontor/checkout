{"ast":null,"code":"/*!\n * schnorr.js - bip340 for bcrypto\n * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on bips/bip-0340:\n *   Copyright (c) 2018-2020, Pieter Wuille (2-clause BSD License).\n *   https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py\n *\n * Parts of this software are based on bitcoin-core/secp256k1:\n *   Copyright (c) 2013, Pieter Wuille.\n *   https://github.com/bitcoin-core/secp256k1\n *\n * Resources:\n *   https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n *   https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py\n *   https://github.com/bitcoin/bips/blob/master/bip-0340/test-vectors.csv\n *\n * References:\n *\n *   [BIP340] Schnorr Signatures for secp256k1\n *     Pieter Wuille, Jonas Nick, Tim Ruffing\n *     https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst BatchRNG = require('./batch-rng');\n\nconst BN = require('../bn');\n\nconst rng = require('../random');\n\nconst SHA256 = require('../sha256');\n\nconst elliptic = require('./elliptic');\n\nconst pre = require('./precomputed/secp256k1.json');\n/**\n * Schnorr\n */\n\n\nclass Schnorr {\n  constructor(name, hash, pre) {\n    assert(typeof name === 'string');\n    assert(hash);\n    this.id = name;\n    this.type = 'schnorr';\n    this.hash = hash;\n    this.native = 0;\n    this._pre = pre || null;\n    this._curve = null;\n    this._rng = null;\n    this._auxTag = null;\n    this._nonceTag = null;\n    this._challengeTag = null;\n  }\n\n  get curve() {\n    if (!this._curve) {\n      this._curve = elliptic.curve(this.id, this._pre);\n\n      this._curve.precompute(rng);\n\n      this._pre = null;\n      this.check();\n    }\n\n    return this._curve;\n  }\n\n  get rng() {\n    if (!this._rng) this._rng = new BatchRNG(this.curve);\n    return this._rng;\n  }\n\n  get size() {\n    return this.curve.fieldSize;\n  }\n\n  get bits() {\n    return this.curve.fieldBits;\n  }\n\n  check() {\n    // [BIP340] \"Footnotes\".\n    // Must be congruent to 3 mod 4.\n    if (this.curve.p.andln(3) !== 3) throw new Error(`Schnorr is not supported for ${this.curve.id}.`);\n  }\n\n  hashInt() {\n    // [BIP340] \"Specification\".\n    // eslint-disable-next-line\n    const h = new this.hash();\n    h.init();\n\n    for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n      items[_key] = arguments[_key];\n    }\n\n    for (const item of items) h.update(item);\n\n    let hash = h.final();\n    if (hash.length > this.curve.scalarSize) hash = hash.slice(0, this.curve.scalarSize);\n    const num = BN.decode(hash, this.curve.endian);\n    return num.imod(this.curve.n);\n  }\n\n  hashAux(a, d) {\n    assert(Buffer.isBuffer(a));\n    assert(Buffer.isBuffer(d));\n    if (!this._auxTag) this._auxTag = createTag(this.hash, 'BIP340/aux');\n    if (d.length > 32) d = d.slice(0, 32); // eslint-disable-next-line\n\n    const h = new this.hash();\n    h.init();\n    h.update(this._auxTag);\n    h.update(d);\n    const hash = h.final();\n    const t = Buffer.alloc(a.length);\n\n    for (let i = 0; i < t.length; i++) t[i] = a[i] ^ hash[i % hash.length];\n\n    return t;\n  }\n\n  hashNonce(a, A, m, d) {\n    if (!this._nonceTag) this._nonceTag = createTag(this.hash, 'BIP340/nonce');\n    return this.hashInt(this._nonceTag, this.hashAux(a, d), A, m);\n  }\n\n  hashChallenge(R, A, m) {\n    if (!this._challengeTag) this._challengeTag = createTag(this.hash, 'BIP340/challenge');\n    return this.hashInt(this._challengeTag, R, A, m);\n  }\n\n  privateKeyGenerate() {\n    const a = this.curve.randomScalar(rng);\n    return this.curve.encodeScalar(a);\n  }\n\n  privateKeyVerify(key) {\n    assert(Buffer.isBuffer(key));\n    let a;\n\n    try {\n      a = this.curve.decodeScalar(key);\n    } catch (e) {\n      return false;\n    }\n\n    return !a.isZero() && a.cmp(this.curve.n) < 0;\n  }\n\n  privateKeyExport(key) {\n    const a = this.curve.decodeScalar(key);\n    if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');\n    let A = this.curve.g.mul(a);\n\n    if (!A.isEven()) {\n      a.ineg().imod(this.curve.n);\n      A = A.neg();\n    }\n\n    return {\n      d: this.curve.encodeScalar(a),\n      x: this.curve.encodeField(A.x.fromRed()),\n      y: this.curve.encodeField(A.y.fromRed())\n    };\n  }\n\n  privateKeyImport(json) {\n    assert(json && typeof json === 'object');\n    const a = BN.decode(json.d, this.curve.endian);\n    if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');\n    return this.curve.encodeScalar(a);\n  }\n\n  privateKeyTweakAdd(key, tweak) {\n    const t = this.curve.decodeScalar(tweak);\n    if (t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');\n    const a = this.curve.decodeScalar(key);\n    if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');\n    const A = this.curve.g.mul(a);\n    if (!A.isEven()) a.ineg().imod(this.curve.n);\n    const k = a.add(t).imod(this.curve.n);\n    if (k.isZero()) throw new Error('Invalid private key.');\n    return this.curve.encodeScalar(k);\n  }\n\n  privateKeyTweakMul(key, tweak) {\n    const t = this.curve.decodeScalar(tweak);\n    if (t.isZero() || t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');\n    const a = this.curve.decodeScalar(key);\n    if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');\n    const k = a.mul(t).imod(this.curve.n);\n    if (k.isZero()) throw new Error('Invalid private key.');\n    return this.curve.encodeScalar(k);\n  }\n\n  privateKeyReduce(key) {\n    assert(Buffer.isBuffer(key));\n    if (key.length > this.curve.scalarSize) key = key.slice(0, this.curve.scalarSize);\n    const a = BN.decode(key, this.curve.endian).imod(this.curve.n);\n    if (a.isZero()) throw new Error('Invalid private key.');\n    return this.curve.encodeScalar(a);\n  }\n\n  privateKeyInvert(key) {\n    const a = this.curve.decodeScalar(key);\n    if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');\n    const k = a.invert(this.curve.n);\n    return this.curve.encodeScalar(k);\n  }\n\n  publicKeyCreate(key) {\n    // [BIP340] \"Public Key Generation\".\n    const a = this.curve.decodeScalar(key);\n    if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');\n    const A = this.curve.g.mulBlind(a);\n    return A.encodeX();\n  }\n\n  publicKeyFromUniform(bytes) {\n    const u = this.curve.decodeUniform(bytes);\n    const A = this.curve.pointFromUniform(u);\n    return A.encodeX();\n  }\n\n  publicKeyToUniform(key) {\n    let hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : rng.randomInt();\n    const A = this.curve.decodeEven(key);\n    const u = this.curve.pointToUniform(A, hint);\n    return this.curve.encodeUniform(u, rng);\n  }\n\n  publicKeyFromHash(bytes) {\n    const A = this.curve.pointFromHash(bytes);\n    return A.encodeX();\n  }\n\n  publicKeyToHash(key) {\n    const A = this.curve.decodeEven(key);\n    return this.curve.pointToHash(A, rng);\n  }\n\n  publicKeyVerify(key) {\n    assert(Buffer.isBuffer(key));\n\n    try {\n      this.curve.decodeEven(key);\n    } catch (e) {\n      return false;\n    }\n\n    return true;\n  }\n\n  publicKeyExport(key) {\n    const {\n      x,\n      y\n    } = this.curve.decodeEven(key);\n    return {\n      x: this.curve.encodeField(x.fromRed()),\n      y: this.curve.encodeField(y.fromRed())\n    };\n  }\n\n  publicKeyImport(json) {\n    assert(json && typeof json === 'object');\n    const x = BN.decode(json.x, this.curve.endian);\n    if (x.cmp(this.curve.p) >= 0) throw new Error('Invalid point.');\n    const A = this.curve.pointFromX(x);\n    return A.encodeX();\n  }\n\n  publicKeyTweakAdd(key, tweak) {\n    const t = this.curve.decodeScalar(tweak);\n    if (t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');\n    const A = this.curve.decodeEven(key);\n    const T = this.curve.g.jmul(t);\n    const P = T.add(A);\n    return P.encodeX();\n  }\n\n  publicKeyTweakMul(key, tweak) {\n    const t = this.curve.decodeScalar(tweak);\n    if (t.isZero() || t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');\n    const A = this.curve.decodeEven(key);\n    const P = A.mul(t);\n    return P.encodeX();\n  }\n\n  publicKeyTweakTest(key, tweak, negate, test) {\n    assert(typeof negate === 'boolean');\n    const t = this.curve.decodeScalar(tweak);\n    if (t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');\n    const A = this.curve.decodeEven(key);\n    const T = this.curve.g.jmul(t);\n    const Q = this.curve.decodeEven(test);\n    let P = T.add(A);\n    if (negate) P = P.neg();\n    return P.eq(Q.toJ());\n  }\n\n  publicKeyCombine(keys) {\n    assert(Array.isArray(keys));\n    let P = this.curve.jpoint();\n\n    for (const key of keys) {\n      const A = this.curve.decodeEven(key);\n      P = P.add(A);\n    }\n\n    return P.encodeX();\n  }\n\n  sign(msg, key) {\n    let aux = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : rng.randomBytes(32);\n    assert(Buffer.isBuffer(msg));\n    assert(Buffer.isBuffer(aux));\n    return this._sign(msg, key, aux);\n  }\n\n  _sign(msg, key, aux) {\n    // Schnorr Signing.\n    //\n    // [BIP340] \"Default Signing\".\n    //\n    // Assumptions:\n    //\n    //   - Let `H` be a cryptographic hash function.\n    //   - Let `m` be a 32-byte array.\n    //   - Let `a` be a secret non-zero scalar.\n    //   - Let `d` be a 0 to 32-byte array.\n    //   - k != 0.\n    //\n    // Computation:\n    //\n    //   A = G * a\n    //   a = -a mod n, if y(A) is not even\n    //   x = x(A)\n    //   t = a xor H(\"BIP340/aux\", d)\n    //   k = H(\"BIP340/nonce\", t, x, m) mod n\n    //   R = G * k\n    //   k = -k mod n, if y(R) is not square\n    //   r = x(R)\n    //   e = H(\"BIP340/challenge\", r, x, m) mod n\n    //   s = (k + e * a) mod n\n    //   S = (r, s)\n    //\n    // Note that `k` must remain secret,\n    // otherwise an attacker can compute:\n    //\n    //   a = (s - k) / e mod n\n    const {\n      n\n    } = this.curve;\n    const G = this.curve.g;\n    const a = this.curve.decodeScalar(key);\n    if (a.isZero() || a.cmp(n) >= 0) throw new Error('Invalid private key.');\n    const A = G.mulBlind(a);\n    if (!A.isEven()) a.ineg().imod(n);\n    const araw = this.curve.encodeScalar(a);\n    const Araw = A.encodeX();\n    const k = this.hashNonce(araw, Araw, msg, aux);\n    if (k.isZero()) throw new Error('Signing failed (k\\' = 0).');\n    const R = G.mulBlind(k);\n    if (!R.isSquare()) k.ineg().imod(n);\n    const Rraw = R.encodeX();\n    const e = this.hashChallenge(Rraw, Araw, msg);\n    const s = k.add(e.mul(a)).imod(n);\n    return Buffer.concat([Rraw, this.curve.encodeScalar(s)]);\n  }\n\n  verify(msg, sig, key) {\n    assert(Buffer.isBuffer(msg));\n    assert(Buffer.isBuffer(sig));\n    assert(Buffer.isBuffer(key));\n    if (sig.length !== this.curve.fieldSize + this.curve.scalarSize) return false;\n    if (key.length !== this.curve.fieldSize) return false;\n\n    try {\n      return this._verify(msg, sig, key);\n    } catch (e) {\n      return false;\n    }\n  }\n\n  _verify(msg, sig, key) {\n    // Schnorr Verification.\n    //\n    // [BIP340] \"Verification\".\n    //\n    // Assumptions:\n    //\n    //   - Let `H` be a cryptographic hash function.\n    //   - Let `m` be a 32-byte array.\n    //   - Let `r` and `s` be signature elements.\n    //   - Let `x` be a field element.\n    //   - r^3 + a * r + b is square in F(p).\n    //   - x^3 + a * x + b is even in F(p).\n    //   - r < p, s < n, x < p.\n    //   - R != O.\n    //\n    // Computation:\n    //\n    //   R = (r, sqrt(r^3 + a * r + b))\n    //   A = (x, sqrt(x^3 + a * x + b))\n    //   e = H(\"BIP340/challenge\", r, x, m) mod n\n    //   R == G * s - A * e\n    //\n    // We can skip a square root with:\n    //\n    //   A = (x, sqrt(x^3 + a * x + b))\n    //   e = H(\"BIP340/challenge\", r, x, m) mod n\n    //   R = G * s - A * e\n    //   y(R) is square\n    //   x(R) == r\n    //\n    // We can also avoid affinization by\n    // replacing the two assertions with:\n    //\n    //   (y(R) * z(R) mod p) is square\n    //   x(R) == r * z(R)^2 mod p\n    //\n    // Furthermore, squareness can be calculated\n    // with a variable time Jacobi symbol algorithm.\n    const {\n      p,\n      n\n    } = this.curve;\n    const G = this.curve.g;\n    const Rraw = sig.slice(0, this.curve.fieldSize);\n    const sraw = sig.slice(this.curve.fieldSize);\n    const r = this.curve.decodeField(Rraw);\n    const s = this.curve.decodeScalar(sraw);\n    const A = this.curve.decodeEven(key);\n    if (r.cmp(p) >= 0 || s.cmp(n) >= 0) return false;\n    const e = this.hashChallenge(Rraw, key, msg);\n    const R = G.jmulAdd(s, A, e.ineg().imod(n));\n    if (!R.isSquare()) return false;\n    if (!R.eqX(r)) return false;\n    return true;\n  }\n\n  verifyBatch(batch) {\n    assert(Array.isArray(batch));\n\n    for (const item of batch) {\n      assert(Array.isArray(item) && item.length === 3);\n      const [msg, sig, key] = item;\n      assert(Buffer.isBuffer(msg));\n      assert(Buffer.isBuffer(sig));\n      assert(Buffer.isBuffer(key));\n      if (sig.length !== this.curve.fieldSize + this.curve.scalarSize) return false;\n      if (key.length !== this.curve.fieldSize) return false;\n    }\n\n    try {\n      return this._verifyBatch(batch);\n    } catch (e) {\n      return false;\n    }\n  }\n\n  _verifyBatch(batch) {\n    // Schnorr Batch Verification.\n    //\n    // [BIP340] \"Batch Verification\".\n    //\n    // Assumptions:\n    //\n    //   - Let `H` be a cryptographic hash function.\n    //   - Let `m` be a 32-byte array.\n    //   - Let `r` and `s` be signature elements.\n    //   - Let `x` be a field element.\n    //   - Let `i` be the batch item index.\n    //   - r^3 + a * r + b is square in F(p).\n    //   - x^3 + a * x + b is even in F(p).\n    //   - r < p, s < n, x < p.\n    //   - a1 = 1 mod n.\n    //\n    // Computation:\n    //\n    //   Ri = (ri, sqrt(ri^3 + a * ri + b))\n    //   Ai = (xi, sqrt(xi^3 + a * xi + b))\n    //   ei = H(\"BIP340/challenge\", ri, xi, mi) mod n\n    //   ai = random integer in [1,n-1]\n    //   lhs = si * ai + ... mod n\n    //   rhs = Ri * ai + Ai * (ei * ai mod n) + ...\n    //   G * -lhs + rhs == O\n    const {\n      n\n    } = this.curve;\n    const G = this.curve.g;\n    const points = new Array(1 + batch.length * 2);\n    const coeffs = new Array(1 + batch.length * 2);\n    const sum = new BN(0);\n    this.rng.init(batch);\n    points[0] = G;\n    coeffs[0] = sum;\n\n    for (let i = 0; i < batch.length; i++) {\n      const [msg, sig, key] = batch[i];\n      const Rraw = sig.slice(0, this.curve.fieldSize);\n      const sraw = sig.slice(this.curve.fieldSize);\n      const R = this.curve.decodeSquare(Rraw);\n      const s = this.curve.decodeScalar(sraw);\n      const A = this.curve.decodeEven(key);\n      if (s.cmp(n) >= 0) return false;\n      const e = this.hashChallenge(Rraw, key, msg);\n      const a = this.rng.generate(i);\n      const ea = e.mul(a).imod(n);\n      sum.iadd(s.mul(a)).imod(n);\n      points[1 + i * 2 + 0] = R;\n      coeffs[1 + i * 2 + 0] = a;\n      points[1 + i * 2 + 1] = A;\n      coeffs[1 + i * 2 + 1] = ea;\n    }\n\n    sum.ineg().imod(n);\n    return this.curve.jmulAll(points, coeffs).isInfinity();\n  }\n\n  derive(pub, priv) {\n    const A = this.curve.decodeEven(pub);\n    const a = this.curve.decodeScalar(priv);\n    if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');\n    const P = A.mulConst(a, rng);\n    return P.encodeX();\n  }\n\n}\n/*\n * Helpers\n */\n\n\nfunction createTag(alg, tag) {\n  // [BIP340] \"Tagged Hashes\".\n  const raw = Buffer.from(tag, 'binary');\n  const hash = alg.digest(raw);\n  return Buffer.concat([hash, hash]);\n}\n/*\n * Expose\n */\n\n\nmodule.exports = new Schnorr('SECP256K1', SHA256, pre);","map":null,"metadata":{},"sourceType":"script"}