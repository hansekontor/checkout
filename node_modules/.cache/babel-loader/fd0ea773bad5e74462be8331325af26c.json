{"ast":null,"code":"/*!\n * compress.js - coin compressor for bcoin\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n/**\n * @module coins/compress\n * @ignore\n */\n\nconst assert = require('bsert');\n\nconst {\n  encoding\n} = require('bufio');\n\nconst secp256k1 = require('bcrypto/lib/secp256k1');\n\nconst consensus = require('../protocol/consensus');\n/*\n * Constants\n */\n\n\nconst COMPRESS_TYPES = 6;\nconst EMPTY_BUFFER = Buffer.alloc(0);\n/**\n * Compress a script, write directly to the buffer.\n * @param {Script} script\n * @param {BufferWriter} bw\n */\n\nfunction compressScript(script, bw) {\n  // Attempt to compress the output scripts.\n  // We can _only_ ever compress them if\n  // they are serialized as minimaldata, as\n  // we need to recreate them when we read\n  // them.\n  // P2PKH -> 0 | key-hash\n  // Saves 5 bytes.\n  const pkh = script.getPubkeyhash(true);\n\n  if (pkh) {\n    bw.writeU8(0);\n    bw.writeBytes(pkh);\n    return bw;\n  } // P2SH -> 1 | script-hash\n  // Saves 3 bytes.\n\n\n  const sh = script.getScripthash();\n\n  if (sh) {\n    bw.writeU8(1);\n    bw.writeBytes(sh);\n    return bw;\n  } // P2PK -> 2-5 | compressed-key\n  // Only works if the key is valid.\n  // Saves up to 35 bytes.\n\n\n  const pk = script.getPubkey(true);\n\n  if (pk) {\n    if (publicKeyVerify(pk)) {\n      const key = compressKey(pk);\n      bw.writeBytes(key);\n      return bw;\n    }\n  } // Raw -> varlen + 10 | script\n\n\n  bw.writeVarint(script.raw.length + COMPRESS_TYPES);\n  bw.writeBytes(script.raw);\n  return bw;\n}\n/**\n * Decompress a script from buffer reader.\n * @param {Script} script\n * @param {BufferReader} br\n */\n\n\nfunction decompressScript(script, br) {\n  // Decompress the script.\n  switch (br.readU8()) {\n    case 0:\n      {\n        const hash = br.readBytes(20, true);\n        script.fromPubkeyhash(hash);\n        break;\n      }\n\n    case 1:\n      {\n        const hash = br.readBytes(20, true);\n        script.fromScripthash(hash);\n        break;\n      }\n\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n      {\n        br.offset -= 1;\n        const data = br.readBytes(33, true); // Decompress the key. If this fails,\n        // we have database corruption!\n\n        const key = decompressKey(data);\n        script.fromPubkey(key);\n        break;\n      }\n\n    default:\n      {\n        br.offset -= 1;\n        const size = br.readVarint() - COMPRESS_TYPES;\n\n        if (size > consensus.MAX_SCRIPT_SIZE) {\n          // This violates consensus rules.\n          // We don't need to read it.\n          script.fromNulldata(EMPTY_BUFFER);\n          br.seek(size);\n        } else {\n          const data = br.readBytes(size);\n          script.fromRaw(data);\n        }\n\n        break;\n      }\n  }\n\n  return script;\n}\n/**\n * Calculate script size.\n * @returns {Number}\n */\n\n\nfunction sizeScript(script) {\n  if (script.isPubkeyhash(true)) return 21;\n  if (script.isScripthash()) return 21;\n  const pk = script.getPubkey(true);\n\n  if (pk) {\n    if (publicKeyVerify(pk)) return 33;\n  }\n\n  let size = 0;\n  size += encoding.sizeVarint(script.raw.length + COMPRESS_TYPES);\n  size += script.raw.length;\n  return size;\n}\n/**\n * Compress an output.\n * @param {Output} output\n * @param {BufferWriter} bw\n */\n\n\nfunction compressOutput(output, bw) {\n  bw.writeVarint(output.value);\n  compressScript(output.script, bw);\n  return bw;\n}\n/**\n * Decompress a script from buffer reader.\n * @param {Output} output\n * @param {BufferReader} br\n */\n\n\nfunction decompressOutput(output, br) {\n  output.value = br.readVarint();\n  decompressScript(output.script, br);\n  return output;\n}\n/**\n * Calculate output size.\n * @returns {Number}\n */\n\n\nfunction sizeOutput(output) {\n  let size = 0;\n  size += encoding.sizeVarint(output.value);\n  size += sizeScript(output.script);\n  return size;\n}\n/**\n * Compress value using an exponent. Takes advantage of\n * the fact that many bitcoin values are divisible by 10.\n * @see https://github.com/btcsuite/btcd/blob/master/blockchain/compress.go\n * @param {Amount} value\n * @returns {Number}\n */\n\n\nfunction compressValue(value) {\n  if (value === 0) return 0;\n  let exp = 0;\n\n  while (value % 10 === 0 && exp < 9) {\n    value /= 10;\n    exp++;\n  }\n\n  if (exp < 9) {\n    const last = value % 10;\n    value = (value - last) / 10;\n    return 1 + 10 * (9 * value + last - 1) + exp;\n  }\n\n  return 10 + 10 * (value - 1);\n}\n/**\n * Decompress value.\n * @param {Number} value - Compressed value.\n * @returns {Amount} value\n */\n\n\nfunction decompressValue(value) {\n  if (value === 0) return 0;\n  value--;\n  let exp = value % 10;\n  value = (value - exp) / 10;\n  let n;\n\n  if (exp < 9) {\n    const last = value % 9;\n    value = (value - last) / 9;\n    n = value * 10 + last + 1;\n  } else {\n    n = value + 1;\n  }\n\n  while (exp > 0) {\n    n *= 10;\n    exp--;\n  }\n\n  return n;\n}\n/**\n * Verify a public key (no hybrid keys allowed).\n * @param {Buffer} key\n * @returns {Boolean}\n */\n\n\nfunction publicKeyVerify(key) {\n  if (key.length === 0) return false;\n\n  switch (key[0]) {\n    case 0x02:\n    case 0x03:\n      return key.length === 33;\n\n    case 0x04:\n      if (key.length !== 65) return false;\n      return secp256k1.publicKeyVerify(key);\n\n    default:\n      return false;\n  }\n}\n/**\n * Compress a public key to coins compression format.\n * @param {Buffer} key\n * @returns {Buffer}\n */\n\n\nfunction compressKey(key) {\n  let out;\n\n  switch (key[0]) {\n    case 0x02:\n    case 0x03:\n      // Key is already compressed.\n      out = key;\n      break;\n\n    case 0x04:\n      // Compress the key normally.\n      out = secp256k1.publicKeyConvert(key, true); // Store the oddness.\n      // Pseudo-hybrid format.\n\n      out[0] = 0x04 | key[64] & 0x01;\n      break;\n\n    default:\n      throw new Error('Bad point format.');\n  }\n\n  assert(out.length === 33);\n  return out;\n}\n/**\n * Decompress a public key from the coins compression format.\n * @param {Buffer} key\n * @returns {Buffer}\n */\n\n\nfunction decompressKey(key) {\n  const format = key[0];\n  assert(key.length === 33);\n\n  switch (format) {\n    case 0x02:\n    case 0x03:\n      return key;\n\n    case 0x04:\n      key[0] = 0x02;\n      break;\n\n    case 0x05:\n      key[0] = 0x03;\n      break;\n\n    default:\n      throw new Error('Bad point format.');\n  } // Decompress the key.\n\n\n  const out = secp256k1.publicKeyConvert(key, false); // Reset the first byte so as not to\n  // mutate the original buffer.\n\n  key[0] = format;\n  return out;\n} // Make eslint happy.\n\n\ncompressValue;\ndecompressValue;\n/*\n * Expose\n */\n\nexports.pack = compressOutput;\nexports.unpack = decompressOutput;\nexports.size = sizeOutput;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/coins/compress.js"],"names":["assert","require","encoding","secp256k1","consensus","COMPRESS_TYPES","EMPTY_BUFFER","Buffer","alloc","compressScript","script","bw","pkh","getPubkeyhash","writeU8","writeBytes","sh","getScripthash","pk","getPubkey","publicKeyVerify","key","compressKey","writeVarint","raw","length","decompressScript","br","readU8","hash","readBytes","fromPubkeyhash","fromScripthash","offset","data","decompressKey","fromPubkey","size","readVarint","MAX_SCRIPT_SIZE","fromNulldata","seek","fromRaw","sizeScript","isPubkeyhash","isScripthash","sizeVarint","compressOutput","output","value","decompressOutput","sizeOutput","compressValue","exp","last","decompressValue","n","out","publicKeyConvert","Error","format","exports","pack","unpack"],"mappings":"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","sourcesContent":["/*!\n * compress.js - coin compressor for bcoin\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\n/**\n * @module coins/compress\n * @ignore\n */\n\nconst assert = require('bsert');\nconst {encoding} = require('bufio');\nconst secp256k1 = require('bcrypto/lib/secp256k1');\nconst consensus = require('../protocol/consensus');\n\n/*\n * Constants\n */\n\nconst COMPRESS_TYPES = 6;\nconst EMPTY_BUFFER = Buffer.alloc(0);\n\n/**\n * Compress a script, write directly to the buffer.\n * @param {Script} script\n * @param {BufferWriter} bw\n */\n\nfunction compressScript(script, bw) {\n  // Attempt to compress the output scripts.\n  // We can _only_ ever compress them if\n  // they are serialized as minimaldata, as\n  // we need to recreate them when we read\n  // them.\n\n  // P2PKH -> 0 | key-hash\n  // Saves 5 bytes.\n  const pkh = script.getPubkeyhash(true);\n  if (pkh) {\n    bw.writeU8(0);\n    bw.writeBytes(pkh);\n    return bw;\n  }\n\n  // P2SH -> 1 | script-hash\n  // Saves 3 bytes.\n  const sh = script.getScripthash();\n  if (sh) {\n    bw.writeU8(1);\n    bw.writeBytes(sh);\n    return bw;\n  }\n\n  // P2PK -> 2-5 | compressed-key\n  // Only works if the key is valid.\n  // Saves up to 35 bytes.\n  const pk = script.getPubkey(true);\n  if (pk) {\n    if (publicKeyVerify(pk)) {\n      const key = compressKey(pk);\n      bw.writeBytes(key);\n      return bw;\n    }\n  }\n\n  // Raw -> varlen + 10 | script\n  bw.writeVarint(script.raw.length + COMPRESS_TYPES);\n  bw.writeBytes(script.raw);\n\n  return bw;\n}\n\n/**\n * Decompress a script from buffer reader.\n * @param {Script} script\n * @param {BufferReader} br\n */\n\nfunction decompressScript(script, br) {\n  // Decompress the script.\n  switch (br.readU8()) {\n    case 0: {\n      const hash = br.readBytes(20, true);\n      script.fromPubkeyhash(hash);\n      break;\n    }\n    case 1: {\n      const hash = br.readBytes(20, true);\n      script.fromScripthash(hash);\n      break;\n    }\n    case 2:\n    case 3:\n    case 4:\n    case 5: {\n      br.offset -= 1;\n      const data = br.readBytes(33, true);\n      // Decompress the key. If this fails,\n      // we have database corruption!\n      const key = decompressKey(data);\n      script.fromPubkey(key);\n      break;\n    }\n    default: {\n      br.offset -= 1;\n      const size = br.readVarint() - COMPRESS_TYPES;\n      if (size > consensus.MAX_SCRIPT_SIZE) {\n        // This violates consensus rules.\n        // We don't need to read it.\n        script.fromNulldata(EMPTY_BUFFER);\n        br.seek(size);\n      } else {\n        const data = br.readBytes(size);\n        script.fromRaw(data);\n      }\n      break;\n    }\n  }\n\n  return script;\n}\n\n/**\n * Calculate script size.\n * @returns {Number}\n */\n\nfunction sizeScript(script) {\n  if (script.isPubkeyhash(true))\n    return 21;\n\n  if (script.isScripthash())\n    return 21;\n\n  const pk = script.getPubkey(true);\n  if (pk) {\n    if (publicKeyVerify(pk))\n      return 33;\n  }\n\n  let size = 0;\n  size += encoding.sizeVarint(script.raw.length + COMPRESS_TYPES);\n  size += script.raw.length;\n\n  return size;\n}\n\n/**\n * Compress an output.\n * @param {Output} output\n * @param {BufferWriter} bw\n */\n\nfunction compressOutput(output, bw) {\n  bw.writeVarint(output.value);\n  compressScript(output.script, bw);\n  return bw;\n}\n\n/**\n * Decompress a script from buffer reader.\n * @param {Output} output\n * @param {BufferReader} br\n */\n\nfunction decompressOutput(output, br) {\n  output.value = br.readVarint();\n  decompressScript(output.script, br);\n  return output;\n}\n\n/**\n * Calculate output size.\n * @returns {Number}\n */\n\nfunction sizeOutput(output) {\n  let size = 0;\n  size += encoding.sizeVarint(output.value);\n  size += sizeScript(output.script);\n  return size;\n}\n\n/**\n * Compress value using an exponent. Takes advantage of\n * the fact that many bitcoin values are divisible by 10.\n * @see https://github.com/btcsuite/btcd/blob/master/blockchain/compress.go\n * @param {Amount} value\n * @returns {Number}\n */\n\nfunction compressValue(value) {\n  if (value === 0)\n    return 0;\n\n  let exp = 0;\n  while (value % 10 === 0 && exp < 9) {\n    value /= 10;\n    exp++;\n  }\n\n  if (exp < 9) {\n    const last = value % 10;\n    value = (value - last) / 10;\n    return 1 + 10 * (9 * value + last - 1) + exp;\n  }\n\n  return 10 + 10 * (value - 1);\n}\n\n/**\n * Decompress value.\n * @param {Number} value - Compressed value.\n * @returns {Amount} value\n */\n\nfunction decompressValue(value) {\n  if (value === 0)\n    return 0;\n\n  value--;\n\n  let exp = value % 10;\n\n  value = (value - exp) / 10;\n\n  let n;\n  if (exp < 9) {\n    const last = value % 9;\n    value = (value - last) / 9;\n    n = value * 10 + last + 1;\n  } else {\n    n = value + 1;\n  }\n\n  while (exp > 0) {\n    n *= 10;\n    exp--;\n  }\n\n  return n;\n}\n\n/**\n * Verify a public key (no hybrid keys allowed).\n * @param {Buffer} key\n * @returns {Boolean}\n */\n\nfunction publicKeyVerify(key) {\n  if (key.length === 0)\n    return false;\n\n  switch (key[0]) {\n    case 0x02:\n    case 0x03:\n      return key.length === 33;\n    case 0x04:\n      if (key.length !== 65)\n        return false;\n\n      return secp256k1.publicKeyVerify(key);\n    default:\n      return false;\n  }\n}\n\n/**\n * Compress a public key to coins compression format.\n * @param {Buffer} key\n * @returns {Buffer}\n */\n\nfunction compressKey(key) {\n  let out;\n\n  switch (key[0]) {\n    case 0x02:\n    case 0x03:\n      // Key is already compressed.\n      out = key;\n      break;\n    case 0x04:\n      // Compress the key normally.\n      out = secp256k1.publicKeyConvert(key, true);\n      // Store the oddness.\n      // Pseudo-hybrid format.\n      out[0] = 0x04 | (key[64] & 0x01);\n      break;\n    default:\n      throw new Error('Bad point format.');\n  }\n\n  assert(out.length === 33);\n\n  return out;\n}\n\n/**\n * Decompress a public key from the coins compression format.\n * @param {Buffer} key\n * @returns {Buffer}\n */\n\nfunction decompressKey(key) {\n  const format = key[0];\n\n  assert(key.length === 33);\n\n  switch (format) {\n    case 0x02:\n    case 0x03:\n      return key;\n    case 0x04:\n      key[0] = 0x02;\n      break;\n    case 0x05:\n      key[0] = 0x03;\n      break;\n    default:\n      throw new Error('Bad point format.');\n  }\n\n  // Decompress the key.\n  const out = secp256k1.publicKeyConvert(key, false);\n\n  // Reset the first byte so as not to\n  // mutate the original buffer.\n  key[0] = format;\n\n  return out;\n}\n\n// Make eslint happy.\ncompressValue;\ndecompressValue;\n\n/*\n * Expose\n */\n\nexports.pack = compressOutput;\nexports.unpack = decompressOutput;\nexports.size = sizeOutput;\n"]},"metadata":{},"sourceType":"module"}