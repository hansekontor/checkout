{"ast":null,"code":"/*!\n * slp.js - simple ledger protocol script for bcash\n * Copyright (c) 2021, Vin Armani (MIT License).\n * https://github.com/badger-cash/bcash\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bio = require('bufio');\n\nconst {\n  U64\n} = require('n64');\n\nconst consensus = require('../protocol/consensus');\n\nconst Script = require('./script');\n\nconst ScriptNum = require('./scriptnum');\n/**\n * SLP Coin Record\n */\n\n\nconst SLP_TYPES = {\n  GENESIS: 0x00,\n  MINT: 0x01,\n  SEND: 0x02,\n  BATON: 0x03,\n  BURN: 0x04\n};\n\nclass SlpCoinRecord {\n  /**\n   * Create a record of SLP data for a given coin.\n   * @param {Buffer?} hash the output hash of the coin\n   * @param {Number?} vout the output index of the coin\n   * @param {Buffer?} tokenId 32 byte txid\n   * @param {Buffer?} tokenIndex 4 byte unsigned integer (index of tx hash in db)\n   * @param {Buffer} value big endian value of token base units\n   * @param {String} type GENESIS | MINT | SEND | BURN | BATON\n   * @param {Number?} version token type\n   * @constructor\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.hash = options.hash;\n    this.vout = options.vout;\n    this.tokenId = options.tokenId;\n    this.tokenIndex = options.tokenIndex;\n    this.value = options.value;\n    this.type = options.type;\n    this.version = options.version;\n  }\n  /**\n   * Get the value as 64 bit big-endian buffer\n   * @private\n   * @returns {Buffer}\n   */\n\n\n  getValueUInt64BE() {\n    assert(this.value.length <= 8, 'value buffer must be 8 bytes or less');\n    const padding = Buffer.alloc(8 - this.value.length);\n    return Buffer.concat([padding, this.value]);\n  }\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   */\n\n\n  fromDbData(data) {\n    const br = bio.read(data);\n    this.tokenIndex = br.readBytes(4);\n    const valueBytes = br.readVarBytes();\n    const padding = Buffer.alloc(8 - valueBytes.length);\n    this.value = Buffer.concat([padding, valueBytes]);\n    this.type = Object.keys(SLP_TYPES)[br.readU8()]; // Get version and handle if out of bounds\n\n    try {\n      this.version = br.readU8();\n    } catch (err) {\n      if (err.code === 'ERR_ENCODING') this.version = 1;else throw err;\n    }\n\n    assert(this.version >= 1 && this.version <= 2);\n    assert(Object.keys(SLP_TYPES).includes(this.type));\n    return this;\n  }\n  /**\n   * Instantiate SLP record from serialized data.\n   * @param {Buffer} data\n   * @returns {SlpCoinRecord}\n   */\n\n\n  static fromDbData(data) {\n    return new this().fromDbData(data);\n  }\n  /**\n   * Serialize the SLP record.\n   * @returns {Buffer}\n   */\n\n\n  toDbData() {\n    assert(this.tokenIndex, 'Missing tokenIndex');\n    assert(this.tokenIndex.length == 4, 'tokenId must be a sha256 hash'); // assert(this.value, 'Missing token amount (in base units)')\n\n    assert(this.value.byteLength, 'Token amount must be a buffer');\n    assert(Object.keys(SLP_TYPES).includes(this.type), 'Type must be GENESIS | MINT | SEND | BATON | BURN'); // Remove padding (minimal)\n\n    for (let i = 0; i < this.value.length; i++) {\n      if (this.value[i] != 0) {\n        this.value = this.value.slice(i);\n        break;\n      }\n    }\n\n    const bw = bio.write();\n    bw.writeBytes(this.tokenIndex);\n    bw.writeVarBytes(this.value);\n    bw.writeU8(SLP_TYPES[this.type]);\n    bw.writeU8(this.version || 1);\n    return bw.render();\n  }\n  /**\n   * Convert object to JSON.\n   * @returns {Object}\n   */\n\n\n  getJSON() {\n    assert(this.tokenId, 'tokenId must be defined');\n    const json = {\n      hash: this.hash ? Buffer.from(this.hash).reverse().toString('hex') : undefined,\n      vout: this.vout,\n      tokenId: this.tokenId.toString('hex'),\n      value: U64.fromBE(this.value).toString(10),\n      type: this.type,\n      version: this.version || 1\n    };\n    return json;\n  }\n  /**\n   * Convert from JSON to Object.\n   * @param {Object} json\n   * @returns {SlpCoinRecord}\n   */\n\n\n  fromJSON(json) {\n    this.hash = Buffer.from(json.hash, 'hex').reverse();\n    this.vout = json.vout;\n    this.tokenId = Buffer.from(json.tokenId, 'hex');\n    this.value = U64.fromString(json.value).toBE(Buffer);\n    this.type = json.type;\n    this.version = json.version || 1;\n    return this;\n  }\n  /**\n   * Convert from JSON to Object.\n   * @param {Object} json\n   * @returns {TokenRecord}\n   */\n\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n\n}\n/**\n * Token Record\n */\n\n\nclass TokenRecord {\n  /**\n   * Create a token record.\n   * @constructor\n   * @param {Buffer?} tokenId\n   * @param {Buffer?} tokenIndex\n   * @param {String?} ticker\n   * @param {String?} name\n   * @param {String?} uri\n   * @param {String?} hash\n   * @param {Number} decimals\n   * @param {Number?} version\n   * @param {Buffer?} vaultScriptHash\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.tokenId = options.tokenId;\n    this.tokenIndex = options.tokenIndex;\n    this.ticker = options.ticker || '';\n    this.name = options.name || '';\n    this.uri = options.uri || '';\n    this.hash = options.hash || '';\n    this.decimals = options.decimals;\n    this.version = options.version;\n    if (this.version === 2) this.vaultScriptHash = options.vaultScriptHash;\n  }\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   */\n\n\n  fromDbData(data) {\n    const br = bio.read(data);\n    this.tokenId = br.readHash();\n    this.ticker = br.readVarString('utf8'); // assert(this.ticker.length > 0);\n\n    this.name = br.readVarString('utf8'); // assert(this.name.length > 0);\n\n    this.uri = br.readVarString('utf8');\n    this.hash = br.readVarString('hex');\n    this.decimals = br.readU8(); // Get version and handle if out of bounds\n\n    try {\n      this.version = br.readU8();\n    } catch (err) {\n      if (err.code === 'ERR_ENCODING') {\n        this.version = 1;\n      } else throw err;\n    } // Read MINT vault ScriptHash\n\n\n    if (this.version === 2) this.vaultScriptHash = br.readBytes(20);\n    assert(this.version >= 1 && this.version <= 2); // assert(this.decimals >= 0 && this.decimals < 9);\n\n    return this;\n  }\n  /**\n   * Instantiate token record from serialized data.\n   * @param {Buffer} data\n   * @returns {TokenRecord}\n   */\n\n\n  static fromDbData(data) {\n    return new this().fromDbData(data);\n  }\n  /**\n   * Serialize the token record.\n   * @returns {Buffer}\n   */\n\n\n  toDbData() {\n    const bw = bio.write();\n    const encoding = bio.encoding;\n    bw.writeHash(this.tokenId);\n    bw.writeVarString(this.ticker, 'utf8');\n    if (this.ticker.length === 0) bw.offset += encoding.sizeVarint(0);\n    bw.writeVarString(this.name, 'utf8');\n    if (this.name.length === 0) bw.offset += encoding.sizeVarint(0);\n    bw.writeVarString(this.uri, 'utf8');\n    if (this.uri.length === 0) bw.offset += encoding.sizeVarint(0);\n    bw.writeVarString(this.hash, 'hex');\n    if (this.hash.length === 0) bw.offset += encoding.sizeVarint(0);\n    bw.writeU8(this.decimals);\n    bw.writeU8(this.version || 1);\n    if (this.version === 2) bw.writeBytes(this.vaultScriptHash);\n    return bw.render();\n  }\n  /**\n   * Convert object to JSON.\n   * @returns {Object}\n   */\n\n\n  getJSON() {\n    assert(this.tokenId, 'tokenId must be defined');\n    const json = {\n      tokenId: this.tokenId.toString('hex'),\n      ticker: this.ticker,\n      name: this.name,\n      uri: this.uri,\n      hash: this.hash,\n      decimals: this.decimals,\n      version: this.version || 1\n    };\n    if (json.version === 2 && this.vaultScriptHash) json.vaultScriptHash = this.vaultScriptHash.toString('hex');\n    return json;\n  }\n  /**\n   * Convert from JSON to Object.\n   * @param {Object} json\n   * @returns {SlpCoinRecord}\n   */\n\n\n  fromJSON(json) {\n    this.tokenId = Buffer.from(json.tokenId, 'hex');\n    this.ticker = json.ticker;\n    this.name = json.name;\n    this.uri = json.uri;\n    this.hash = json.hash;\n    this.decimals = json.decimals;\n    this.version = json.version;\n    if (json.version === 2 && json.vaultScriptHash) this.vaultScriptHash = Buffer.from(json.vaultScriptHash, 'hex');\n    return this;\n  }\n  /**\n   * Convert from JSON to Object.\n   * @param {Object} json\n   * @returns {TokenRecord}\n   */\n\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n\n}\n/**\n * SLP\n * @alias module:script.SLP\n * @extends Script\n */\n\n\nclass SLP extends Script {\n  /**\n   * Create an SLP script.\n   * @constructor\n   * @param {Buffer|Array|Object} code\n   */\n  constructor(options) {\n    super(options);\n    this.valid = null;\n  } //   /**\n  //    * Is SLP script is of valid construction?\n  //    * Use this as opposed to calling property this.isValid\n  //    * @private\n  //    * @returns {Boolean}\n  //    */\n\n\n  isValidSlp() {\n    if (this.valid === null) {\n      this.valid = this.verifySlp();\n    }\n\n    return this.valid;\n  } //   /**\n  //    * Test whether SLP script is of valid construction\n  //    * (Does not test if transaction is valid SLP transaction)\n  //    * @private\n  //    * @param {Script?} script\n  //    * @returns {Boolean}\n  //    */\n\n\n  verifySlp(script) {\n    if (script == undefined) script = this;\n    if (script.getSym(0) != 'OP_RETURN') return false; // LOKAD_ID\n\n    if (script.getString(1, 'hex') != '534c5000') return false; // Check version\n\n    const versionHex = script.getString(2, 'hex');\n    if (versionHex != '01' && versionHex != '02') return false; // Type\n\n    const type = script.getType();\n\n    switch (type) {\n      case 'GENESIS':\n        {\n          if (script.code.length != 11) return false; // Hash\n\n          if (!script.getData(7)) return false;\n          if (script.getData(7).length != 0 && script.getData(7).length != 32) return false; // Decimals\n\n          if (!script.getData(8)) return false;\n          if (script.getData(8).length != 1 || script.getInt(8) > 9) return false;\n\n          if (versionHex == '01') {\n            // Mint Baton\n            if (!script.getData(9)) return false;\n            if (script.getData(9).length > 1) return false;\n            if (script.getData(9).length == 1 && script.getInt(9) < 2) return false;\n          } else if (versionHex == '02') {\n            // Mint Vault ScriptHash\n            if (!script.getData(9)) return false;\n            if (script.getData(9).length != 20) return false;\n          } // Minted Tokens\n\n\n          if (script.getData(10).length != 8) return false;\n          break;\n        }\n\n      case 'MINT':\n        {\n          if (script.code.length != 7) return false; // Token ID\n\n          if (script.getData(4).length != 32) return false;\n\n          if (versionHex == '01') {\n            // Mint Baton\n            if (!script.getData(5)) return false;\n            if (script.getData(5).length > 1) return false;\n            if (script.getData(5).length == 1 && script.getInt(5) < 2) return false; // Minted Tokens\n\n            if (script.getData(6).length != 8) return false;\n          } else if (versionHex == '02') {\n            const outputs = script.code.slice(5);\n\n            for (let i = 0; i < outputs.length; i++) {\n              const op = outputs[i]; // Sent Tokens\n\n              if (op.data.length != 8) return false;\n            }\n          }\n\n          break;\n        }\n\n      case 'SEND':\n        {\n          if (script.code.length < 6) return false; // Token ID\n\n          if (script.getData(4).length != 32) return false;\n          const outputs = script.code.slice(5);\n\n          for (let i = 0; i < outputs.length; i++) {\n            const op = outputs[i]; // Sent Tokens\n\n            if (op.data.length != 8) return false;\n          }\n\n          break;\n        }\n\n      case 'BURN':\n        {\n          if (script.code.length != 6) return false; // Token ID\n\n          if (script.getData(4).length != 32) return false; // Sent Tokens\n\n          if (script.getData(5).length != 8) return false;\n          break;\n        }\n\n      default:\n        {\n          return false;\n        }\n    }\n\n    return true;\n  } //   /**\n  //    * Test whether script is of valid construction\n  //    * (Does not test if transaction is valid SLP transaction)\n  //    * @param {Script?} script\n  //    * @returns {Boolean}\n  //    */\n\n\n  static verifySlp(script) {\n    return new this().verifySlp(script);\n  }\n  /**\n   * Inject properties from a script\n   * @private\n   * @param {Script} code\n   * @returns {SLP}\n   */\n\n\n  fromScript(script) {\n    this.inject(script);\n    return this;\n  }\n  /**\n   * Inject properties from a script\n   * @param {Script} code\n   * @returns {SLP}\n   */\n\n\n  static fromScript(script) {\n    return new this().fromScript(script);\n  }\n  /**\n   * Get token ID for this script\n   * @private\n   * @returns {Hash}\n   */\n\n\n  getTokenId() {\n    assert(this.verifySlp(), 'This is not a valid SLP script'); // Type\n\n    const type = this.getType();\n    assert(type != 'GENESIS', 'Cannot derive the tokenID from GENESIS script'); // Return tokenId as buffer\n\n    return this.getData(4);\n  }\n  /**\n   * Get records for a this script\n   * @private\n   * @param {Buffer?} txId The txid of the transaction containing this script\n   * @returns {(SlpCoinRecord | TokenRecord)[]}\n   */\n\n\n  getRecords(txId) {\n    assert(this.isValidSlp(), 'Must be a valid SLP Script');\n    const type = this.getType();\n    assert(Object.keys(SLP_TYPES).includes(type) && type != 'BATON', 'Type must be GENESIS | MINT | SEND | BURN');\n    assert(txId.byteLength, 'tokenId must be a buffer');\n    assert(txId.length == 32, 'tokenId must be a sha256 hash');\n\n    switch (type) {\n      case 'GENESIS':\n        {\n          return this.getGenesisRecords(txId);\n          break;\n        }\n\n      case 'MINT':\n        {\n          return this.getMintRecords(txId);\n          break;\n        }\n\n      case 'SEND':\n        {\n          return this.getSendRecords(txId);\n          break;\n        }\n\n      case 'BURN':\n        {\n          return this.getBurnRecords(txId);\n          break;\n        }\n\n      default:\n        {\n          return null;\n        }\n    }\n  }\n  /**\n   * Get records for a GENESIS script\n   * @private\n   * @param {Buffer} tokenId The tokenId of the transaction containing this script\n   * @returns {(SlpCoinRecord | TokenRecord)[]}\n   */\n\n\n  getGenesisRecords(tokenId) {\n    assert(tokenId.byteLength, 'tokenId must be a buffer');\n    assert(tokenId.byteLength == 32, 'tokenId must be a sha256 hash');\n    const type = this.getType();\n    assert(type == 'GENESIS', 'This is not a GENESIS transaction');\n    const versionInt = this.getInt(2);\n    const records = []; // Create TokenRecord\n\n    records.push(this.constructor.TokenRecord({\n      tokenId,\n      version: versionInt,\n      ticker: this.getString(4, 'utf-8'),\n      name: this.getString(5, 'utf-8'),\n      uri: this.getString(6, 'utf-8'),\n      hash: this.getString(7, 'hex'),\n      decimals: this.getInt(8),\n      vaultScriptHash: versionInt === 2 ? this.getData(9) : undefined\n    })); // Create Minted Tokens SLPCoinRecord\n\n    records.push(this.constructor.SlpCoinRecord({\n      hash: Buffer.from(tokenId).reverse(),\n      vout: 1,\n      tokenId,\n      value: this.getData(10),\n      type,\n      version: this.getInt(2)\n    })); // Create Mint Baton SLPCoinRecord\n\n    if (versionInt === 1 && this.getInt(9) >= 2) {\n      const valBuf = Buffer.alloc(1);\n      valBuf.writeInt8(1);\n      records.push(this.constructor.SlpCoinRecord({\n        hash: Buffer.from(tokenId).reverse(),\n        vout: this.getInt(9),\n        tokenId,\n        value: valBuf,\n        type: 'BATON',\n        version: this.getInt(2)\n      }));\n    }\n\n    return records;\n  }\n  /**\n   * Get records for a MINT script\n   * @private\n   * @param {Buffer} txId The txHash of the transaction containing this script\n   * @returns {SlpCoinRecord[]}\n   */\n\n\n  getMintRecords(txId) {\n    assert(txId.byteLength, 'txId must be a buffer');\n    assert(txId.byteLength == 32, 'txId must be a sha256 hash');\n    const type = this.getType();\n    assert(type == 'MINT', 'This is not a MINT transaction');\n    const versionInt = this.getInt(2);\n    const records = []; // Create Minted Tokens SLPCoinRecord\n\n    if (versionInt === 1) {\n      records.push(this.constructor.SlpCoinRecord({\n        hash: Buffer.from(txId).reverse(),\n        vout: 1,\n        tokenId: this.getData(4),\n        value: this.getData(6),\n        type,\n        version: versionInt\n      })); // Create Mint Baton SLPCoinRecord\n\n      if (this.getInt(5) >= 2) {\n        const valBuf = U64.fromInt(1).toBE(Buffer);\n        records.push(this.constructor.SlpCoinRecord({\n          hash: Buffer.from(txId).reverse(),\n          vout: this.getInt(5),\n          tokenId: this.getData(4),\n          value: valBuf,\n          type: 'BATON',\n          version: versionInt\n        }));\n      }\n    } else if (versionInt === 2) {\n      // Mimic Token Type 1 SEND\n      const outputs = this.code.slice(5);\n\n      for (let i = 0; i < outputs.length; i++) {\n        const valueBuf = outputs[i].toData();\n        const vout = i + 1; // Create Token Type 2 Mint Tokens SLPCoinRecord\n\n        records.push(this.constructor.SlpCoinRecord({\n          hash: Buffer.from(txId).reverse(),\n          vout,\n          tokenId: this.getData(4),\n          value: valueBuf,\n          type,\n          version: this.getInt(2)\n        }));\n      }\n    }\n\n    return records;\n  }\n  /**\n   * Get records for a SEND script\n   * @private\n   * @param {Buffer} txId The txHash of the transaction containing this script\n   * @param {Boolean} nonStandardOuts OP_RETURN is located at an index other than 0\n   * @returns {SlpCoinRecord[]}\n   */\n\n\n  getSendRecords(txId) {\n    let nonStandardOuts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    assert(txId.byteLength, 'txId must be a buffer');\n    assert(txId.byteLength == 32, 'txId must be a sha256 hash');\n    const type = this.getType();\n    assert(type == 'SEND', 'This is not a SEND transaction');\n    const records = [];\n    const outputs = this.code.slice(5);\n\n    for (let i = 0; i < outputs.length; i++) {\n      const valueBuf = outputs[i].toData();\n      const vout = nonStandardOuts ? i : i + 1; // Create Send Tokens SLPCoinRecord\n\n      records.push(this.constructor.SlpCoinRecord({\n        hash: Buffer.from(txId).reverse(),\n        vout,\n        tokenId: this.getData(4),\n        value: valueBuf,\n        type,\n        version: this.getInt(2)\n      }));\n    }\n\n    return records;\n  }\n\n  getBurnRecords(txId) {\n    let nonStandardOuts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    assert(txId.byteLength, 'txId must be a buffer');\n    assert(txId.byteLength == 32, 'txId must be a sha256 hash');\n    const type = this.getType();\n    assert(type == 'BURN', 'This is not a BURN transaction');\n    const records = [];\n    const valueBuf = this.code[5].toData(); // Create Send Tokens SLPCoinRecord\n\n    records.push(this.constructor.SlpCoinRecord({\n      hash: Buffer.from(txId).reverse(),\n      vout: 0,\n      tokenId: this.getData(4),\n      value: valueBuf,\n      type,\n      version: this.getInt(2)\n    }));\n    return records;\n  }\n  /**\n   * Re-encode the script internally. Useful if you\n   * changed something manually in the `code` array.\n   * @returns {Script}\n   */\n\n\n  compile() {\n    super.compile();\n    this.valid = null;\n    this.isValidSlp();\n  }\n  /**\n   * Inspect the script.\n   * @returns {String} Human-readable script code.\n   */\n\n\n  inspect() {\n    return `<SLP: ${this.toString()}>`;\n  }\n\n  getType() {\n    return this.getString(3);\n  }\n  /**\n   * Create a new TokenRecord\n   * @param {Buffer?} tokenId\n   * @param {Buffer?} tokenIndex\n   * @param {String?} ticker\n   * @param {String?} name\n   * @param {String?} uri\n   * @param {String?} hash\n   * @param {Number} decimals\n   * @param {Number?} version\n   * @returns {TokenRecord}\n   */\n\n\n  static TokenRecord() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new TokenRecord(options);\n  }\n  /**\n   * Create a new SlpCoinRecord\n   * @param {Buffer?} hash the output hash of the coin\n   * @param {Number?} vout the output index of the coin\n   * @param {Buffer?} tokenId 32 byte txid\n   * @param {Buffer?} tokenIndex 4 byte unsigned integer (index of tx hash in db)\n   * @param {Number} value\n   * @param {String} type GENESIS | MINT | SEND | BATON\n   * @param {Number?} version\n   * @returns {SlpCoinRecord}\n   */\n\n\n  static SlpCoinRecord() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new SlpCoinRecord(options);\n  }\n\n}\n\nmodule.exports = SLP;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/script/slp.js"],"names":["assert","require","bio","U64","consensus","Script","ScriptNum","SLP_TYPES","GENESIS","MINT","SEND","BATON","BURN","SlpCoinRecord","constructor","options","hash","vout","tokenId","tokenIndex","value","type","version","getValueUInt64BE","length","padding","Buffer","alloc","concat","fromDbData","data","br","read","readBytes","valueBytes","readVarBytes","Object","keys","readU8","err","code","includes","toDbData","byteLength","i","slice","bw","write","writeBytes","writeVarBytes","writeU8","render","getJSON","json","from","reverse","toString","undefined","fromBE","fromJSON","fromString","toBE","TokenRecord","ticker","name","uri","decimals","vaultScriptHash","readHash","readVarString","encoding","writeHash","writeVarString","offset","sizeVarint","SLP","valid","isValidSlp","verifySlp","script","getSym","getString","versionHex","getType","getData","getInt","outputs","op","fromScript","inject","getTokenId","getRecords","txId","getGenesisRecords","getMintRecords","getSendRecords","getBurnRecords","versionInt","records","push","valBuf","writeInt8","fromInt","valueBuf","toData","nonStandardOuts","compile","inspect","module","exports"],"mappings":"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","sourcesContent":["/*!\n * slp.js - simple ledger protocol script for bcash\n * Copyright (c) 2021, Vin Armani (MIT License).\n * https://github.com/badger-cash/bcash\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bio = require('bufio');\nconst {U64} = require('n64');\nconst consensus = require('../protocol/consensus');\nconst Script = require('./script');\nconst ScriptNum = require('./scriptnum');\n\n/**\n * SLP Coin Record\n */\n\n const SLP_TYPES = {\n  GENESIS: 0x00,\n  MINT: 0x01,\n  SEND: 0x02,\n  BATON: 0x03,\n  BURN: 0x04\n}\n\nclass SlpCoinRecord {\n  /**\n   * Create a record of SLP data for a given coin.\n   * @param {Buffer?} hash the output hash of the coin\n   * @param {Number?} vout the output index of the coin\n   * @param {Buffer?} tokenId 32 byte txid\n   * @param {Buffer?} tokenIndex 4 byte unsigned integer (index of tx hash in db)\n   * @param {Buffer} value big endian value of token base units\n   * @param {String} type GENESIS | MINT | SEND | BURN | BATON\n   * @param {Number?} version token type\n   * @constructor\n   */\n\n  constructor(options = {}) {\n    this.hash = options.hash;\n    this.vout = options.vout;\n    this.tokenId = options.tokenId;\n    this.tokenIndex = options.tokenIndex;\n    this.value = options.value;\n    this.type = options.type;\n    this.version = options.version;\n    \n  }\n\n  /**\n   * Get the value as 64 bit big-endian buffer\n   * @private\n   * @returns {Buffer}\n   */\n  getValueUInt64BE() {\n    assert(this.value.length <= 8, 'value buffer must be 8 bytes or less');\n    const padding = Buffer.alloc(8 - this.value.length);\n    return Buffer.concat([padding, this.value]);\n  }\n\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   */\n\n  fromDbData(data) {\n    const br = bio.read(data);\n\n    this.tokenIndex = br.readBytes(4);\n    const valueBytes = br.readVarBytes();\n    const padding = Buffer.alloc(8 - valueBytes.length);\n    this.value = Buffer.concat([padding, valueBytes]);\n    this.type = Object.keys(SLP_TYPES)[br.readU8()];\n    // Get version and handle if out of bounds\n    try {\n      this.version = br.readU8();\n    } catch (err) {\n      if (err.code === 'ERR_ENCODING')\n        this.version = 1;\n      else throw(err)\n    }\n\n    assert(this.version >= 1 && this.version <= 2);\n    assert(Object.keys(SLP_TYPES).includes(this.type));\n\n    return this;\n  }\n\n  /**\n   * Instantiate SLP record from serialized data.\n   * @param {Buffer} data\n   * @returns {SlpCoinRecord}\n   */\n\n  static fromDbData(data) {\n    return new this().fromDbData(data);\n  }\n\n  /**\n   * Serialize the SLP record.\n   * @returns {Buffer}\n   */\n\n  toDbData() {\n    assert(this.tokenIndex, 'Missing tokenIndex');\n    assert(this.tokenIndex.length == 4, 'tokenId must be a sha256 hash');\n    // assert(this.value, 'Missing token amount (in base units)')\n    assert(this.value.byteLength, 'Token amount must be a buffer')\n    assert(Object.keys(SLP_TYPES).includes(this.type), 'Type must be GENESIS | MINT | SEND | BATON | BURN');\n    // Remove padding (minimal)\n    for (let i = 0; i < this.value.length; i++) {\n      if (this.value[i] != 0) {\n        this.value = this.value.slice(i)\n        break;\n      }\n    }\n    const bw = bio.write();\n\n    bw.writeBytes(this.tokenIndex);\n    bw.writeVarBytes(this.value);\n    bw.writeU8(SLP_TYPES[this.type]);\n    bw.writeU8(this.version || 1);\n\n    return bw.render();\n  }\n\n  /**\n   * Convert object to JSON.\n   * @returns {Object}\n   */\n\n  getJSON() {\n    assert(this.tokenId, 'tokenId must be defined');\n\n    const json = {\n      hash: this.hash ? Buffer.from(this.hash).reverse().toString('hex') : undefined,\n      vout: this.vout,\n      tokenId: this.tokenId.toString('hex'),\n      value: U64.fromBE(this.value).toString(10),\n      type: this.type,\n      version: this.version || 1\n\n    }\n    return json;\n  }\n\n  /**\n   * Convert from JSON to Object.\n   * @param {Object} json\n   * @returns {SlpCoinRecord}\n   */\n\n   fromJSON(json) {\n\n    this.hash = Buffer.from(json.hash, 'hex').reverse();\n    this.vout = json.vout;\n    this.tokenId = Buffer.from(json.tokenId, 'hex');\n    this.value = U64.fromString(json.value).toBE(Buffer);\n    this.type = json.type;\n    this.version = json.version || 1\n\n    return this\n  }\n\n  /**\n   * Convert from JSON to Object.\n   * @param {Object} json\n   * @returns {TokenRecord}\n   */\n\n   static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n}\n\n/**\n * Token Record\n */\n\n class TokenRecord {\n  /**\n   * Create a token record.\n   * @constructor\n   * @param {Buffer?} tokenId\n   * @param {Buffer?} tokenIndex\n   * @param {String?} ticker\n   * @param {String?} name\n   * @param {String?} uri\n   * @param {String?} hash\n   * @param {Number} decimals\n   * @param {Number?} version\n   * @param {Buffer?} vaultScriptHash\n   */\n\n  constructor(options = {}) {\n    this.tokenId = options.tokenId;\n    this.tokenIndex = options.tokenIndex;\n    this.ticker = options.ticker || '';\n    this.name = options.name || '';\n    this.uri = options.uri || '';\n    this.hash = options.hash || '';\n    this.decimals = options.decimals;\n    this.version = options.version;\n    if (this.version === 2 )\n      this.vaultScriptHash = options.vaultScriptHash;\n\n  }\n\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   */\n\n  fromDbData(data) {\n    const br = bio.read(data);\n\n    this.tokenId = br.readHash();\n    this.ticker = br.readVarString('utf8');\n    // assert(this.ticker.length > 0);\n\n    this.name = br.readVarString('utf8');\n    // assert(this.name.length > 0);\n\n    this.uri = br.readVarString('utf8');\n    this.hash = br.readVarString('hex');\n    this.decimals = br.readU8();\n    // Get version and handle if out of bounds\n    try {\n      this.version = br.readU8();\n    } catch(err) {\n      if (err.code === 'ERR_ENCODING') {\n        this.version = 1;\n      } else throw(err)\n    }\n\n    // Read MINT vault ScriptHash\n    if (this.version ===2)\n      this.vaultScriptHash = br.readBytes(20);\n\n    assert(this.version >= 1 && this.version <= 2);\n    // assert(this.decimals >= 0 && this.decimals < 9);\n\n    return this;\n  }\n\n  /**\n   * Instantiate token record from serialized data.\n   * @param {Buffer} data\n   * @returns {TokenRecord}\n   */\n\n  static fromDbData(data) {\n    return new this().fromDbData(data);\n  }\n\n  /**\n   * Serialize the token record.\n   * @returns {Buffer}\n   */\n\n  toDbData() {\n    const bw = bio.write();\n    const encoding = bio.encoding;\n\n    bw.writeHash(this.tokenId);\n    bw.writeVarString(this.ticker, 'utf8');\n    if (this.ticker.length === 0)\n      bw.offset += encoding.sizeVarint(0);\n    bw.writeVarString(this.name, 'utf8');\n    if (this.name.length === 0)\n      bw.offset += encoding.sizeVarint(0);\n    bw.writeVarString(this.uri, 'utf8');\n    if (this.uri.length === 0)\n      bw.offset += encoding.sizeVarint(0);\n    bw.writeVarString(this.hash, 'hex');\n    if (this.hash.length === 0)\n      bw.offset += encoding.sizeVarint(0);\n    bw.writeU8(this.decimals);\n    bw.writeU8(this.version || 1);\n\n    if (this.version === 2)\n      bw.writeBytes(this.vaultScriptHash);\n\n    return bw.render();\n  }\n\n  /**\n   * Convert object to JSON.\n   * @returns {Object}\n   */\n\n  getJSON() {\n    assert(this.tokenId, 'tokenId must be defined');\n\n    const json = {\n      tokenId: this.tokenId.toString('hex'),\n      ticker: this.ticker,\n      name: this.name,\n      uri: this.uri,\n      hash: this.hash,\n      decimals: this.decimals,\n      version: this.version || 1\n    }\n\n    if (json.version === 2 && this.vaultScriptHash)\n      json.vaultScriptHash = this.vaultScriptHash.toString('hex');\n    \n    return json;\n  }\n\n  /**\n   * Convert from JSON to Object.\n   * @param {Object} json\n   * @returns {SlpCoinRecord}\n   */\n\n   fromJSON(json) {\n\n    this.tokenId = Buffer.from(json.tokenId, 'hex');\n    this.ticker = json.ticker;\n    this.name = json.name;\n    this.uri = json.uri;\n    this.hash = json.hash\n    this.decimals = json.decimals;\n    this.version = json.version;\n\n    if (json.version === 2 && json.vaultScriptHash)\n      this.vaultScriptHash = Buffer.from(json.vaultScriptHash, 'hex');\n\n    return this\n  }\n\n  /**\n   * Convert from JSON to Object.\n   * @param {Object} json\n   * @returns {TokenRecord}\n   */\n\n   static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n\n}\n\n\n/**\n * SLP\n * @alias module:script.SLP\n * @extends Script\n */\n\nclass SLP extends Script {\n  /**\n   * Create an SLP script.\n   * @constructor\n   * @param {Buffer|Array|Object} code\n   */\n\n  constructor(options) {\n    super(options);\n\n    this.valid = null;\n  }\n\n//   /**\n//    * Is SLP script is of valid construction?\n//    * Use this as opposed to calling property this.isValid\n//    * @private\n//    * @returns {Boolean}\n//    */\n  isValidSlp() {\n    if (this.valid === null) {\n      this.valid = this.verifySlp();\n    }\n    return this.valid;\n  }\n\n//   /**\n//    * Test whether SLP script is of valid construction\n//    * (Does not test if transaction is valid SLP transaction)\n//    * @private\n//    * @param {Script?} script\n//    * @returns {Boolean}\n//    */\n\n  verifySlp(script) {\n    if (script == undefined)\n      script = this;\n\n    if (script.getSym(0) != 'OP_RETURN')\n      return false;\n\n    // LOKAD_ID\n    if (script.getString(1, 'hex') != '534c5000')\n      return false;\n\n    // Check version\n    const versionHex = script.getString(2, 'hex');\n    if (versionHex != '01' && versionHex != '02') \n      return false;\n\n    // Type\n    const type = script.getType();\n\n    switch (type) {\n      case 'GENESIS': {\n        if (script.code.length != 11)\n          return false;\n        // Hash\n        if (!script.getData(7))\n          return false;\n        if (script.getData(7).length != 0 && script.getData(7).length != 32)\n          return false;\n        // Decimals\n        if (!script.getData(8))\n          return false;\n        if (script.getData(8).length != 1 || script.getInt(8) > 9)\n          return false;\n        if (versionHex == '01') {\n          // Mint Baton\n          if (!script.getData(9))\n            return false;\n          if (script.getData(9).length > 1)\n            return false;\n          if (script.getData(9).length == 1 && script.getInt(9) < 2)\n            return false;\n        } else if (versionHex == '02') {\n          // Mint Vault ScriptHash\n          if (!script.getData(9))\n            return false;\n          if (script.getData(9).length != 20)\n            return false;\n        }\n        // Minted Tokens\n        if (script.getData(10).length != 8)\n          return false\n        break;\n      }\n      case 'MINT': {\n        if (script.code.length != 7)\n          return false;\n        // Token ID\n        if (script.getData(4).length != 32)\n          return false;\n        if (versionHex == '01') {\n          // Mint Baton\n          if (!script.getData(5))\n            return false;\n          if (script.getData(5).length > 1)\n            return false;\n          if (script.getData(5).length == 1 && script.getInt(5) < 2)\n            return false;\n          // Minted Tokens\n          if (script.getData(6).length != 8)\n            return false\n        } else if (versionHex == '02') {\n          const outputs = script.code.slice(5);\n          for (let i = 0; i < outputs.length; i++) {\n            const op = outputs[i];\n            // Sent Tokens\n            if (op.data.length != 8)\n              return false\n          }\n        }\n        break;\n      }\n      case 'SEND': {\n        if (script.code.length < 6)\n          return false;\n        // Token ID\n        if (script.getData(4).length != 32)\n          return false;\n        const outputs = script.code.slice(5);\n        for (let i = 0; i < outputs.length; i++) {\n          const op = outputs[i];\n          // Sent Tokens\n          if (op.data.length != 8)\n            return false\n        }\n        break;\n      }\n      case 'BURN': {\n        if (script.code.length != 6)\n          return false;\n        // Token ID\n        if (script.getData(4).length != 32)\n          return false;\n        // Sent Tokens\n        if (script.getData(5).length != 8)\n          return false\n        break;\n      }\n      default: {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n//   /**\n//    * Test whether script is of valid construction\n//    * (Does not test if transaction is valid SLP transaction)\n//    * @param {Script?} script\n//    * @returns {Boolean}\n//    */\n\n  static verifySlp(script) {\n    return new this().verifySlp(script);\n  }\n\n  /**\n   * Inject properties from a script\n   * @private\n   * @param {Script} code\n   * @returns {SLP}\n   */\n\n  fromScript(script) {\n    this.inject(script);\n    return this;\n  }\n\n  /**\n   * Inject properties from a script\n   * @param {Script} code\n   * @returns {SLP}\n   */\n\n   static fromScript(script) {\n    return new this().fromScript(script);\n  }\n\n  /**\n   * Get token ID for this script\n   * @private\n   * @returns {Hash}\n   */\n\n    getTokenId() {\n      assert(this.verifySlp(), 'This is not a valid SLP script')\n    \n      // Type\n      const type = this.getType();\n      assert(type != 'GENESIS', 'Cannot derive the tokenID from GENESIS script')\n      \n      // Return tokenId as buffer\n      return this.getData(4);\n    }\n\n  /**\n   * Get records for a this script\n   * @private\n   * @param {Buffer?} txId The txid of the transaction containing this script\n   * @returns {(SlpCoinRecord | TokenRecord)[]}\n   */\n\n  getRecords(txId) {\n    assert(this.isValidSlp(), 'Must be a valid SLP Script' )\n\n    const type = this.getType();\n    assert(Object.keys(SLP_TYPES).includes(type) && type != 'BATON', 'Type must be GENESIS | MINT | SEND | BURN');\n    assert(txId.byteLength, 'tokenId must be a buffer');\n    assert(txId.length == 32, 'tokenId must be a sha256 hash');\n\n    switch (type) {\n      case 'GENESIS': {\n        return this.getGenesisRecords(txId);\n        break;\n      }\n      case 'MINT': {\n        return this.getMintRecords(txId);\n        break;\n      }\n      case 'SEND': {\n        return this.getSendRecords(txId);\n        break;\n      }\n      case 'BURN': {\n        return this.getBurnRecords(txId);\n        break;\n      }\n      default: {\n        return null;\n      }\n    }\n  }\n\n  /**\n   * Get records for a GENESIS script\n   * @private\n   * @param {Buffer} tokenId The tokenId of the transaction containing this script\n   * @returns {(SlpCoinRecord | TokenRecord)[]}\n   */\n\n  getGenesisRecords(tokenId) {\n    assert(tokenId.byteLength, 'tokenId must be a buffer');\n    assert(tokenId.byteLength == 32, 'tokenId must be a sha256 hash');\n    const type = this.getType();\n    assert(type == 'GENESIS', 'This is not a GENESIS transaction')\n\n    const versionInt = this.getInt(2);\n    const records = [];\n    // Create TokenRecord\n    records.push(this.constructor.TokenRecord({      \n      tokenId,      \n      version: versionInt,\n      ticker: this.getString(4, 'utf-8'),\n      name: this.getString(5, 'utf-8'),\n      uri: this.getString(6, 'utf-8'),\n      hash: this.getString(7, 'hex'),\n      decimals: this.getInt(8),\n      vaultScriptHash: versionInt === 2 ? this.getData(9) : undefined\n    }));\n    // Create Minted Tokens SLPCoinRecord\n    records.push(this.constructor.SlpCoinRecord({\n      hash: Buffer.from(tokenId).reverse(),\n      vout: 1,\n      tokenId,\n      value: this.getData(10),\n      type,\n      version: this.getInt(2)\n    }));\n    // Create Mint Baton SLPCoinRecord\n    if (versionInt === 1 && this.getInt(9) >= 2) {\n      const valBuf = Buffer.alloc(1);\n      valBuf.writeInt8(1);\n      records.push(this.constructor.SlpCoinRecord({\n        hash: Buffer.from(tokenId).reverse(),\n        vout: this.getInt(9),\n        tokenId,\n        value: valBuf,\n        type: 'BATON',\n        version: this.getInt(2)\n      }));\n    }\n    return records;\n  }\n\n  /**\n   * Get records for a MINT script\n   * @private\n   * @param {Buffer} txId The txHash of the transaction containing this script\n   * @returns {SlpCoinRecord[]}\n   */\n\n  getMintRecords(txId) {\n    assert(txId.byteLength, 'txId must be a buffer');\n    assert(txId.byteLength == 32, 'txId must be a sha256 hash');\n    const type = this.getType();\n    assert(type == 'MINT', 'This is not a MINT transaction');\n\n    const versionInt = this.getInt(2);\n    const records = [];\n    // Create Minted Tokens SLPCoinRecord\n    if (versionInt === 1) {\n      records.push(this.constructor.SlpCoinRecord({\n        hash: Buffer.from(txId).reverse(),\n        vout: 1,\n        tokenId: this.getData(4),\n        value: this.getData(6),\n        type,\n        version: versionInt\n      }));\n      // Create Mint Baton SLPCoinRecord\n      if (this.getInt(5) >= 2) {\n        const valBuf = U64.fromInt(1).toBE(Buffer);\n        records.push(this.constructor.SlpCoinRecord({\n          hash: Buffer.from(txId).reverse(),\n          vout: this.getInt(5),\n          tokenId: this.getData(4),\n          value: valBuf,\n          type: 'BATON',\n          version: versionInt\n        }));\n      }\n    } else if (versionInt === 2) {\n      // Mimic Token Type 1 SEND\n      const outputs = this.code.slice(5);\n      for (let i = 0; i < outputs.length; i++) {\n        const valueBuf = outputs[i].toData();\n        const vout = i + 1;\n      \n        // Create Token Type 2 Mint Tokens SLPCoinRecord\n        records.push(this.constructor.SlpCoinRecord({\n          hash: Buffer.from(txId).reverse(),\n          vout,\n          tokenId: this.getData(4),\n          value: valueBuf,\n          type,\n          version: this.getInt(2)\n        }));\n      }\n    }\n    return records;\n  }\n\n  /**\n   * Get records for a SEND script\n   * @private\n   * @param {Buffer} txId The txHash of the transaction containing this script\n   * @param {Boolean} nonStandardOuts OP_RETURN is located at an index other than 0\n   * @returns {SlpCoinRecord[]}\n   */\n\n  getSendRecords(txId, nonStandardOuts = false) {\n    assert(txId.byteLength, 'txId must be a buffer');\n    assert(txId.byteLength == 32, 'txId must be a sha256 hash');\n    const type = this.getType();\n    assert(type == 'SEND', 'This is not a SEND transaction')\n\n    const records = [];\n    const outputs = this.code.slice(5);\n    for (let i = 0; i < outputs.length; i++) {\n      const valueBuf = outputs[i].toData();\n      const vout = nonStandardOuts ? i : i + 1;\n    \n      // Create Send Tokens SLPCoinRecord\n      records.push(this.constructor.SlpCoinRecord({\n        hash: Buffer.from(txId).reverse(),\n        vout,\n        tokenId: this.getData(4),\n        value: valueBuf,\n        type,\n        version: this.getInt(2)\n      }));\n    }\n    return records;\n  }\n\n  getBurnRecords(txId, nonStandardOuts = false) {\n    assert(txId.byteLength, 'txId must be a buffer');\n    assert(txId.byteLength == 32, 'txId must be a sha256 hash');\n    const type = this.getType();\n    assert(type == 'BURN', 'This is not a BURN transaction');\n\n    const records = [];\n    const valueBuf = this.code[5].toData();\n  \n    // Create Send Tokens SLPCoinRecord\n    records.push(this.constructor.SlpCoinRecord({\n      hash: Buffer.from(txId).reverse(),\n      vout: 0,\n      tokenId: this.getData(4),\n      value: valueBuf,\n      type,\n      version: this.getInt(2)\n    }));\n\n    return records;\n  }\n  \n  /**\n   * Re-encode the script internally. Useful if you\n   * changed something manually in the `code` array.\n   * @returns {Script}\n   */\n\n  compile() {\n    super.compile();\n\n    this.valid = null;\n    this.isValidSlp();\n  }\n\n  /**\n   * Inspect the script.\n   * @returns {String} Human-readable script code.\n   */\n\n  inspect() {\n    return `<SLP: ${this.toString()}>`;\n  }\n\n  getType() {\n    return this.getString(3);\n  }\n\n  /**\n   * Create a new TokenRecord\n   * @param {Buffer?} tokenId\n   * @param {Buffer?} tokenIndex\n   * @param {String?} ticker\n   * @param {String?} name\n   * @param {String?} uri\n   * @param {String?} hash\n   * @param {Number} decimals\n   * @param {Number?} version\n   * @returns {TokenRecord}\n   */\n\n  static TokenRecord(options = {}) {\n    return new TokenRecord(options);\n  }\n\n  /**\n   * Create a new SlpCoinRecord\n   * @param {Buffer?} hash the output hash of the coin\n   * @param {Number?} vout the output index of the coin\n   * @param {Buffer?} tokenId 32 byte txid\n   * @param {Buffer?} tokenIndex 4 byte unsigned integer (index of tx hash in db)\n   * @param {Number} value\n   * @param {String} type GENESIS | MINT | SEND | BATON\n   * @param {Number?} version\n   * @returns {SlpCoinRecord}\n   */\n\n  static SlpCoinRecord(options = {}) {\n    return new SlpCoinRecord(options);\n  }\n\n}\n\nmodule.exports = SLP;\n"]},"metadata":{},"sourceType":"module"}