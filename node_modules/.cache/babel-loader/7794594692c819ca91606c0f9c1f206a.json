{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2008 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.oned {*/\n\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\n\nvar ChecksumException_1 = require(\"../ChecksumException\");\n\nvar FormatException_1 = require(\"../FormatException\");\n\nvar NotFoundException_1 = require(\"../NotFoundException\");\n\nvar OneDReader_1 = require(\"./OneDReader\");\n\nvar Result_1 = require(\"../Result\");\n\nvar ResultPoint_1 = require(\"../ResultPoint\");\n/**\r\n * <p>Decodes Code 39 barcodes. Supports \"Full ASCII Code 39\" if USE_CODE_39_EXTENDED_MODE is set.</p>\r\n *\r\n * @author Sean Owen\r\n * @see Code93Reader\r\n */\n\n\nvar Code39Reader =\n/** @class */\nfunction (_super) {\n  __extends(Code39Reader, _super);\n  /**\r\n   * Creates a reader that assumes all encoded data is data, and does not treat the final\r\n   * character as a check digit. It will not decoded \"extended Code 39\" sequences.\r\n   */\n  // public Code39Reader() {\n  //   this(false);\n  // }\n\n  /**\r\n   * Creates a reader that can be configured to check the last character as a check digit.\r\n   * It will not decoded \"extended Code 39\" sequences.\r\n   *\r\n   * @param usingCheckDigit if true, treat the last data character as a check digit, not\r\n   * data, and verify that the checksum passes.\r\n   */\n  // public Code39Reader(boolean usingCheckDigit) {\n  //   this(usingCheckDigit, false);\n  // }\n\n  /**\r\n   * Creates a reader that can be configured to check the last character as a check digit,\r\n   * or optionally attempt to decode \"extended Code 39\" sequences that are used to encode\r\n   * the full ASCII character set.\r\n   *\r\n   * @param usingCheckDigit if true, treat the last data character as a check digit, not\r\n   * data, and verify that the checksum passes.\r\n   * @param extendedMode if true, will attempt to decode extended Code 39 sequences in the\r\n   * text.\r\n   */\n\n\n  function Code39Reader(usingCheckDigit, extendedMode) {\n    if (usingCheckDigit === void 0) {\n      usingCheckDigit = false;\n    }\n\n    if (extendedMode === void 0) {\n      extendedMode = false;\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.usingCheckDigit = usingCheckDigit;\n    _this.extendedMode = extendedMode;\n    _this.decodeRowResult = '';\n    _this.counters = new Array(9);\n    return _this;\n  }\n\n  Code39Reader.prototype.decodeRow = function (rowNumber, row, hints) {\n    var theCounters = this.counters;\n    theCounters.fill(0);\n    this.decodeRowResult = '';\n    var start = Code39Reader.findAsteriskPattern(row, theCounters); // Read off white space\n\n    var nextStart = row.getNextSet(start[1]);\n    var end = row.getSize();\n    var decodedChar;\n    var lastStart;\n\n    do {\n      Code39Reader.recordPattern(row, nextStart, theCounters);\n      var pattern = Code39Reader.toNarrowWidePattern(theCounters);\n\n      if (pattern < 0) {\n        throw new NotFoundException_1.default();\n      }\n\n      decodedChar = Code39Reader.patternToChar(pattern);\n      this.decodeRowResult += decodedChar;\n      lastStart = nextStart;\n\n      for (var _i = 0, theCounters_1 = theCounters; _i < theCounters_1.length; _i++) {\n        var counter = theCounters_1[_i];\n        nextStart += counter;\n      } // Read off white space\n\n\n      nextStart = row.getNextSet(nextStart);\n    } while (decodedChar !== '*');\n\n    this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1); // remove asterisk\n    // Look for whitespace after pattern:\n\n    var lastPatternSize = 0;\n\n    for (var _a = 0, theCounters_2 = theCounters; _a < theCounters_2.length; _a++) {\n      var counter = theCounters_2[_a];\n      lastPatternSize += counter;\n    }\n\n    var whiteSpaceAfterEnd = nextStart - lastStart - lastPatternSize; // If 50% of last pattern size, following last pattern, is not whitespace, fail\n    // (but if it's whitespace to the very end of the image, that's OK)\n\n    if (nextStart !== end && whiteSpaceAfterEnd * 2 < lastPatternSize) {\n      throw new NotFoundException_1.default();\n    }\n\n    if (this.usingCheckDigit) {\n      var max = this.decodeRowResult.length - 1;\n      var total = 0;\n\n      for (var i = 0; i < max; i++) {\n        total += Code39Reader.ALPHABET_STRING.indexOf(this.decodeRowResult.charAt(i));\n      }\n\n      if (this.decodeRowResult.charAt(max) !== Code39Reader.ALPHABET_STRING.charAt(total % 43)) {\n        throw new ChecksumException_1.default();\n      }\n\n      this.decodeRowResult = this.decodeRowResult.substring(0, max);\n    }\n\n    if (this.decodeRowResult.length === 0) {\n      // false positive\n      throw new NotFoundException_1.default();\n    }\n\n    var resultString;\n\n    if (this.extendedMode) {\n      resultString = Code39Reader.decodeExtended(this.decodeRowResult);\n    } else {\n      resultString = this.decodeRowResult;\n    }\n\n    var left = (start[1] + start[0]) / 2.0;\n    var right = lastStart + lastPatternSize / 2.0;\n    return new Result_1.default(resultString, null, 0, [new ResultPoint_1.default(left, rowNumber), new ResultPoint_1.default(right, rowNumber)], BarcodeFormat_1.default.CODE_39, new Date().getTime());\n  };\n\n  Code39Reader.findAsteriskPattern = function (row, counters) {\n    var width = row.getSize();\n    var rowOffset = row.getNextSet(0);\n    var counterPosition = 0;\n    var patternStart = rowOffset;\n    var isWhite = false;\n    var patternLength = counters.length;\n\n    for (var i = rowOffset; i < width; i++) {\n      if (row.get(i) !== isWhite) {\n        counters[counterPosition]++;\n      } else {\n        if (counterPosition === patternLength - 1) {\n          // Look for whitespace before start pattern, >= 50% of width of start pattern\n          if (this.toNarrowWidePattern(counters) === Code39Reader.ASTERISK_ENCODING && row.isRange(Math.max(0, patternStart - Math.floor((i - patternStart) / 2)), patternStart, false)) {\n            return [patternStart, i];\n          }\n\n          patternStart += counters[0] + counters[1];\n          counters.copyWithin(0, 2, 2 + counterPosition - 1);\n          counters[counterPosition - 1] = 0;\n          counters[counterPosition] = 0;\n          counterPosition--;\n        } else {\n          counterPosition++;\n        }\n\n        counters[counterPosition] = 1;\n        isWhite = !isWhite;\n      }\n    }\n\n    throw new NotFoundException_1.default();\n  }; // For efficiency, returns -1 on failure. Not throwing here saved as many as 700 exceptions\n  // per image when using some of our blackbox images.\n\n\n  Code39Reader.toNarrowWidePattern = function (counters) {\n    var numCounters = counters.length;\n    var maxNarrowCounter = 0;\n    var wideCounters;\n\n    do {\n      var minCounter = 0x7fffffff;\n\n      for (var _i = 0, counters_1 = counters; _i < counters_1.length; _i++) {\n        var counter = counters_1[_i];\n\n        if (counter < minCounter && counter > maxNarrowCounter) {\n          minCounter = counter;\n        }\n      }\n\n      maxNarrowCounter = minCounter;\n      wideCounters = 0;\n      var totalWideCountersWidth = 0;\n      var pattern = 0;\n\n      for (var i = 0; i < numCounters; i++) {\n        var counter = counters[i];\n\n        if (counter > maxNarrowCounter) {\n          pattern |= 1 << numCounters - 1 - i;\n          wideCounters++;\n          totalWideCountersWidth += counter;\n        }\n      }\n\n      if (wideCounters === 3) {\n        // Found 3 wide counters, but are they close enough in width?\n        // We can perform a cheap, conservative check to see if any individual\n        // counter is more than 1.5 times the average:\n        for (var i = 0; i < numCounters && wideCounters > 0; i++) {\n          var counter = counters[i];\n\n          if (counter > maxNarrowCounter) {\n            wideCounters--; // totalWideCountersWidth = 3 * average, so this checks if counter >= 3/2 * average\n\n            if (counter * 2 >= totalWideCountersWidth) {\n              return -1;\n            }\n          }\n        }\n\n        return pattern;\n      }\n    } while (wideCounters > 3);\n\n    return -1;\n  };\n\n  Code39Reader.patternToChar = function (pattern) {\n    for (var i = 0; i < Code39Reader.CHARACTER_ENCODINGS.length; i++) {\n      if (Code39Reader.CHARACTER_ENCODINGS[i] === pattern) {\n        return Code39Reader.ALPHABET_STRING.charAt(i);\n      }\n    }\n\n    if (pattern === Code39Reader.ASTERISK_ENCODING) {\n      return '*';\n    }\n\n    throw new NotFoundException_1.default();\n  };\n\n  Code39Reader.decodeExtended = function (encoded) {\n    var length = encoded.length;\n    var decoded = '';\n\n    for (var i = 0; i < length; i++) {\n      var c = encoded.charAt(i);\n\n      if (c === '+' || c === '$' || c === '%' || c === '/') {\n        var next = encoded.charAt(i + 1);\n        var decodedChar = '\\0';\n\n        switch (c) {\n          case '+':\n            // +A to +Z map to a to z\n            if (next >= 'A' && next <= 'Z') {\n              decodedChar = String.fromCharCode(next.charCodeAt(0) + 32);\n            } else {\n              throw new FormatException_1.default();\n            }\n\n            break;\n\n          case '$':\n            // $A to $Z map to control codes SH to SB\n            if (next >= 'A' && next <= 'Z') {\n              decodedChar = String.fromCharCode(next.charCodeAt(0) - 64);\n            } else {\n              throw new FormatException_1.default();\n            }\n\n            break;\n\n          case '%':\n            // %A to %E map to control codes ESC to US\n            if (next >= 'A' && next <= 'E') {\n              decodedChar = String.fromCharCode(next.charCodeAt(0) - 38);\n            } else if (next >= 'F' && next <= 'J') {\n              decodedChar = String.fromCharCode(next.charCodeAt(0) - 11);\n            } else if (next >= 'K' && next <= 'O') {\n              decodedChar = String.fromCharCode(next.charCodeAt(0) + 16);\n            } else if (next >= 'P' && next <= 'T') {\n              decodedChar = String.fromCharCode(next.charCodeAt(0) + 43);\n            } else if (next === 'U') {\n              decodedChar = '\\0';\n            } else if (next === 'V') {\n              decodedChar = '@';\n            } else if (next === 'W') {\n              decodedChar = '`';\n            } else if (next === 'X' || next === 'Y' || next === 'Z') {\n              decodedChar = '\\x7f';\n            } else {\n              throw new FormatException_1.default();\n            }\n\n            break;\n\n          case '/':\n            // /A to /O map to ! to , and /Z maps to :\n            if (next >= 'A' && next <= 'O') {\n              decodedChar = String.fromCharCode(next.charCodeAt(0) - 32);\n            } else if (next === 'Z') {\n              decodedChar = ':';\n            } else {\n              throw new FormatException_1.default();\n            }\n\n            break;\n        }\n\n        decoded += decodedChar; // bump up i again since we read two characters\n\n        i++;\n      } else {\n        decoded += c;\n      }\n    }\n\n    return decoded;\n  };\n\n  Code39Reader.ALPHABET_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%';\n  /**\r\n   * These represent the encodings of characters, as patterns of wide and narrow bars.\r\n   * The 9 least-significant bits of each int correspond to the pattern of wide and narrow,\r\n   * with 1s representing \"wide\" and 0s representing narrow.\r\n   */\n\n  Code39Reader.CHARACTER_ENCODINGS = [0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064, 0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C, 0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016, 0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x0A8, 0x0A2, 0x08A, 0x02A // /-%\n  ];\n  Code39Reader.ASTERISK_ENCODING = 0x094;\n  return Code39Reader;\n}(OneDReader_1.default);\n\nexports.default = Code39Reader;","map":null,"metadata":{},"sourceType":"script"}