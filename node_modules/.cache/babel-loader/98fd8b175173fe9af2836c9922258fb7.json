{"ast":null,"code":"/*!\n * base32.js - base32 for bcrypto\n * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on bitcoin/bitcoin:\n *   Copyright (c) 2009-2019, The Bitcoin Core Developers (MIT License).\n *   Copyright (c) 2009-2019, The Bitcoin Developers (MIT License).\n *   https://github.com/bitcoin/bitcoin\n *\n * Resources:\n *   https://tools.ietf.org/html/rfc4648\n *   https://github.com/bitcoin/bitcoin/blob/11d486d/src/utilstrencodings.cpp#L230\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n/*\n * Constants\n */\n\n\nconst CHARSET = 'abcdefghijklmnopqrstuvwxyz234567';\nconst TABLE = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1];\nconst CHARSET_HEX = '0123456789abcdefghijklmnopqrstuv';\nconst TABLE_HEX = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1];\nconst PADDING = [0, 6, 4, 3, 1];\n/**\n * Encode a base32 string.\n * @param {Buffer} data\n * @param {Boolean} [pad=false]\n * @returns {String}\n */\n\nfunction encode(data) {\n  let pad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return _encode(data, CHARSET, pad);\n}\n/**\n * Encode a base32hex string.\n * @param {Buffer} data\n * @param {Boolean} [pad=false]\n * @returns {String}\n */\n\n\nfunction encodeHex(data) {\n  let pad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return _encode(data, CHARSET_HEX, pad);\n}\n/**\n * Encode a base32 string.\n * @private\n * @param {Buffer} data\n * @param {String} charset\n * @param {Boolean} [pad=false]\n * @returns {String}\n */\n\n\nfunction _encode(data, charset, pad) {\n  assert(Buffer.isBuffer(data));\n  assert(typeof pad === 'boolean');\n  let str = '';\n  let mode = 0;\n  let left = 0;\n\n  for (let i = 0; i < data.length; i++) {\n    const ch = data[i];\n\n    switch (mode) {\n      case 0:\n        str += charset[ch >>> 3];\n        left = (ch & 7) << 2;\n        mode = 1;\n        break;\n\n      case 1:\n        str += charset[left | ch >>> 6];\n        str += charset[ch >>> 1 & 31];\n        left = (ch & 1) << 4;\n        mode = 2;\n        break;\n\n      case 2:\n        str += charset[left | ch >>> 4];\n        left = (ch & 15) << 1;\n        mode = 3;\n        break;\n\n      case 3:\n        str += charset[left | ch >>> 7];\n        str += charset[ch >>> 2 & 31];\n        left = (ch & 3) << 3;\n        mode = 4;\n        break;\n\n      case 4:\n        str += charset[left | ch >>> 5];\n        str += charset[ch & 31];\n        mode = 0;\n        break;\n    }\n  }\n\n  if (mode > 0) {\n    str += charset[left];\n\n    if (pad) {\n      for (let i = 0; i < PADDING[mode]; i++) str += '=';\n    }\n  }\n\n  return str;\n}\n/**\n * Decode a base32 string.\n * @param {String} str\n * @param {Boolean} [unpad=false]\n * @returns {Buffer}\n */\n\n\nfunction decode(str) {\n  let unpad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return _decode(str, TABLE, unpad);\n}\n/**\n * Decode a base32hex string.\n * @param {String} str\n * @param {Boolean} [unpad=false]\n * @returns {Buffer}\n */\n\n\nfunction decodeHex(str) {\n  let unpad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return _decode(str, TABLE_HEX, unpad);\n}\n/**\n * Decode a base32 string.\n * @private\n * @param {String} str\n * @param {Array} table\n * @param {Boolean} [unpad=false]\n * @returns {Buffer}\n */\n\n\nfunction _decode(str, table, unpad) {\n  assert(typeof str === 'string');\n  assert(typeof unpad === 'boolean');\n  const data = Buffer.allocUnsafe((str.length * 5 + 7) / 8 | 0);\n  let mode = 0;\n  let left = 0;\n  let j = 0;\n  let i = 0;\n\n  for (; i < str.length; i++) {\n    const ch = str.charCodeAt(i);\n    const v = ch & 0xff80 ? -1 : table[ch];\n    if (v === -1) break;\n\n    switch (mode) {\n      case 0:\n        left = v;\n        mode = 1;\n        break;\n\n      case 1:\n        data[j++] = left << 3 | v >>> 2;\n        left = v & 3;\n        mode = 2;\n        break;\n\n      case 2:\n        left = left << 5 | v;\n        mode = 3;\n        break;\n\n      case 3:\n        data[j++] = left << 1 | v >>> 4;\n        left = v & 15;\n        mode = 4;\n        break;\n\n      case 4:\n        data[j++] = left << 4 | v >>> 1;\n        left = v & 1;\n        mode = 5;\n        break;\n\n      case 5:\n        left = left << 5 | v;\n        mode = 6;\n        break;\n\n      case 6:\n        data[j++] = left << 2 | v >>> 3;\n        left = v & 7;\n        mode = 7;\n        break;\n\n      case 7:\n        data[j++] = left << 5 | v;\n        left = 0;\n        mode = 0;\n        break;\n    }\n  }\n\n  if (mode === 1 || mode === 3 || mode === 6) throw new Error('Invalid base32 string.');\n  if (left > 0) throw new Error('Invalid base32 string.');\n  if (str.length !== i + (-mode & 7) * unpad) throw new Error('Invalid base32 string.');\n\n  for (; i < str.length; i++) {\n    const ch = str.charCodeAt(i);\n    if (ch !== 0x3d) throw new Error('Invalid base32 string.');\n  }\n\n  return data.slice(0, j);\n}\n/**\n * Test a base32 string.\n * @param {String} str\n * @param {Boolean} [unpad=false]\n * @returns {Buffer}\n */\n\n\nfunction test(str) {\n  let unpad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  assert(typeof str === 'string');\n  assert(typeof unpad === 'boolean');\n\n  try {\n    decode(str, unpad);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * Test a base32 hex string.\n * @param {String} str\n * @param {Boolean} [unpad=false]\n * @returns {Buffer}\n */\n\n\nfunction testHex(str) {\n  let unpad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  assert(typeof str === 'string');\n  assert(typeof unpad === 'boolean');\n\n  try {\n    decodeHex(str, unpad);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/*\n * Expose\n */\n\n\nexports.encode = encode;\nexports.encodeHex = encodeHex;\nexports.decode = decode;\nexports.decodeHex = decodeHex;\nexports.test = test;\nexports.testHex = testHex;","map":null,"metadata":{},"sourceType":"script"}