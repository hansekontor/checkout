{"ast":null,"code":"/*!\n * pkcs8.js - PKCS8 encoding for javascript\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on golang/go:\n *   Copyright (c) 2009 The Go Authors. All rights reserved.\n *   https://github.com/golang/go\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/PKCS_8\n *   https://tools.ietf.org/html/rfc5208\n *   https://tools.ietf.org/html/rfc5958\n *   https://github.com/golang/go/blob/master/src/crypto/x509/pkcs8.go\n */\n'use strict';\n\nconst asn1 = require('./asn1');\n\nconst pem = require('./pem');\n\nconst x509 = require('./x509');\n/**\n * PublicKeyInfo\n */\n// PublicKeyInfo ::= SEQUENCE {\n//   algorithm       AlgorithmIdentifier,\n//   PublicKey       BIT STRING\n// }\n\n\nclass PublicKeyInfo extends asn1.Sequence {\n  constructor(algorithm, identifier, publicKey) {\n    super();\n    this.algorithm = new x509.AlgorithmIdentifier(algorithm, identifier);\n    this.publicKey = new asn1.BitString(publicKey);\n  }\n\n  getBodySize() {\n    let size = 0;\n    size += this.algorithm.getSize();\n    size += this.publicKey.getSize();\n    return size;\n  }\n\n  writeBody(bw) {\n    this.algorithm.write(bw);\n    this.publicKey.write(bw);\n    return bw;\n  }\n\n  readBody(br) {\n    this.algorithm.read(br);\n    this.publicKey.read(br);\n    return this;\n  }\n\n  clean() {\n    return this.algorithm.clean() && this.publicKey.clean();\n  }\n\n  toPEM() {\n    return pem.toPEM(this.encode(), 'PUBLIC KEY');\n  }\n\n  fromPEM(str) {\n    const data = pem.fromPEM(str, 'PUBLIC KEY');\n    return this.decode(data);\n  }\n\n  format() {\n    return {\n      type: this.constructor.name,\n      algorithm: this.algorithm,\n      publicKey: this.publicKey\n    };\n  }\n\n}\n/**\n * PrivateKeyInfo\n */\n// PrivateKeyInfo ::= SEQUENCE {\n//   version         Version,\n//   algorithm       AlgorithmIdentifier,\n//   PrivateKey      OCTET STRING\n// }\n//\n// PrivateKeyInfo ::= SEQUENCE {\n//    version Version,\n//    privateKeyAlgorithm AlgorithmIdentifier {{PrivateKeyAlgorithms}},\n//    privateKey PrivateKey,\n//    attributes [0] Attributes OPTIONAL\n// }\n//\n// Version ::= INTEGER {v1(0)} (v1,...)\n//\n// PrivateKey ::= OCTET STRING\n\n\nclass PrivateKeyInfo extends asn1.Sequence {\n  constructor(version, algorithm, parameters, privateKey) {\n    super();\n    this.version = new asn1.Unsigned(version);\n    this.algorithm = new x509.AlgorithmIdentifier(algorithm, parameters);\n    this.privateKey = new asn1.OctString(privateKey);\n  }\n\n  get isRaw() {\n    return true;\n  }\n\n  getBodySize() {\n    let size = 0;\n    size += this.version.getSize();\n    size += this.algorithm.getSize();\n    size += this.privateKey.getSize();\n    return size;\n  }\n\n  writeBody(bw) {\n    this.version.write(bw);\n    this.algorithm.write(bw);\n    this.privateKey.write(bw);\n    return bw;\n  }\n\n  readBody(br) {\n    this.version.read(br);\n    this.algorithm.read(br);\n    this.privateKey.read(br);\n    return this;\n  }\n\n  clean() {\n    return this.version.clean() && this.algorithm.clean() && this.privateKey.clean();\n  }\n\n  toPEM() {\n    return pem.toPEM(this.encode(), 'PRIVATE KEY');\n  }\n\n  fromPEM(str) {\n    const data = pem.fromPEM(str, 'PRIVATE KEY');\n    return this.decode(data);\n  }\n\n  format() {\n    return {\n      type: this.constructor.name,\n      version: this.version,\n      algorithm: this.algorithm,\n      privateKey: this.privateKey\n    };\n  }\n\n}\n/**\n * EncryptedPrivateKeyInfo\n */\n// EncryptedPrivateKeyInfo ::= SEQUENCE {\n//   encryptionAlgorithm  EncryptionAlgorithmIdentifier,\n//   encryptedData        EncryptedData\n// }\n//\n// EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier\n//\n// EncryptedData ::= OCTET STRING\n\n\nclass EncryptedPrivateKeyInfo extends asn1.Sequence {\n  constructor(algorithm, identifier, data) {\n    super();\n    this.algorithm = new x509.AlgorithmIdentifier(algorithm, identifier);\n    this.data = new asn1.OctString(data);\n  }\n\n  getBodySize() {\n    let size = 0;\n    size += this.algorithm.getSize();\n    size += this.data.getSize();\n    return size;\n  }\n\n  writeBody(bw) {\n    this.algorithm.write(bw);\n    this.data.write(bw);\n    return bw;\n  }\n\n  readBody(br) {\n    this.algorithm.read(br);\n    this.data.read(br);\n    return this;\n  }\n\n  clean() {\n    return this.algorithm.clean() && this.data.clean();\n  }\n\n  toPEM() {\n    return pem.toPEM(this.encode(), 'ENCRYPTED PRIVATE KEY');\n  }\n\n  fromPEM(str) {\n    const data = pem.fromPEM(str, 'ENCRYPTED PRIVATE KEY');\n    return this.decode(data);\n  }\n\n  format() {\n    return {\n      type: this.constructor.name,\n      algorithm: this.algorithm,\n      data: this.data\n    };\n  }\n\n}\n/*\n * Expose\n */\n\n\nexports.PublicKeyInfo = PublicKeyInfo;\nexports.PrivateKeyInfo = PrivateKeyInfo;\nexports.EncryptedPrivateKeyInfo = EncryptedPrivateKeyInfo;","map":null,"metadata":{},"sourceType":"script"}