{"ast":null,"code":"/*!\n * input.js - input object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bio = require('bufio');\n\nconst Network = require('../protocol/network');\n\nconst Script = require('../script/script');\n\nconst Outpoint = require('./outpoint');\n\nconst {\n  inspectSymbol\n} = require('../utils');\n/**\n * Input\n * Represents a transaction input.\n * @alias module:primitives.Input\n * @property {Outpoint} prevout - Outpoint.\n * @property {Script} script - Input script / scriptSig.\n * @property {Number} sequence - nSequence.\n */\n\n\nclass Input {\n  /**\n   * Create transaction input.\n   * @constructor\n   * @param {Object} options\n   */\n  constructor(options) {\n    this.prevout = new Outpoint();\n    this.script = new Script();\n    this.sequence = 0xffffffff;\n    if (options) this.fromOptions(options);\n  }\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n\n  fromOptions(options) {\n    assert(options, 'Input data is required.');\n    this.prevout.fromOptions(options.prevout);\n    if (options.script) this.script.fromOptions(options.script);\n\n    if (options.sequence != null) {\n      assert(options.sequence >>> 0 === options.sequence, 'Sequence must be a uint32.');\n      this.sequence = options.sequence;\n    }\n\n    return this;\n  }\n  /**\n   * Instantiate an Input from options object.\n   * @param {Object} options\n   * @returns {Input}\n   */\n\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n  /**\n   * Clone the input.\n   * @returns {Input}\n   */\n\n\n  clone() {\n    const input = new this.constructor();\n    input.prevout = this.prevout;\n    input.script.inject(this.script);\n    input.sequence = this.sequence;\n    return input;\n  }\n  /**\n   * Test equality against another input.\n   * @param {Input} input\n   * @returns {Boolean}\n   */\n\n\n  equals(input) {\n    assert(Input.isInput(input));\n    return this.prevout.equals(input.prevout);\n  }\n  /**\n   * Compare against another input (BIP69).\n   * @param {Input} input\n   * @returns {Number}\n   */\n\n\n  compare(input) {\n    assert(Input.isInput(input));\n    return this.prevout.compare(input.prevout);\n  }\n  /**\n   * Get the previous output script type as a string.\n   * Will \"guess\" based on the input script and/or\n   * witness if coin is not available.\n   * @param {Coin?} coin\n   * @returns {ScriptType} type\n   */\n\n\n  getType(coin) {\n    if (this.isCoinbase()) return 'coinbase';\n    if (coin) return coin.getType();\n    const type = this.script.getInputType();\n    return Script.typesByVal[type].toLowerCase();\n  }\n  /**\n   * Get the redeem script.\n   * @param {Coin?} coin\n   * @returns {Script?} Redeem script.\n   */\n\n\n  getRedeem(coin) {\n    if (this.isCoinbase()) return null;\n\n    if (!coin) {\n      if (this.script.isScripthashInput()) return this.script.getRedeem();\n      return null;\n    }\n\n    let prev = coin.script;\n    let redeem = null;\n\n    if (prev.isScripthash()) {\n      prev = this.script.getRedeem();\n      redeem = prev;\n    }\n\n    return redeem;\n  }\n  /**\n   * Get the redeem script type.\n   * @param {Coin?} coin\n   * @returns {String} subtype\n   */\n\n\n  getSubtype(coin) {\n    if (this.isCoinbase()) return null;\n    const redeem = this.getRedeem(coin);\n    if (!redeem) return null;\n    const type = redeem.getType();\n    return Script.typesByVal[type].toLowerCase();\n  }\n  /**\n   * Get the previous output script's address. Will \"guess\"\n   * based on the input script and/or witness if coin\n   * is not available.\n   * @param {Coin?} coin\n   * @returns {Address?} addr\n   */\n\n\n  getAddress(coin) {\n    if (this.isCoinbase()) return null;\n    if (coin) return coin.getAddress();\n    if (this.script.code.length > 0) return this.script.getInputAddress();\n    return null;\n  }\n  /**\n   * Get the address hash.\n   * @param {Coin?} coin\n   * @param {String?} enc\n   * @returns {Hash} hash\n   */\n\n\n  getHash(coin, enc) {\n    const addr = this.getAddress(coin);\n    if (!addr) return null;\n    return addr.getHash(enc);\n  }\n  /**\n   * Test to see if nSequence is equal to uint32max.\n   * @returns {Boolean}\n   */\n\n\n  isFinal() {\n    return this.sequence === 0xffffffff;\n  }\n  /**\n   * Test to see if nSequence is less than 0xfffffffe.\n   * @returns {Boolean}\n   */\n\n\n  isRBF() {\n    return this.sequence < 0xfffffffe;\n  }\n  /**\n   * Test to see if outpoint is null.\n   * @returns {Boolean}\n   */\n\n\n  isCoinbase() {\n    return this.prevout.isNull();\n  }\n  /**\n   * Convert the input to a more user-friendly object.\n   * @returns {Object}\n   */\n\n\n  [inspectSymbol]() {\n    return this.format();\n  }\n  /**\n   * Convert the input to a more user-friendly object.\n   * @param {Coin?} coin\n   * @returns {Object}\n   */\n\n\n  format(coin) {\n    return {\n      type: this.getType(coin),\n      subtype: this.getSubtype(coin),\n      address: this.getAddress(coin),\n      script: this.script,\n      redeem: this.getRedeem(coin),\n      sequence: this.sequence,\n      prevout: this.prevout,\n      coin: coin || null\n    };\n  }\n  /**\n   * Convert the input to an object suitable\n   * for JSON serialization.\n   * @returns {Object}\n   */\n\n\n  toJSON(network, coin) {\n    return this.getJSON();\n  }\n  /**\n   * Convert the input to an object suitable\n   * for JSON serialization. Note that the hashes\n   * will be reversed to abide by bitcoind's legacy\n   * of little-endian uint256s.\n   * @param {Network} network\n   * @param {Coin} coin\n   * @returns {Object}\n   */\n\n\n  getJSON(network, coin) {\n    network = Network.get(network);\n    let addr;\n\n    if (!coin) {\n      addr = this.getAddress();\n      if (addr) addr = addr.toString(network);\n    }\n\n    return {\n      prevout: this.prevout.toJSON(),\n      script: this.script.toJSON(),\n      sequence: this.sequence,\n      address: addr,\n      coin: coin ? coin.getJSON(network, true) : undefined\n    };\n  }\n  /**\n   * Inject properties from a JSON object.\n   * @private\n   * @param {Object} json\n   */\n\n\n  fromJSON(json) {\n    assert(json, 'Input data is required.');\n    assert(json.sequence >>> 0 === json.sequence, 'Sequence must be a uint32.');\n    this.prevout.fromJSON(json.prevout);\n    this.script.fromJSON(json.script);\n    this.sequence = json.sequence;\n    return this;\n  }\n  /**\n   * Instantiate an Input from a jsonified input object.\n   * @param {Object} json - The jsonified input object.\n   * @returns {Input}\n   */\n\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n  /**\n   * Calculate size of serialized input.\n   * @returns {Number}\n   */\n\n\n  getSize() {\n    return 40 + this.script.getVarSize();\n  }\n  /**\n   * Serialize the input.\n   * @param {String?} enc - Encoding, can be `'hex'` or null.\n   * @returns {Buffer|String}\n   */\n\n\n  toRaw() {\n    const size = this.getSize();\n    return this.toWriter(bio.write(size)).render();\n  }\n  /**\n   * Write the input to a buffer writer.\n   * @param {BufferWriter} bw\n   */\n\n\n  toWriter(bw) {\n    this.prevout.toWriter(bw);\n    bw.writeVarBytes(this.script.toRaw());\n    bw.writeU32(this.sequence);\n    return bw;\n  }\n  /**\n   * Inject properties from buffer reader.\n   * @private\n   * @param {BufferReader} br\n   */\n\n\n  fromReader(br) {\n    this.prevout.fromReader(br);\n    this.script.fromRaw(br.readVarBytes());\n    this.sequence = br.readU32();\n    return this;\n  }\n  /**\n   * Inject properties from serialized data.\n   * @param {Buffer} data\n   */\n\n\n  fromRaw(data) {\n    return this.fromReader(bio.read(data));\n  }\n  /**\n   * Instantiate an input from a buffer reader.\n   * @param {BufferReader} br\n   * @returns {Input}\n   */\n\n\n  static fromReader(br) {\n    return new this().fromReader(br);\n  }\n  /**\n   * Instantiate an input from a serialized Buffer.\n   * @param {Buffer} data\n   * @param {String?} enc - Encoding, can be `'hex'` or null.\n   * @returns {Input}\n   */\n\n\n  static fromRaw(data, enc) {\n    if (typeof data === 'string') data = Buffer.from(data, enc);\n    return new this().fromRaw(data);\n  }\n  /**\n   * Inject properties from outpoint.\n   * @private\n   * @param {Outpoint} outpoint\n   */\n\n\n  fromOutpoint(outpoint) {\n    assert(Buffer.isBuffer(outpoint.hash));\n    assert(typeof outpoint.index === 'number');\n    this.prevout.hash = outpoint.hash;\n    this.prevout.index = outpoint.index;\n    return this;\n  }\n  /**\n   * Instantiate input from outpoint.\n   * @param {Outpoint}\n   * @returns {Input}\n   */\n\n\n  static fromOutpoint(outpoint) {\n    return new this().fromOutpoint(outpoint);\n  }\n  /**\n   * Inject properties from coin.\n   * @private\n   * @param {Coin} coin\n   */\n\n\n  fromCoin(coin) {\n    assert(Buffer.isBuffer(coin.hash));\n    assert(typeof coin.index === 'number');\n    this.prevout.hash = coin.hash;\n    this.prevout.index = coin.index;\n    return this;\n  }\n  /**\n   * Instantiate input from coin.\n   * @param {Coin}\n   * @returns {Input}\n   */\n\n\n  static fromCoin(coin) {\n    return new this().fromCoin(coin);\n  }\n  /**\n   * Inject properties from transaction.\n   * @private\n   * @param {TX} tx\n   * @param {Number} index\n   */\n\n\n  fromTX(tx, index) {\n    assert(tx);\n    assert(typeof index === 'number');\n    assert(index >= 0 && index < tx.outputs.length);\n    this.prevout.hash = tx.hash();\n    this.prevout.index = index;\n    return this;\n  }\n  /**\n   * Instantiate input from tx.\n   * @param {TX} tx\n   * @param {Number} index\n   * @returns {Input}\n   */\n\n\n  static fromTX(tx, index) {\n    return new this().fromTX(tx, index);\n  }\n  /**\n   * Test an object to see if it is an Input.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n\n  static isInput(obj) {\n    return obj instanceof Input;\n  }\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = Input;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/primitives/input.js"],"names":["assert","require","bio","Network","Script","Outpoint","inspectSymbol","Input","constructor","options","prevout","script","sequence","fromOptions","clone","input","inject","equals","isInput","compare","getType","coin","isCoinbase","type","getInputType","typesByVal","toLowerCase","getRedeem","isScripthashInput","prev","redeem","isScripthash","getSubtype","getAddress","code","length","getInputAddress","getHash","enc","addr","isFinal","isRBF","isNull","format","subtype","address","toJSON","network","getJSON","get","toString","undefined","fromJSON","json","getSize","getVarSize","toRaw","size","toWriter","write","render","bw","writeVarBytes","writeU32","fromReader","br","fromRaw","readVarBytes","readU32","data","read","Buffer","from","fromOutpoint","outpoint","isBuffer","hash","index","fromCoin","fromTX","tx","outputs","obj","module","exports"],"mappings":"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","sourcesContent":["/*!\n * input.js - input object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bio = require('bufio');\nconst Network = require('../protocol/network');\nconst Script = require('../script/script');\nconst Outpoint = require('./outpoint');\nconst {inspectSymbol} = require('../utils');\n\n\n/**\n * Input\n * Represents a transaction input.\n * @alias module:primitives.Input\n * @property {Outpoint} prevout - Outpoint.\n * @property {Script} script - Input script / scriptSig.\n * @property {Number} sequence - nSequence.\n */\n\nclass Input {\n  /**\n   * Create transaction input.\n   * @constructor\n   * @param {Object} options\n   */\n\n  constructor(options) {\n    this.prevout = new Outpoint();\n    this.script = new Script();\n    this.sequence = 0xffffffff;\n\n    if (options)\n      this.fromOptions(options);\n  }\n\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n  fromOptions(options) {\n    assert(options, 'Input data is required.');\n\n    this.prevout.fromOptions(options.prevout);\n\n    if (options.script)\n      this.script.fromOptions(options.script);\n\n    if (options.sequence != null) {\n      assert((options.sequence >>> 0) === options.sequence,\n        'Sequence must be a uint32.');\n      this.sequence = options.sequence;\n    }\n\n    return this;\n  }\n\n  /**\n   * Instantiate an Input from options object.\n   * @param {Object} options\n   * @returns {Input}\n   */\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n\n  /**\n   * Clone the input.\n   * @returns {Input}\n   */\n\n  clone() {\n    const input = new this.constructor();\n    input.prevout = this.prevout;\n    input.script.inject(this.script);\n    input.sequence = this.sequence;\n    return input;\n  }\n\n  /**\n   * Test equality against another input.\n   * @param {Input} input\n   * @returns {Boolean}\n   */\n\n  equals(input) {\n    assert(Input.isInput(input));\n    return this.prevout.equals(input.prevout);\n  }\n\n  /**\n   * Compare against another input (BIP69).\n   * @param {Input} input\n   * @returns {Number}\n   */\n\n  compare(input) {\n    assert(Input.isInput(input));\n    return this.prevout.compare(input.prevout);\n  }\n\n  /**\n   * Get the previous output script type as a string.\n   * Will \"guess\" based on the input script and/or\n   * witness if coin is not available.\n   * @param {Coin?} coin\n   * @returns {ScriptType} type\n   */\n\n  getType(coin) {\n    if (this.isCoinbase())\n      return 'coinbase';\n\n    if (coin)\n      return coin.getType();\n\n    const type = this.script.getInputType();\n\n    return Script.typesByVal[type].toLowerCase();\n  }\n\n  /**\n   * Get the redeem script.\n   * @param {Coin?} coin\n   * @returns {Script?} Redeem script.\n   */\n\n  getRedeem(coin) {\n    if (this.isCoinbase())\n      return null;\n\n    if (!coin) {\n      if (this.script.isScripthashInput())\n        return this.script.getRedeem();\n\n      return null;\n    }\n\n    let prev = coin.script;\n    let redeem = null;\n\n    if (prev.isScripthash()) {\n      prev = this.script.getRedeem();\n      redeem = prev;\n    }\n\n    return redeem;\n  }\n\n  /**\n   * Get the redeem script type.\n   * @param {Coin?} coin\n   * @returns {String} subtype\n   */\n\n  getSubtype(coin) {\n    if (this.isCoinbase())\n      return null;\n\n    const redeem = this.getRedeem(coin);\n\n    if (!redeem)\n      return null;\n\n    const type = redeem.getType();\n\n    return Script.typesByVal[type].toLowerCase();\n  }\n\n  /**\n   * Get the previous output script's address. Will \"guess\"\n   * based on the input script and/or witness if coin\n   * is not available.\n   * @param {Coin?} coin\n   * @returns {Address?} addr\n   */\n\n  getAddress(coin) {\n    if (this.isCoinbase())\n      return null;\n\n    if (coin)\n      return coin.getAddress();\n\n    if (this.script.code.length > 0)\n      return this.script.getInputAddress();\n\n    return null;\n  }\n\n  /**\n   * Get the address hash.\n   * @param {Coin?} coin\n   * @param {String?} enc\n   * @returns {Hash} hash\n   */\n\n  getHash(coin, enc) {\n    const addr = this.getAddress(coin);\n\n    if (!addr)\n      return null;\n\n    return addr.getHash(enc);\n  }\n\n  /**\n   * Test to see if nSequence is equal to uint32max.\n   * @returns {Boolean}\n   */\n\n  isFinal() {\n    return this.sequence === 0xffffffff;\n  }\n\n  /**\n   * Test to see if nSequence is less than 0xfffffffe.\n   * @returns {Boolean}\n   */\n\n  isRBF() {\n    return this.sequence < 0xfffffffe;\n  }\n\n  /**\n   * Test to see if outpoint is null.\n   * @returns {Boolean}\n   */\n\n  isCoinbase() {\n    return this.prevout.isNull();\n  }\n\n  /**\n   * Convert the input to a more user-friendly object.\n   * @returns {Object}\n   */\n\n  [inspectSymbol]() {\n    return this.format();\n  }\n\n  /**\n   * Convert the input to a more user-friendly object.\n   * @param {Coin?} coin\n   * @returns {Object}\n   */\n\n  format(coin) {\n    return {\n      type: this.getType(coin),\n      subtype: this.getSubtype(coin),\n      address: this.getAddress(coin),\n      script: this.script,\n      redeem: this.getRedeem(coin),\n      sequence: this.sequence,\n      prevout: this.prevout,\n      coin: coin || null\n    };\n  }\n\n  /**\n   * Convert the input to an object suitable\n   * for JSON serialization.\n   * @returns {Object}\n   */\n\n  toJSON(network, coin) {\n    return this.getJSON();\n  }\n\n  /**\n   * Convert the input to an object suitable\n   * for JSON serialization. Note that the hashes\n   * will be reversed to abide by bitcoind's legacy\n   * of little-endian uint256s.\n   * @param {Network} network\n   * @param {Coin} coin\n   * @returns {Object}\n   */\n\n  getJSON(network, coin) {\n    network = Network.get(network);\n\n    let addr;\n    if (!coin) {\n      addr = this.getAddress();\n      if (addr)\n        addr = addr.toString(network);\n    }\n\n    return {\n      prevout: this.prevout.toJSON(),\n      script: this.script.toJSON(),\n      sequence: this.sequence,\n      address: addr,\n      coin: coin ? coin.getJSON(network, true) : undefined\n    };\n  }\n\n  /**\n   * Inject properties from a JSON object.\n   * @private\n   * @param {Object} json\n   */\n\n  fromJSON(json) {\n    assert(json, 'Input data is required.');\n    assert((json.sequence >>> 0) === json.sequence,\n      'Sequence must be a uint32.');\n    this.prevout.fromJSON(json.prevout);\n    this.script.fromJSON(json.script);\n    this.sequence = json.sequence;\n    return this;\n  }\n\n  /**\n   * Instantiate an Input from a jsonified input object.\n   * @param {Object} json - The jsonified input object.\n   * @returns {Input}\n   */\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n\n  /**\n   * Calculate size of serialized input.\n   * @returns {Number}\n   */\n\n  getSize() {\n    return 40 + this.script.getVarSize();\n  }\n\n  /**\n   * Serialize the input.\n   * @param {String?} enc - Encoding, can be `'hex'` or null.\n   * @returns {Buffer|String}\n   */\n\n  toRaw() {\n    const size = this.getSize();\n    return this.toWriter(bio.write(size)).render();\n  }\n\n  /**\n   * Write the input to a buffer writer.\n   * @param {BufferWriter} bw\n   */\n\n  toWriter(bw) {\n    this.prevout.toWriter(bw);\n    bw.writeVarBytes(this.script.toRaw());\n    bw.writeU32(this.sequence);\n    return bw;\n  }\n\n  /**\n   * Inject properties from buffer reader.\n   * @private\n   * @param {BufferReader} br\n   */\n\n  fromReader(br) {\n    this.prevout.fromReader(br);\n    this.script.fromRaw(br.readVarBytes());\n    this.sequence = br.readU32();\n    return this;\n  }\n\n  /**\n   * Inject properties from serialized data.\n   * @param {Buffer} data\n   */\n\n  fromRaw(data) {\n    return this.fromReader(bio.read(data));\n  }\n\n  /**\n   * Instantiate an input from a buffer reader.\n   * @param {BufferReader} br\n   * @returns {Input}\n   */\n\n  static fromReader(br) {\n    return new this().fromReader(br);\n  }\n\n  /**\n   * Instantiate an input from a serialized Buffer.\n   * @param {Buffer} data\n   * @param {String?} enc - Encoding, can be `'hex'` or null.\n   * @returns {Input}\n   */\n\n  static fromRaw(data, enc) {\n    if (typeof data === 'string')\n      data = Buffer.from(data, enc);\n    return new this().fromRaw(data);\n  }\n\n  /**\n   * Inject properties from outpoint.\n   * @private\n   * @param {Outpoint} outpoint\n   */\n\n  fromOutpoint(outpoint) {\n    assert(Buffer.isBuffer(outpoint.hash));\n    assert(typeof outpoint.index === 'number');\n    this.prevout.hash = outpoint.hash;\n    this.prevout.index = outpoint.index;\n    return this;\n  }\n\n  /**\n   * Instantiate input from outpoint.\n   * @param {Outpoint}\n   * @returns {Input}\n   */\n\n  static fromOutpoint(outpoint) {\n    return new this().fromOutpoint(outpoint);\n  }\n\n  /**\n   * Inject properties from coin.\n   * @private\n   * @param {Coin} coin\n   */\n\n  fromCoin(coin) {\n    assert(Buffer.isBuffer(coin.hash));\n    assert(typeof coin.index === 'number');\n    this.prevout.hash = coin.hash;\n    this.prevout.index = coin.index;\n    return this;\n  }\n\n  /**\n   * Instantiate input from coin.\n   * @param {Coin}\n   * @returns {Input}\n   */\n\n  static fromCoin(coin) {\n    return new this().fromCoin(coin);\n  }\n\n  /**\n   * Inject properties from transaction.\n   * @private\n   * @param {TX} tx\n   * @param {Number} index\n   */\n\n  fromTX(tx, index) {\n    assert(tx);\n    assert(typeof index === 'number');\n    assert(index >= 0 && index < tx.outputs.length);\n    this.prevout.hash = tx.hash();\n    this.prevout.index = index;\n    return this;\n  }\n\n  /**\n   * Instantiate input from tx.\n   * @param {TX} tx\n   * @param {Number} index\n   * @returns {Input}\n   */\n\n  static fromTX(tx, index) {\n    return new this().fromTX(tx, index);\n  }\n\n  /**\n   * Test an object to see if it is an Input.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n  static isInput(obj) {\n    return obj instanceof Input;\n  }\n}\n\n/*\n * Expose\n */\n\nmodule.exports = Input;\n"]},"metadata":{},"sourceType":"module"}