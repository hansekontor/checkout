{"ast":null,"code":"/*!\n * des.js - DES for javascript\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on indutny/des.js:\n *   Copyright (c) 2015, Fedor Indutny (MIT License).\n *   https://github.com/indutny/des.js\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/Data_Encryption_Standard\n *   https://github.com/indutny/des.js/tree/master/lib/des\n */\n'use strict';\n\nconst assert = require('../../internal/assert');\n/*\n * Constants\n */\n\n\nconst PC2 = new Uint8Array([// inL => outL\n0x0e, 0x0b, 0x11, 0x04, 0x1b, 0x17, 0x19, 0x00, 0x0d, 0x16, 0x07, 0x12, 0x05, 0x09, 0x10, 0x18, 0x02, 0x14, 0x0c, 0x15, 0x01, 0x08, 0x0f, 0x1a, // inR => outR\n0x0f, 0x04, 0x19, 0x13, 0x09, 0x01, 0x1a, 0x10, 0x05, 0x0b, 0x17, 0x08, 0x0c, 0x07, 0x11, 0x00, 0x16, 0x03, 0x0a, 0x0e, 0x06, 0x14, 0x1b, 0x18]);\nconst S = new Uint8Array([0x0e, 0x00, 0x04, 0x0f, 0x0d, 0x07, 0x01, 0x04, 0x02, 0x0e, 0x0f, 0x02, 0x0b, 0x0d, 0x08, 0x01, 0x03, 0x0a, 0x0a, 0x06, 0x06, 0x0c, 0x0c, 0x0b, 0x05, 0x09, 0x09, 0x05, 0x00, 0x03, 0x07, 0x08, 0x04, 0x0f, 0x01, 0x0c, 0x0e, 0x08, 0x08, 0x02, 0x0d, 0x04, 0x06, 0x09, 0x02, 0x01, 0x0b, 0x07, 0x0f, 0x05, 0x0c, 0x0b, 0x09, 0x03, 0x07, 0x0e, 0x03, 0x0a, 0x0a, 0x00, 0x05, 0x06, 0x00, 0x0d, 0x0f, 0x03, 0x01, 0x0d, 0x08, 0x04, 0x0e, 0x07, 0x06, 0x0f, 0x0b, 0x02, 0x03, 0x08, 0x04, 0x0e, 0x09, 0x0c, 0x07, 0x00, 0x02, 0x01, 0x0d, 0x0a, 0x0c, 0x06, 0x00, 0x09, 0x05, 0x0b, 0x0a, 0x05, 0x00, 0x0d, 0x0e, 0x08, 0x07, 0x0a, 0x0b, 0x01, 0x0a, 0x03, 0x04, 0x0f, 0x0d, 0x04, 0x01, 0x02, 0x05, 0x0b, 0x08, 0x06, 0x0c, 0x07, 0x06, 0x0c, 0x09, 0x00, 0x03, 0x05, 0x02, 0x0e, 0x0f, 0x09, 0x0a, 0x0d, 0x00, 0x07, 0x09, 0x00, 0x0e, 0x09, 0x06, 0x03, 0x03, 0x04, 0x0f, 0x06, 0x05, 0x0a, 0x01, 0x02, 0x0d, 0x08, 0x0c, 0x05, 0x07, 0x0e, 0x0b, 0x0c, 0x04, 0x0b, 0x02, 0x0f, 0x08, 0x01, 0x0d, 0x01, 0x06, 0x0a, 0x04, 0x0d, 0x09, 0x00, 0x08, 0x06, 0x0f, 0x09, 0x03, 0x08, 0x00, 0x07, 0x0b, 0x04, 0x01, 0x0f, 0x02, 0x0e, 0x0c, 0x03, 0x05, 0x0b, 0x0a, 0x05, 0x0e, 0x02, 0x07, 0x0c, 0x07, 0x0d, 0x0d, 0x08, 0x0e, 0x0b, 0x03, 0x05, 0x00, 0x06, 0x06, 0x0f, 0x09, 0x00, 0x0a, 0x03, 0x01, 0x04, 0x02, 0x07, 0x08, 0x02, 0x05, 0x0c, 0x0b, 0x01, 0x0c, 0x0a, 0x04, 0x0e, 0x0f, 0x09, 0x0a, 0x03, 0x06, 0x0f, 0x09, 0x00, 0x00, 0x06, 0x0c, 0x0a, 0x0b, 0x01, 0x07, 0x0d, 0x0d, 0x08, 0x0f, 0x09, 0x01, 0x04, 0x03, 0x05, 0x0e, 0x0b, 0x05, 0x0c, 0x02, 0x07, 0x08, 0x02, 0x04, 0x0e, 0x02, 0x0e, 0x0c, 0x0b, 0x04, 0x02, 0x01, 0x0c, 0x07, 0x04, 0x0a, 0x07, 0x0b, 0x0d, 0x06, 0x01, 0x08, 0x05, 0x05, 0x00, 0x03, 0x0f, 0x0f, 0x0a, 0x0d, 0x03, 0x00, 0x09, 0x0e, 0x08, 0x09, 0x06, 0x04, 0x0b, 0x02, 0x08, 0x01, 0x0c, 0x0b, 0x07, 0x0a, 0x01, 0x0d, 0x0e, 0x07, 0x02, 0x08, 0x0d, 0x0f, 0x06, 0x09, 0x0f, 0x0c, 0x00, 0x05, 0x09, 0x06, 0x0a, 0x03, 0x04, 0x00, 0x05, 0x0e, 0x03, 0x0c, 0x0a, 0x01, 0x0f, 0x0a, 0x04, 0x0f, 0x02, 0x09, 0x07, 0x02, 0x0c, 0x06, 0x09, 0x08, 0x05, 0x00, 0x06, 0x0d, 0x01, 0x03, 0x0d, 0x04, 0x0e, 0x0e, 0x00, 0x07, 0x0b, 0x05, 0x03, 0x0b, 0x08, 0x09, 0x04, 0x0e, 0x03, 0x0f, 0x02, 0x05, 0x0c, 0x02, 0x09, 0x08, 0x05, 0x0c, 0x0f, 0x03, 0x0a, 0x07, 0x0b, 0x00, 0x0e, 0x04, 0x01, 0x0a, 0x07, 0x01, 0x06, 0x0d, 0x00, 0x0b, 0x08, 0x06, 0x0d, 0x04, 0x0d, 0x0b, 0x00, 0x02, 0x0b, 0x0e, 0x07, 0x0f, 0x04, 0x00, 0x09, 0x08, 0x01, 0x0d, 0x0a, 0x03, 0x0e, 0x0c, 0x03, 0x09, 0x05, 0x07, 0x0c, 0x05, 0x02, 0x0a, 0x0f, 0x06, 0x08, 0x01, 0x06, 0x01, 0x06, 0x04, 0x0b, 0x0b, 0x0d, 0x0d, 0x08, 0x0c, 0x01, 0x03, 0x04, 0x07, 0x0a, 0x0e, 0x07, 0x0a, 0x09, 0x0f, 0x05, 0x06, 0x00, 0x08, 0x0f, 0x00, 0x0e, 0x05, 0x02, 0x09, 0x03, 0x02, 0x0c, 0x0d, 0x01, 0x02, 0x0f, 0x08, 0x0d, 0x04, 0x08, 0x06, 0x0a, 0x0f, 0x03, 0x0b, 0x07, 0x01, 0x04, 0x0a, 0x0c, 0x09, 0x05, 0x03, 0x06, 0x0e, 0x0b, 0x05, 0x00, 0x00, 0x0e, 0x0c, 0x09, 0x07, 0x02, 0x07, 0x02, 0x0b, 0x01, 0x04, 0x0e, 0x01, 0x07, 0x09, 0x04, 0x0c, 0x0a, 0x0e, 0x08, 0x02, 0x0d, 0x00, 0x0f, 0x06, 0x0c, 0x0a, 0x09, 0x0d, 0x00, 0x0f, 0x03, 0x03, 0x05, 0x05, 0x06, 0x08, 0x0b]);\nconst PERMUTE = new Uint8Array([0x10, 0x19, 0x0c, 0x0b, 0x03, 0x14, 0x04, 0x0f, 0x1f, 0x11, 0x09, 0x06, 0x1b, 0x0e, 0x01, 0x16, 0x1e, 0x18, 0x08, 0x12, 0x00, 0x05, 0x1d, 0x17, 0x0d, 0x13, 0x02, 0x1a, 0x0a, 0x15, 0x1c, 0x07]);\nconst SHIFT = new Uint8Array([0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01]);\n/**\n * DES\n */\n\nclass DES {\n  constructor() {\n    this.block = new Uint32Array(2);\n    this.keys = new Uint32Array(16 * 2);\n  }\n\n  get blockSize() {\n    return 8;\n  }\n\n  init(key) {\n    assert(Buffer.isBuffer(key));\n    assert(key.length === 8);\n    return this.derive(key);\n  }\n\n  encrypt(input, ipos, output, opos) {\n    return this.crypt(input, ipos, output, opos, true);\n  }\n\n  decrypt(input, ipos, output, opos) {\n    return this.crypt(input, ipos, output, opos, false);\n  }\n\n  destroy() {\n    for (let i = 0; i < 2; i++) this.block[i] = 0;\n\n    for (let i = 0; i < 32; i++) this.keys[i] = 0;\n\n    return this;\n  }\n\n  derive(key) {\n    let kL = readU32(key, 0);\n    let kR = readU32(key, 4);\n    pc1(kL, kR, this.block, 0);\n    kL = this.block[0];\n    kR = this.block[1];\n\n    for (let i = 0; i < this.keys.length; i += 2) {\n      const shift = SHIFT[i >>> 1];\n      kL = r28shl(kL, shift);\n      kR = r28shl(kR, shift);\n      pc2(kL, kR, this.keys, i);\n    }\n\n    return this;\n  }\n\n  crypt(input, ipos, output, opos, encrypt) {\n    let l = readU32(input, ipos);\n    let r = readU32(input, ipos + 4); // Initial Permutation\n\n    ip(l, r, this.block, 0);\n    l = this.block[0];\n    r = this.block[1];\n    if (encrypt) this.encipher(l, r, this.block, 0);else this.decipher(l, r, this.block, 0);\n    l = this.block[0];\n    r = this.block[1];\n    writeU32(output, l, opos);\n    writeU32(output, r, opos + 4);\n    return this;\n  }\n\n  encipher(lStart, rStart, out, off) {\n    let l = lStart;\n    let r = rStart; // Apply f() x16 times\n\n    for (let i = 0; i < this.keys.length; i += 2) {\n      let keyL = this.keys[i];\n      let keyR = this.keys[i + 1]; // f(r, k)\n\n      expand(r, this.block, 0);\n      keyL ^= this.block[0];\n      keyR ^= this.block[1];\n      const s = substitute(keyL, keyR);\n      const f = permute(s);\n      const t = r;\n      r = (l ^ f) >>> 0;\n      l = t;\n    } // Reverse Initial Permutation\n\n\n    rip(r, l, out, off);\n    return this;\n  }\n\n  decipher(lStart, rStart, out, off) {\n    let l = rStart;\n    let r = lStart; // Apply f() x16 times\n\n    for (let i = this.keys.length - 2; i >= 0; i -= 2) {\n      let keyL = this.keys[i];\n      let keyR = this.keys[i + 1]; // f(r, k)\n\n      expand(l, this.block, 0);\n      keyL ^= this.block[0];\n      keyR ^= this.block[1];\n      const s = substitute(keyL, keyR);\n      const f = permute(s);\n      const t = l;\n      l = (r ^ f) >>> 0;\n      r = t;\n    } // Reverse Initial Permutation\n\n\n    rip(l, r, out, off);\n    return this;\n  }\n\n}\n/**\n * EDE\n */\n\n\nclass EDE {\n  constructor() {\n    this.x = new DES();\n    this.y = new DES();\n  }\n\n  get blockSize() {\n    return 8;\n  }\n\n  init(key) {\n    assert(Buffer.isBuffer(key));\n    assert(key.length === 16);\n    const k1 = key.slice(0, 8);\n    const k2 = key.slice(8, 16);\n    this.x.init(k1);\n    this.y.init(k2);\n    return this;\n  }\n\n  encrypt(input, ipos, output, opos) {\n    this.x.encrypt(input, ipos, output, opos);\n    this.y.decrypt(output, opos, output, opos);\n    this.x.encrypt(output, opos, output, opos);\n    return this;\n  }\n\n  decrypt(input, ipos, output, opos) {\n    this.x.decrypt(input, ipos, output, opos);\n    this.y.encrypt(output, opos, output, opos);\n    this.x.decrypt(output, opos, output, opos);\n    return this;\n  }\n\n  destroy() {\n    this.x.destroy();\n    this.y.destroy();\n    return this;\n  }\n\n}\n/**\n * EDE3\n */\n\n\nclass EDE3 {\n  constructor() {\n    this.x = new DES();\n    this.y = new DES();\n    this.z = new DES();\n  }\n\n  get blockSize() {\n    return 8;\n  }\n\n  init(key) {\n    assert(Buffer.isBuffer(key));\n    assert(key.length === 24);\n    const k1 = key.slice(0, 8);\n    const k2 = key.slice(8, 16);\n    const k3 = key.slice(16, 24);\n    this.x.init(k1);\n    this.y.init(k2);\n    this.z.init(k3);\n    return this;\n  }\n\n  encrypt(input, ipos, output, opos) {\n    this.x.encrypt(input, ipos, output, opos);\n    this.y.decrypt(output, opos, output, opos);\n    this.z.encrypt(output, opos, output, opos);\n    return this;\n  }\n\n  decrypt(input, ipos, output, opos) {\n    this.z.decrypt(input, ipos, output, opos);\n    this.y.encrypt(output, opos, output, opos);\n    this.x.decrypt(output, opos, output, opos);\n    return this;\n  }\n\n  destroy() {\n    this.x.destroy();\n    this.y.destroy();\n    this.z.destroy();\n    return this;\n  }\n\n}\n/*\n * Helpers\n */\n\n\nfunction ip(inL, inR, out, off) {\n  let outL = 0;\n  let outR = 0;\n\n  for (let i = 6; i >= 0; i -= 2) {\n    for (let j = 0; j <= 24; j += 8) {\n      outL <<= 1;\n      outL |= inR >>> j + i & 1;\n    }\n\n    for (let j = 0; j <= 24; j += 8) {\n      outL <<= 1;\n      outL |= inL >>> j + i & 1;\n    }\n  }\n\n  for (let i = 6; i >= 0; i -= 2) {\n    for (let j = 1; j <= 25; j += 8) {\n      outR <<= 1;\n      outR |= inR >>> j + i & 1;\n    }\n\n    for (let j = 1; j <= 25; j += 8) {\n      outR <<= 1;\n      outR |= inL >>> j + i & 1;\n    }\n  }\n\n  out[off + 0] = outL >>> 0;\n  out[off + 1] = outR >>> 0;\n}\n\nfunction rip(inL, inR, out, off) {\n  let outL = 0;\n  let outR = 0;\n\n  for (let i = 0; i < 4; i++) {\n    for (let j = 24; j >= 0; j -= 8) {\n      outL <<= 1;\n      outL |= inR >>> j + i & 1;\n      outL <<= 1;\n      outL |= inL >>> j + i & 1;\n    }\n  }\n\n  for (let i = 4; i < 8; i++) {\n    for (let j = 24; j >= 0; j -= 8) {\n      outR <<= 1;\n      outR |= inR >>> j + i & 1;\n      outR <<= 1;\n      outR |= inL >>> j + i & 1;\n    }\n  }\n\n  out[off + 0] = outL >>> 0;\n  out[off + 1] = outR >>> 0;\n}\n\nfunction pc1(inL, inR, out, off) {\n  let outL = 0;\n  let outR = 0; // 7, 15, 23, 31, 39, 47, 55, 63\n  // 6, 14, 22, 30, 39, 47, 55, 63\n  // 5, 13, 21, 29, 39, 47, 55, 63\n  // 4, 12, 20, 28\n\n  for (let i = 7; i >= 5; i--) {\n    for (let j = 0; j <= 24; j += 8) {\n      outL <<= 1;\n      outL |= inR >> j + i & 1;\n    }\n\n    for (let j = 0; j <= 24; j += 8) {\n      outL <<= 1;\n      outL |= inL >> j + i & 1;\n    }\n  }\n\n  for (let j = 0; j <= 24; j += 8) {\n    outL <<= 1;\n    outL |= inR >> j + 4 & 1;\n  } // 1, 9, 17, 25, 33, 41, 49, 57\n  // 2, 10, 18, 26, 34, 42, 50, 58\n  // 3, 11, 19, 27, 35, 43, 51, 59\n  // 36, 44, 52, 60\n\n\n  for (let i = 1; i <= 3; i++) {\n    for (let j = 0; j <= 24; j += 8) {\n      outR <<= 1;\n      outR |= inR >> j + i & 1;\n    }\n\n    for (let j = 0; j <= 24; j += 8) {\n      outR <<= 1;\n      outR |= inL >> j + i & 1;\n    }\n  }\n\n  for (let j = 0; j <= 24; j += 8) {\n    outR <<= 1;\n    outR |= inL >> j + 4 & 1;\n  }\n\n  out[off + 0] = outL >>> 0;\n  out[off + 1] = outR >>> 0;\n}\n\nfunction r28shl(num, shift) {\n  return num << shift & 0xfffffff | num >>> 28 - shift;\n}\n\nfunction pc2(inL, inR, out, off) {\n  let outL = 0;\n  let outR = 0;\n  const len = PC2.length >>> 1;\n\n  for (let i = 0; i < len; i++) {\n    outL <<= 1;\n    outL |= inL >>> PC2[i] & 1;\n  }\n\n  for (let i = len; i < PC2.length; i++) {\n    outR <<= 1;\n    outR |= inR >>> PC2[i] & 1;\n  }\n\n  out[off + 0] = outL >>> 0;\n  out[off + 1] = outR >>> 0;\n}\n\nfunction expand(r, out, off) {\n  let outL = 0;\n  let outR = 0;\n  outL = (r & 1) << 5 | r >>> 27;\n\n  for (let i = 23; i >= 15; i -= 4) {\n    outL <<= 6;\n    outL |= r >>> i & 0x3f;\n  }\n\n  for (let i = 11; i >= 3; i -= 4) {\n    outR |= r >>> i & 0x3f;\n    outR <<= 6;\n  }\n\n  outR |= (r & 0x1f) << 1 | r >>> 31;\n  out[off + 0] = outL >>> 0;\n  out[off + 1] = outR >>> 0;\n}\n\nfunction substitute(inL, inR) {\n  let out = 0;\n\n  for (let i = 0; i < 4; i++) {\n    const b = inL >>> 18 - i * 6 & 0x3f;\n    const sb = S[i * 0x40 + b];\n    out <<= 4;\n    out |= sb;\n  }\n\n  for (let i = 0; i < 4; i++) {\n    const b = inR >>> 18 - i * 6 & 0x3f;\n    const sb = S[4 * 0x40 + i * 0x40 + b];\n    out <<= 4;\n    out |= sb;\n  }\n\n  return out >>> 0;\n}\n\nfunction permute(num) {\n  let out = 0;\n\n  for (let i = 0; i < PERMUTE.length; i++) {\n    out <<= 1;\n    out |= num >>> PERMUTE[i] & 1;\n  }\n\n  return out >>> 0;\n}\n\nfunction readU32(data, off) {\n  return data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];\n}\n\nfunction writeU32(dst, num, off) {\n  dst[off++] = num >>> 24;\n  dst[off++] = num >>> 16;\n  dst[off++] = num >>> 8;\n  dst[off++] = num;\n  return off;\n}\n/*\n * Expose\n */\n\n\nexports.DES = DES;\nexports.EDE = EDE;\nexports.EDE3 = EDE3;","map":null,"metadata":{},"sourceType":"script"}