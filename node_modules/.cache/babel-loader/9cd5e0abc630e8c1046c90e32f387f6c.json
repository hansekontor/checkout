{"ast":null,"code":"/*!\n * slp.js - simple ledger protocol script for bcash\n * Copyright (c) 2021, Vin Armani (MIT License).\n * https://github.com/badger-cash/bcash\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bio = require('bufio');\n\nconst {\n  U64\n} = require('n64');\n\nconst consensus = require('../protocol/consensus');\n\nconst Script = require('./script');\n\nconst ScriptNum = require('./scriptnum');\n/**\n * SLP Coin Record\n */\n\n\nconst SLP_TYPES = {\n  GENESIS: 0x00,\n  MINT: 0x01,\n  SEND: 0x02,\n  BATON: 0x03,\n  BURN: 0x04\n};\n\nclass SlpCoinRecord {\n  /**\n   * Create a record of SLP data for a given coin.\n   * @param {Buffer?} hash the output hash of the coin\n   * @param {Number?} vout the output index of the coin\n   * @param {Buffer?} tokenId 32 byte txid\n   * @param {Buffer?} tokenIndex 4 byte unsigned integer (index of tx hash in db)\n   * @param {Buffer} value big endian value of token base units\n   * @param {String} type GENESIS | MINT | SEND | BURN | BATON\n   * @param {Number?} version token type\n   * @constructor\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.hash = options.hash;\n    this.vout = options.vout;\n    this.tokenId = options.tokenId;\n    this.tokenIndex = options.tokenIndex;\n    this.value = options.value;\n    this.type = options.type;\n    this.version = options.version;\n  } //   /**\n  //    * Get the value as 64 bit big-endian buffer\n  //    * @private\n  //    * @returns {Buffer}\n  //    */\n  //   getValueUInt64BE() {\n  //     assert(this.value.length <= 8, 'value buffer must be 8 bytes or less');\n  //     const padding = Buffer.alloc(8 - this.value.length);\n  //     return Buffer.concat([padding, this.value]);\n  //   }\n  //   /**\n  //    * Inject properties from serialized data.\n  //    * @private\n  //    * @param {Buffer} data\n  //    */\n  //   fromDbData(data) {\n  //     const br = bio.read(data);\n  //     this.tokenIndex = br.readBytes(4);\n  //     const valueBytes = br.readVarBytes();\n  //     const padding = Buffer.alloc(8 - valueBytes.length);\n  //     this.value = Buffer.concat([padding, valueBytes]);\n  //     this.type = Object.keys(SLP_TYPES)[br.readU8()];\n  //     // Get version and handle if out of bounds\n  //     try {\n  //       this.version = br.readU8();\n  //     } catch (err) {\n  //       if (err.code === 'ERR_ENCODING')\n  //         this.version = 1;\n  //       else throw(err)\n  //     }\n  //     assert(this.version >= 1 && this.version <= 2);\n  //     assert(Object.keys(SLP_TYPES).includes(this.type));\n  //     return this;\n  //   }\n  //   /**\n  //    * Instantiate SLP record from serialized data.\n  //    * @param {Buffer} data\n  //    * @returns {SlpCoinRecord}\n  //    */\n  //   static fromDbData(data) {\n  //     return new this().fromDbData(data);\n  //   }\n  //   /**\n  //    * Serialize the SLP record.\n  //    * @returns {Buffer}\n  //    */\n  //   toDbData() {\n  //     assert(this.tokenIndex, 'Missing tokenIndex');\n  //     assert(this.tokenIndex.length == 4, 'tokenId must be a sha256 hash');\n  //     // assert(this.value, 'Missing token amount (in base units)')\n  //     assert(this.value.byteLength, 'Token amount must be a buffer')\n  //     assert(Object.keys(SLP_TYPES).includes(this.type), 'Type must be GENESIS | MINT | SEND | BATON | BURN');\n  //     // Remove padding (minimal)\n  //     for (let i = 0; i < this.value.length; i++) {\n  //       if (this.value[i] != 0) {\n  //         this.value = this.value.slice(i)\n  //         break;\n  //       }\n  //     }\n  //     const bw = bio.write();\n  //     bw.writeBytes(this.tokenIndex);\n  //     bw.writeVarBytes(this.value);\n  //     bw.writeU8(SLP_TYPES[this.type]);\n  //     bw.writeU8(this.version || 1);\n  //     return bw.render();\n  //   }\n  //   /**\n  //    * Convert object to JSON.\n  //    * @returns {Object}\n  //    */\n  //   getJSON() {\n  //     assert(this.tokenId, 'tokenId must be defined');\n  //     const json = {\n  //       hash: this.hash ? Buffer.from(this.hash).reverse().toString('hex') : undefined,\n  //       vout: this.vout,\n  //       tokenId: this.tokenId.toString('hex'),\n  //       value: U64.fromBE(this.value).toString(10),\n  //       type: this.type,\n  //       version: this.version || 1\n  //     }\n  //     return json;\n  //   }\n\n  /**\n   * Convert from JSON to Object.\n   * @param {Object} json\n   * @returns {SlpCoinRecord}\n   */\n\n\n  fromJSON(json) {\n    this.hash = Buffer.from(json.hash, 'hex').reverse();\n    this.vout = json.vout;\n    this.tokenId = Buffer.from(json.tokenId, 'hex');\n    this.value = U64.fromString(json.value).toBE(Buffer);\n    this.type = json.type;\n    this.version = json.version || 1;\n    return this;\n  } //   /**\n  //    * Convert from JSON to Object.\n  //    * @param {Object} json\n  //    * @returns {TokenRecord}\n  //    */\n  //    static fromJSON(json) {\n  //     return new this().fromJSON(json);\n  //   }\n\n\n} // /**\n//  * Token Record\n//  */\n//  class TokenRecord {\n//   /**\n//    * Create a token record.\n//    * @constructor\n//    * @param {Buffer?} tokenId\n//    * @param {Buffer?} tokenIndex\n//    * @param {String?} ticker\n//    * @param {String?} name\n//    * @param {String?} uri\n//    * @param {String?} hash\n//    * @param {Number} decimals\n//    * @param {Number?} version\n//    * @param {Buffer?} vaultScriptHash\n//    */\n//   constructor(options = {}) {\n//     this.tokenId = options.tokenId;\n//     this.tokenIndex = options.tokenIndex;\n//     this.ticker = options.ticker || '';\n//     this.name = options.name || '';\n//     this.uri = options.uri || '';\n//     this.hash = options.hash || '';\n//     this.decimals = options.decimals;\n//     this.version = options.version;\n//     if (this.version === 2 )\n//       this.vaultScriptHash = options.vaultScriptHash;\n//   }\n//   /**\n//    * Inject properties from serialized data.\n//    * @private\n//    * @param {Buffer} data\n//    */\n//   fromDbData(data) {\n//     const br = bio.read(data);\n//     this.tokenId = br.readHash();\n//     this.ticker = br.readVarString('utf8');\n//     // assert(this.ticker.length > 0);\n//     this.name = br.readVarString('utf8');\n//     // assert(this.name.length > 0);\n//     this.uri = br.readVarString('utf8');\n//     this.hash = br.readVarString('hex');\n//     this.decimals = br.readU8();\n//     // Get version and handle if out of bounds\n//     try {\n//       this.version = br.readU8();\n//     } catch(err) {\n//       if (err.code === 'ERR_ENCODING') {\n//         this.version = 1;\n//       } else throw(err)\n//     }\n//     // Read MINT vault ScriptHash\n//     if (this.version ===2)\n//       this.vaultScriptHash = br.readBytes(20);\n//     assert(this.version >= 1 && this.version <= 2);\n//     // assert(this.decimals >= 0 && this.decimals < 9);\n//     return this;\n//   }\n//   /**\n//    * Instantiate token record from serialized data.\n//    * @param {Buffer} data\n//    * @returns {TokenRecord}\n//    */\n//   static fromDbData(data) {\n//     return new this().fromDbData(data);\n//   }\n//   /**\n//    * Serialize the token record.\n//    * @returns {Buffer}\n//    */\n//   toDbData() {\n//     const bw = bio.write();\n//     const encoding = bio.encoding;\n//     bw.writeHash(this.tokenId);\n//     bw.writeVarString(this.ticker, 'utf8');\n//     if (this.ticker.length === 0)\n//       bw.offset += encoding.sizeVarint(0);\n//     bw.writeVarString(this.name, 'utf8');\n//     if (this.name.length === 0)\n//       bw.offset += encoding.sizeVarint(0);\n//     bw.writeVarString(this.uri, 'utf8');\n//     if (this.uri.length === 0)\n//       bw.offset += encoding.sizeVarint(0);\n//     bw.writeVarString(this.hash, 'hex');\n//     if (this.hash.length === 0)\n//       bw.offset += encoding.sizeVarint(0);\n//     bw.writeU8(this.decimals);\n//     bw.writeU8(this.version || 1);\n//     if (this.version === 2)\n//       bw.writeBytes(this.vaultScriptHash);\n//     return bw.render();\n//   }\n//   /**\n//    * Convert object to JSON.\n//    * @returns {Object}\n//    */\n//   getJSON() {\n//     assert(this.tokenId, 'tokenId must be defined');\n//     const json = {\n//       tokenId: this.tokenId.toString('hex'),\n//       ticker: this.ticker,\n//       name: this.name,\n//       uri: this.uri,\n//       hash: this.hash,\n//       decimals: this.decimals,\n//       version: this.version || 1\n//     }\n//     if (json.version === 2 && this.vaultScriptHash)\n//       json.vaultScriptHash = this.vaultScriptHash.toString('hex');\n//     return json;\n//   }\n//   /**\n//    * Convert from JSON to Object.\n//    * @param {Object} json\n//    * @returns {SlpCoinRecord}\n//    */\n//    fromJSON(json) {\n//     this.tokenId = Buffer.from(json.tokenId, 'hex');\n//     this.ticker = json.ticker;\n//     this.name = json.name;\n//     this.uri = json.uri;\n//     this.hash = json.hash\n//     this.decimals = json.decimals;\n//     this.version = json.version;\n//     if (json.version === 2 && json.vaultScriptHash)\n//       this.vaultScriptHash = Buffer.from(json.vaultScriptHash, 'hex');\n//     return this\n//   }\n//   /**\n//    * Convert from JSON to Object.\n//    * @param {Object} json\n//    * @returns {TokenRecord}\n//    */\n//    static fromJSON(json) {\n//     return new this().fromJSON(json);\n//   }\n// }\n\n/**\n * SLP\n * @alias module:script.SLP\n * @extends Script\n */\n\n\nclass SLP extends Script {\n  /**\n   * Create an SLP script.\n   * @constructor\n   * @param {Buffer|Array|Object} code\n   */\n  constructor(options) {\n    super(options);\n    this.valid = null;\n  } // //   /**\n  // //    * Is SLP script is of valid construction?\n  // //    * Use this as opposed to calling property this.isValid\n  // //    * @private\n  // //    * @returns {Boolean}\n  // //    */\n  //   isValidSlp() {\n  //     if (this.valid === null) {\n  //       this.valid = this.verifySlp();\n  //     }\n  //     return this.valid;\n  //   }\n  // //   /**\n  // //    * Test whether SLP script is of valid construction\n  // //    * (Does not test if transaction is valid SLP transaction)\n  // //    * @private\n  // //    * @param {Script?} script\n  // //    * @returns {Boolean}\n  // //    */\n  //   verifySlp(script) {\n  //     if (script == undefined)\n  //       script = this;\n  //     if (script.getSym(0) != 'OP_RETURN')\n  //       return false;\n  //     // LOKAD_ID\n  //     if (script.getString(1, 'hex') != '534c5000')\n  //       return false;\n  //     // Check version\n  //     const versionHex = script.getString(2, 'hex');\n  //     if (versionHex != '01' && versionHex != '02') \n  //       return false;\n  //     // Type\n  //     const type = script.getType();\n  //     switch (type) {\n  //       case 'GENESIS': {\n  //         if (script.code.length != 11)\n  //           return false;\n  //         // Hash\n  //         if (!script.getData(7))\n  //           return false;\n  //         if (script.getData(7).length != 0 && script.getData(7).length != 32)\n  //           return false;\n  //         // Decimals\n  //         if (!script.getData(8))\n  //           return false;\n  //         if (script.getData(8).length != 1 || script.getInt(8) > 9)\n  //           return false;\n  //         if (versionHex == '01') {\n  //           // Mint Baton\n  //           if (!script.getData(9))\n  //             return false;\n  //           if (script.getData(9).length > 1)\n  //             return false;\n  //           if (script.getData(9).length == 1 && script.getInt(9) < 2)\n  //             return false;\n  //         } else if (versionHex == '02') {\n  //           // Mint Vault ScriptHash\n  //           if (!script.getData(9))\n  //             return false;\n  //           if (script.getData(9).length != 20)\n  //             return false;\n  //         }\n  //         // Minted Tokens\n  //         if (script.getData(10).length != 8)\n  //           return false\n  //         break;\n  //       }\n  //       case 'MINT': {\n  //         if (script.code.length != 7)\n  //           return false;\n  //         // Token ID\n  //         if (script.getData(4).length != 32)\n  //           return false;\n  //         if (versionHex == '01') {\n  //           // Mint Baton\n  //           if (!script.getData(5))\n  //             return false;\n  //           if (script.getData(5).length > 1)\n  //             return false;\n  //           if (script.getData(5).length == 1 && script.getInt(5) < 2)\n  //             return false;\n  //           // Minted Tokens\n  //           if (script.getData(6).length != 8)\n  //             return false\n  //         } else if (versionHex == '02') {\n  //           const outputs = script.code.slice(5);\n  //           for (let i = 0; i < outputs.length; i++) {\n  //             const op = outputs[i];\n  //             // Sent Tokens\n  //             if (op.data.length != 8)\n  //               return false\n  //           }\n  //         }\n  //         break;\n  //       }\n  //       case 'SEND': {\n  //         if (script.code.length < 6)\n  //           return false;\n  //         // Token ID\n  //         if (script.getData(4).length != 32)\n  //           return false;\n  //         const outputs = script.code.slice(5);\n  //         for (let i = 0; i < outputs.length; i++) {\n  //           const op = outputs[i];\n  //           // Sent Tokens\n  //           if (op.data.length != 8)\n  //             return false\n  //         }\n  //         break;\n  //       }\n  //       case 'BURN': {\n  //         if (script.code.length != 6)\n  //           return false;\n  //         // Token ID\n  //         if (script.getData(4).length != 32)\n  //           return false;\n  //         // Sent Tokens\n  //         if (script.getData(5).length != 8)\n  //           return false\n  //         break;\n  //       }\n  //       default: {\n  //         return false;\n  //       }\n  //     }\n  //     return true;\n  //   }\n  // //   /**\n  // //    * Test whether script is of valid construction\n  // //    * (Does not test if transaction is valid SLP transaction)\n  // //    * @param {Script?} script\n  // //    * @returns {Boolean}\n  // //    */\n  //   static verifySlp(script) {\n  //     return new this().verifySlp(script);\n  //   }\n  //   /**\n  //    * Inject properties from a script\n  //    * @private\n  //    * @param {Script} code\n  //    * @returns {SLP}\n  //    */\n  //   fromScript(script) {\n  //     this.inject(script);\n  //     return this;\n  //   }\n  //   /**\n  //    * Inject properties from a script\n  //    * @param {Script} code\n  //    * @returns {SLP}\n  //    */\n  //    static fromScript(script) {\n  //     return new this().fromScript(script);\n  //   }\n  //   /**\n  //    * Get token ID for this script\n  //    * @private\n  //    * @returns {Hash}\n  //    */\n  //     getTokenId() {\n  //       assert(this.verifySlp(), 'This is not a valid SLP script')\n  //       // Type\n  //       const type = this.getType();\n  //       assert(type != 'GENESIS', 'Cannot derive the tokenID from GENESIS script')\n  //       // Return tokenId as buffer\n  //       return this.getData(4);\n  //     }\n  //   /**\n  //    * Get records for a this script\n  //    * @private\n  //    * @param {Buffer?} txId The txid of the transaction containing this script\n  //    * @returns {(SlpCoinRecord | TokenRecord)[]}\n  //    */\n  //   getRecords(txId) {\n  //     assert(this.isValidSlp(), 'Must be a valid SLP Script' )\n  //     const type = this.getType();\n  //     assert(Object.keys(SLP_TYPES).includes(type) && type != 'BATON', 'Type must be GENESIS | MINT | SEND | BURN');\n  //     assert(txId.byteLength, 'tokenId must be a buffer');\n  //     assert(txId.length == 32, 'tokenId must be a sha256 hash');\n  //     switch (type) {\n  //       case 'GENESIS': {\n  //         return this.getGenesisRecords(txId);\n  //         break;\n  //       }\n  //       case 'MINT': {\n  //         return this.getMintRecords(txId);\n  //         break;\n  //       }\n  //       case 'SEND': {\n  //         return this.getSendRecords(txId);\n  //         break;\n  //       }\n  //       case 'BURN': {\n  //         return this.getBurnRecords(txId);\n  //         break;\n  //       }\n  //       default: {\n  //         return null;\n  //       }\n  //     }\n  //   }\n  //   /**\n  //    * Get records for a GENESIS script\n  //    * @private\n  //    * @param {Buffer} tokenId The tokenId of the transaction containing this script\n  //    * @returns {(SlpCoinRecord | TokenRecord)[]}\n  //    */\n  //   getGenesisRecords(tokenId) {\n  //     assert(tokenId.byteLength, 'tokenId must be a buffer');\n  //     assert(tokenId.byteLength == 32, 'tokenId must be a sha256 hash');\n  //     const type = this.getType();\n  //     assert(type == 'GENESIS', 'This is not a GENESIS transaction')\n  //     const versionInt = this.getInt(2);\n  //     const records = [];\n  //     // Create TokenRecord\n  //     records.push(this.constructor.TokenRecord({      \n  //       tokenId,      \n  //       version: versionInt,\n  //       ticker: this.getString(4, 'utf-8'),\n  //       name: this.getString(5, 'utf-8'),\n  //       uri: this.getString(6, 'utf-8'),\n  //       hash: this.getString(7, 'hex'),\n  //       decimals: this.getInt(8),\n  //       vaultScriptHash: versionInt === 2 ? this.getData(9) : undefined\n  //     }));\n  //     // Create Minted Tokens SLPCoinRecord\n  //     records.push(this.constructor.SlpCoinRecord({\n  //       hash: Buffer.from(tokenId).reverse(),\n  //       vout: 1,\n  //       tokenId,\n  //       value: this.getData(10),\n  //       type,\n  //       version: this.getInt(2)\n  //     }));\n  //     // Create Mint Baton SLPCoinRecord\n  //     if (versionInt === 1 && this.getInt(9) >= 2) {\n  //       const valBuf = Buffer.alloc(1);\n  //       valBuf.writeInt8(1);\n  //       records.push(this.constructor.SlpCoinRecord({\n  //         hash: Buffer.from(tokenId).reverse(),\n  //         vout: this.getInt(9),\n  //         tokenId,\n  //         value: valBuf,\n  //         type: 'BATON',\n  //         version: this.getInt(2)\n  //       }));\n  //     }\n  //     return records;\n  //   }\n  //   /**\n  //    * Get records for a MINT script\n  //    * @private\n  //    * @param {Buffer} txId The txHash of the transaction containing this script\n  //    * @returns {SlpCoinRecord[]}\n  //    */\n  //   getMintRecords(txId) {\n  //     assert(txId.byteLength, 'txId must be a buffer');\n  //     assert(txId.byteLength == 32, 'txId must be a sha256 hash');\n  //     const type = this.getType();\n  //     assert(type == 'MINT', 'This is not a MINT transaction');\n  //     const versionInt = this.getInt(2);\n  //     const records = [];\n  //     // Create Minted Tokens SLPCoinRecord\n  //     if (versionInt === 1) {\n  //       records.push(this.constructor.SlpCoinRecord({\n  //         hash: Buffer.from(txId).reverse(),\n  //         vout: 1,\n  //         tokenId: this.getData(4),\n  //         value: this.getData(6),\n  //         type,\n  //         version: versionInt\n  //       }));\n  //       // Create Mint Baton SLPCoinRecord\n  //       if (this.getInt(5) >= 2) {\n  //         const valBuf = U64.fromInt(1).toBE(Buffer);\n  //         records.push(this.constructor.SlpCoinRecord({\n  //           hash: Buffer.from(txId).reverse(),\n  //           vout: this.getInt(5),\n  //           tokenId: this.getData(4),\n  //           value: valBuf,\n  //           type: 'BATON',\n  //           version: versionInt\n  //         }));\n  //       }\n  //     } else if (versionInt === 2) {\n  //       // Mimic Token Type 1 SEND\n  //       const outputs = this.code.slice(5);\n  //       for (let i = 0; i < outputs.length; i++) {\n  //         const valueBuf = outputs[i].toData();\n  //         const vout = i + 1;\n  //         // Create Token Type 2 Mint Tokens SLPCoinRecord\n  //         records.push(this.constructor.SlpCoinRecord({\n  //           hash: Buffer.from(txId).reverse(),\n  //           vout,\n  //           tokenId: this.getData(4),\n  //           value: valueBuf,\n  //           type,\n  //           version: this.getInt(2)\n  //         }));\n  //       }\n  //     }\n  //     return records;\n  //   }\n  //   /**\n  //    * Get records for a SEND script\n  //    * @private\n  //    * @param {Buffer} txId The txHash of the transaction containing this script\n  //    * @param {Boolean} nonStandardOuts OP_RETURN is located at an index other than 0\n  //    * @returns {SlpCoinRecord[]}\n  //    */\n  //   getSendRecords(txId, nonStandardOuts = false) {\n  //     assert(txId.byteLength, 'txId must be a buffer');\n  //     assert(txId.byteLength == 32, 'txId must be a sha256 hash');\n  //     const type = this.getType();\n  //     assert(type == 'SEND', 'This is not a SEND transaction')\n  //     const records = [];\n  //     const outputs = this.code.slice(5);\n  //     for (let i = 0; i < outputs.length; i++) {\n  //       const valueBuf = outputs[i].toData();\n  //       const vout = nonStandardOuts ? i : i + 1;\n  //       // Create Send Tokens SLPCoinRecord\n  //       records.push(this.constructor.SlpCoinRecord({\n  //         hash: Buffer.from(txId).reverse(),\n  //         vout,\n  //         tokenId: this.getData(4),\n  //         value: valueBuf,\n  //         type,\n  //         version: this.getInt(2)\n  //       }));\n  //     }\n  //     return records;\n  //   }\n  //   getBurnRecords(txId, nonStandardOuts = false) {\n  //     assert(txId.byteLength, 'txId must be a buffer');\n  //     assert(txId.byteLength == 32, 'txId must be a sha256 hash');\n  //     const type = this.getType();\n  //     assert(type == 'BURN', 'This is not a BURN transaction');\n  //     const records = [];\n  //     const valueBuf = this.code[5].toData();\n  //     // Create Send Tokens SLPCoinRecord\n  //     records.push(this.constructor.SlpCoinRecord({\n  //       hash: Buffer.from(txId).reverse(),\n  //       vout: 0,\n  //       tokenId: this.getData(4),\n  //       value: valueBuf,\n  //       type,\n  //       version: this.getInt(2)\n  //     }));\n  //     return records;\n  //   }\n  //   /**\n  //    * Re-encode the script internally. Useful if you\n  //    * changed something manually in the `code` array.\n  //    * @returns {Script}\n  //    */\n  //   compile() {\n  //     super.compile();\n  //     this.valid = null;\n  //     this.isValidSlp();\n  //   }\n  //   /**\n  //    * Inspect the script.\n  //    * @returns {String} Human-readable script code.\n  //    */\n  //   inspect() {\n  //     return `<SLP: ${this.toString()}>`;\n  //   }\n  //   getType() {\n  //     return this.getString(3);\n  //   }\n  //   /**\n  //    * Create a new TokenRecord\n  //    * @param {Buffer?} tokenId\n  //    * @param {Buffer?} tokenIndex\n  //    * @param {String?} ticker\n  //    * @param {String?} name\n  //    * @param {String?} uri\n  //    * @param {String?} hash\n  //    * @param {Number} decimals\n  //    * @param {Number?} version\n  //    * @returns {TokenRecord}\n  //    */\n  //   static TokenRecord(options = {}) {\n  //     return new TokenRecord(options);\n  //   }\n\n  /**\n   * Create a new SlpCoinRecord\n   * @param {Buffer?} hash the output hash of the coin\n   * @param {Number?} vout the output index of the coin\n   * @param {Buffer?} tokenId 32 byte txid\n   * @param {Buffer?} tokenIndex 4 byte unsigned integer (index of tx hash in db)\n   * @param {Number} value\n   * @param {String} type GENESIS | MINT | SEND | BATON\n   * @param {Number?} version\n   * @returns {SlpCoinRecord}\n   */\n\n\n  static SlpCoinRecord() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new SlpCoinRecord(options);\n  }\n\n}\n\nmodule.exports = SLP;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/script/slp.js"],"names":["assert","require","bio","U64","consensus","Script","ScriptNum","SLP_TYPES","GENESIS","MINT","SEND","BATON","BURN","SlpCoinRecord","constructor","options","hash","vout","tokenId","tokenIndex","value","type","version","fromJSON","json","Buffer","from","reverse","fromString","toBE","SLP","valid","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,OAAD,CAAtB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAM;AAACE,EAAAA;AAAD,IAAQF,OAAO,CAAC,KAAD,CAArB;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,uBAAD,CAAzB;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMK,SAAS,GAAGL,OAAO,CAAC,aAAD,CAAzB;AAEA;AACA;AACA;;;AAEC,MAAMM,SAAS,GAAG;AACjBC,EAAAA,OAAO,EAAE,IADQ;AAEjBC,EAAAA,IAAI,EAAE,IAFW;AAGjBC,EAAAA,IAAI,EAAE,IAHW;AAIjBC,EAAAA,KAAK,EAAE,IAJU;AAKjBC,EAAAA,IAAI,EAAE;AALW,CAAlB;;AAQD,MAAMC,aAAN,CAAoB;AAClB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEEC,EAAAA,WAAW,GAAe;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AACxB,SAAKC,IAAL,GAAYD,OAAO,CAACC,IAApB;AACA,SAAKC,IAAL,GAAYF,OAAO,CAACE,IAApB;AACA,SAAKC,OAAL,GAAeH,OAAO,CAACG,OAAvB;AACA,SAAKC,UAAL,GAAkBJ,OAAO,CAACI,UAA1B;AACA,SAAKC,KAAL,GAAaL,OAAO,CAACK,KAArB;AACA,SAAKC,IAAL,GAAYN,OAAO,CAACM,IAApB;AACA,SAAKC,OAAL,GAAeP,OAAO,CAACO,OAAvB;AAED,GAtBiB,CAwBpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;;;AAEGC,EAAAA,QAAQ,CAACC,IAAD,EAAO;AAEd,SAAKR,IAAL,GAAYS,MAAM,CAACC,IAAP,CAAYF,IAAI,CAACR,IAAjB,EAAuB,KAAvB,EAA8BW,OAA9B,EAAZ;AACA,SAAKV,IAAL,GAAYO,IAAI,CAACP,IAAjB;AACA,SAAKC,OAAL,GAAeO,MAAM,CAACC,IAAP,CAAYF,IAAI,CAACN,OAAjB,EAA0B,KAA1B,CAAf;AACA,SAAKE,KAAL,GAAajB,GAAG,CAACyB,UAAJ,CAAeJ,IAAI,CAACJ,KAApB,EAA2BS,IAA3B,CAAgCJ,MAAhC,CAAb;AACA,SAAKJ,IAAL,GAAYG,IAAI,CAACH,IAAjB;AACA,SAAKC,OAAL,GAAeE,IAAI,CAACF,OAAL,IAAgB,CAA/B;AAEA,WAAO,IAAP;AACD,GA1IiB,CA4IpB;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AApJoB,C,CAuJpB;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAGA;AACA;AACA;AACA;AACA;;;AAEA,MAAMQ,GAAN,SAAkBzB,MAAlB,CAAyB;AACvB;AACF;AACA;AACA;AACA;AAEES,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB,UAAMA,OAAN;AAEA,SAAKgB,KAAL,GAAa,IAAb;AACD,GAXsB,CAazB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEsB,SAAblB,aAAa,GAAe;AAAA,QAAdE,OAAc,uEAAJ,EAAI;AACjC,WAAO,IAAIF,aAAJ,CAAkBE,OAAlB,CAAP;AACD;;AA1csB;;AA8czBiB,MAAM,CAACC,OAAP,GAAiBH,GAAjB","sourcesContent":["/*!\n * slp.js - simple ledger protocol script for bcash\n * Copyright (c) 2021, Vin Armani (MIT License).\n * https://github.com/badger-cash/bcash\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bio = require('bufio');\nconst {U64} = require('n64');\nconst consensus = require('../protocol/consensus');\nconst Script = require('./script');\nconst ScriptNum = require('./scriptnum');\n\n/**\n * SLP Coin Record\n */\n\n const SLP_TYPES = {\n  GENESIS: 0x00,\n  MINT: 0x01,\n  SEND: 0x02,\n  BATON: 0x03,\n  BURN: 0x04\n}\n\nclass SlpCoinRecord {\n  /**\n   * Create a record of SLP data for a given coin.\n   * @param {Buffer?} hash the output hash of the coin\n   * @param {Number?} vout the output index of the coin\n   * @param {Buffer?} tokenId 32 byte txid\n   * @param {Buffer?} tokenIndex 4 byte unsigned integer (index of tx hash in db)\n   * @param {Buffer} value big endian value of token base units\n   * @param {String} type GENESIS | MINT | SEND | BURN | BATON\n   * @param {Number?} version token type\n   * @constructor\n   */\n\n  constructor(options = {}) {\n    this.hash = options.hash;\n    this.vout = options.vout;\n    this.tokenId = options.tokenId;\n    this.tokenIndex = options.tokenIndex;\n    this.value = options.value;\n    this.type = options.type;\n    this.version = options.version;\n    \n  }\n\n//   /**\n//    * Get the value as 64 bit big-endian buffer\n//    * @private\n//    * @returns {Buffer}\n//    */\n//   getValueUInt64BE() {\n//     assert(this.value.length <= 8, 'value buffer must be 8 bytes or less');\n//     const padding = Buffer.alloc(8 - this.value.length);\n//     return Buffer.concat([padding, this.value]);\n//   }\n\n//   /**\n//    * Inject properties from serialized data.\n//    * @private\n//    * @param {Buffer} data\n//    */\n\n//   fromDbData(data) {\n//     const br = bio.read(data);\n\n//     this.tokenIndex = br.readBytes(4);\n//     const valueBytes = br.readVarBytes();\n//     const padding = Buffer.alloc(8 - valueBytes.length);\n//     this.value = Buffer.concat([padding, valueBytes]);\n//     this.type = Object.keys(SLP_TYPES)[br.readU8()];\n//     // Get version and handle if out of bounds\n//     try {\n//       this.version = br.readU8();\n//     } catch (err) {\n//       if (err.code === 'ERR_ENCODING')\n//         this.version = 1;\n//       else throw(err)\n//     }\n\n//     assert(this.version >= 1 && this.version <= 2);\n//     assert(Object.keys(SLP_TYPES).includes(this.type));\n\n//     return this;\n//   }\n\n//   /**\n//    * Instantiate SLP record from serialized data.\n//    * @param {Buffer} data\n//    * @returns {SlpCoinRecord}\n//    */\n\n//   static fromDbData(data) {\n//     return new this().fromDbData(data);\n//   }\n\n//   /**\n//    * Serialize the SLP record.\n//    * @returns {Buffer}\n//    */\n\n//   toDbData() {\n//     assert(this.tokenIndex, 'Missing tokenIndex');\n//     assert(this.tokenIndex.length == 4, 'tokenId must be a sha256 hash');\n//     // assert(this.value, 'Missing token amount (in base units)')\n//     assert(this.value.byteLength, 'Token amount must be a buffer')\n//     assert(Object.keys(SLP_TYPES).includes(this.type), 'Type must be GENESIS | MINT | SEND | BATON | BURN');\n//     // Remove padding (minimal)\n//     for (let i = 0; i < this.value.length; i++) {\n//       if (this.value[i] != 0) {\n//         this.value = this.value.slice(i)\n//         break;\n//       }\n//     }\n//     const bw = bio.write();\n\n//     bw.writeBytes(this.tokenIndex);\n//     bw.writeVarBytes(this.value);\n//     bw.writeU8(SLP_TYPES[this.type]);\n//     bw.writeU8(this.version || 1);\n\n//     return bw.render();\n//   }\n\n//   /**\n//    * Convert object to JSON.\n//    * @returns {Object}\n//    */\n\n//   getJSON() {\n//     assert(this.tokenId, 'tokenId must be defined');\n\n//     const json = {\n//       hash: this.hash ? Buffer.from(this.hash).reverse().toString('hex') : undefined,\n//       vout: this.vout,\n//       tokenId: this.tokenId.toString('hex'),\n//       value: U64.fromBE(this.value).toString(10),\n//       type: this.type,\n//       version: this.version || 1\n\n//     }\n//     return json;\n//   }\n\n  /**\n   * Convert from JSON to Object.\n   * @param {Object} json\n   * @returns {SlpCoinRecord}\n   */\n\n   fromJSON(json) {\n\n    this.hash = Buffer.from(json.hash, 'hex').reverse();\n    this.vout = json.vout;\n    this.tokenId = Buffer.from(json.tokenId, 'hex');\n    this.value = U64.fromString(json.value).toBE(Buffer);\n    this.type = json.type;\n    this.version = json.version || 1\n\n    return this\n  }\n\n//   /**\n//    * Convert from JSON to Object.\n//    * @param {Object} json\n//    * @returns {TokenRecord}\n//    */\n\n//    static fromJSON(json) {\n//     return new this().fromJSON(json);\n//   }\n}\n\n// /**\n//  * Token Record\n//  */\n\n//  class TokenRecord {\n//   /**\n//    * Create a token record.\n//    * @constructor\n//    * @param {Buffer?} tokenId\n//    * @param {Buffer?} tokenIndex\n//    * @param {String?} ticker\n//    * @param {String?} name\n//    * @param {String?} uri\n//    * @param {String?} hash\n//    * @param {Number} decimals\n//    * @param {Number?} version\n//    * @param {Buffer?} vaultScriptHash\n//    */\n\n//   constructor(options = {}) {\n//     this.tokenId = options.tokenId;\n//     this.tokenIndex = options.tokenIndex;\n//     this.ticker = options.ticker || '';\n//     this.name = options.name || '';\n//     this.uri = options.uri || '';\n//     this.hash = options.hash || '';\n//     this.decimals = options.decimals;\n//     this.version = options.version;\n//     if (this.version === 2 )\n//       this.vaultScriptHash = options.vaultScriptHash;\n\n//   }\n\n//   /**\n//    * Inject properties from serialized data.\n//    * @private\n//    * @param {Buffer} data\n//    */\n\n//   fromDbData(data) {\n//     const br = bio.read(data);\n\n//     this.tokenId = br.readHash();\n//     this.ticker = br.readVarString('utf8');\n//     // assert(this.ticker.length > 0);\n\n//     this.name = br.readVarString('utf8');\n//     // assert(this.name.length > 0);\n\n//     this.uri = br.readVarString('utf8');\n//     this.hash = br.readVarString('hex');\n//     this.decimals = br.readU8();\n//     // Get version and handle if out of bounds\n//     try {\n//       this.version = br.readU8();\n//     } catch(err) {\n//       if (err.code === 'ERR_ENCODING') {\n//         this.version = 1;\n//       } else throw(err)\n//     }\n\n//     // Read MINT vault ScriptHash\n//     if (this.version ===2)\n//       this.vaultScriptHash = br.readBytes(20);\n\n//     assert(this.version >= 1 && this.version <= 2);\n//     // assert(this.decimals >= 0 && this.decimals < 9);\n\n//     return this;\n//   }\n\n//   /**\n//    * Instantiate token record from serialized data.\n//    * @param {Buffer} data\n//    * @returns {TokenRecord}\n//    */\n\n//   static fromDbData(data) {\n//     return new this().fromDbData(data);\n//   }\n\n//   /**\n//    * Serialize the token record.\n//    * @returns {Buffer}\n//    */\n\n//   toDbData() {\n//     const bw = bio.write();\n//     const encoding = bio.encoding;\n\n//     bw.writeHash(this.tokenId);\n//     bw.writeVarString(this.ticker, 'utf8');\n//     if (this.ticker.length === 0)\n//       bw.offset += encoding.sizeVarint(0);\n//     bw.writeVarString(this.name, 'utf8');\n//     if (this.name.length === 0)\n//       bw.offset += encoding.sizeVarint(0);\n//     bw.writeVarString(this.uri, 'utf8');\n//     if (this.uri.length === 0)\n//       bw.offset += encoding.sizeVarint(0);\n//     bw.writeVarString(this.hash, 'hex');\n//     if (this.hash.length === 0)\n//       bw.offset += encoding.sizeVarint(0);\n//     bw.writeU8(this.decimals);\n//     bw.writeU8(this.version || 1);\n\n//     if (this.version === 2)\n//       bw.writeBytes(this.vaultScriptHash);\n\n//     return bw.render();\n//   }\n\n//   /**\n//    * Convert object to JSON.\n//    * @returns {Object}\n//    */\n\n//   getJSON() {\n//     assert(this.tokenId, 'tokenId must be defined');\n\n//     const json = {\n//       tokenId: this.tokenId.toString('hex'),\n//       ticker: this.ticker,\n//       name: this.name,\n//       uri: this.uri,\n//       hash: this.hash,\n//       decimals: this.decimals,\n//       version: this.version || 1\n//     }\n\n//     if (json.version === 2 && this.vaultScriptHash)\n//       json.vaultScriptHash = this.vaultScriptHash.toString('hex');\n    \n//     return json;\n//   }\n\n//   /**\n//    * Convert from JSON to Object.\n//    * @param {Object} json\n//    * @returns {SlpCoinRecord}\n//    */\n\n//    fromJSON(json) {\n\n//     this.tokenId = Buffer.from(json.tokenId, 'hex');\n//     this.ticker = json.ticker;\n//     this.name = json.name;\n//     this.uri = json.uri;\n//     this.hash = json.hash\n//     this.decimals = json.decimals;\n//     this.version = json.version;\n\n//     if (json.version === 2 && json.vaultScriptHash)\n//       this.vaultScriptHash = Buffer.from(json.vaultScriptHash, 'hex');\n\n//     return this\n//   }\n\n//   /**\n//    * Convert from JSON to Object.\n//    * @param {Object} json\n//    * @returns {TokenRecord}\n//    */\n\n//    static fromJSON(json) {\n//     return new this().fromJSON(json);\n//   }\n\n// }\n\n\n/**\n * SLP\n * @alias module:script.SLP\n * @extends Script\n */\n\nclass SLP extends Script {\n  /**\n   * Create an SLP script.\n   * @constructor\n   * @param {Buffer|Array|Object} code\n   */\n\n  constructor(options) {\n    super(options);\n\n    this.valid = null;\n  }\n\n// //   /**\n// //    * Is SLP script is of valid construction?\n// //    * Use this as opposed to calling property this.isValid\n// //    * @private\n// //    * @returns {Boolean}\n// //    */\n//   isValidSlp() {\n//     if (this.valid === null) {\n//       this.valid = this.verifySlp();\n//     }\n//     return this.valid;\n//   }\n\n// //   /**\n// //    * Test whether SLP script is of valid construction\n// //    * (Does not test if transaction is valid SLP transaction)\n// //    * @private\n// //    * @param {Script?} script\n// //    * @returns {Boolean}\n// //    */\n\n//   verifySlp(script) {\n//     if (script == undefined)\n//       script = this;\n\n//     if (script.getSym(0) != 'OP_RETURN')\n//       return false;\n\n//     // LOKAD_ID\n//     if (script.getString(1, 'hex') != '534c5000')\n//       return false;\n\n//     // Check version\n//     const versionHex = script.getString(2, 'hex');\n//     if (versionHex != '01' && versionHex != '02') \n//       return false;\n\n//     // Type\n//     const type = script.getType();\n\n//     switch (type) {\n//       case 'GENESIS': {\n//         if (script.code.length != 11)\n//           return false;\n//         // Hash\n//         if (!script.getData(7))\n//           return false;\n//         if (script.getData(7).length != 0 && script.getData(7).length != 32)\n//           return false;\n//         // Decimals\n//         if (!script.getData(8))\n//           return false;\n//         if (script.getData(8).length != 1 || script.getInt(8) > 9)\n//           return false;\n//         if (versionHex == '01') {\n//           // Mint Baton\n//           if (!script.getData(9))\n//             return false;\n//           if (script.getData(9).length > 1)\n//             return false;\n//           if (script.getData(9).length == 1 && script.getInt(9) < 2)\n//             return false;\n//         } else if (versionHex == '02') {\n//           // Mint Vault ScriptHash\n//           if (!script.getData(9))\n//             return false;\n//           if (script.getData(9).length != 20)\n//             return false;\n//         }\n//         // Minted Tokens\n//         if (script.getData(10).length != 8)\n//           return false\n//         break;\n//       }\n//       case 'MINT': {\n//         if (script.code.length != 7)\n//           return false;\n//         // Token ID\n//         if (script.getData(4).length != 32)\n//           return false;\n//         if (versionHex == '01') {\n//           // Mint Baton\n//           if (!script.getData(5))\n//             return false;\n//           if (script.getData(5).length > 1)\n//             return false;\n//           if (script.getData(5).length == 1 && script.getInt(5) < 2)\n//             return false;\n//           // Minted Tokens\n//           if (script.getData(6).length != 8)\n//             return false\n//         } else if (versionHex == '02') {\n//           const outputs = script.code.slice(5);\n//           for (let i = 0; i < outputs.length; i++) {\n//             const op = outputs[i];\n//             // Sent Tokens\n//             if (op.data.length != 8)\n//               return false\n//           }\n//         }\n//         break;\n//       }\n//       case 'SEND': {\n//         if (script.code.length < 6)\n//           return false;\n//         // Token ID\n//         if (script.getData(4).length != 32)\n//           return false;\n//         const outputs = script.code.slice(5);\n//         for (let i = 0; i < outputs.length; i++) {\n//           const op = outputs[i];\n//           // Sent Tokens\n//           if (op.data.length != 8)\n//             return false\n//         }\n//         break;\n//       }\n//       case 'BURN': {\n//         if (script.code.length != 6)\n//           return false;\n//         // Token ID\n//         if (script.getData(4).length != 32)\n//           return false;\n//         // Sent Tokens\n//         if (script.getData(5).length != 8)\n//           return false\n//         break;\n//       }\n//       default: {\n//         return false;\n//       }\n//     }\n\n//     return true;\n//   }\n\n// //   /**\n// //    * Test whether script is of valid construction\n// //    * (Does not test if transaction is valid SLP transaction)\n// //    * @param {Script?} script\n// //    * @returns {Boolean}\n// //    */\n\n//   static verifySlp(script) {\n//     return new this().verifySlp(script);\n//   }\n\n//   /**\n//    * Inject properties from a script\n//    * @private\n//    * @param {Script} code\n//    * @returns {SLP}\n//    */\n\n//   fromScript(script) {\n//     this.inject(script);\n//     return this;\n//   }\n\n//   /**\n//    * Inject properties from a script\n//    * @param {Script} code\n//    * @returns {SLP}\n//    */\n\n//    static fromScript(script) {\n//     return new this().fromScript(script);\n//   }\n\n//   /**\n//    * Get token ID for this script\n//    * @private\n//    * @returns {Hash}\n//    */\n\n//     getTokenId() {\n//       assert(this.verifySlp(), 'This is not a valid SLP script')\n    \n//       // Type\n//       const type = this.getType();\n//       assert(type != 'GENESIS', 'Cannot derive the tokenID from GENESIS script')\n      \n//       // Return tokenId as buffer\n//       return this.getData(4);\n//     }\n\n//   /**\n//    * Get records for a this script\n//    * @private\n//    * @param {Buffer?} txId The txid of the transaction containing this script\n//    * @returns {(SlpCoinRecord | TokenRecord)[]}\n//    */\n\n//   getRecords(txId) {\n//     assert(this.isValidSlp(), 'Must be a valid SLP Script' )\n\n//     const type = this.getType();\n//     assert(Object.keys(SLP_TYPES).includes(type) && type != 'BATON', 'Type must be GENESIS | MINT | SEND | BURN');\n//     assert(txId.byteLength, 'tokenId must be a buffer');\n//     assert(txId.length == 32, 'tokenId must be a sha256 hash');\n\n//     switch (type) {\n//       case 'GENESIS': {\n//         return this.getGenesisRecords(txId);\n//         break;\n//       }\n//       case 'MINT': {\n//         return this.getMintRecords(txId);\n//         break;\n//       }\n//       case 'SEND': {\n//         return this.getSendRecords(txId);\n//         break;\n//       }\n//       case 'BURN': {\n//         return this.getBurnRecords(txId);\n//         break;\n//       }\n//       default: {\n//         return null;\n//       }\n//     }\n//   }\n\n//   /**\n//    * Get records for a GENESIS script\n//    * @private\n//    * @param {Buffer} tokenId The tokenId of the transaction containing this script\n//    * @returns {(SlpCoinRecord | TokenRecord)[]}\n//    */\n\n//   getGenesisRecords(tokenId) {\n//     assert(tokenId.byteLength, 'tokenId must be a buffer');\n//     assert(tokenId.byteLength == 32, 'tokenId must be a sha256 hash');\n//     const type = this.getType();\n//     assert(type == 'GENESIS', 'This is not a GENESIS transaction')\n\n//     const versionInt = this.getInt(2);\n//     const records = [];\n//     // Create TokenRecord\n//     records.push(this.constructor.TokenRecord({      \n//       tokenId,      \n//       version: versionInt,\n//       ticker: this.getString(4, 'utf-8'),\n//       name: this.getString(5, 'utf-8'),\n//       uri: this.getString(6, 'utf-8'),\n//       hash: this.getString(7, 'hex'),\n//       decimals: this.getInt(8),\n//       vaultScriptHash: versionInt === 2 ? this.getData(9) : undefined\n//     }));\n//     // Create Minted Tokens SLPCoinRecord\n//     records.push(this.constructor.SlpCoinRecord({\n//       hash: Buffer.from(tokenId).reverse(),\n//       vout: 1,\n//       tokenId,\n//       value: this.getData(10),\n//       type,\n//       version: this.getInt(2)\n//     }));\n//     // Create Mint Baton SLPCoinRecord\n//     if (versionInt === 1 && this.getInt(9) >= 2) {\n//       const valBuf = Buffer.alloc(1);\n//       valBuf.writeInt8(1);\n//       records.push(this.constructor.SlpCoinRecord({\n//         hash: Buffer.from(tokenId).reverse(),\n//         vout: this.getInt(9),\n//         tokenId,\n//         value: valBuf,\n//         type: 'BATON',\n//         version: this.getInt(2)\n//       }));\n//     }\n//     return records;\n//   }\n\n//   /**\n//    * Get records for a MINT script\n//    * @private\n//    * @param {Buffer} txId The txHash of the transaction containing this script\n//    * @returns {SlpCoinRecord[]}\n//    */\n\n//   getMintRecords(txId) {\n//     assert(txId.byteLength, 'txId must be a buffer');\n//     assert(txId.byteLength == 32, 'txId must be a sha256 hash');\n//     const type = this.getType();\n//     assert(type == 'MINT', 'This is not a MINT transaction');\n\n//     const versionInt = this.getInt(2);\n//     const records = [];\n//     // Create Minted Tokens SLPCoinRecord\n//     if (versionInt === 1) {\n//       records.push(this.constructor.SlpCoinRecord({\n//         hash: Buffer.from(txId).reverse(),\n//         vout: 1,\n//         tokenId: this.getData(4),\n//         value: this.getData(6),\n//         type,\n//         version: versionInt\n//       }));\n//       // Create Mint Baton SLPCoinRecord\n//       if (this.getInt(5) >= 2) {\n//         const valBuf = U64.fromInt(1).toBE(Buffer);\n//         records.push(this.constructor.SlpCoinRecord({\n//           hash: Buffer.from(txId).reverse(),\n//           vout: this.getInt(5),\n//           tokenId: this.getData(4),\n//           value: valBuf,\n//           type: 'BATON',\n//           version: versionInt\n//         }));\n//       }\n//     } else if (versionInt === 2) {\n//       // Mimic Token Type 1 SEND\n//       const outputs = this.code.slice(5);\n//       for (let i = 0; i < outputs.length; i++) {\n//         const valueBuf = outputs[i].toData();\n//         const vout = i + 1;\n      \n//         // Create Token Type 2 Mint Tokens SLPCoinRecord\n//         records.push(this.constructor.SlpCoinRecord({\n//           hash: Buffer.from(txId).reverse(),\n//           vout,\n//           tokenId: this.getData(4),\n//           value: valueBuf,\n//           type,\n//           version: this.getInt(2)\n//         }));\n//       }\n//     }\n//     return records;\n//   }\n\n//   /**\n//    * Get records for a SEND script\n//    * @private\n//    * @param {Buffer} txId The txHash of the transaction containing this script\n//    * @param {Boolean} nonStandardOuts OP_RETURN is located at an index other than 0\n//    * @returns {SlpCoinRecord[]}\n//    */\n\n//   getSendRecords(txId, nonStandardOuts = false) {\n//     assert(txId.byteLength, 'txId must be a buffer');\n//     assert(txId.byteLength == 32, 'txId must be a sha256 hash');\n//     const type = this.getType();\n//     assert(type == 'SEND', 'This is not a SEND transaction')\n\n//     const records = [];\n//     const outputs = this.code.slice(5);\n//     for (let i = 0; i < outputs.length; i++) {\n//       const valueBuf = outputs[i].toData();\n//       const vout = nonStandardOuts ? i : i + 1;\n    \n//       // Create Send Tokens SLPCoinRecord\n//       records.push(this.constructor.SlpCoinRecord({\n//         hash: Buffer.from(txId).reverse(),\n//         vout,\n//         tokenId: this.getData(4),\n//         value: valueBuf,\n//         type,\n//         version: this.getInt(2)\n//       }));\n//     }\n//     return records;\n//   }\n\n//   getBurnRecords(txId, nonStandardOuts = false) {\n//     assert(txId.byteLength, 'txId must be a buffer');\n//     assert(txId.byteLength == 32, 'txId must be a sha256 hash');\n//     const type = this.getType();\n//     assert(type == 'BURN', 'This is not a BURN transaction');\n\n//     const records = [];\n//     const valueBuf = this.code[5].toData();\n  \n//     // Create Send Tokens SLPCoinRecord\n//     records.push(this.constructor.SlpCoinRecord({\n//       hash: Buffer.from(txId).reverse(),\n//       vout: 0,\n//       tokenId: this.getData(4),\n//       value: valueBuf,\n//       type,\n//       version: this.getInt(2)\n//     }));\n\n//     return records;\n//   }\n  \n//   /**\n//    * Re-encode the script internally. Useful if you\n//    * changed something manually in the `code` array.\n//    * @returns {Script}\n//    */\n\n//   compile() {\n//     super.compile();\n\n//     this.valid = null;\n//     this.isValidSlp();\n//   }\n\n//   /**\n//    * Inspect the script.\n//    * @returns {String} Human-readable script code.\n//    */\n\n//   inspect() {\n//     return `<SLP: ${this.toString()}>`;\n//   }\n\n//   getType() {\n//     return this.getString(3);\n//   }\n\n//   /**\n//    * Create a new TokenRecord\n//    * @param {Buffer?} tokenId\n//    * @param {Buffer?} tokenIndex\n//    * @param {String?} ticker\n//    * @param {String?} name\n//    * @param {String?} uri\n//    * @param {String?} hash\n//    * @param {Number} decimals\n//    * @param {Number?} version\n//    * @returns {TokenRecord}\n//    */\n\n//   static TokenRecord(options = {}) {\n//     return new TokenRecord(options);\n//   }\n\n  /**\n   * Create a new SlpCoinRecord\n   * @param {Buffer?} hash the output hash of the coin\n   * @param {Number?} vout the output index of the coin\n   * @param {Buffer?} tokenId 32 byte txid\n   * @param {Buffer?} tokenIndex 4 byte unsigned integer (index of tx hash in db)\n   * @param {Number} value\n   * @param {String} type GENESIS | MINT | SEND | BATON\n   * @param {Number?} version\n   * @returns {SlpCoinRecord}\n   */\n\n  static SlpCoinRecord(options = {}) {\n    return new SlpCoinRecord(options);\n  }\n\n}\n\nmodule.exports = SLP;\n"]},"metadata":{},"sourceType":"module"}