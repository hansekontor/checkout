{"ast":null,"code":"/*!\n * hash-drbg.js - hash-drbg implementation for bcrypto\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on cryptocoinjs/drbg.js:\n *   Copyright (c) 2016 Kirill Fomichev\n *   https://github.com/cryptocoinjs/drbg.js\n *\n * Resources:\n *   https://csrc.nist.gov/publications/detail/sp/800-90a/archive/2012-01-23\n *   https://github.com/cryptocoinjs/drbg.js/blob/master/hash.js\n */\n'use strict';\n\nconst assert = require('./internal/assert');\n/*\n * Constants\n */\n\n\nconst RESEED_INTERVAL = 0x1000000000000;\nconst ONE = Buffer.from([0x01]);\nconst TWO = Buffer.from([0x02]);\nconst THREE = Buffer.from([0x03]);\n/**\n * HashDRBG\n */\n\nclass HashDRBG {\n  constructor(hash, entropy, nonce, pers) {\n    assert(hash && typeof hash.id === 'string');\n    this.hash = hash;\n    this.minEntropy = hash.id === 'SHA1' ? 10 : 24;\n    this.seedLen = hash.size <= 32 ? 55 : 111;\n    this.V = Buffer.allocUnsafe(this.seedLen);\n    this.C = Buffer.allocUnsafe(this.seedLen);\n    this.len = Buffer.allocUnsafe(8);\n    this.rounds = 0;\n    if (entropy) this.init(entropy, nonce, pers);\n  }\n\n  init(entropy) {\n    let nonce = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let pers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    assert(Buffer.isBuffer(entropy));\n    assert(!nonce || Buffer.isBuffer(nonce));\n    assert(!pers || Buffer.isBuffer(pers));\n    const seed = concat(entropy, nonce, pers);\n    if (seed.length < this.minEntropy) throw new Error('Not enough entropy.');\n    this.V = this.derive(seed, this.seedLen, null);\n    this.C = this.derive(this.V, this.seedLen, 0x00);\n    this.rounds = 1;\n    return this;\n  }\n\n  reseed(entropy) {\n    let add = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    assert(Buffer.isBuffer(entropy));\n    assert(!add || Buffer.isBuffer(add));\n    if (this.rounds === 0) throw new Error('DRBG not initialized.');\n    const seed = concat(this.V, entropy, add);\n    if (seed.length < this.minEntropy) throw new Error('Not enough entropy.');\n    this.V = this.derive(seed, this.seedLen, 0x01);\n    this.C = this.derive(this.V, this.seedLen, 0x00);\n    this.rounds = 1;\n    return this;\n  }\n\n  generate(len) {\n    let add = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    assert(len >>> 0 === len);\n    assert(!add || Buffer.isBuffer(add));\n    if (this.rounds === 0) throw new Error('DRBG not initialized.');\n    if (this.rounds > RESEED_INTERVAL) throw new Error('Reseed is required.');\n    if (add && add.length !== 0) this.sum(this.V, this.hash.multi(TWO, this.V, add));\n    const data = Buffer.from(this.V);\n    const blocks = Math.ceil(len / this.hash.size);\n    const out = Buffer.allocUnsafe(blocks * this.hash.size);\n\n    for (let i = 0; i < blocks; i++) {\n      this.hash.digest(data).copy(out, i * this.hash.size);\n      this.sum(data, ONE);\n    }\n\n    this.update();\n    this.rounds += 1;\n    return out.slice(0, len);\n  }\n\n  randomBytes(size) {\n    return this.generate(size);\n  }\n  /*\n   * Helpers\n   */\n\n\n  update() {\n    const H = this.hash.multi(THREE, this.V);\n    const hi = this.rounds / 0x100000000 >>> 0;\n    const lo = this.rounds >>> 0;\n    this.len[0] = hi >>> 24;\n    this.len[1] = hi >>> 16;\n    this.len[2] = hi >>> 8;\n    this.len[3] = hi;\n    this.len[4] = lo >>> 24;\n    this.len[5] = lo >>> 16;\n    this.len[6] = lo >>> 8;\n    this.len[7] = lo;\n    this.sum(this.V, H, this.C, this.len);\n    return this;\n  }\n\n  derive(input, len) {\n    let prepend = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    assert(Buffer.isBuffer(input));\n    assert(len >>> 0 === len);\n    const p = prepend != null ? 1 : 0;\n    const data = Buffer.allocUnsafe(5 + p + input.length);\n    data[0] = 0x01;\n    data[1] = len >>> 21;\n    data[2] = len >>> 13;\n    data[3] = len >>> 5;\n    data[4] = (len & 0x1f) << 3;\n    if (p) data[5] = prepend;\n    input.copy(data, 5 + p);\n    const blocks = Math.ceil(len / this.hash.size);\n    const out = Buffer.allocUnsafe(blocks * this.hash.size);\n\n    for (let i = 0; i < blocks; i++) {\n      this.hash.digest(data).copy(out, i * this.hash.size);\n      data[0] += 1;\n    }\n\n    return out.slice(0, len);\n  }\n\n  sum(dst) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    for (const buf of args) {\n      let i = buf.length - 1;\n      let j = dst.length - 1;\n      let carry = 0;\n\n      while (i >= 0) {\n        carry += buf[i] + dst[j];\n        dst[j] = carry & 0xff;\n        carry >>>= 8;\n        i -= 1;\n        j -= 1;\n      }\n\n      while (carry > 0 && j >= 0) {\n        carry += dst[j];\n        dst[j] = carry & 0xff;\n        carry >>>= 8;\n        j -= 1;\n      }\n    }\n\n    return dst;\n  }\n\n}\n/*\n * Static\n */\n\n\nHashDRBG.native = 0;\n/*\n * Helpers\n */\n\nfunction concat(a) {\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (!b && !c) return a;\n  let s = a.length;\n  let p = 0;\n  if (b) s += b.length;\n  if (c) s += c.length;\n  const d = Buffer.allocUnsafe(s);\n  p += a.copy(d, p);\n  if (b) p += b.copy(d, p);\n  if (c) c.copy(d, p);\n  return d;\n}\n/*\n * Expose\n */\n\n\nmodule.exports = HashDRBG;","map":null,"metadata":{},"sourceType":"script"}