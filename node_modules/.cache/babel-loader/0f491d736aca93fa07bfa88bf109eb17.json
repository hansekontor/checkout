{"ast":null,"code":"/*!\n * opcode.js - opcode object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bio = require('bufio');\n\nconst ScriptNum = require('./scriptnum');\n\nconst common = require('./common');\n\nconst opcodes = common.opcodes;\nconst opCache = [];\nlet PARSE_ERROR = null;\n/**\n * Opcode\n * A simple struct which contains\n * an opcode and pushdata buffer.\n * @alias module:script.Opcode\n * @property {Number} value\n * @property {Buffer|null} data\n */\n\nclass Opcode {\n  /**\n   * Create an opcode.\n   * Note: this should not be called directly.\n   * @constructor\n   * @param {Number} value - Opcode.\n   * @param {Buffer?} data - Pushdata buffer.\n   */\n  constructor(value, data) {\n    this.value = value || 0;\n    this.data = data || null;\n  }\n  /**\n   * Test whether a pushdata abides by minimaldata.\n   * @returns {Boolean}\n   */\n\n\n  isMinimal() {\n    assert(0 <= this.value && this.value <= opcodes.OP_PUSHDATA4);\n    if (!this.data) return true;\n\n    if (this.data.length === 1) {\n      if (this.data[0] === 0x81) return false;\n      if (this.data[0] >= 1 && this.data[0] <= 16) return false;\n    }\n\n    if (this.data.length <= 0x4b) return this.value === this.data.length;\n    if (this.data.length <= 0xff) return this.value === opcodes.OP_PUSHDATA1;\n    if (this.data.length <= 0xffff) return this.value === opcodes.OP_PUSHDATA2;\n    return true;\n  }\n  /**\n   * Test whether opcode is a disabled opcode.\n   * @param {Number?} flags - Script standard flags.\n   * @returns {Boolean}\n   */\n\n\n  isDisabled(flags) {\n    switch (this.value) {\n      case opcodes.OP_INVERT:\n      case opcodes.OP_2MUL:\n      case opcodes.OP_2DIV:\n      case opcodes.OP_MUL:\n      case opcodes.OP_LSHIFT:\n      case opcodes.OP_RSHIFT:\n        return true;\n    }\n\n    return false;\n  }\n  /**\n   * Test whether opcode is a branch (if/else/endif).\n   * @returns {Boolean}\n   */\n\n\n  isBranch() {\n    return this.value >= opcodes.OP_IF && this.value <= opcodes.OP_ENDIF;\n  }\n  /**\n   * Test opcode equality.\n   * @param {Opcode} op\n   * @returns {Boolean}\n   */\n\n\n  equals(op) {\n    assert(Opcode.isOpcode(op));\n    if (this.value !== op.value) return false;\n\n    if (!this.data) {\n      assert(!op.data);\n      return true;\n    }\n\n    assert(op.data);\n    return this.data.equals(op.data);\n  }\n  /**\n   * Convert Opcode to opcode value.\n   * @returns {Number}\n   */\n\n\n  toOp() {\n    return this.value;\n  }\n  /**\n   * Covert opcode to data push.\n   * @returns {Buffer|null}\n   */\n\n\n  toData() {\n    return this.data;\n  }\n  /**\n   * Covert opcode to data length.\n   * @returns {Number}\n   */\n\n\n  toLength() {\n    return this.data ? this.data.length : -1;\n  }\n  /**\n   * Covert and _cast_ opcode to data push.\n   * @returns {Buffer|null}\n   */\n\n\n  toPush() {\n    if (this.value === opcodes.OP_0) return common.small[0 + 1];\n    if (this.value === opcodes.OP_1NEGATE) return common.small[-1 + 1];\n    if (this.value >= opcodes.OP_1 && this.value <= opcodes.OP_16) return common.small[this.value - 0x50 + 1];\n    return this.toData();\n  }\n  /**\n   * Get string for opcode.\n   * @param {String?} enc\n   * @returns {Buffer|null}\n   */\n\n\n  toString(enc) {\n    const data = this.toPush();\n    if (!data) return null;\n    return data.toString(enc || 'utf8');\n  }\n  /**\n   * Convert opcode to small integer.\n   * @returns {Number}\n   */\n\n\n  toSmall() {\n    if (this.value === opcodes.OP_0) return 0;\n    if (this.value >= opcodes.OP_1 && this.value <= opcodes.OP_16) return this.value - 0x50;\n    return -1;\n  }\n  /**\n   * Convert opcode to script number.\n   * @param {Boolean?} minimal\n   * @param {Number?} limit\n   * @returns {ScriptNum|null}\n   */\n\n\n  toNum(minimal, limit) {\n    if (this.value === opcodes.OP_0) return ScriptNum.fromInt(0);\n    if (this.value === opcodes.OP_1NEGATE) return ScriptNum.fromInt(-1);\n    if (this.value >= opcodes.OP_1 && this.value <= opcodes.OP_16) return ScriptNum.fromInt(this.value - 0x50);\n    if (!this.data) return null;\n    return ScriptNum.decode(this.data, minimal, limit);\n  }\n  /**\n   * Convert opcode to integer.\n   * @param {Boolean?} minimal\n   * @param {Number?} limit\n   * @returns {Number}\n   */\n\n\n  toInt(minimal, limit) {\n    const num = this.toNum(minimal, limit);\n    if (!num) return -1;\n    return num.getInt();\n  }\n  /**\n   * Convert opcode to boolean.\n   * @returns {Boolean}\n   */\n\n\n  toBool() {\n    const smi = this.toSmall();\n    if (smi === -1) return false;\n    return smi === 1;\n  }\n  /**\n   * Convert opcode to its symbolic representation.\n   * @returns {String}\n   */\n\n\n  toSymbol() {\n    if (this.value === -1) return 'OP_INVALIDOPCODE';\n    const symbol = common.opcodesByVal[this.value];\n    if (!symbol) return `0x${hex8(this.value)}`;\n    return symbol;\n  }\n  /**\n   * Calculate opcode size.\n   * @returns {Number}\n   */\n\n\n  getSize() {\n    if (!this.data) return 1;\n\n    switch (this.value) {\n      case opcodes.OP_PUSHDATA1:\n        return 2 + this.data.length;\n\n      case opcodes.OP_PUSHDATA2:\n        return 3 + this.data.length;\n\n      case opcodes.OP_PUSHDATA4:\n        return 5 + this.data.length;\n\n      default:\n        return 1 + this.data.length;\n    }\n  }\n  /**\n   * Encode the opcode to a buffer writer.\n   * @param {BufferWriter} bw\n   */\n\n\n  toWriter(bw) {\n    if (this.value === -1) throw new Error('Cannot reserialize a parse error.');\n\n    if (!this.data) {\n      bw.writeU8(this.value);\n      return bw;\n    }\n\n    switch (this.value) {\n      case opcodes.OP_PUSHDATA1:\n        bw.writeU8(this.value);\n        bw.writeU8(this.data.length);\n        bw.writeBytes(this.data);\n        break;\n\n      case opcodes.OP_PUSHDATA2:\n        bw.writeU8(this.value);\n        bw.writeU16(this.data.length);\n        bw.writeBytes(this.data);\n        break;\n\n      case opcodes.OP_PUSHDATA4:\n        bw.writeU8(this.value);\n        bw.writeU32(this.data.length);\n        bw.writeBytes(this.data);\n        break;\n\n      default:\n        assert(this.value === this.data.length);\n        bw.writeU8(this.value);\n        bw.writeBytes(this.data);\n        break;\n    }\n\n    return bw;\n  }\n  /**\n   * Encode the opcode.\n   * @returns {Buffer}\n   */\n\n\n  toRaw() {\n    const size = this.getSize();\n    return this.toWriter(bio.write(size)).render();\n  }\n  /**\n   * Convert the opcode to a bitcoind test string.\n   * @returns {String} Human-readable script code.\n   */\n\n\n  toFormat() {\n    if (this.value === -1) return '0x01';\n\n    if (this.data) {\n      // Numbers\n      if (this.data.length <= 4) {\n        const num = this.toNum();\n        if (this.equals(Opcode.fromNum(num))) return num.toString(10);\n      }\n\n      const symbol = common.opcodesByVal[this.value];\n      const data = this.data.toString('hex'); // Direct push\n\n      if (!symbol) {\n        const size = hex8(this.value);\n        return `0x${size} 0x${data}`;\n      } // Pushdatas\n\n\n      let size = this.data.length.toString(16);\n\n      while (size.length % 2 !== 0) size = '0' + size;\n\n      return `${symbol} 0x${size} 0x${data}`;\n    } // Opcodes\n\n\n    const symbol = common.opcodesByVal[this.value];\n    if (symbol) return symbol; // Unknown opcodes\n\n    const value = hex8(this.value);\n    return `0x${value}`;\n  }\n  /**\n   * Format the opcode as bitcoind asm.\n   * @param {Boolean?} decode - Attempt to decode hash types.\n   * @returns {String} Human-readable script.\n   */\n\n\n  toASM(decode) {\n    if (this.value === -1) return '[error]';\n    if (this.data) return common.toASM(this.data, decode);\n    return common.opcodesByVal[this.value] || 'OP_UNKNOWN';\n  }\n  /**\n   * Instantiate an opcode from a number opcode.\n   * @param {Number} op\n   * @returns {Opcode}\n   */\n\n\n  static fromOp(op) {\n    assert(typeof op === 'number');\n    const cached = opCache[op];\n    assert(cached, 'Bad opcode.');\n    return cached;\n  }\n  /**\n   * Instantiate a pushdata opcode from\n   * a buffer (will encode minimaldata).\n   * @param {Buffer} data\n   * @returns {Opcode}\n   */\n\n\n  static fromData(data) {\n    assert(Buffer.isBuffer(data));\n\n    if (data.length === 1) {\n      if (data[0] === 0x81) return this.fromOp(opcodes.OP_1NEGATE);\n      if (data[0] >= 1 && data[0] <= 16) return this.fromOp(data[0] + 0x50);\n    }\n\n    return this.fromPush(data);\n  }\n  /**\n   * Instantiate a pushdata opcode from a\n   * buffer (this differs from fromData in\n   * that it will _always_ be a pushdata op).\n   * @param {Buffer} data\n   * @returns {Opcode}\n   */\n\n\n  static fromPush(data) {\n    assert(Buffer.isBuffer(data));\n    if (data.length === 0) return this.fromOp(opcodes.OP_0);\n    if (data.length <= 0x4b) return new this(data.length, data);\n    if (data.length <= 0xff) return new this(opcodes.OP_PUSHDATA1, data);\n    if (data.length <= 0xffff) return new this(opcodes.OP_PUSHDATA2, data);\n    if (data.length <= 0xffffffff) return new this(opcodes.OP_PUSHDATA4, data);\n    throw new Error('Pushdata size too large.');\n  }\n  /**\n   * Instantiate a pushdata opcode from a string.\n   * @param {String} str\n   * @param {String} [enc=utf8]\n   * @returns {Opcode}\n   */\n\n\n  static fromString(str, enc) {\n    assert(typeof str === 'string');\n    const data = Buffer.from(str, enc || 'utf8');\n    return this.fromData(data);\n  }\n  /**\n   * Instantiate an opcode from a small number.\n   * @param {Number} num\n   * @returns {Opcode}\n   */\n\n\n  static fromSmall(num) {\n    assert((num & 0xff) === num && num >= 0 && num <= 16);\n    return this.fromOp(num === 0 ? 0 : num + 0x50);\n  }\n  /**\n   * Instantiate an opcode from a ScriptNum.\n   * @param {ScriptNumber} num\n   * @returns {Opcode}\n   */\n\n\n  static fromNum(num) {\n    assert(ScriptNum.isScriptNum(num));\n    return this.fromData(num.encode());\n  }\n  /**\n   * Instantiate an opcode from a Number.\n   * @param {Number} num\n   * @returns {Opcode}\n   */\n\n\n  static fromInt(num) {\n    assert(Number.isSafeInteger(num));\n    if (num === 0) return this.fromOp(opcodes.OP_0);\n    if (num === -1) return this.fromOp(opcodes.OP_1NEGATE);\n    if (num >= 1 && num <= 16) return this.fromOp(num + 0x50);\n    return this.fromNum(ScriptNum.fromNumber(num));\n  }\n  /**\n   * Instantiate an opcode from a Number.\n   * @param {Boolean} value\n   * @returns {Opcode}\n   */\n\n\n  static fromBool(value) {\n    assert(typeof value === 'boolean');\n    return this.fromSmall(value ? 1 : 0);\n  }\n  /**\n   * Instantiate a pushdata opcode from symbolic name.\n   * @example\n   *   Opcode.fromSymbol('checksequenceverify')\n   * @param {String} name\n   * @returns {Opcode}\n   */\n\n\n  static fromSymbol(name) {\n    assert(typeof name === 'string');\n    assert(name.length > 0);\n    if (name.charCodeAt(0) & 32) name = name.toUpperCase();\n    if (!/^OP_/.test(name)) name = `OP_${name}`;\n    const op = common.opcodes[name];\n    if (op != null) return this.fromOp(op);\n    assert(/^OP_0X/.test(name), 'Unknown opcode.');\n    assert(name.length === 7, 'Unknown opcode.');\n    const value = parseInt(name.substring(5), 16);\n    assert((value & 0xff) === value, 'Unknown opcode.');\n    return this.fromOp(value);\n  }\n  /**\n   * Instantiate opcode from buffer reader.\n   * @param {BufferReader} br\n   * @returns {Opcode}\n   */\n\n\n  static fromReader(br) {\n    const value = br.readU8();\n    const op = opCache[value];\n    if (op) return op;\n\n    switch (value) {\n      case opcodes.OP_PUSHDATA1:\n        {\n          if (br.left() < 1) return PARSE_ERROR;\n          const size = br.readU8();\n\n          if (br.left() < size) {\n            br.seek(br.left());\n            return PARSE_ERROR;\n          }\n\n          const data = br.readBytes(size);\n          return new this(value, data);\n        }\n\n      case opcodes.OP_PUSHDATA2:\n        {\n          if (br.left() < 2) {\n            br.seek(br.left());\n            return PARSE_ERROR;\n          }\n\n          const size = br.readU16();\n\n          if (br.left() < size) {\n            br.seek(br.left());\n            return PARSE_ERROR;\n          }\n\n          const data = br.readBytes(size);\n          return new this(value, data);\n        }\n\n      case opcodes.OP_PUSHDATA4:\n        {\n          if (br.left() < 4) {\n            br.seek(br.left());\n            return PARSE_ERROR;\n          }\n\n          const size = br.readU32();\n\n          if (br.left() < size) {\n            br.seek(br.left());\n            return PARSE_ERROR;\n          }\n\n          const data = br.readBytes(size);\n          return new this(value, data);\n        }\n\n      default:\n        {\n          if (br.left() < value) {\n            br.seek(br.left());\n            return PARSE_ERROR;\n          }\n\n          const data = br.readBytes(value);\n          return new this(value, data);\n        }\n    }\n  }\n  /**\n   * Instantiate opcode from serialized data.\n   * @param {Buffer} data\n   * @returns {Opcode}\n   */\n\n\n  static fromRaw(data) {\n    return this.fromReader(bio.read(data));\n  }\n  /**\n   * Test whether an object an Opcode.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n\n  static isOpcode(obj) {\n    return obj instanceof Opcode;\n  }\n\n}\n/*\n * Helpers\n */\n\n\nfunction hex8(num) {\n  if (num <= 0x0f) return '0' + num.toString(16);\n  return num.toString(16);\n}\n/*\n * Fill Cache\n */\n\n\nPARSE_ERROR = Object.freeze(new Opcode(-1));\n\nfor (let value = 0x00; value <= 0xff; value++) {\n  if (value >= 0x01 && value <= 0x4e) {\n    opCache.push(null);\n    continue;\n  }\n\n  const op = new Opcode(value);\n  opCache.push(Object.freeze(op));\n}\n/*\n * Expose\n */\n\n\nmodule.exports = Opcode;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/script/opcode.js"],"names":["assert","require","bio","ScriptNum","common","opcodes","opCache","PARSE_ERROR","Opcode","constructor","value","data","isMinimal","OP_PUSHDATA4","length","OP_PUSHDATA1","OP_PUSHDATA2","isDisabled","flags","OP_INVERT","OP_2MUL","OP_2DIV","OP_MUL","OP_LSHIFT","OP_RSHIFT","isBranch","OP_IF","OP_ENDIF","equals","op","isOpcode","toOp","toData","toLength","toPush","OP_0","small","OP_1NEGATE","OP_1","OP_16","toString","enc","toSmall","toNum","minimal","limit","fromInt","decode","toInt","num","getInt","toBool","smi","toSymbol","symbol","opcodesByVal","hex8","getSize","toWriter","bw","Error","writeU8","writeBytes","writeU16","writeU32","toRaw","size","write","render","toFormat","fromNum","toASM","fromOp","cached","fromData","Buffer","isBuffer","fromPush","fromString","str","from","fromSmall","isScriptNum","encode","Number","isSafeInteger","fromNumber","fromBool","fromSymbol","name","charCodeAt","toUpperCase","test","parseInt","substring","fromReader","br","readU8","left","seek","readBytes","readU16","readU32","fromRaw","read","obj","Object","freeze","push","module","exports"],"mappings":"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","sourcesContent":["/*!\n * opcode.js - opcode object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bio = require('bufio');\nconst ScriptNum = require('./scriptnum');\nconst common = require('./common');\nconst opcodes = common.opcodes;\n\nconst opCache = [];\n\nlet PARSE_ERROR = null;\n\n/**\n * Opcode\n * A simple struct which contains\n * an opcode and pushdata buffer.\n * @alias module:script.Opcode\n * @property {Number} value\n * @property {Buffer|null} data\n */\n\nclass Opcode {\n  /**\n   * Create an opcode.\n   * Note: this should not be called directly.\n   * @constructor\n   * @param {Number} value - Opcode.\n   * @param {Buffer?} data - Pushdata buffer.\n   */\n\n  constructor(value, data) {\n    this.value = value || 0;\n    this.data = data || null;\n  }\n\n  /**\n   * Test whether a pushdata abides by minimaldata.\n   * @returns {Boolean}\n   */\n\n  isMinimal() {\n    assert(0 <= this.value && this.value <= opcodes.OP_PUSHDATA4);\n\n    if (!this.data)\n      return true;\n\n    if (this.data.length === 1) {\n      if (this.data[0] === 0x81)\n        return false;\n\n      if (this.data[0] >= 1 && this.data[0] <= 16)\n        return false;\n    }\n\n    if (this.data.length <= 0x4b)\n      return this.value === this.data.length;\n\n    if (this.data.length <= 0xff)\n      return this.value === opcodes.OP_PUSHDATA1;\n\n    if (this.data.length <= 0xffff)\n      return this.value === opcodes.OP_PUSHDATA2;\n\n    return true;\n  }\n\n  /**\n   * Test whether opcode is a disabled opcode.\n   * @param {Number?} flags - Script standard flags.\n   * @returns {Boolean}\n   */\n\n  isDisabled(flags) {\n    switch (this.value) {\n      case opcodes.OP_INVERT:\n      case opcodes.OP_2MUL:\n      case opcodes.OP_2DIV:\n      case opcodes.OP_MUL:\n      case opcodes.OP_LSHIFT:\n      case opcodes.OP_RSHIFT:\n        return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Test whether opcode is a branch (if/else/endif).\n   * @returns {Boolean}\n   */\n\n  isBranch() {\n    return this.value >= opcodes.OP_IF && this.value <= opcodes.OP_ENDIF;\n  }\n\n  /**\n   * Test opcode equality.\n   * @param {Opcode} op\n   * @returns {Boolean}\n   */\n\n  equals(op) {\n    assert(Opcode.isOpcode(op));\n\n    if (this.value !== op.value)\n      return false;\n\n    if (!this.data) {\n      assert(!op.data);\n      return true;\n    }\n\n    assert(op.data);\n\n    return this.data.equals(op.data);\n  }\n\n  /**\n   * Convert Opcode to opcode value.\n   * @returns {Number}\n   */\n\n  toOp() {\n    return this.value;\n  }\n\n  /**\n   * Covert opcode to data push.\n   * @returns {Buffer|null}\n   */\n\n  toData() {\n    return this.data;\n  }\n\n  /**\n   * Covert opcode to data length.\n   * @returns {Number}\n   */\n\n  toLength() {\n    return this.data ? this.data.length : -1;\n  }\n\n  /**\n   * Covert and _cast_ opcode to data push.\n   * @returns {Buffer|null}\n   */\n\n  toPush() {\n    if (this.value === opcodes.OP_0)\n      return common.small[0 + 1];\n\n    if (this.value === opcodes.OP_1NEGATE)\n      return common.small[-1 + 1];\n\n    if (this.value >= opcodes.OP_1 && this.value <= opcodes.OP_16)\n      return common.small[this.value - 0x50 + 1];\n\n    return this.toData();\n  }\n\n  /**\n   * Get string for opcode.\n   * @param {String?} enc\n   * @returns {Buffer|null}\n   */\n\n  toString(enc) {\n    const data = this.toPush();\n\n    if (!data)\n      return null;\n\n    return data.toString(enc || 'utf8');\n  }\n\n  /**\n   * Convert opcode to small integer.\n   * @returns {Number}\n   */\n\n  toSmall() {\n    if (this.value === opcodes.OP_0)\n      return 0;\n\n    if (this.value >= opcodes.OP_1 && this.value <= opcodes.OP_16)\n      return this.value - 0x50;\n\n    return -1;\n  }\n\n  /**\n   * Convert opcode to script number.\n   * @param {Boolean?} minimal\n   * @param {Number?} limit\n   * @returns {ScriptNum|null}\n   */\n\n  toNum(minimal, limit) {\n    if (this.value === opcodes.OP_0)\n      return ScriptNum.fromInt(0);\n\n    if (this.value === opcodes.OP_1NEGATE)\n      return ScriptNum.fromInt(-1);\n\n    if (this.value >= opcodes.OP_1 && this.value <= opcodes.OP_16)\n      return ScriptNum.fromInt(this.value - 0x50);\n\n    if (!this.data)\n      return null;\n\n    return ScriptNum.decode(this.data, minimal, limit);\n  }\n\n  /**\n   * Convert opcode to integer.\n   * @param {Boolean?} minimal\n   * @param {Number?} limit\n   * @returns {Number}\n   */\n\n  toInt(minimal, limit) {\n    const num = this.toNum(minimal, limit);\n\n    if (!num)\n      return -1;\n\n    return num.getInt();\n  }\n\n  /**\n   * Convert opcode to boolean.\n   * @returns {Boolean}\n   */\n\n  toBool() {\n    const smi = this.toSmall();\n\n    if (smi === -1)\n      return false;\n\n    return smi === 1;\n  }\n\n  /**\n   * Convert opcode to its symbolic representation.\n   * @returns {String}\n   */\n\n  toSymbol() {\n    if (this.value === -1)\n      return 'OP_INVALIDOPCODE';\n\n    const symbol = common.opcodesByVal[this.value];\n\n    if (!symbol)\n      return `0x${hex8(this.value)}`;\n\n    return symbol;\n  }\n\n  /**\n   * Calculate opcode size.\n   * @returns {Number}\n   */\n\n  getSize() {\n    if (!this.data)\n      return 1;\n\n    switch (this.value) {\n      case opcodes.OP_PUSHDATA1:\n        return 2 + this.data.length;\n      case opcodes.OP_PUSHDATA2:\n        return 3 + this.data.length;\n      case opcodes.OP_PUSHDATA4:\n        return 5 + this.data.length;\n      default:\n        return 1 + this.data.length;\n    }\n  }\n\n  /**\n   * Encode the opcode to a buffer writer.\n   * @param {BufferWriter} bw\n   */\n\n  toWriter(bw) {\n    if (this.value === -1)\n      throw new Error('Cannot reserialize a parse error.');\n\n    if (!this.data) {\n      bw.writeU8(this.value);\n      return bw;\n    }\n\n    switch (this.value) {\n      case opcodes.OP_PUSHDATA1:\n        bw.writeU8(this.value);\n        bw.writeU8(this.data.length);\n        bw.writeBytes(this.data);\n        break;\n      case opcodes.OP_PUSHDATA2:\n        bw.writeU8(this.value);\n        bw.writeU16(this.data.length);\n        bw.writeBytes(this.data);\n        break;\n      case opcodes.OP_PUSHDATA4:\n        bw.writeU8(this.value);\n        bw.writeU32(this.data.length);\n        bw.writeBytes(this.data);\n        break;\n      default:\n        assert(this.value === this.data.length);\n        bw.writeU8(this.value);\n        bw.writeBytes(this.data);\n        break;\n    }\n\n    return bw;\n  }\n\n  /**\n   * Encode the opcode.\n   * @returns {Buffer}\n   */\n\n  toRaw() {\n    const size = this.getSize();\n    return this.toWriter(bio.write(size)).render();\n  }\n\n  /**\n   * Convert the opcode to a bitcoind test string.\n   * @returns {String} Human-readable script code.\n   */\n\n  toFormat() {\n    if (this.value === -1)\n      return '0x01';\n\n    if (this.data) {\n      // Numbers\n      if (this.data.length <= 4) {\n        const num = this.toNum();\n        if (this.equals(Opcode.fromNum(num)))\n          return num.toString(10);\n      }\n\n      const symbol = common.opcodesByVal[this.value];\n      const data = this.data.toString('hex');\n\n      // Direct push\n      if (!symbol) {\n        const size = hex8(this.value);\n        return `0x${size} 0x${data}`;\n      }\n\n      // Pushdatas\n      let size = this.data.length.toString(16);\n\n      while (size.length % 2 !== 0)\n        size = '0' + size;\n\n      return `${symbol} 0x${size} 0x${data}`;\n    }\n\n    // Opcodes\n    const symbol = common.opcodesByVal[this.value];\n    if (symbol)\n      return symbol;\n\n    // Unknown opcodes\n    const value = hex8(this.value);\n\n    return `0x${value}`;\n  }\n\n  /**\n   * Format the opcode as bitcoind asm.\n   * @param {Boolean?} decode - Attempt to decode hash types.\n   * @returns {String} Human-readable script.\n   */\n\n  toASM(decode) {\n    if (this.value === -1)\n      return '[error]';\n\n    if (this.data)\n      return common.toASM(this.data, decode);\n\n    return common.opcodesByVal[this.value] || 'OP_UNKNOWN';\n  }\n\n  /**\n   * Instantiate an opcode from a number opcode.\n   * @param {Number} op\n   * @returns {Opcode}\n   */\n\n  static fromOp(op) {\n    assert(typeof op === 'number');\n\n    const cached = opCache[op];\n\n    assert(cached, 'Bad opcode.');\n\n    return cached;\n  }\n\n  /**\n   * Instantiate a pushdata opcode from\n   * a buffer (will encode minimaldata).\n   * @param {Buffer} data\n   * @returns {Opcode}\n   */\n\n  static fromData(data) {\n    assert(Buffer.isBuffer(data));\n\n    if (data.length === 1) {\n      if (data[0] === 0x81)\n        return this.fromOp(opcodes.OP_1NEGATE);\n\n      if (data[0] >= 1 && data[0] <= 16)\n        return this.fromOp(data[0] + 0x50);\n    }\n\n    return this.fromPush(data);\n  }\n\n  /**\n   * Instantiate a pushdata opcode from a\n   * buffer (this differs from fromData in\n   * that it will _always_ be a pushdata op).\n   * @param {Buffer} data\n   * @returns {Opcode}\n   */\n\n  static fromPush(data) {\n    assert(Buffer.isBuffer(data));\n\n    if (data.length === 0)\n      return this.fromOp(opcodes.OP_0);\n\n    if (data.length <= 0x4b)\n      return new this(data.length, data);\n\n    if (data.length <= 0xff)\n      return new this(opcodes.OP_PUSHDATA1, data);\n\n    if (data.length <= 0xffff)\n      return new this(opcodes.OP_PUSHDATA2, data);\n\n    if (data.length <= 0xffffffff)\n      return new this(opcodes.OP_PUSHDATA4, data);\n\n    throw new Error('Pushdata size too large.');\n  }\n\n  /**\n   * Instantiate a pushdata opcode from a string.\n   * @param {String} str\n   * @param {String} [enc=utf8]\n   * @returns {Opcode}\n   */\n\n  static fromString(str, enc) {\n    assert(typeof str === 'string');\n    const data = Buffer.from(str, enc || 'utf8');\n    return this.fromData(data);\n  }\n\n  /**\n   * Instantiate an opcode from a small number.\n   * @param {Number} num\n   * @returns {Opcode}\n   */\n\n  static fromSmall(num) {\n    assert((num & 0xff) === num && num >= 0 && num <= 16);\n    return this.fromOp(num === 0 ? 0 : num + 0x50);\n  }\n\n  /**\n   * Instantiate an opcode from a ScriptNum.\n   * @param {ScriptNumber} num\n   * @returns {Opcode}\n   */\n\n  static fromNum(num) {\n    assert(ScriptNum.isScriptNum(num));\n    return this.fromData(num.encode());\n  }\n\n  /**\n   * Instantiate an opcode from a Number.\n   * @param {Number} num\n   * @returns {Opcode}\n   */\n\n  static fromInt(num) {\n    assert(Number.isSafeInteger(num));\n\n    if (num === 0)\n      return this.fromOp(opcodes.OP_0);\n\n    if (num === -1)\n      return this.fromOp(opcodes.OP_1NEGATE);\n\n    if (num >= 1 && num <= 16)\n      return this.fromOp(num + 0x50);\n\n    return this.fromNum(ScriptNum.fromNumber(num));\n  }\n\n  /**\n   * Instantiate an opcode from a Number.\n   * @param {Boolean} value\n   * @returns {Opcode}\n   */\n\n  static fromBool(value) {\n    assert(typeof value === 'boolean');\n    return this.fromSmall(value ? 1 : 0);\n  }\n\n  /**\n   * Instantiate a pushdata opcode from symbolic name.\n   * @example\n   *   Opcode.fromSymbol('checksequenceverify')\n   * @param {String} name\n   * @returns {Opcode}\n   */\n\n  static fromSymbol(name) {\n    assert(typeof name === 'string');\n    assert(name.length > 0);\n\n    if (name.charCodeAt(0) & 32)\n      name = name.toUpperCase();\n\n    if (!/^OP_/.test(name))\n      name = `OP_${name}`;\n\n    const op = common.opcodes[name];\n\n    if (op != null)\n      return this.fromOp(op);\n\n    assert(/^OP_0X/.test(name), 'Unknown opcode.');\n    assert(name.length === 7, 'Unknown opcode.');\n\n    const value = parseInt(name.substring(5), 16);\n\n    assert((value & 0xff) === value, 'Unknown opcode.');\n\n    return this.fromOp(value);\n  }\n\n  /**\n   * Instantiate opcode from buffer reader.\n   * @param {BufferReader} br\n   * @returns {Opcode}\n   */\n\n  static fromReader(br) {\n    const value = br.readU8();\n    const op = opCache[value];\n\n    if (op)\n      return op;\n\n    switch (value) {\n      case opcodes.OP_PUSHDATA1: {\n        if (br.left() < 1)\n          return PARSE_ERROR;\n\n        const size = br.readU8();\n\n        if (br.left() < size) {\n          br.seek(br.left());\n          return PARSE_ERROR;\n        }\n\n        const data = br.readBytes(size);\n\n        return new this(value, data);\n      }\n      case opcodes.OP_PUSHDATA2: {\n        if (br.left() < 2) {\n          br.seek(br.left());\n          return PARSE_ERROR;\n        }\n\n        const size = br.readU16();\n\n        if (br.left() < size) {\n          br.seek(br.left());\n          return PARSE_ERROR;\n        }\n\n        const data = br.readBytes(size);\n\n        return new this(value, data);\n      }\n      case opcodes.OP_PUSHDATA4: {\n        if (br.left() < 4) {\n          br.seek(br.left());\n          return PARSE_ERROR;\n        }\n\n        const size = br.readU32();\n\n        if (br.left() < size) {\n          br.seek(br.left());\n          return PARSE_ERROR;\n        }\n\n        const data = br.readBytes(size);\n\n        return new this(value, data);\n      }\n      default: {\n        if (br.left() < value) {\n          br.seek(br.left());\n          return PARSE_ERROR;\n        }\n\n        const data = br.readBytes(value);\n\n        return new this(value, data);\n      }\n    }\n  }\n\n  /**\n   * Instantiate opcode from serialized data.\n   * @param {Buffer} data\n   * @returns {Opcode}\n   */\n\n  static fromRaw(data) {\n    return this.fromReader(bio.read(data));\n  }\n\n  /**\n   * Test whether an object an Opcode.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n  static isOpcode(obj) {\n    return obj instanceof Opcode;\n  }\n}\n\n/*\n * Helpers\n */\n\nfunction hex8(num) {\n  if (num <= 0x0f)\n    return '0' + num.toString(16);\n  return num.toString(16);\n}\n\n/*\n * Fill Cache\n */\n\nPARSE_ERROR = Object.freeze(new Opcode(-1));\n\nfor (let value = 0x00; value <= 0xff; value++) {\n  if (value >= 0x01 && value <= 0x4e) {\n    opCache.push(null);\n    continue;\n  }\n  const op = new Opcode(value);\n  opCache.push(Object.freeze(op));\n}\n\n/*\n * Expose\n */\n\nmodule.exports = Opcode;\n"]},"metadata":{},"sourceType":"module"}