{"ast":null,"code":"import { PaymentRequest, Payment, PaymentACK } from \"b70\";\nexport const validatePrUrl = urlString => {\n  // Check for BIP70\n  try {\n    const prUrl = new URL(urlString);\n    if (prUrl.protocol === 'https:') return prUrl.href;\n  } catch {\n    return null;\n  }\n\n  return null;\n};\nexport const getUrlFromQueryString = queryString => {\n  if (typeof queryString !== 'string') return null;\n  const [queryParameter, queryData] = queryString.split('=');\n\n  if (queryParameter === 'r') {\n    // Check for BIP70\n    return validatePrUrl(queryData);\n  }\n\n  return null;\n};\n\nconst getAsArrayBuffer = (url, headers) => {\n  return new Promise((accept, reject) => {\n    let req = new XMLHttpRequest();\n    req.open(\"GET\", url, true);\n    Object.entries(headers).forEach(_ref => {\n      let [key, value] = _ref;\n      req.setRequestHeader(key, value);\n    });\n    req.responseType = \"arraybuffer\";\n\n    req.onload = function (event) {\n      let resp = req.response;\n\n      if (resp) {\n        accept(resp);\n      }\n    };\n\n    req.onerror = function (err) {\n      console.warn(err);\n      reject(err);\n    };\n\n    req.send(null);\n  });\n};\n\nconst postAsArrayBuffer = (url, headers, body) => {\n  return new Promise((accept, reject) => {\n    let req = new XMLHttpRequest();\n    req.open(\"POST\", url, true);\n    Object.entries(headers).forEach(_ref2 => {\n      let [key, value] = _ref2;\n      req.setRequestHeader(key, value);\n    });\n    req.responseType = \"arraybuffer\";\n\n    req.onload = function (event) {\n      let resp = req.response;\n\n      if (req.status === 400 || req.status === 404 || req.status === 500 || req.status === 402) {\n        console.log(req);\n        reject(new Error(`Error processing payment, please check with the merchant and try again later.`, {\n          cause: {\n            code: req.status\n          }\n        }));\n        return;\n      }\n\n      if (resp) {\n        accept(resp);\n      }\n    };\n\n    req.onerror = function (err) {\n      console.warn(err);\n      reject(err);\n    };\n\n    req.send(body);\n  });\n};\n\nexport const getPaymentRequest = async (paymentRequestUrl, type) => {\n  let paymentReq;\n  const headers = {\n    Accept: `application/${type}-paymentrequest`,\n    \"Content-Type\": \"application/octet-stream\"\n  };\n  console.log('headers', headers);\n\n  try {\n    const res = await getAsArrayBuffer(paymentRequestUrl, headers);\n    const resBuf = Buffer.from(res);\n    paymentReq = PaymentRequest.fromRaw(resBuf);\n  } catch (err) {\n    console.log(err);\n    throw new Error('Error fetching Payment Request');\n  }\n\n  if (!paymentReq.verifyChain()) throw new Error('Invalid Payment Request certificate chain');\n  if (!paymentReq.verify()) throw new Error('Invalid Payment Request signature');\n  return paymentReq;\n};\n/* default paymentObj = {\n        merchantData: null,\n        transactions: [],\n        refundTo:[],\n        memo:null\n    } \n*/\n\nexport const postPayment = async (paymentUrl, paymentObj, type) => {\n  const payment = new Payment(paymentObj); // serialize and send\n\n  const rawbody = payment.toRaw();\n  const headers = {\n    Accept: `application/${type}-paymentrequest, application/${type}-paymentack`,\n    \"Content-Type\": `application/${type}-payment`,\n    \"Content-Transfer-Encoding\": \"binary\"\n  };\n  const rawPaymentResponse = await postAsArrayBuffer(paymentUrl, headers, rawbody);\n  const responseBuf = Buffer.from(rawPaymentResponse);\n  const ack = PaymentACK.fromRaw(responseBuf);\n  return ack;\n};","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bip70.js"],"names":["PaymentRequest","Payment","PaymentACK","validatePrUrl","urlString","prUrl","URL","protocol","href","getUrlFromQueryString","queryString","queryParameter","queryData","split","getAsArrayBuffer","url","headers","Promise","accept","reject","req","XMLHttpRequest","open","Object","entries","forEach","key","value","setRequestHeader","responseType","onload","event","resp","response","onerror","err","console","warn","send","postAsArrayBuffer","body","status","log","Error","cause","code","getPaymentRequest","paymentRequestUrl","type","paymentReq","Accept","res","resBuf","Buffer","from","fromRaw","verifyChain","verify","postPayment","paymentUrl","paymentObj","payment","rawbody","toRaw","rawPaymentResponse","responseBuf","ack"],"mappings":"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","sourcesContent":["import { \n    PaymentRequest,\n    Payment,\n    PaymentACK\n} from \"b70\";\n\nexport const validatePrUrl = (urlString) => {\n     // Check for BIP70\n     try {\n        const prUrl = new URL(urlString);\n        if (prUrl.protocol === 'https:')\n            return prUrl.href;\n    } catch {\n        return null;\n    }\n    return null;\n}\n\nexport const getUrlFromQueryString = (queryString) => {\n    if (typeof queryString !== 'string')\n        return null;\n\n    const [ queryParameter, queryData ] = queryString.split('=');\n    if ( queryParameter === 'r') {\n        // Check for BIP70\n        return validatePrUrl(queryData);\n    }\n    return null;\n}\n\nconst getAsArrayBuffer = (url, headers)  => {\n    return new Promise((accept, reject) => {\n        let req = new XMLHttpRequest();\n        req.open(\"GET\", url, true);\n        Object.entries(headers).forEach(([key, value]) => {\n            req.setRequestHeader(key, value);\n        });\n        req.responseType = \"arraybuffer\";\n\n        req.onload = function(event) {\n            let resp = req.response;\n\n            if (resp) {\n                accept(resp);\n            }\n        };\n\n        req.onerror = function(err) {\n            console.warn(err);\n            reject(err);\n        };\n\n        req.send(null);\n    });\n};\n\nconst postAsArrayBuffer = (url, headers, body) => {\n    return new Promise((accept, reject) => {\n        let req = new XMLHttpRequest();\n\n        req.open(\"POST\", url, true);\n        Object.entries(headers).forEach(([key, value]) => {\n            req.setRequestHeader(key, value);\n        });\n        req.responseType = \"arraybuffer\";\n\n        req.onload = function(event) {\n            let resp = req.response;\n\n            if (req.status === 400 || req.status === 404 || req.status === 500 || req.status === 402) {\n                console.log(req)\n                reject(\n                new Error(\n                    `Error processing payment, please check with the merchant and try again later.`,\n                    { cause: {code: req.status} }\n                )\n                );\n                return;\n            }\n\n            if (resp) {\n                accept(resp);\n            }\n        };\n\n        req.onerror = function(err) {\n            console.warn(err);\n            reject(err);\n        };\n\n        req.send(body);\n    });\n  };\n\nexport const getPaymentRequest = async (paymentRequestUrl, type) => {\n    let paymentReq;\n    const headers = {\n        Accept: `application/${type}-paymentrequest`,\n        \"Content-Type\": \"application/octet-stream\"\n    };\n    console.log('headers', headers)\n    try {\n        const res = await getAsArrayBuffer(paymentRequestUrl, headers);\n        const resBuf = Buffer.from(res);\n        paymentReq = PaymentRequest.fromRaw(resBuf);\n    } catch (err) {\n        console.log(err)\n        throw new Error('Error fetching Payment Request')\n    }\n\n    if (!paymentReq.verifyChain())\n            throw new Error('Invalid Payment Request certificate chain');\n\n    if (!paymentReq.verify())\n        throw new Error('Invalid Payment Request signature');\n\n    return paymentReq;\n}\n\n/* default paymentObj = {\n        merchantData: null,\n        transactions: [],\n        refundTo:[],\n        memo:null\n    } \n*/\n\nexport const postPayment = async (paymentUrl, paymentObj, type) => {\n    const payment = new Payment(paymentObj);\n    // serialize and send\n    const rawbody = payment.toRaw();\n    const headers = {\n        Accept:\n        `application/${type}-paymentrequest, application/${type}-paymentack`,\n        \"Content-Type\": `application/${type}-payment`,\n        \"Content-Transfer-Encoding\": \"binary\"\n    };\n\n    const rawPaymentResponse = await postAsArrayBuffer(\n        paymentUrl,\n        headers,\n        rawbody\n    );\n\n    const responseBuf = Buffer.from(rawPaymentResponse);\n    const ack = PaymentACK.fromRaw(responseBuf);\n\n    return ack;\n}\n"]},"metadata":{},"sourceType":"module"}