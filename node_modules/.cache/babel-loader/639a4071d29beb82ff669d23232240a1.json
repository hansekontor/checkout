{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2009 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BarcodeFormat_1 = require(\"./BarcodeFormat\");\n\nvar QRCodeReader_1 = require(\"./qrcode/QRCodeReader\");\n\nvar MultiFormatOneDReader_1 = require(\"./oned/MultiFormatOneDReader\");\n\nvar DataMatrixReader_1 = require(\"./datamatrix/DataMatrixReader\");\n\nvar NotFoundException_1 = require(\"./NotFoundException\");\n\nvar ReaderException_1 = require(\"./ReaderException\");\n/*namespace com.google.zxing {*/\n\n/**\r\n * MultiFormatReader is a convenience class and the main entry point into the library for most uses.\r\n * By default it attempts to decode all barcode formats that the library supports. Optionally, you\r\n * can provide a hints object to request different behavior, for example only decoding QR codes.\r\n *\r\n * @author Sean Owen\r\n * @author dswitkin@google.com (Daniel Switkin)\r\n */\n\n\nvar MultiFormatReader =\n/** @class */\nfunction () {\n  function MultiFormatReader() {}\n  /**\r\n   * This version of decode honors the intent of Reader.decode(BinaryBitmap) in that it\r\n   * passes null as a hint to the decoders. However, that makes it inefficient to call repeatedly.\r\n   * Use setHints() followed by decodeWithState() for continuous scan applications.\r\n   *\r\n   * @param image The pixel data to decode\r\n   * @return The contents of the image\r\n   *\r\n   * @throws NotFoundException Any errors which occurred\r\n   */\n\n  /*@Override*/\n  // public decode(image: BinaryBitmap): Result {\n  //   setHints(null)\n  //   return decodeInternal(image)\n  // }\n\n  /**\r\n   * Decode an image using the hints provided. Does not honor existing state.\r\n   *\r\n   * @param image The pixel data to decode\r\n   * @param hints The hints to use, clearing the previous state.\r\n   * @return The contents of the image\r\n   *\r\n   * @throws NotFoundException Any errors which occurred\r\n   */\n\n  /*@Override*/\n\n\n  MultiFormatReader.prototype.decode = function (image, hints) {\n    this.setHints(hints);\n    return this.decodeInternal(image);\n  };\n  /**\r\n   * Decode an image using the state set up by calling setHints() previously. Continuous scan\r\n   * clients will get a <b>large</b> speed increase by using this instead of decode().\r\n   *\r\n   * @param image The pixel data to decode\r\n   * @return The contents of the image\r\n   *\r\n   * @throws NotFoundException Any errors which occurred\r\n   */\n\n\n  MultiFormatReader.prototype.decodeWithState = function (image) {\n    // Make sure to set up the default state so we don't crash\n    if (this.readers === null || this.readers === undefined) {\n      this.setHints(null);\n    }\n\n    return this.decodeInternal(image);\n  };\n  /**\r\n   * This method adds state to the MultiFormatReader. By setting the hints once, subsequent calls\r\n   * to decodeWithState(image) can reuse the same set of readers without reallocating memory. This\r\n   * is important for performance in continuous scan clients.\r\n   *\r\n   * @param hints The set of hints to use for subsequent calls to decode(image)\r\n   */\n\n\n  MultiFormatReader.prototype.setHints = function (hints) {\n    this.hints = hints;\n    var tryHarder = hints !== null && hints !== undefined && undefined !== hints.get(3\n    /* TRY_HARDER */\n    );\n    /*@SuppressWarnings(\"unchecked\")*/\n\n    var formats = hints === null || hints === undefined ? null : hints.get(2\n    /* POSSIBLE_FORMATS */\n    );\n    var readers = new Array();\n\n    if (formats !== null && formats !== undefined) {\n      var addOneDReader = formats.some(function (f) {\n        return f === BarcodeFormat_1.default.UPC_A || f === BarcodeFormat_1.default.UPC_E || f === BarcodeFormat_1.default.EAN_13 || f === BarcodeFormat_1.default.EAN_8 || f === BarcodeFormat_1.default.CODABAR || f === BarcodeFormat_1.default.CODE_39 || f === BarcodeFormat_1.default.CODE_93 || f === BarcodeFormat_1.default.CODE_128 || f === BarcodeFormat_1.default.ITF || f === BarcodeFormat_1.default.RSS_14 || f === BarcodeFormat_1.default.RSS_EXPANDED;\n      }); // Put 1D readers upfront in \"normal\" mode\n      // TYPESCRIPTPORT: TODO: uncomment below as they are ported\n\n      if (addOneDReader && !tryHarder) {\n        readers.push(new MultiFormatOneDReader_1.default(hints));\n      }\n\n      if (formats.includes(BarcodeFormat_1.default.QR_CODE)) {\n        readers.push(new QRCodeReader_1.default());\n      }\n\n      if (formats.includes(BarcodeFormat_1.default.DATA_MATRIX)) {\n        readers.push(new DataMatrixReader_1.default());\n      } // if (formats.includes(BarcodeFormat.AZTEC)) {\n      //   readers.push(new AztecReader())\n      // }\n      // if (formats.includes(BarcodeFormat.PDF_417)) {\n      //    readers.push(new PDF417Reader())\n      // }\n      // if (formats.includes(BarcodeFormat.MAXICODE)) {\n      //    readers.push(new MaxiCodeReader())\n      // }\n      // At end in \"try harder\" mode\n\n\n      if (addOneDReader && tryHarder) {\n        readers.push(new MultiFormatOneDReader_1.default(hints));\n      }\n    }\n\n    if (readers.length === 0) {\n      if (!tryHarder) {\n        readers.push(new MultiFormatOneDReader_1.default(hints));\n      }\n\n      readers.push(new QRCodeReader_1.default());\n      readers.push(new DataMatrixReader_1.default()); // readers.push(new AztecReader())\n      // readers.push(new PDF417Reader())\n      // readers.push(new MaxiCodeReader())\n\n      if (tryHarder) {\n        readers.push(new MultiFormatOneDReader_1.default(hints));\n      }\n    }\n\n    this.readers = readers; // .toArray(new Reader[readers.size()])\n  };\n  /*@Override*/\n\n\n  MultiFormatReader.prototype.reset = function () {\n    if (this.readers !== null) {\n      for (var _i = 0, _a = this.readers; _i < _a.length; _i++) {\n        var reader = _a[_i];\n        reader.reset();\n      }\n    }\n  };\n  /**\r\n   * @throws NotFoundException\r\n   */\n\n\n  MultiFormatReader.prototype.decodeInternal = function (image) {\n    if (this.readers === null) {\n      throw new ReaderException_1.default('No readers where selected, nothing can be read.');\n    }\n\n    for (var _i = 0, _a = this.readers; _i < _a.length; _i++) {\n      var reader = _a[_i]; // Trying to decode with ${reader} reader.\n\n      try {\n        return reader.decode(image, this.hints);\n      } catch (ex) {\n        if (ex instanceof ReaderException_1.default) {\n          continue;\n        } // Bad Exception.\n\n      }\n    }\n\n    throw new NotFoundException_1.default('No MultiFormat Readers were able to detect the code.');\n  };\n\n  return MultiFormatReader;\n}();\n\nexports.default = MultiFormatReader;","map":null,"metadata":{},"sourceType":"script"}