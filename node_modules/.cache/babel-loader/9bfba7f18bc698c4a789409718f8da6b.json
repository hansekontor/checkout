{"ast":null,"code":"/*!\n * encoding.js - encoding utils for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n/* eslint no-implicit-coercion: \"off\" */\n'use strict';\n\nconst enforce = require('./enforce');\n\nconst EncodingError = require('./error');\n/*\n * Constants\n */\n\n\nconst HI = 1 / 0x100000000;\nconst {\n  MAX_SAFE_INTEGER\n} = Number;\nconst F32_ARRAY = new Float32Array(1);\nconst F328_ARRAY = new Uint8Array(F32_ARRAY.buffer);\nconst F64_ARRAY = new Float64Array(1);\nconst F648_ARRAY = new Uint8Array(F64_ARRAY.buffer);\nF32_ARRAY[0] = -1;\nconst BIG_ENDIAN = F328_ARRAY[3] === 0;\n/*\n * Read Unsigned LE\n */\n\nfunction readU(data, off, len) {\n  switch (len) {\n    case 8:\n      return readU64(data, off);\n\n    case 7:\n      return readU56(data, off);\n\n    case 6:\n      return readU48(data, off);\n\n    case 5:\n      return readU40(data, off);\n\n    case 4:\n      return readU32(data, off);\n\n    case 3:\n      return readU24(data, off);\n\n    case 2:\n      return readU16(data, off);\n\n    case 1:\n      return readU8(data, off);\n\n    default:\n      throw new EncodingError(off, 'Invalid read length');\n  }\n}\n\nfunction readU64(data, off) {\n  const hi = readU32(data, off + 4);\n  const lo = readU32(data, off);\n  check((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');\n  return hi * 0x100000000 + lo;\n}\n\nfunction readU56(data, off) {\n  const hi = readU24(data, off + 4);\n  const lo = readU32(data, off);\n  check((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');\n  return hi * 0x100000000 + lo;\n}\n\nfunction readU48(data, off) {\n  return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off++] * 0x1000000 + data[off++] * 0x100000000 + data[off] * 0x10000000000;\n}\n\nfunction readU40(data, off) {\n  return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off++] * 0x1000000 + data[off] * 0x100000000;\n}\n\nfunction readU32(data, off) {\n  return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;\n}\n\nfunction readU24(data, off) {\n  return data[off++] + data[off++] * 0x100 + data[off] * 0x10000;\n}\n\nfunction readU16(data, off) {\n  return data[off++] + data[off] * 0x100;\n}\n\nfunction readU8(data, off) {\n  return data[off];\n}\n/*\n * Read Unsigned BE\n */\n\n\nfunction readUBE(data, off, len) {\n  switch (len) {\n    case 8:\n      return readU64BE(data, off);\n\n    case 7:\n      return readU56BE(data, off);\n\n    case 6:\n      return readU48BE(data, off);\n\n    case 5:\n      return readU40BE(data, off);\n\n    case 4:\n      return readU32BE(data, off);\n\n    case 3:\n      return readU24BE(data, off);\n\n    case 2:\n      return readU16BE(data, off);\n\n    case 1:\n      return readU8(data, off);\n\n    default:\n      throw new EncodingError(off, 'Invalid read length');\n  }\n}\n\nfunction readU64BE(data, off) {\n  const hi = readU32BE(data, off);\n  const lo = readU32BE(data, off + 4);\n  check((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');\n  return hi * 0x100000000 + lo;\n}\n\nfunction readU56BE(data, off) {\n  const hi = readU24BE(data, off);\n  const lo = readU32BE(data, off + 3);\n  check((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');\n  return hi * 0x100000000 + lo;\n}\n\nfunction readU48BE(data, off) {\n  return data[off++] * 0x10000000000 + data[off++] * 0x100000000 + data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];\n}\n\nfunction readU40BE(data, off) {\n  return data[off++] * 0x100000000 + data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];\n}\n\nfunction readU32BE(data, off) {\n  return data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];\n}\n\nfunction readU24BE(data, off) {\n  return data[off++] * 0x10000 + data[off++] * 0x100 + data[off];\n}\n\nfunction readU16BE(data, off) {\n  return data[off++] * 0x100 + data[off];\n}\n/*\n * Read Signed LE\n */\n\n\nfunction readI(data, off, len) {\n  switch (len) {\n    case 8:\n      return readI64(data, off);\n\n    case 7:\n      return readI56(data, off);\n\n    case 6:\n      return readI48(data, off);\n\n    case 5:\n      return readI40(data, off);\n\n    case 4:\n      return readI32(data, off);\n\n    case 3:\n      return readI24(data, off);\n\n    case 2:\n      return readI16(data, off);\n\n    case 1:\n      return readI8(data, off);\n\n    default:\n      throw new EncodingError(off, 'Invalid read length');\n  }\n}\n\nfunction readI64(data, off) {\n  const hi = readI32(data, off + 4);\n  const lo = readU32(data, off);\n  check(isSafe(hi, lo), 'Number exceeds 2^53-1');\n  return hi * 0x100000000 + lo;\n}\n\nfunction readI56(data, off) {\n  const hi = readI24(data, off + 4);\n  const lo = readU32(data, off);\n  check(isSafe(hi, lo), 'Number exceeds 2^53-1');\n  return hi * 0x100000000 + lo;\n}\n\nfunction readI48(data, off) {\n  const val = data[off + 4] + data[off + 5] * 0x100;\n  return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000 + (val | (val & 0x8000) * 0x1fffe) * 0x100000000;\n}\n\nfunction readI40(data, off) {\n  return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off++] * 0x1000000 + (data[off] | (data[off] & 0x80) * 0x1fffffe) * 0x100000000;\n}\n\nfunction readI32(data, off) {\n  return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + (data[off] << 24);\n}\n\nfunction readI24(data, off) {\n  const val = data[off++] + data[off++] * 0x100 + data[off] * 0x10000;\n  return val | (val & 0x800000) * 0x1fe;\n}\n\nfunction readI16(data, off) {\n  const val = data[off++] + data[off] * 0x100;\n  return val | (val & 0x8000) * 0x1fffe;\n}\n\nfunction readI8(data, off) {\n  const val = data[off];\n  return val | (val & 0x80) * 0x1fffffe;\n}\n/*\n * Read Signed BE\n */\n\n\nfunction readIBE(data, off, len) {\n  switch (len) {\n    case 8:\n      return readI64BE(data, off);\n\n    case 7:\n      return readI56BE(data, off);\n\n    case 6:\n      return readI48BE(data, off);\n\n    case 5:\n      return readI40BE(data, off);\n\n    case 4:\n      return readI32BE(data, off);\n\n    case 3:\n      return readI24BE(data, off);\n\n    case 2:\n      return readI16BE(data, off);\n\n    case 1:\n      return readI8(data, off);\n\n    default:\n      throw new EncodingError(off, 'Invalid read length');\n  }\n}\n\nfunction readI64BE(data, off) {\n  const hi = readI32BE(data, off);\n  const lo = readU32BE(data, off + 4);\n  check(isSafe(hi, lo), 'Number exceeds 2^53-1');\n  return hi * 0x100000000 + lo;\n}\n\nfunction readI56BE(data, off) {\n  const hi = readI24BE(data, off);\n  const lo = readU32BE(data, off + 3);\n  check(isSafe(hi, lo), 'Number exceeds 2^53-1');\n  return hi * 0x100000000 + lo;\n}\n\nfunction readI48BE(data, off) {\n  const val = data[off++] * 0x100 + data[off++];\n  return (val | (val & 0x8000) * 0x1fffe) * 0x100000000 + data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];\n}\n\nfunction readI40BE(data, off) {\n  const val = data[off++];\n  return (val | (val & 0x80) * 0x1fffffe) * 0x100000000 + data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];\n}\n\nfunction readI32BE(data, off) {\n  return (data[off++] << 24) + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];\n}\n\nfunction readI24BE(data, off) {\n  const val = data[off++] * 0x10000 + data[off++] * 0x100 + data[off];\n  return val | (val & 0x800000) * 0x1fe;\n}\n\nfunction readI16BE(data, off) {\n  const val = data[off++] * 0x100 + data[off];\n  return val | (val & 0x8000) * 0x1fffe;\n}\n/*\n * Read Float\n */\n\n\nfunction _readFloatBackwards(data, off) {\n  F328_ARRAY[3] = data[off++];\n  F328_ARRAY[2] = data[off++];\n  F328_ARRAY[1] = data[off++];\n  F328_ARRAY[0] = data[off];\n  return F32_ARRAY[0];\n}\n\nfunction _readFloatForwards(data, off) {\n  F328_ARRAY[0] = data[off++];\n  F328_ARRAY[1] = data[off++];\n  F328_ARRAY[2] = data[off++];\n  F328_ARRAY[3] = data[off];\n  return F32_ARRAY[0];\n}\n\nfunction _readDoubleBackwards(data, off) {\n  F648_ARRAY[7] = data[off++];\n  F648_ARRAY[6] = data[off++];\n  F648_ARRAY[5] = data[off++];\n  F648_ARRAY[4] = data[off++];\n  F648_ARRAY[3] = data[off++];\n  F648_ARRAY[2] = data[off++];\n  F648_ARRAY[1] = data[off++];\n  F648_ARRAY[0] = data[off];\n  return F64_ARRAY[0];\n}\n\nfunction _readDoubleForwards(data, off) {\n  F648_ARRAY[0] = data[off++];\n  F648_ARRAY[1] = data[off++];\n  F648_ARRAY[2] = data[off++];\n  F648_ARRAY[3] = data[off++];\n  F648_ARRAY[4] = data[off++];\n  F648_ARRAY[5] = data[off++];\n  F648_ARRAY[6] = data[off++];\n  F648_ARRAY[7] = data[off];\n  return F64_ARRAY[0];\n}\n\nconst readFloat = BIG_ENDIAN ? _readFloatBackwards : _readFloatForwards;\nconst readFloatBE = BIG_ENDIAN ? _readFloatForwards : _readFloatBackwards;\nconst readDouble = BIG_ENDIAN ? _readDoubleBackwards : _readDoubleForwards;\nconst readDoubleBE = BIG_ENDIAN ? _readDoubleForwards : _readDoubleBackwards;\n/*\n * Write Unsigned LE\n */\n\nfunction writeU(dst, num, off, len) {\n  switch (len) {\n    case 8:\n      return writeU64(dst, num, off);\n\n    case 7:\n      return writeU56(dst, num, off);\n\n    case 6:\n      return writeU48(dst, num, off);\n\n    case 5:\n      return writeU40(dst, num, off);\n\n    case 4:\n      return writeU32(dst, num, off);\n\n    case 3:\n      return writeU24(dst, num, off);\n\n    case 2:\n      return writeU16(dst, num, off);\n\n    case 1:\n      return writeU8(dst, num, off);\n\n    default:\n      throw new EncodingError(off, 'Invalid write length');\n  }\n}\n\nfunction writeU64(dst, num, off) {\n  enforce(Number.isSafeInteger(num), 'num', 'integer');\n  return write64(dst, num, off, false);\n}\n\nfunction writeU56(dst, num, off) {\n  enforce(Number.isSafeInteger(num), 'num', 'integer');\n  return write56(dst, num, off, false);\n}\n\nfunction writeU48(dst, num, off) {\n  enforce(Number.isSafeInteger(num), 'num', 'integer');\n  const hi = num * HI | 0;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  dst[off++] = hi;\n  dst[off++] = hi >>> 8;\n  return off;\n}\n\nfunction writeU40(dst, num, off) {\n  enforce(Number.isSafeInteger(num), 'num', 'integer');\n  const hi = num * HI | 0;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  dst[off++] = hi;\n  return off;\n}\n\nfunction writeU32(dst, num, off) {\n  enforce(Number.isSafeInteger(num), 'num', 'integer');\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  return off;\n}\n\nfunction writeU24(dst, num, off) {\n  enforce(Number.isSafeInteger(num), 'num', 'integer');\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  return off;\n}\n\nfunction writeU16(dst, num, off) {\n  enforce(Number.isSafeInteger(num), 'num', 'integer');\n  dst[off++] = num;\n  dst[off++] = num >>> 8;\n  return off;\n}\n\nfunction writeU8(dst, num, off) {\n  enforce(Number.isSafeInteger(num), 'num', 'integer');\n  dst[off] = num;\n  return off + 1;\n}\n/*\n * Write Unsigned BE\n */\n\n\nfunction writeUBE(dst, num, off, len) {\n  switch (len) {\n    case 8:\n      return writeU64BE(dst, num, off);\n\n    case 7:\n      return writeU56BE(dst, num, off);\n\n    case 6:\n      return writeU48BE(dst, num, off);\n\n    case 5:\n      return writeU40BE(dst, num, off);\n\n    case 4:\n      return writeU32BE(dst, num, off);\n\n    case 3:\n      return writeU24BE(dst, num, off);\n\n    case 2:\n      return writeU16BE(dst, num, off);\n\n    case 1:\n      return writeU8(dst, num, off);\n\n    default:\n      throw new EncodingError(off, 'Invalid write length');\n  }\n}\n\nfunction writeU64BE(dst, num, off) {\n  enforce(Number.isSafeInteger(num), 'num', 'integer');\n  return write64(dst, num, off, true);\n}\n\nfunction writeU56BE(dst, num, off) {\n  enforce(Number.isSafeInteger(num), 'num', 'integer');\n  return write56(dst, num, off, true);\n}\n\nfunction writeU48BE(dst, num, off) {\n  enforce(Number.isSafeInteger(num), 'num', 'integer');\n  const hi = num * HI | 0;\n  dst[off++] = hi >>> 8;\n  dst[off++] = hi;\n  dst[off + 3] = num;\n  num >>>= 8;\n  dst[off + 2] = num;\n  num >>>= 8;\n  dst[off + 1] = num;\n  num >>>= 8;\n  dst[off] = num;\n  return off + 4;\n}\n\nfunction writeU40BE(dst, num, off) {\n  enforce(Number.isSafeInteger(num), 'num', 'integer');\n  const hi = num * HI | 0;\n  dst[off++] = hi;\n  dst[off + 3] = num;\n  num >>>= 8;\n  dst[off + 2] = num;\n  num >>>= 8;\n  dst[off + 1] = num;\n  num >>>= 8;\n  dst[off] = num;\n  return off + 4;\n}\n\nfunction writeU32BE(dst, num, off) {\n  enforce(Number.isSafeInteger(num), 'num', 'integer');\n  dst[off + 3] = num;\n  num >>>= 8;\n  dst[off + 2] = num;\n  num >>>= 8;\n  dst[off + 1] = num;\n  num >>>= 8;\n  dst[off] = num;\n  return off + 4;\n}\n\nfunction writeU24BE(dst, num, off) {\n  enforce(Number.isSafeInteger(num), 'num', 'integer');\n  dst[off + 2] = num;\n  num >>>= 8;\n  dst[off + 1] = num;\n  num >>>= 8;\n  dst[off] = num;\n  return off + 3;\n}\n\nfunction writeU16BE(dst, num, off) {\n  enforce(Number.isSafeInteger(num), 'num', 'integer');\n  dst[off++] = num >>> 8;\n  dst[off++] = num;\n  return off;\n}\n/*\n * Write Signed LE\n */\n\n\nfunction writeI(dst, num, off, len) {\n  switch (len) {\n    case 8:\n      return writeU64(dst, num, off);\n\n    case 7:\n      return writeU56(dst, num, off);\n\n    case 6:\n      return writeU48(dst, num, off);\n\n    case 5:\n      return writeU40(dst, num, off);\n\n    case 4:\n      return writeU24(dst, num, off);\n\n    case 3:\n      return writeU32(dst, num, off);\n\n    case 2:\n      return writeU16(dst, num, off);\n\n    case 1:\n      return writeU8(dst, num, off);\n\n    default:\n      throw new EncodingError(off, 'Invalid write length');\n  }\n}\n\nfunction writeI64(dst, num, off) {\n  return writeU64(dst, num, off);\n}\n\nfunction writeI56(dst, num, off) {\n  return writeU56(dst, num, off);\n}\n\nfunction writeI48(dst, num, off) {\n  return writeU48(dst, num, off);\n}\n\nfunction writeI40(dst, num, off) {\n  return writeU40(dst, num, off);\n}\n\nfunction writeI32(dst, num, off) {\n  return writeU32(dst, num, off);\n}\n\nfunction writeI24(dst, num, off) {\n  return writeU24(dst, num, off);\n}\n\nfunction writeI16(dst, num, off) {\n  return writeU16(dst, num, off);\n}\n\nfunction writeI8(dst, num, off) {\n  return writeU8(dst, num, off);\n}\n/*\n * Write Signed BE\n */\n\n\nfunction writeIBE(dst, num, off, len) {\n  switch (len) {\n    case 8:\n      return writeU64BE(dst, num, off);\n\n    case 7:\n      return writeU56BE(dst, num, off);\n\n    case 6:\n      return writeU48BE(dst, num, off);\n\n    case 5:\n      return writeU40BE(dst, num, off);\n\n    case 4:\n      return writeU32BE(dst, num, off);\n\n    case 3:\n      return writeU24BE(dst, num, off);\n\n    case 2:\n      return writeU16BE(dst, num, off);\n\n    case 1:\n      return writeU8(dst, num, off);\n\n    default:\n      throw new EncodingError(off, 'Invalid write length');\n  }\n}\n\nfunction writeI64BE(dst, num, off) {\n  return writeU64BE(dst, num, off);\n}\n\nfunction writeI56BE(dst, num, off) {\n  return writeU56BE(dst, num, off);\n}\n\nfunction writeI48BE(dst, num, off) {\n  return writeU48BE(dst, num, off);\n}\n\nfunction writeI40BE(dst, num, off) {\n  return writeU40BE(dst, num, off);\n}\n\nfunction writeI32BE(dst, num, off) {\n  return writeU32BE(dst, num, off);\n}\n\nfunction writeI24BE(dst, num, off) {\n  return writeU24BE(dst, num, off);\n}\n\nfunction writeI16BE(dst, num, off) {\n  return writeU16BE(dst, num, off);\n}\n\nfunction _writeDoubleForwards(dst, num, off) {\n  enforce(isNumber(num), 'num', 'number');\n  F64_ARRAY[0] = num;\n  dst[off++] = F648_ARRAY[0];\n  dst[off++] = F648_ARRAY[1];\n  dst[off++] = F648_ARRAY[2];\n  dst[off++] = F648_ARRAY[3];\n  dst[off++] = F648_ARRAY[4];\n  dst[off++] = F648_ARRAY[5];\n  dst[off++] = F648_ARRAY[6];\n  dst[off++] = F648_ARRAY[7];\n  return off;\n}\n\nfunction _writeDoubleBackwards(dst, num, off) {\n  enforce(isNumber(num), 'num', 'number');\n  F64_ARRAY[0] = num;\n  dst[off++] = F648_ARRAY[7];\n  dst[off++] = F648_ARRAY[6];\n  dst[off++] = F648_ARRAY[5];\n  dst[off++] = F648_ARRAY[4];\n  dst[off++] = F648_ARRAY[3];\n  dst[off++] = F648_ARRAY[2];\n  dst[off++] = F648_ARRAY[1];\n  dst[off++] = F648_ARRAY[0];\n  return off;\n}\n\nfunction _writeFloatForwards(dst, num, off) {\n  enforce(isNumber(num), 'num', 'number');\n  F32_ARRAY[0] = num;\n  dst[off++] = F328_ARRAY[0];\n  dst[off++] = F328_ARRAY[1];\n  dst[off++] = F328_ARRAY[2];\n  dst[off++] = F328_ARRAY[3];\n  return off;\n}\n\nfunction _writeFloatBackwards(dst, num, off) {\n  enforce(isNumber(num), 'num', 'number');\n  F32_ARRAY[0] = num;\n  dst[off++] = F328_ARRAY[3];\n  dst[off++] = F328_ARRAY[2];\n  dst[off++] = F328_ARRAY[1];\n  dst[off++] = F328_ARRAY[0];\n  return off;\n}\n\nconst writeFloat = BIG_ENDIAN ? _writeFloatBackwards : _writeFloatForwards;\nconst writeFloatBE = BIG_ENDIAN ? _writeFloatForwards : _writeFloatBackwards;\nconst writeDouble = BIG_ENDIAN ? _writeDoubleBackwards : _writeDoubleForwards;\nconst writeDoubleBE = BIG_ENDIAN ? _writeDoubleForwards : _writeDoubleBackwards;\n/*\n * Varints\n */\n\nfunction readVarint(data, off) {\n  let value, size;\n  checkRead(off < data.length, off);\n\n  switch (data[off]) {\n    case 0xff:\n      size = 9;\n      checkRead(off + size <= data.length, off);\n      value = readU64(data, off + 1);\n      check(value > 0xffffffff, off, 'Non-canonical varint');\n      break;\n\n    case 0xfe:\n      size = 5;\n      checkRead(off + size <= data.length, off);\n      value = readU32(data, off + 1);\n      check(value > 0xffff, off, 'Non-canonical varint');\n      break;\n\n    case 0xfd:\n      size = 3;\n      checkRead(off + size <= data.length, off);\n      value = readU16(data, off + 1);\n      check(value >= 0xfd, off, 'Non-canonical varint');\n      break;\n\n    default:\n      size = 1;\n      value = data[off];\n      break;\n  }\n\n  return new Varint(size, value);\n}\n\nfunction writeVarint(dst, num, off) {\n  enforce(Number.isSafeInteger(num), 'num', 'integer');\n\n  if (num < 0xfd) {\n    dst[off++] = num;\n    return off;\n  }\n\n  if (num <= 0xffff) {\n    dst[off++] = 0xfd;\n    return writeU16(dst, num, off);\n  }\n\n  if (num <= 0xffffffff) {\n    dst[off++] = 0xfe;\n    return writeU32(dst, num, off);\n  }\n\n  dst[off++] = 0xff;\n  return writeU64(dst, num, off);\n}\n\nfunction sizeVarint(num) {\n  enforce(Number.isSafeInteger(num), 'num', 'integer');\n  if (num < 0xfd) return 1;\n  if (num <= 0xffff) return 3;\n  if (num <= 0xffffffff) return 5;\n  return 9;\n}\n\nfunction readVarint2(data, off) {\n  let num = 0;\n  let size = 0;\n\n  for (;;) {\n    checkRead(off < data.length, off);\n    const ch = data[off++];\n    size += 1; // Number.MAX_SAFE_INTEGER >>> 7\n\n    check(num <= 0x3fffffffffff - (ch & 0x7f), off, 'Number exceeds 2^53-1'); // num = (num << 7) | (ch & 0x7f);\n\n    num = num * 0x80 + (ch & 0x7f);\n    if ((ch & 0x80) === 0) break;\n    check(num !== MAX_SAFE_INTEGER, off, 'Number exceeds 2^53-1');\n    num += 1;\n  }\n\n  return new Varint(size, num);\n}\n\nfunction writeVarint2(dst, num, off) {\n  enforce(Number.isSafeInteger(num), 'num', 'integer');\n  const tmp = [];\n  let len = 0;\n\n  for (;;) {\n    tmp[len] = num & 0x7f | (len ? 0x80 : 0x00);\n    if (num <= 0x7f) break; // num = (num >>> 7) - 1;\n\n    num = (num - num % 0x80) / 0x80 - 1;\n    len += 1;\n  }\n\n  checkRead(off + len + 1 <= dst.length, off);\n\n  do {\n    dst[off++] = tmp[len];\n  } while (len--);\n\n  return off;\n}\n\nfunction sizeVarint2(num) {\n  enforce(Number.isSafeInteger(num), 'num', 'integer');\n  let size = 0;\n\n  for (;;) {\n    size += 1;\n    if (num <= 0x7f) break; // num = (num >>> 7) - 1;\n\n    num = (num - num % 0x80) / 0x80 - 1;\n  }\n\n  return size;\n}\n/*\n * Bytes\n */\n\n\nfunction sliceBytes(data, off, size) {\n  enforce(Buffer.isBuffer(data), 'data', 'buffer');\n  enforce(off >>> 0 === off, 'off', 'integer');\n  enforce(size >>> 0 === size, 'size', 'integer');\n  if (off + size > data.length) throw new EncodingError(off, 'Out of bounds read');\n  return data.slice(off, off + size);\n}\n\nfunction readBytes(data, off, size) {\n  enforce(Buffer.isBuffer(data), 'data', 'buffer');\n  enforce(off >>> 0 === off, 'off', 'integer');\n  enforce(size >>> 0 === size, 'size', 'integer');\n  if (off + size > data.length) throw new EncodingError(off, 'Out of bounds read');\n  const buf = Buffer.allocUnsafeSlow(size);\n  data.copy(buf, 0, off, off + size);\n  return buf;\n}\n\nfunction writeBytes(data, value, off) {\n  enforce(Buffer.isBuffer(data), 'data', 'buffer');\n  enforce(Buffer.isBuffer(value), 'value', 'buffer');\n  enforce(off >>> 0 === off, 'off', 'integer');\n  if (off + value.length > data.length) throw new EncodingError(off, 'Out of bounds write');\n  return value.copy(data, off, 0, value.length);\n}\n\nfunction readString(data, off, size, enc) {\n  if (enc == null) enc = 'binary';\n  enforce(Buffer.isBuffer(data), 'data', 'buffer');\n  enforce(off >>> 0 === off, 'off', 'integer');\n  enforce(size >>> 0 === size, 'size', 'integer');\n  enforce(typeof enc === 'string', 'enc', 'string');\n  if (off + size > data.length) throw new EncodingError(off, 'Out of bounds read');\n  return data.toString(enc, off, off + size);\n}\n\nfunction writeString(data, str, off, enc) {\n  if (enc == null) enc = 'binary';\n  enforce(Buffer.isBuffer(data), 'data', 'buffer');\n  enforce(typeof str === 'string', 'str', 'string');\n  enforce(off >>> 0 === off, 'off', 'integer');\n  enforce(typeof enc === 'string', 'enc', 'string');\n  if (str.length === 0) return 0;\n  const size = Buffer.byteLength(str, enc);\n  if (off + size > data.length) throw new EncodingError(off, 'Out of bounds write');\n  return data.write(str, off, enc);\n}\n\nfunction realloc(data, size) {\n  enforce(Buffer.isBuffer(data), 'data', 'buffer');\n  const buf = Buffer.allocUnsafeSlow(size);\n  data.copy(buf, 0);\n  return buf;\n}\n\nfunction copy(data) {\n  enforce(Buffer.isBuffer(data), 'data', 'buffer');\n  return realloc(data, data.length);\n}\n\nfunction concat(a, b) {\n  enforce(Buffer.isBuffer(a), 'a', 'buffer');\n  enforce(Buffer.isBuffer(b), 'b', 'buffer');\n  const size = a.length + b.length;\n  const buf = Buffer.allocUnsafeSlow(size);\n  a.copy(buf, 0);\n  b.copy(buf, a.length);\n  return buf;\n}\n/*\n * Size Helpers\n */\n\n\nfunction sizeVarBytes(data) {\n  enforce(Buffer.isBuffer(data), 'data', 'buffer');\n  return sizeVarint(data.length) + data.length;\n}\n\nfunction sizeVarlen(len) {\n  return sizeVarint(len) + len;\n}\n\nfunction sizeVarString(str, enc) {\n  if (enc == null) enc = 'binary';\n  enforce(typeof str === 'string', 'str', 'string');\n  enforce(typeof enc === 'string', 'enc', 'string');\n  if (str.length === 0) return 1;\n  const len = Buffer.byteLength(str, enc);\n  return sizeVarint(len) + len;\n}\n/*\n * Helpers\n */\n\n\nfunction isSafe(hi, lo) {\n  if (hi < 0) {\n    hi = ~hi;\n    if (lo === 0) hi += 1;\n  }\n\n  return (hi & 0xffe00000) === 0;\n}\n\nfunction write64(dst, num, off, be) {\n  let neg = false;\n\n  if (num < 0) {\n    num = -num;\n    neg = true;\n  }\n\n  let hi = num * HI | 0;\n  let lo = num | 0;\n\n  if (neg) {\n    if (lo === 0) {\n      hi = ~hi + 1 | 0;\n    } else {\n      hi = ~hi;\n      lo = ~lo + 1;\n    }\n  }\n\n  if (be) {\n    off = writeI32BE(dst, hi, off);\n    off = writeI32BE(dst, lo, off);\n  } else {\n    off = writeI32(dst, lo, off);\n    off = writeI32(dst, hi, off);\n  }\n\n  return off;\n}\n\nfunction write56(dst, num, off, be) {\n  let neg = false;\n\n  if (num < 0) {\n    num = -num;\n    neg = true;\n  }\n\n  let hi = num * HI | 0;\n  let lo = num | 0;\n\n  if (neg) {\n    if (lo === 0) {\n      hi = ~hi + 1 | 0;\n    } else {\n      hi = ~hi;\n      lo = ~lo + 1;\n    }\n  }\n\n  if (be) {\n    off = writeI24BE(dst, hi, off);\n    off = writeI32BE(dst, lo, off);\n  } else {\n    off = writeI32(dst, lo, off);\n    off = writeI24(dst, hi, off);\n  }\n\n  return off;\n}\n\nclass Varint {\n  constructor(size, value) {\n    this.size = size;\n    this.value = value;\n  }\n\n}\n\nfunction isNumber(num) {\n  return typeof num === 'number' && isFinite(num);\n}\n\nfunction checkRead(value, offset) {\n  if (!value) throw new EncodingError(offset, 'Out of bounds read', checkRead);\n}\n\nfunction check(value, offset, reason) {\n  if (!value) throw new EncodingError(offset, reason, check);\n}\n/*\n * Expose\n */\n\n\nexports.readU = readU;\nexports.readU64 = readU64;\nexports.readU56 = readU56;\nexports.readU48 = readU48;\nexports.readU40 = readU40;\nexports.readU32 = readU32;\nexports.readU24 = readU24;\nexports.readU16 = readU16;\nexports.readU8 = readU8;\nexports.readUBE = readUBE;\nexports.readU64BE = readU64BE;\nexports.readU56BE = readU56BE;\nexports.readU48BE = readU48BE;\nexports.readU40BE = readU40BE;\nexports.readU32BE = readU32BE;\nexports.readU24BE = readU24BE;\nexports.readU16BE = readU16BE;\nexports.readI = readI;\nexports.readI64 = readI64;\nexports.readI56 = readI56;\nexports.readI48 = readI48;\nexports.readI40 = readI40;\nexports.readI32 = readI32;\nexports.readI24 = readI24;\nexports.readI16 = readI16;\nexports.readI8 = readI8;\nexports.readIBE = readIBE;\nexports.readI64BE = readI64BE;\nexports.readI56BE = readI56BE;\nexports.readI48BE = readI48BE;\nexports.readI40BE = readI40BE;\nexports.readI32BE = readI32BE;\nexports.readI24BE = readI24BE;\nexports.readI16BE = readI16BE;\nexports.readFloat = readFloat;\nexports.readFloatBE = readFloatBE;\nexports.readDouble = readDouble;\nexports.readDoubleBE = readDoubleBE;\nexports.writeU = writeU;\nexports.writeU64 = writeU64;\nexports.writeU56 = writeU56;\nexports.writeU48 = writeU48;\nexports.writeU40 = writeU40;\nexports.writeU32 = writeU32;\nexports.writeU24 = writeU24;\nexports.writeU16 = writeU16;\nexports.writeU8 = writeU8;\nexports.writeUBE = writeUBE;\nexports.writeU64BE = writeU64BE;\nexports.writeU56BE = writeU56BE;\nexports.writeU48BE = writeU48BE;\nexports.writeU40BE = writeU40BE;\nexports.writeU32BE = writeU32BE;\nexports.writeU24BE = writeU24BE;\nexports.writeU16BE = writeU16BE;\nexports.writeI = writeI;\nexports.writeI64 = writeI64;\nexports.writeI56 = writeI56;\nexports.writeI48 = writeI48;\nexports.writeI40 = writeI40;\nexports.writeI32 = writeI32;\nexports.writeI24 = writeI24;\nexports.writeI16 = writeI16;\nexports.writeI8 = writeI8;\nexports.writeIBE = writeIBE;\nexports.writeI64BE = writeI64BE;\nexports.writeI56BE = writeI56BE;\nexports.writeI48BE = writeI48BE;\nexports.writeI40BE = writeI40BE;\nexports.writeI32BE = writeI32BE;\nexports.writeI24BE = writeI24BE;\nexports.writeI16BE = writeI16BE;\nexports.writeFloat = writeFloat;\nexports.writeFloatBE = writeFloatBE;\nexports.writeDouble = writeDouble;\nexports.writeDoubleBE = writeDoubleBE;\nexports.readVarint = readVarint;\nexports.writeVarint = writeVarint;\nexports.sizeVarint = sizeVarint;\nexports.readVarint2 = readVarint2;\nexports.writeVarint2 = writeVarint2;\nexports.sizeVarint2 = sizeVarint2;\nexports.sliceBytes = sliceBytes;\nexports.readBytes = readBytes;\nexports.writeBytes = writeBytes;\nexports.readString = readString;\nexports.writeString = writeString;\nexports.realloc = realloc;\nexports.copy = copy;\nexports.concat = concat;\nexports.sizeVarBytes = sizeVarBytes;\nexports.sizeVarlen = sizeVarlen;\nexports.sizeVarString = sizeVarString;","map":null,"metadata":{},"sourceType":"script"}