{"ast":null,"code":"/*!\n * network.js - network object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst binary = require('../utils/binary');\n\nconst networks = require('./networks');\n\nconst consensus = require('./consensus');\n\nconst TimeData = require('./timedata');\n/**\n * Network\n * Represents a network.\n * @alias module:protocol.Network\n */\n\n\nclass Network {\n  /**\n   * Create a network.\n   * @constructor\n   * @param {Object} options\n   */\n  constructor(options) {\n    assert(!Network[options.type], 'Cannot create two networks.');\n    this.type = options.type;\n    this.seeds = options.seeds;\n    this.magic = options.magic;\n    this.port = options.port;\n    this.checkpointMap = options.checkpointMap;\n    this.lastCheckpoint = options.lastCheckpoint;\n    this.checkpoints = [];\n    this.halvingInterval = options.halvingInterval;\n    this.genesis = options.genesis;\n    this.genesisBlock = options.genesisBlock;\n    this.pow = options.pow;\n    this.block = options.block;\n    this.bip30 = options.bip30;\n    this.activationThreshold = options.activationThreshold;\n    this.minerWindow = options.minerWindow;\n    this.deployments = options.deployments;\n    this.deploys = options.deploys;\n    this.unknownBits = ~consensus.VERSION_TOP_MASK;\n    this.keyPrefix = options.keyPrefix;\n    this.addressPrefix = options.addressPrefix;\n    this.requireStandard = options.requireStandard;\n    this.rpcPort = options.rpcPort;\n    this.walletPort = options.walletPort;\n    this.minRelay = options.minRelay;\n    this.feeRate = options.feeRate;\n    this.maxFeeRate = options.maxFeeRate;\n    this.selfConnect = options.selfConnect;\n    this.requestMempool = options.requestMempool;\n    this.time = new TimeData();\n    this.init();\n  } //   /**\n  //    * Get a deployment by bit index.\n  //    * @param {Number} bit\n  //    * @returns {Object}\n  //    */\n  //   init() {\n  //     let bits = 0;\n  //     for (const deployment of this.deploys)\n  //       bits |= 1 << deployment.bit;\n  //     bits |= consensus.VERSION_TOP_MASK;\n  //     this.unknownBits = ~bits >>> 0;\n  //     for (const key of Object.keys(this.checkpointMap)) {\n  //       const hash = this.checkpointMap[key];\n  //       const height = Number(key);\n  //       this.checkpoints.push({ hash, height });\n  //     }\n  //     this.checkpoints.sort(cmpNode);\n  //   }\n  //   /**\n  //    * Get a deployment by bit index.\n  //    * @param {Number} bit\n  //    * @returns {Object}\n  //    */\n  //   byBit(bit) {\n  //     const index = binary.search(this.deploys, bit, cmpBit);\n  //     if (index === -1)\n  //       return null;\n  //     return this.deploys[index];\n  //   }\n  //   /**\n  //    * Get network adjusted time.\n  //    * @returns {Number}\n  //    */\n  //   now() {\n  //     return this.time.now();\n  //   }\n  //   /**\n  //    * Get network adjusted time in milliseconds.\n  //    * @returns {Number}\n  //    */\n  //   ms() {\n  //     return this.time.ms();\n  //   }\n\n  /**\n   * Create a network. Get existing network if possible.\n   * @param {NetworkType|Object} options\n   * @returns {Network}\n   */\n\n\n  static create(options) {\n    if (typeof options === 'string') options = networks[options];\n    assert(options, 'Unknown network.');\n    if (Network[options.type]) return Network[options.type];\n    const network = new Network(options);\n    Network[network.type] = network;\n    if (!Network.primary) Network.primary = network;\n    return network;\n  } //   /**\n  //    * Set the default network. This network will be used\n  //    * if nothing is passed as the `network` option for\n  //    * certain objects.\n  //    * @param {NetworkType} type - Network type.\n  //    * @returns {Network}\n  //    */\n  //   static set(type) {\n  //     assert(typeof type === 'string', 'Bad network.');\n  //     Network.primary = Network.get(type);\n  //     Network.type = type;\n  //     return Network.primary;\n  //   }\n\n  /**\n   * Get a network with a string or a Network object.\n   * @param {NetworkType|Network} type - Network type.\n   * @returns {Network}\n   */\n\n\n  static get(type) {\n    if (!type) {\n      assert(Network.primary, 'No default network.');\n      return Network.primary;\n    }\n\n    if (type instanceof Network) return type;\n    if (typeof type === 'string') return Network.create(type);\n    throw new Error('Unknown network.');\n  } //   /**\n  //    * Get a network with a string or a Network object.\n  //    * @param {NetworkType|Network} type - Network type.\n  //    * @returns {Network}\n  //    */\n  //   static ensure(type) {\n  //     if (!type) {\n  //       assert(Network.primary, 'No default network.');\n  //       return Network.primary;\n  //     }\n  //     if (type instanceof Network)\n  //       return type;\n  //     if (typeof type === 'string') {\n  //       if (networks[type])\n  //         return Network.create(type);\n  //     }\n  //     assert(Network.primary, 'No default network.');\n  //     return Network.primary;\n  //   }\n\n  /**\n   * Get a network by an associated comparator.\n   * @private\n   * @param {Object} value\n   * @param {Function} compare\n   * @param {Network|null} network\n   * @param {String} name\n   * @returns {Network}\n   */\n\n\n  static by(value, compare, network, name) {\n    if (network) {\n      network = Network.get(network);\n      if (compare(network, value)) return network;\n      throw new Error(`Network mismatch for ${name}.`);\n    }\n\n    for (const type of networks.types) {\n      network = networks[type];\n      if (compare(network, value)) return Network.get(type);\n    }\n\n    throw new Error(`Network not found for ${name}.`);\n  } //   /**\n  //    * Get a network by its magic number.\n  //    * @param {Number} value\n  //    * @param {Network?} network\n  //    * @returns {Network}\n  //    */\n  //   static fromMagic(value, network) {\n  //     return Network.by(value, cmpMagic, network, 'magic number');\n  //   }\n\n  /**\n   * Get a network by its WIF prefix.\n   * @param {Number} value\n   * @param {Network?} network\n   * @returns {Network}\n   */\n\n\n  static fromWIF(prefix, network) {\n    return Network.by(prefix, cmpWIF, network, 'WIF');\n  } //   /**\n  //    * Get a network by its xpubkey prefix.\n  //    * @param {Number} value\n  //    * @param {Network?} network\n  //    * @returns {Network}\n  //    */\n  //   static fromPublic(prefix, network) {\n  //     return Network.by(prefix, cmpPub, network, 'xpubkey');\n  //   }\n  //   /**\n  //    * Get a network by its xprivkey prefix.\n  //    * @param {Number} value\n  //    * @param {Network?} network\n  //    * @returns {Network}\n  //    */\n  //   static fromPrivate(prefix, network) {\n  //     return Network.by(prefix, cmpPriv, network, 'xprivkey');\n  //   }\n  //   /**\n  //    * Get a network by its xpubkey base58 prefix.\n  //    * @param {String} prefix\n  //    * @param {Network?} network\n  //    * @returns {Network}\n  //    */\n  //   static fromPublic58(prefix, network) {\n  //     return Network.by(prefix, cmpPub58, network, 'xpubkey');\n  //   }\n  //   /**\n  //    * Get a network by its xprivkey base58 prefix.\n  //    * @param {String} prefix\n  //    * @param {Network?} network\n  //    * @returns {Network}\n  //    */\n  //   static fromPrivate58(prefix, network) {\n  //     return Network.by(prefix, cmpPriv58, network, 'xprivkey');\n  //   }\n  //   /**\n  //    * Get a network by its base58 address prefix.\n  //    * @param {Number} value\n  //    * @param {Network?} network\n  //    * @returns {Network}\n  //    */\n  //   static fromAddress(prefix, network) {\n  //     return Network.by(prefix, cmpAddress, network, 'base58 address');\n  //   }\n  //   /**\n  //    * Get a network by its cashaddr address prefix.\n  //    * @param {String} hrp\n  //    * @param {Network?} network\n  //    * @returns {Network}\n  //    */\n  //   static fromCashAddr(prefix, network) {\n  //     return Network.by(prefix, cmpCashAddr, network, 'cashaddr address');\n  //   }\n  //   /**\n  //    * Convert the network to a string.\n  //    * @returns {String}\n  //    */\n  //   toString() {\n  //     return this.type;\n  //   }\n  //   /**\n  //    * Inspect the network.\n  //    * @returns {String}\n  //    */\n  //   inspect() {\n  //     return `<Network: ${this.type}>`;\n  //   }\n  //   /**\n  //    * Test an object to see if it is a Network.\n  //    * @param {Object} obj\n  //    * @returns {Boolean}\n  //    */\n  //   static isNetwork(obj) {\n  //     return obj instanceof Network;\n  //   }\n\n\n}\n/**\n * Default network.\n * @type {Network}\n */\n\n\nNetwork.primary = null;\n/**\n * Default network type.\n * @type {String}\n */\n\nNetwork.type = null;\n/*\n * Networks (to avoid hash table mode).\n */\n\nNetwork.main = null;\nNetwork.testnet = null;\nNetwork.regtest = null;\nNetwork.segnet4 = null;\nNetwork.simnet = null;\n/*\n * Set initial network.\n */\n\nNetwork.set(process.env.BCASH_NETWORK || 'main'); // /*\n//  * Helpers\n//  */\n// function cmpBit(a, b) {\n//   return a.bit - b;\n// }\n// function cmpNode(a, b) {\n//   return a.height - b.height;\n// }\n// function cmpMagic(network, magic) {\n//   return network.magic === magic;\n// }\n// function cmpWIF(network, prefix) {\n//   return network.keyPrefix.privkey === prefix;\n// }\n// function cmpPub(network, prefix) {\n//   return network.keyPrefix.xpubkey === prefix;\n// }\n// function cmpPriv(network, prefix) {\n//   return network.keyPrefix.xprivkey === prefix;\n// }\n// function cmpPub58(network, prefix) {\n//   return network.keyPrefix.xpubkey58 === prefix;\n// }\n// function cmpPriv58(network, prefix) {\n//   return network.keyPrefix.xprivkey58 === prefix;\n// }\n// function cmpAddress(network, prefix) {\n//   const prefixes = network.addressPrefix;\n//   switch (prefix) {\n//     case prefixes.pubkeyhash:\n//     case prefixes.scripthash:\n//       return true;\n//   }\n//   return false;\n// }\n// function cmpCashAddr(network, prefix) {\n//   return network.addressPrefix.cashaddr === prefix;\n// }\n\n/*\n * Expose\n */\n\nmodule.exports = Network;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/protocol/network.js"],"names":["assert","require","binary","networks","consensus","TimeData","Network","constructor","options","type","seeds","magic","port","checkpointMap","lastCheckpoint","checkpoints","halvingInterval","genesis","genesisBlock","pow","block","bip30","activationThreshold","minerWindow","deployments","deploys","unknownBits","VERSION_TOP_MASK","keyPrefix","addressPrefix","requireStandard","rpcPort","walletPort","minRelay","feeRate","maxFeeRate","selfConnect","requestMempool","time","init","create","network","primary","get","Error","by","value","compare","name","types","fromWIF","prefix","cmpWIF","main","testnet","regtest","segnet4","simnet","set","process","env","BCASH_NETWORK","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,OAAD,CAAtB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,iBAAD,CAAtB;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,aAAD,CAAzB;;AACA,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,YAAD,CAAxB;AAEA;AACA;AACA;AACA;AACA;;;AAEA,MAAMK,OAAN,CAAc;AACZ;AACF;AACA;AACA;AACA;AAEEC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnBR,IAAAA,MAAM,CAAC,CAACM,OAAO,CAACE,OAAO,CAACC,IAAT,CAAT,EAAyB,6BAAzB,CAAN;AAEA,SAAKA,IAAL,GAAYD,OAAO,CAACC,IAApB;AACA,SAAKC,KAAL,GAAaF,OAAO,CAACE,KAArB;AACA,SAAKC,KAAL,GAAaH,OAAO,CAACG,KAArB;AACA,SAAKC,IAAL,GAAYJ,OAAO,CAACI,IAApB;AACA,SAAKC,aAAL,GAAqBL,OAAO,CAACK,aAA7B;AACA,SAAKC,cAAL,GAAsBN,OAAO,CAACM,cAA9B;AACA,SAAKC,WAAL,GAAmB,EAAnB;AACA,SAAKC,eAAL,GAAuBR,OAAO,CAACQ,eAA/B;AACA,SAAKC,OAAL,GAAeT,OAAO,CAACS,OAAvB;AACA,SAAKC,YAAL,GAAoBV,OAAO,CAACU,YAA5B;AACA,SAAKC,GAAL,GAAWX,OAAO,CAACW,GAAnB;AACA,SAAKC,KAAL,GAAaZ,OAAO,CAACY,KAArB;AACA,SAAKC,KAAL,GAAab,OAAO,CAACa,KAArB;AACA,SAAKC,mBAAL,GAA2Bd,OAAO,CAACc,mBAAnC;AACA,SAAKC,WAAL,GAAmBf,OAAO,CAACe,WAA3B;AACA,SAAKC,WAAL,GAAmBhB,OAAO,CAACgB,WAA3B;AACA,SAAKC,OAAL,GAAejB,OAAO,CAACiB,OAAvB;AACA,SAAKC,WAAL,GAAmB,CAACtB,SAAS,CAACuB,gBAA9B;AACA,SAAKC,SAAL,GAAiBpB,OAAO,CAACoB,SAAzB;AACA,SAAKC,aAAL,GAAqBrB,OAAO,CAACqB,aAA7B;AACA,SAAKC,eAAL,GAAuBtB,OAAO,CAACsB,eAA/B;AACA,SAAKC,OAAL,GAAevB,OAAO,CAACuB,OAAvB;AACA,SAAKC,UAAL,GAAkBxB,OAAO,CAACwB,UAA1B;AACA,SAAKC,QAAL,GAAgBzB,OAAO,CAACyB,QAAxB;AACA,SAAKC,OAAL,GAAe1B,OAAO,CAAC0B,OAAvB;AACA,SAAKC,UAAL,GAAkB3B,OAAO,CAAC2B,UAA1B;AACA,SAAKC,WAAL,GAAmB5B,OAAO,CAAC4B,WAA3B;AACA,SAAKC,cAAL,GAAsB7B,OAAO,CAAC6B,cAA9B;AACA,SAAKC,IAAL,GAAY,IAAIjC,QAAJ,EAAZ;AAEA,SAAKkC,IAAL;AACD,GAzCW,CA2Cd;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;;;AAEe,SAANC,MAAM,CAAChC,OAAD,EAAU;AACrB,QAAI,OAAOA,OAAP,KAAmB,QAAvB,EACEA,OAAO,GAAGL,QAAQ,CAACK,OAAD,CAAlB;AAEFR,IAAAA,MAAM,CAACQ,OAAD,EAAU,kBAAV,CAAN;AAEA,QAAIF,OAAO,CAACE,OAAO,CAACC,IAAT,CAAX,EACE,OAAOH,OAAO,CAACE,OAAO,CAACC,IAAT,CAAd;AAEF,UAAMgC,OAAO,GAAG,IAAInC,OAAJ,CAAYE,OAAZ,CAAhB;AAEAF,IAAAA,OAAO,CAACmC,OAAO,CAAChC,IAAT,CAAP,GAAwBgC,OAAxB;AAEA,QAAI,CAACnC,OAAO,CAACoC,OAAb,EACEpC,OAAO,CAACoC,OAAR,GAAkBD,OAAlB;AAEF,WAAOA,OAAP;AACD,GA7HW,CA+Hd;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;;;AAEY,SAAHE,GAAG,CAAClC,IAAD,EAAO;AACf,QAAI,CAACA,IAAL,EAAW;AACTT,MAAAA,MAAM,CAACM,OAAO,CAACoC,OAAT,EAAkB,qBAAlB,CAAN;AACA,aAAOpC,OAAO,CAACoC,OAAf;AACD;;AAED,QAAIjC,IAAI,YAAYH,OAApB,EACE,OAAOG,IAAP;AAEF,QAAI,OAAOA,IAAP,KAAgB,QAApB,EACE,OAAOH,OAAO,CAACkC,MAAR,CAAe/B,IAAf,CAAP;AAEF,UAAM,IAAImC,KAAJ,CAAU,kBAAV,CAAN;AACD,GAjKW,CAmKd;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEW,SAAFC,EAAE,CAACC,KAAD,EAAQC,OAAR,EAAiBN,OAAjB,EAA0BO,IAA1B,EAAgC;AACvC,QAAIP,OAAJ,EAAa;AACXA,MAAAA,OAAO,GAAGnC,OAAO,CAACqC,GAAR,CAAYF,OAAZ,CAAV;AACA,UAAIM,OAAO,CAACN,OAAD,EAAUK,KAAV,CAAX,EACE,OAAOL,OAAP;AACF,YAAM,IAAIG,KAAJ,CAAW,wBAAuBI,IAAK,GAAvC,CAAN;AACD;;AAED,SAAK,MAAMvC,IAAX,IAAmBN,QAAQ,CAAC8C,KAA5B,EAAmC;AACjCR,MAAAA,OAAO,GAAGtC,QAAQ,CAACM,IAAD,CAAlB;AACA,UAAIsC,OAAO,CAACN,OAAD,EAAUK,KAAV,CAAX,EACE,OAAOxC,OAAO,CAACqC,GAAR,CAAYlC,IAAZ,CAAP;AACH;;AAED,UAAM,IAAImC,KAAJ,CAAW,yBAAwBI,IAAK,GAAxC,CAAN;AACD,GArNW,CAuNd;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;;;AAEgB,SAAPE,OAAO,CAACC,MAAD,EAASV,OAAT,EAAkB;AAC9B,WAAOnC,OAAO,CAACuC,EAAR,CAAWM,MAAX,EAAmBC,MAAnB,EAA2BX,OAA3B,EAAoC,KAApC,CAAP;AACD,GA3OW,CA6Od;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAzUc;AA4Ud;AACA;AACA;AACA;;;AAEAnC,OAAO,CAACoC,OAAR,GAAkB,IAAlB;AAEA;AACA;AACA;AACA;;AAEApC,OAAO,CAACG,IAAR,GAAe,IAAf;AAEA;AACA;AACA;;AAEAH,OAAO,CAAC+C,IAAR,GAAe,IAAf;AACA/C,OAAO,CAACgD,OAAR,GAAkB,IAAlB;AACAhD,OAAO,CAACiD,OAAR,GAAkB,IAAlB;AACAjD,OAAO,CAACkD,OAAR,GAAkB,IAAlB;AACAlD,OAAO,CAACmD,MAAR,GAAiB,IAAjB;AAEA;AACA;AACA;;AAEAnD,OAAO,CAACoD,GAAR,CAAYC,OAAO,CAACC,GAAR,CAAYC,aAAZ,IAA6B,MAAzC,E,CAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEAC,MAAM,CAACC,OAAP,GAAiBzD,OAAjB","sourcesContent":["/*!\n * network.js - network object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst binary = require('../utils/binary');\nconst networks = require('./networks');\nconst consensus = require('./consensus');\nconst TimeData = require('./timedata');\n\n/**\n * Network\n * Represents a network.\n * @alias module:protocol.Network\n */\n\nclass Network {\n  /**\n   * Create a network.\n   * @constructor\n   * @param {Object} options\n   */\n\n  constructor(options) {\n    assert(!Network[options.type], 'Cannot create two networks.');\n\n    this.type = options.type;\n    this.seeds = options.seeds;\n    this.magic = options.magic;\n    this.port = options.port;\n    this.checkpointMap = options.checkpointMap;\n    this.lastCheckpoint = options.lastCheckpoint;\n    this.checkpoints = [];\n    this.halvingInterval = options.halvingInterval;\n    this.genesis = options.genesis;\n    this.genesisBlock = options.genesisBlock;\n    this.pow = options.pow;\n    this.block = options.block;\n    this.bip30 = options.bip30;\n    this.activationThreshold = options.activationThreshold;\n    this.minerWindow = options.minerWindow;\n    this.deployments = options.deployments;\n    this.deploys = options.deploys;\n    this.unknownBits = ~consensus.VERSION_TOP_MASK;\n    this.keyPrefix = options.keyPrefix;\n    this.addressPrefix = options.addressPrefix;\n    this.requireStandard = options.requireStandard;\n    this.rpcPort = options.rpcPort;\n    this.walletPort = options.walletPort;\n    this.minRelay = options.minRelay;\n    this.feeRate = options.feeRate;\n    this.maxFeeRate = options.maxFeeRate;\n    this.selfConnect = options.selfConnect;\n    this.requestMempool = options.requestMempool;\n    this.time = new TimeData();\n\n    this.init();\n  }\n\n//   /**\n//    * Get a deployment by bit index.\n//    * @param {Number} bit\n//    * @returns {Object}\n//    */\n\n//   init() {\n//     let bits = 0;\n\n//     for (const deployment of this.deploys)\n//       bits |= 1 << deployment.bit;\n\n//     bits |= consensus.VERSION_TOP_MASK;\n\n//     this.unknownBits = ~bits >>> 0;\n\n//     for (const key of Object.keys(this.checkpointMap)) {\n//       const hash = this.checkpointMap[key];\n//       const height = Number(key);\n\n//       this.checkpoints.push({ hash, height });\n//     }\n\n//     this.checkpoints.sort(cmpNode);\n//   }\n\n//   /**\n//    * Get a deployment by bit index.\n//    * @param {Number} bit\n//    * @returns {Object}\n//    */\n\n//   byBit(bit) {\n//     const index = binary.search(this.deploys, bit, cmpBit);\n\n//     if (index === -1)\n//       return null;\n\n//     return this.deploys[index];\n//   }\n\n//   /**\n//    * Get network adjusted time.\n//    * @returns {Number}\n//    */\n\n//   now() {\n//     return this.time.now();\n//   }\n\n//   /**\n//    * Get network adjusted time in milliseconds.\n//    * @returns {Number}\n//    */\n\n//   ms() {\n//     return this.time.ms();\n//   }\n\n  /**\n   * Create a network. Get existing network if possible.\n   * @param {NetworkType|Object} options\n   * @returns {Network}\n   */\n\n  static create(options) {\n    if (typeof options === 'string')\n      options = networks[options];\n\n    assert(options, 'Unknown network.');\n\n    if (Network[options.type])\n      return Network[options.type];\n\n    const network = new Network(options);\n\n    Network[network.type] = network;\n\n    if (!Network.primary)\n      Network.primary = network;\n\n    return network;\n  }\n\n//   /**\n//    * Set the default network. This network will be used\n//    * if nothing is passed as the `network` option for\n//    * certain objects.\n//    * @param {NetworkType} type - Network type.\n//    * @returns {Network}\n//    */\n\n//   static set(type) {\n//     assert(typeof type === 'string', 'Bad network.');\n//     Network.primary = Network.get(type);\n//     Network.type = type;\n//     return Network.primary;\n//   }\n\n  /**\n   * Get a network with a string or a Network object.\n   * @param {NetworkType|Network} type - Network type.\n   * @returns {Network}\n   */\n\n  static get(type) {\n    if (!type) {\n      assert(Network.primary, 'No default network.');\n      return Network.primary;\n    }\n\n    if (type instanceof Network)\n      return type;\n\n    if (typeof type === 'string')\n      return Network.create(type);\n\n    throw new Error('Unknown network.');\n  }\n\n//   /**\n//    * Get a network with a string or a Network object.\n//    * @param {NetworkType|Network} type - Network type.\n//    * @returns {Network}\n//    */\n\n//   static ensure(type) {\n//     if (!type) {\n//       assert(Network.primary, 'No default network.');\n//       return Network.primary;\n//     }\n\n//     if (type instanceof Network)\n//       return type;\n\n//     if (typeof type === 'string') {\n//       if (networks[type])\n//         return Network.create(type);\n//     }\n\n//     assert(Network.primary, 'No default network.');\n\n//     return Network.primary;\n//   }\n\n  /**\n   * Get a network by an associated comparator.\n   * @private\n   * @param {Object} value\n   * @param {Function} compare\n   * @param {Network|null} network\n   * @param {String} name\n   * @returns {Network}\n   */\n\n  static by(value, compare, network, name) {\n    if (network) {\n      network = Network.get(network);\n      if (compare(network, value))\n        return network;\n      throw new Error(`Network mismatch for ${name}.`);\n    }\n\n    for (const type of networks.types) {\n      network = networks[type];\n      if (compare(network, value))\n        return Network.get(type);\n    }\n\n    throw new Error(`Network not found for ${name}.`);\n  }\n\n//   /**\n//    * Get a network by its magic number.\n//    * @param {Number} value\n//    * @param {Network?} network\n//    * @returns {Network}\n//    */\n\n//   static fromMagic(value, network) {\n//     return Network.by(value, cmpMagic, network, 'magic number');\n//   }\n\n  /**\n   * Get a network by its WIF prefix.\n   * @param {Number} value\n   * @param {Network?} network\n   * @returns {Network}\n   */\n\n  static fromWIF(prefix, network) {\n    return Network.by(prefix, cmpWIF, network, 'WIF');\n  }\n\n//   /**\n//    * Get a network by its xpubkey prefix.\n//    * @param {Number} value\n//    * @param {Network?} network\n//    * @returns {Network}\n//    */\n\n//   static fromPublic(prefix, network) {\n//     return Network.by(prefix, cmpPub, network, 'xpubkey');\n//   }\n\n//   /**\n//    * Get a network by its xprivkey prefix.\n//    * @param {Number} value\n//    * @param {Network?} network\n//    * @returns {Network}\n//    */\n\n//   static fromPrivate(prefix, network) {\n//     return Network.by(prefix, cmpPriv, network, 'xprivkey');\n//   }\n\n//   /**\n//    * Get a network by its xpubkey base58 prefix.\n//    * @param {String} prefix\n//    * @param {Network?} network\n//    * @returns {Network}\n//    */\n\n//   static fromPublic58(prefix, network) {\n//     return Network.by(prefix, cmpPub58, network, 'xpubkey');\n//   }\n\n//   /**\n//    * Get a network by its xprivkey base58 prefix.\n//    * @param {String} prefix\n//    * @param {Network?} network\n//    * @returns {Network}\n//    */\n\n//   static fromPrivate58(prefix, network) {\n//     return Network.by(prefix, cmpPriv58, network, 'xprivkey');\n//   }\n\n//   /**\n//    * Get a network by its base58 address prefix.\n//    * @param {Number} value\n//    * @param {Network?} network\n//    * @returns {Network}\n//    */\n\n//   static fromAddress(prefix, network) {\n//     return Network.by(prefix, cmpAddress, network, 'base58 address');\n//   }\n\n//   /**\n//    * Get a network by its cashaddr address prefix.\n//    * @param {String} hrp\n//    * @param {Network?} network\n//    * @returns {Network}\n//    */\n\n//   static fromCashAddr(prefix, network) {\n//     return Network.by(prefix, cmpCashAddr, network, 'cashaddr address');\n//   }\n\n//   /**\n//    * Convert the network to a string.\n//    * @returns {String}\n//    */\n\n//   toString() {\n//     return this.type;\n//   }\n\n//   /**\n//    * Inspect the network.\n//    * @returns {String}\n//    */\n\n//   inspect() {\n//     return `<Network: ${this.type}>`;\n//   }\n\n//   /**\n//    * Test an object to see if it is a Network.\n//    * @param {Object} obj\n//    * @returns {Boolean}\n//    */\n\n//   static isNetwork(obj) {\n//     return obj instanceof Network;\n//   }\n}\n\n/**\n * Default network.\n * @type {Network}\n */\n\nNetwork.primary = null;\n\n/**\n * Default network type.\n * @type {String}\n */\n\nNetwork.type = null;\n\n/*\n * Networks (to avoid hash table mode).\n */\n\nNetwork.main = null;\nNetwork.testnet = null;\nNetwork.regtest = null;\nNetwork.segnet4 = null;\nNetwork.simnet = null;\n\n/*\n * Set initial network.\n */\n\nNetwork.set(process.env.BCASH_NETWORK || 'main');\n\n// /*\n//  * Helpers\n//  */\n\n// function cmpBit(a, b) {\n//   return a.bit - b;\n// }\n\n// function cmpNode(a, b) {\n//   return a.height - b.height;\n// }\n\n// function cmpMagic(network, magic) {\n//   return network.magic === magic;\n// }\n\n// function cmpWIF(network, prefix) {\n//   return network.keyPrefix.privkey === prefix;\n// }\n\n// function cmpPub(network, prefix) {\n//   return network.keyPrefix.xpubkey === prefix;\n// }\n\n// function cmpPriv(network, prefix) {\n//   return network.keyPrefix.xprivkey === prefix;\n// }\n\n// function cmpPub58(network, prefix) {\n//   return network.keyPrefix.xpubkey58 === prefix;\n// }\n\n// function cmpPriv58(network, prefix) {\n//   return network.keyPrefix.xprivkey58 === prefix;\n// }\n\n// function cmpAddress(network, prefix) {\n//   const prefixes = network.addressPrefix;\n\n//   switch (prefix) {\n//     case prefixes.pubkeyhash:\n//     case prefixes.scripthash:\n//       return true;\n//   }\n\n//   return false;\n// }\n\n// function cmpCashAddr(network, prefix) {\n//   return network.addressPrefix.cashaddr === prefix;\n// }\n\n/*\n * Expose\n */\n\nmodule.exports = Network;\n"]},"metadata":{},"sourceType":"module"}