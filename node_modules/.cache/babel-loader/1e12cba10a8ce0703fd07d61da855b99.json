{"ast":null,"code":"/*!\n * primes.js - Prime number generation for javascript\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on golang/go:\n *   Copyright (c) 2009, The Go Authors. All rights reserved.\n *   https://github.com/golang/go\n *\n * Parts of this software are based on indutny/miller-rabin:\n *   Copyright (c) 2014, Fedor Indutny (MIT License).\n *   https://github.com/indutny/miller-rabin\n *\n * Resources:\n *   https://github.com/golang/go/blob/master/src/crypto/rsa/rsa.go\n *   https://github.com/golang/go/blob/master/src/math/big/prime.go\n *   https://github.com/golang/go/blob/master/src/math/big/int.go\n *   https://github.com/golang/go/blob/master/src/math/big/nat.go\n *   https://github.com/golang/go/blob/master/src/crypto/rand/util.go\n *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst BN = require('../bn');\n\nconst random = require('../random');\n/*\n * Constants\n */\n\n\nconst smallPrimes = new Uint8Array([3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53]);\nconst smallPrimesProduct = new BN('16294579238595022365', 10);\nconst primeBitMaskLo = 0 | 1 << 2 | 1 << 3 | 1 << 5 | 1 << 7 | 1 << 11 | 1 << 13 | 1 << 17 | 1 << 19 | 1 << 23 | 1 << 29 | 1 << 31;\nconst primeBitMaskHi = 0 | 1 << 37 - 32 | 1 << 41 - 32 | 1 << 43 - 32 | 1 << 47 - 32 | 1 << 53 - 32 | 1 << 59 - 32 | 1 << 61 - 32;\nconst primesA = new BN(3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 37);\nconst primesB = new BN(29 * 31 * 41 * 43 * 47 * 53);\n/*\n * Primality\n */\n\nfunction randomPrime(bits) {\n  let reps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;\n  let rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : random;\n  assert(bits >>> 0 === bits);\n  assert(reps >>> 0 === reps);\n  assert(rng != null);\n  if (bits < 2) throw new Error('Prime must be at least 2 bits.');\n\n  for (;;) {\n    const p = BN.randomBits(rng, bits);\n    p.setn(bits - 1, 1);\n    p.setn(bits - 2, 1);\n    p.setn(0, 1);\n    const mod = p.mod(smallPrimesProduct);\n\n    next: for (let delta = 0; delta < 1 << 20; delta += 2) {\n      const m = mod.addn(delta);\n\n      for (let i = 0; i < smallPrimes.length; i++) {\n        const prime = smallPrimes[i];\n        if (m.modrn(prime) === 0 && (bits > 6 || m.cmpn(prime) !== 0)) continue next;\n      }\n\n      p.iaddn(delta);\n      break;\n    }\n\n    if (p.bitLength() !== bits) continue;\n    if (!isProbablePrime(p, reps, rng)) continue;\n    return p;\n  }\n}\n\nfunction isProbablePrime(x, reps) {\n  let rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : random;\n  assert(x instanceof BN);\n  if (x.sign() <= 0) return false;\n\n  if (x.cmpn(64) < 0) {\n    const w = x.word(0);\n    if (w > 31) return (primeBitMaskHi & 1 << w - 32) !== 0;\n    return (primeBitMaskLo & 1 << w) !== 0;\n  }\n\n  if (x.isEven()) return false;\n  const ra = x.mod(primesA).toNumber();\n  const rb = x.mod(primesB).toNumber();\n\n  if (ra % 3 === 0 || ra % 5 === 0 || ra % 7 === 0 || ra % 11 === 0 || ra % 13 === 0 || ra % 17 === 0 || ra % 19 === 0 || ra % 23 === 0 || ra % 37 === 0 || rb % 29 === 0 || rb % 31 === 0 || rb % 41 === 0 || rb % 43 === 0 || rb % 47 === 0 || rb % 53 === 0) {\n    return false;\n  }\n\n  return x.isPrime(rng, reps);\n}\n\nfunction isSafePrime(x, reps, rng) {\n  // Safe Prime (2p + 1).\n  if (!isProbablePrime(x, reps, rng)) return false; // Sophie Germain Prime (p).\n\n  const p = x.subn(1).iushrn(1);\n  if (!isProbablePrime(p, reps, rng)) return false;\n  return true;\n}\n/*\n * Expose\n */\n\n\nexports.randomPrime = randomPrime;\nexports.isProbablePrime = isProbablePrime;\nexports.isSafePrime = isSafePrime;","map":null,"metadata":{},"sourceType":"script"}