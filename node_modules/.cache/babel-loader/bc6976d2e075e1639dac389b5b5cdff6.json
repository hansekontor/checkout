{"ast":null,"code":"/*!\n * script.js - script interpreter for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bio = require('bufio');\n\nconst ripemd160 = require('bcrypto/lib/ripemd160');\n\nconst sha1 = require('bcrypto/lib/sha1');\n\nconst sha256 = require('bcrypto/lib/sha256');\n\nconst hash160 = require('bcrypto/lib/hash160');\n\nconst hash256 = require('bcrypto/lib/hash256');\n\nconst secp256k1 = require('bcrypto/lib/secp256k1');\n\nconst consensus = require('../protocol/consensus');\n\nconst policy = require('../protocol/policy');\n\nconst Opcode = require('./opcode');\n\nconst Stack = require('./stack');\n\nconst ScriptError = require('./scripterror');\n\nconst ScriptNum = require('./scriptnum');\n\nconst common = require('./common');\n\nconst Address = require('../primitives/address');\n\nconst Metrics = require('./metrics');\n\nconst opcodes = common.opcodes;\nconst scriptTypes = common.types;\nconst countBits = common.countBits;\nconst {\n  encoding\n} = bio;\n/*\n * Constants\n */\n\nconst EMPTY_BUFFER = Buffer.alloc(0);\nconst metrics = new Metrics();\n/**\n * Script\n * Represents a input or output script.\n * @alias module:script.Script\n * @property {Array} code - Parsed script code.\n * @property {Buffer?} raw - Serialized script.\n * @property {Number} length - Number of parsed opcodes.\n */\n\nclass Script {\n  /**\n   * Create a script.\n   * @constructor\n   * @param {Buffer|Array|Object} code\n   */\n  constructor(options) {\n    this.raw = EMPTY_BUFFER;\n    this.code = [];\n    if (options) this.fromOptions(options);\n  } //   /**\n  //    * Get length.\n  //    * @returns {Number}\n  //    */\n  //   get length() {\n  //     return this.code.length;\n  //   }\n  //   /**\n  //    * Set length.\n  //    * @param {Number} value\n  //    */\n  //   set length(value) {\n  //     this.code.length = value;\n  //   }\n  //   /**\n  //    * Inject properties from options object.\n  //    * @private\n  //    * @param {Object} options\n  //    */\n  //   fromOptions(options) {\n  //     assert(options, 'Script data is required.');\n  //     if (Buffer.isBuffer(options))\n  //       return this.fromRaw(options);\n  //     if (Array.isArray(options))\n  //       return this.fromArray(options);\n  //     if (options.raw) {\n  //       if (!options.code)\n  //         return this.fromRaw(options.raw);\n  //       assert(Buffer.isBuffer(options.raw), 'Raw must be a Buffer.');\n  //       this.raw = options.raw;\n  //     }\n  //     if (options.code) {\n  //       if (!options.raw)\n  //         return this.fromArray(options.code);\n  //       assert(Array.isArray(options.code), 'Code must be an array.');\n  //       this.code = options.code;\n  //     }\n  //     return this;\n  //   }\n  //   /**\n  //    * Insantiate script from options object.\n  //    * @param {Object} options\n  //    * @returns {Script}\n  //    */\n  //   static fromOptions(options) {\n  //     return new this().fromOptions(options);\n  //   }\n  //   /**\n  //    * Instantiate a value-only iterator.\n  //    * @returns {ScriptIterator}\n  //    */\n  //   values() {\n  //     return this.code.values();\n  //   }\n  //   /**\n  //    * Instantiate a key and value iterator.\n  //    * @returns {ScriptIterator}\n  //    */\n  //   entries() {\n  //     return this.code.entries();\n  //   }\n  //   /**\n  //    * Instantiate a value-only iterator.\n  //    * @returns {ScriptIterator}\n  //    */\n  //   [Symbol.iterator]() {\n  //     return this.code[Symbol.iterator]();\n  //   }\n  //   /**\n  //    * Convert the script to an array of\n  //    * Buffers (pushdatas) and Numbers\n  //    * (opcodes).\n  //    * @returns {Array}\n  //    */\n  //   toArray() {\n  //     return this.code.slice();\n  //   }\n  //   /**\n  //    * Inject properties from an array of\n  //    * of buffers and numbers.\n  //    * @private\n  //    * @param {Array} code\n  //    * @returns {Script}\n  //    */\n  //   fromArray(code) {\n  //     assert(Array.isArray(code));\n  //     this.clear();\n  //     for (const op of code)\n  //       this.push(op);\n  //     return this.compile();\n  //   }\n  //   /**\n  //    * Instantiate script from an array\n  //    * of buffers and numbers.\n  //    * @param {Array} code\n  //    * @returns {Script}\n  //    */\n  //   static fromArray(code) {\n  //     return new this().fromArray(code);\n  //   }\n  //   /**\n  //    * Convert script to stack items.\n  //    * @returns {Buffer[]}\n  //    */\n  //   toItems() {\n  //     const items = [];\n  //     for (const op of this.code) {\n  //       const data = op.toPush();\n  //       if (!data)\n  //         throw new Error('Non-push opcode in script.');\n  //       items.push(data);\n  //     }\n  //     return items;\n  //   }\n  //   /**\n  //    * Inject data from stack items.\n  //    * @private\n  //    * @param {Buffer[]} items\n  //    * @returns {Script}\n  //    */\n  //   fromItems(items) {\n  //     assert(Array.isArray(items));\n  //     this.clear();\n  //     for (const item of items)\n  //       this.pushData(item);\n  //     return this.compile();\n  //   }\n  //   /**\n  //    * Instantiate script from stack items.\n  //    * @param {Buffer[]} items\n  //    * @returns {Script}\n  //    */\n  //   static fromItems(items) {\n  //     return new this().fromItems(items);\n  //   }\n  //   /**\n  //    * Convert script to stack.\n  //    * @returns {Stack}\n  //    */\n  //   toStack() {\n  //     return new Stack(this.toItems());\n  //   }\n  //   /**\n  //    * Inject data from stack.\n  //    * @private\n  //    * @param {Stack} stack\n  //    * @returns {Script}\n  //    */\n  //   fromStack(stack) {\n  //     return this.fromItems(stack.items);\n  //   }\n  //   /**\n  //    * Instantiate script from stack.\n  //    * @param {Stack} stack\n  //    * @returns {Script}\n  //    */\n  //   static fromStack(stack) {\n  //     return new this().fromStack(stack);\n  //   }\n  //   /**\n  //    * Clone the script.\n  //    * @returns {Script} Cloned script.\n  //    */\n  //   clone() {\n  //     return new this.constructor().inject(this);\n  //   }\n  //   /**\n  //    * Inject properties from script.\n  //    * Used for cloning.\n  //    * @private\n  //    * @param {Script} script\n  //    * @returns {Script}\n  //    */\n  //   inject(script) {\n  //     this.raw = script.raw;\n  //     this.code = script.code.slice();\n  //     return this;\n  //   }\n  //   /**\n  //    * Test equality against script.\n  //    * @param {Script} script\n  //    * @returns {Boolean}\n  //    */\n  //   equals(script) {\n  //     assert(Script.isScript(script));\n  //     return this.raw.equals(script.raw);\n  //   }\n  //   /**\n  //    * Compare against another script.\n  //    * @param {Script} script\n  //    * @returns {Number}\n  //    */\n  //   compare(script) {\n  //     assert(Script.isScript(script));\n  //     return this.raw.compare(script.raw);\n  //   }\n  //   /**\n  //    * Clear the script.\n  //    * @returns {Script}\n  //    */\n  //   clear() {\n  //     this.raw = EMPTY_BUFFER;\n  //     this.code.length = 0;\n  //     return this;\n  //   }\n  //   /**\n  //    * Inspect the script.\n  //    * @returns {String} Human-readable script code.\n  //    */\n  //   inspect() {\n  //     return `<Script: ${this.toString()}>`;\n  //   }\n  //   /**\n  //    * Convert the script to a bitcoind test string.\n  //    * @returns {String} Human-readable script code.\n  //    */\n  //   toString() {\n  //     const out = [];\n  //     for (const op of this.code)\n  //       out.push(op.toFormat());\n  //     return out.join(' ');\n  //   }\n  //   /**\n  //    * Format the script as bitcoind asm.\n  //    * @param {Boolean?} decode - Attempt to decode hash types.\n  //    * @returns {String} Human-readable script.\n  //    */\n  //   toASM(decode) {\n  //     if (this.isNulldata())\n  //       decode = false;\n  //     const out = [];\n  //     for (const op of this.code)\n  //       out.push(op.toASM(decode));\n  //     return out.join(' ');\n  //   }\n  //   /**\n  //    * Re-encode the script internally. Useful if you\n  //    * changed something manually in the `code` array.\n  //    * @returns {Script}\n  //    */\n  //   compile() {\n  //     if (this.code.length === 0)\n  //       return this.clear();\n  //     let size = 0;\n  //     for (const op of this.code)\n  //       size += op.getSize();\n  //     const bw = bio.write(size);\n  //     for (const op of this.code)\n  //       op.toWriter(bw);\n  //     this.raw = bw.render();\n  //     return this;\n  //   }\n  //   /**\n  //    * Write the script to a buffer writer.\n  //    * @param {BufferWriter} bw\n  //    */\n  //   toWriter(bw) {\n  //     bw.writeVarBytes(this.raw);\n  //     return bw;\n  //   }\n  //   /**\n  //    * Encode the script to a Buffer. See {@link Script#encode}.\n  //    * @param {String} enc - Encoding, either `'hex'` or `null`.\n  //    * @returns {Buffer|String} Serialized script.\n  //    */\n  //   toRaw() {\n  //     return this.raw;\n  //   }\n  //   /**\n  //    * Convert script to a hex string.\n  //    * @returns {String}\n  //    */\n  //   toJSON() {\n  //     return this.toRaw().toString('hex');\n  //   }\n  //   /**\n  //    * Inject properties from json object.\n  //    * @private\n  //    * @param {String} json\n  //    */\n\n\n  fromJSON(json) {\n    assert(typeof json === 'string', 'Code must be a string.');\n    return this.fromRaw(Buffer.from(json, 'hex'));\n  }\n  /**\n   * Instantiate script from a hex string.\n   * @params {String} json\n   * @returns {Script}\n   */\n\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  } //   /**\n  //    * Get the script's \"subscript\" starting at a separator.\n  //    * @param {Number} index - The last separator to sign/verify beyond.\n  //    * @returns {Script} Subscript.\n  //    */\n  //   getSubscript(index) {\n  //     if (index === 0)\n  //       return this.clone();\n  //     const script = new Script();\n  //     for (let i = index; i < this.code.length; i++) {\n  //       const op = this.code[i];\n  //       if (op.value === -1)\n  //         break;\n  //       script.code.push(op);\n  //     }\n  //     return script.compile();\n  //   }\n  //   /**\n  //    * Get the script's \"subscript\" starting at a separator.\n  //    * Remove all OP_CODESEPARATORs if present. This bizarre\n  //    * behavior is necessary for signing and verification when\n  //    * code separators are present.\n  //    * @returns {Script} Subscript.\n  //    */\n  //   removeSeparators() {\n  //     let found = false;\n  //     // Optimizing for the common case:\n  //     // Check for any separators first.\n  //     for (const op of this.code) {\n  //       if (op.value === -1)\n  //         break;\n  //       if (op.value === opcodes.OP_CODESEPARATOR) {\n  //         found = true;\n  //         break;\n  //       }\n  //     }\n  //     if (!found)\n  //       return this;\n  //     // Uncommon case: someone actually\n  //     // has a code separator. Go through\n  //     // and remove them all.\n  //     const script = new Script();\n  //     for (const op of this.code) {\n  //       if (op.value === -1)\n  //         break;\n  //       if (op.value !== opcodes.OP_CODESEPARATOR)\n  //         script.code.push(op);\n  //     }\n  //     return script.compile();\n  //   }\n  //   /**\n  //    * Get the value of the checkBits while calculated as little endian.\n  //    * @param {Buffer} abkam - Stack depth of the dummy element.\n  //    * @param {Number?} nKeysCount - Stack depth of the top pubkeys.\n  //    * @returns {Number}\n  //    */\n  //   bitcalculator(abkam, nKeysCount) {\n  //     let checkBits = 0;\n  //     const bitfield_size = ((nKeysCount + 7) / 8);\n  //     for (let i = 0; i < bitfield_size; i++) {\n  //       checkBits |= abkam[i] << (8 * i);\n  //     }\n  //     return checkBits;\n  //   }\n  //   /**\n  //    * Execute and interpret the script.\n  //    * @param {Stack} stack - Script execution stack.\n  //    * @param {Number?} flags - Script standard flags.\n  //    * @param {TX?} tx - Transaction being verified.\n  //    * @param {Number?} index - Index of input being verified.\n  //    * @param {Amount?} value - Previous output value.\n  //    * @param {Number?} sigchecks\n  //    * @throws {ScriptError} Will be thrown on VERIFY failures.\n  //    */\n  //   execute(stack, flags, tx, index, value, sigchecks) {\n  //     if (flags == null)\n  //       flags = Script.flags.STANDARD_VERIFY_FLAGS;\n  //     if (this.getSize() > consensus.MAX_SCRIPT_SIZE)\n  //       throw new ScriptError('SCRIPT_SIZE');\n  //     const state = [];\n  //     const alt = [];\n  //     let lastSep = 0;\n  //     let opCount = 0;\n  //     let negate = 0;\n  //     let nSigsRemaining = 0;\n  //     let nKeysRemaining = 0;\n  //     let checkBits;\n  //     let minimal = false;\n  //     if (flags & Script.flags.VERIFY_MINIMALDATA)\n  //       minimal = true;\n  //     for (let ip = 0; ip < this.code.length; ip++) {\n  //       const op = this.code[ip];\n  //       if (op.value === -1)\n  //         throw new ScriptError('BAD_OPCODE', op, ip);\n  //       if (op.data && op.data.length > consensus.MAX_SCRIPT_PUSH)\n  //         throw new ScriptError('PUSH_SIZE', op, ip);\n  //       if (op.value > opcodes.OP_16 && ++opCount > consensus.MAX_SCRIPT_OPS)\n  //         throw new ScriptError('OP_COUNT', op, ip);\n  //       if (op.isDisabled(flags))\n  //         throw new ScriptError('DISABLED_OPCODE', op, ip);\n  //       if (negate && !op.isBranch()) {\n  //         if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK)\n  //           throw new ScriptError('STACK_SIZE', op, ip);\n  //         continue;\n  //       }\n  //       if (op.data && 0 <= op.value <= opcodes.OP_PUSHDATA4) {\n  //         if (minimal && !op.isMinimal())\n  //           throw new ScriptError('MINIMALDATA', op, ip);\n  //         stack.push(op.data);\n  //         if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK)\n  //           throw new ScriptError('STACK_SIZE', op, ip);\n  //         continue;\n  //       }\n  //       switch (op.value) {\n  //         case opcodes.OP_0: {\n  //           stack.pushInt(0);\n  //           break;\n  //         }\n  //         case opcodes.OP_1NEGATE: {\n  //           stack.pushInt(-1);\n  //           break;\n  //         }\n  //         case opcodes.OP_1:\n  //         case opcodes.OP_2:\n  //         case opcodes.OP_3:\n  //         case opcodes.OP_4:\n  //         case opcodes.OP_5:\n  //         case opcodes.OP_6:\n  //         case opcodes.OP_7:\n  //         case opcodes.OP_8:\n  //         case opcodes.OP_9:\n  //         case opcodes.OP_10:\n  //         case opcodes.OP_11:\n  //         case opcodes.OP_12:\n  //         case opcodes.OP_13:\n  //         case opcodes.OP_14:\n  //         case opcodes.OP_15:\n  //         case opcodes.OP_16: {\n  //           stack.pushInt(op.value - 0x50);\n  //           break;\n  //         }\n  //         case opcodes.OP_NOP: {\n  //           break;\n  //         }\n  //         case opcodes.OP_CHECKLOCKTIMEVERIFY: {\n  //           // OP_CHECKLOCKTIMEVERIFY = OP_NOP2\n  //           if (!(flags & Script.flags.VERIFY_CHECKLOCKTIMEVERIFY)) {\n  //             if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n  //               throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);\n  //             break;\n  //           }\n  //           if (!tx)\n  //             throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n  //           if (stack.length === 0)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           const num = stack.getNum(-1, minimal, 5);\n  //           if (num.isNeg())\n  //             throw new ScriptError('NEGATIVE_LOCKTIME', op, ip);\n  //           const locktime = num.toDouble();\n  //           if (!tx.verifyLocktime(index, locktime))\n  //             throw new ScriptError('UNSATISFIED_LOCKTIME', op, ip);\n  //           break;\n  //         }\n  //         case opcodes.OP_CHECKSEQUENCEVERIFY: {\n  //           // OP_CHECKSEQUENCEVERIFY = OP_NOP3\n  //           if (!(flags & Script.flags.VERIFY_CHECKSEQUENCEVERIFY)) {\n  //             if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n  //               throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);\n  //             break;\n  //           }\n  //           if (!tx)\n  //             throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n  //           if (stack.length === 0)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           const num = stack.getNum(-1, minimal, 5);\n  //           if (num.isNeg())\n  //             throw new ScriptError('NEGATIVE_LOCKTIME', op, ip);\n  //           const locktime = num.toDouble();\n  //           if (!tx.verifySequence(index, locktime))\n  //             throw new ScriptError('UNSATISFIED_LOCKTIME', op, ip);\n  //           break;\n  //         }\n  //         case opcodes.OP_NOP1:\n  //         case opcodes.OP_NOP4:\n  //         case opcodes.OP_NOP5:\n  //         case opcodes.OP_NOP6:\n  //         case opcodes.OP_NOP7:\n  //         case opcodes.OP_NOP8:\n  //         case opcodes.OP_NOP9:\n  //         case opcodes.OP_NOP10: {\n  //           if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n  //             throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);\n  //           break;\n  //         }\n  //         case opcodes.OP_IF:\n  //         case opcodes.OP_NOTIF: {\n  //           let val = false;\n  //           if (!negate) {\n  //             if (stack.length < 1)\n  //               throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);\n  //             if (flags & Script.flags.VERIFY_MINIMALIF) {\n  //               const item = stack.get(-1);\n  //               if (item.length > 1)\n  //                 throw new ScriptError('MINIMALIF');\n  //               if (item.length === 1 && item[0] !== 1)\n  //                 throw new ScriptError('MINIMALIF');\n  //             }\n  //             val = stack.getBool(-1);\n  //             if (op.value === opcodes.OP_NOTIF)\n  //               val = !val;\n  //             stack.pop();\n  //           }\n  //           state.push(val);\n  //           if (!val)\n  //             negate += 1;\n  //           break;\n  //         }\n  //         case opcodes.OP_ELSE: {\n  //           if (state.length === 0)\n  //             throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);\n  //           state[state.length - 1] = !state[state.length - 1];\n  //           if (!state[state.length - 1])\n  //             negate += 1;\n  //           else\n  //             negate -= 1;\n  //           break;\n  //         }\n  //         case opcodes.OP_ENDIF: {\n  //           if (state.length === 0)\n  //             throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);\n  //           if (!state.pop())\n  //             negate -= 1;\n  //           break;\n  //         }\n  //         case opcodes.OP_VERIFY: {\n  //           if (stack.length === 0)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           if (!stack.getBool(-1))\n  //             throw new ScriptError('VERIFY', op, ip);\n  //           stack.pop();\n  //           break;\n  //         }\n  //         case opcodes.OP_RETURN: {\n  //           throw new ScriptError('OP_RETURN', op, ip);\n  //         }\n  //         case opcodes.OP_TOALTSTACK: {\n  //           if (stack.length === 0)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           alt.push(stack.pop());\n  //           break;\n  //         }\n  //         case opcodes.OP_FROMALTSTACK: {\n  //           if (alt.length === 0)\n  //             throw new ScriptError('INVALID_ALTSTACK_OPERATION', op, ip);\n  //           stack.push(alt.pop());\n  //           break;\n  //         }\n  //         case opcodes.OP_2DROP: {\n  //           if (stack.length < 2)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           stack.pop();\n  //           stack.pop();\n  //           break;\n  //         }\n  //         case opcodes.OP_2DUP: {\n  //           if (stack.length < 2)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           const v1 = stack.get(-2);\n  //           const v2 = stack.get(-1);\n  //           stack.push(v1);\n  //           stack.push(v2);\n  //           break;\n  //         }\n  //         case opcodes.OP_3DUP: {\n  //           if (stack.length < 3)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           const v1 = stack.get(-3);\n  //           const v2 = stack.get(-2);\n  //           const v3 = stack.get(-1);\n  //           stack.push(v1);\n  //           stack.push(v2);\n  //           stack.push(v3);\n  //           break;\n  //         }\n  //         case opcodes.OP_2OVER: {\n  //           if (stack.length < 4)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           const v1 = stack.get(-4);\n  //           const v2 = stack.get(-3);\n  //           stack.push(v1);\n  //           stack.push(v2);\n  //           break;\n  //         }\n  //         case opcodes.OP_2ROT: {\n  //           if (stack.length < 6)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           const v1 = stack.get(-6);\n  //           const v2 = stack.get(-5);\n  //           stack.erase(-6, -4);\n  //           stack.push(v1);\n  //           stack.push(v2);\n  //           break;\n  //         }\n  //         case opcodes.OP_2SWAP: {\n  //           if (stack.length < 4)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           stack.swap(-4, -2);\n  //           stack.swap(-3, -1);\n  //           break;\n  //         }\n  //         case opcodes.OP_IFDUP: {\n  //           if (stack.length === 0)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           if (stack.getBool(-1)) {\n  //             const val = stack.get(-1);\n  //             stack.push(val);\n  //           }\n  //           break;\n  //         }\n  //         case opcodes.OP_DEPTH: {\n  //           stack.pushInt(stack.length);\n  //           break;\n  //         }\n  //         case opcodes.OP_DROP: {\n  //           if (stack.length === 0)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           stack.pop();\n  //           break;\n  //         }\n  //         case opcodes.OP_DUP: {\n  //           if (stack.length === 0)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           stack.push(stack.get(-1));\n  //           break;\n  //         }\n  //         case opcodes.OP_NIP: {\n  //           if (stack.length < 2)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           stack.remove(-2);\n  //           break;\n  //         }\n  //         case opcodes.OP_OVER: {\n  //           if (stack.length < 2)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           stack.push(stack.get(-2));\n  //           break;\n  //         }\n  //         case opcodes.OP_PICK:\n  //         case opcodes.OP_ROLL: {\n  //           if (stack.length < 2)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           const num = stack.getInt(-1, minimal, 4);\n  //           stack.pop();\n  //           if (num < 0 || num >= stack.length)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           const val = stack.get(-num - 1);\n  //           if (op.value === opcodes.OP_ROLL)\n  //             stack.remove(-num - 1);\n  //           stack.push(val);\n  //           break;\n  //         }\n  //         case opcodes.OP_ROT: {\n  //           if (stack.length < 3)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           stack.swap(-3, -2);\n  //           stack.swap(-2, -1);\n  //           break;\n  //         }\n  //         case opcodes.OP_SWAP: {\n  //           if (stack.length < 2)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           stack.swap(-2, -1);\n  //           break;\n  //         }\n  //         case opcodes.OP_TUCK: {\n  //           if (stack.length < 2)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           stack.insert(-2, stack.get(-1));\n  //           break;\n  //         }\n  //         case opcodes.OP_SIZE: {\n  //           if (stack.length < 1)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           stack.pushInt(stack.get(-1).length);\n  //           break;\n  //         }\n  //         case opcodes.OP_EQUAL:\n  //         case opcodes.OP_EQUALVERIFY: {\n  //           if (stack.length < 2)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           const v1 = stack.get(-2);\n  //           const v2 = stack.get(-1);\n  //           const res = v1.equals(v2);\n  //           stack.pop();\n  //           stack.pop();\n  //           stack.pushBool(res);\n  //           if (op.value === opcodes.OP_EQUALVERIFY) {\n  //             if (!res)\n  //               throw new ScriptError('EQUALVERIFY', op, ip);\n  //             stack.pop();\n  //           }\n  //           break;\n  //         }\n  //         case opcodes.OP_1ADD:\n  //         case opcodes.OP_1SUB:\n  //         case opcodes.OP_NEGATE:\n  //         case opcodes.OP_ABS:\n  //         case opcodes.OP_NOT:\n  //         case opcodes.OP_0NOTEQUAL: {\n  //           if (stack.length < 1)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           let num = stack.getNum(-1, minimal, 4);\n  //           let cmp;\n  //           switch (op.value) {\n  //             case opcodes.OP_1ADD:\n  //               num.iaddn(1);\n  //               break;\n  //             case opcodes.OP_1SUB:\n  //               num.isubn(1);\n  //               break;\n  //             case opcodes.OP_NEGATE:\n  //               num.ineg();\n  //               break;\n  //             case opcodes.OP_ABS:\n  //               num.iabs();\n  //               break;\n  //             case opcodes.OP_NOT:\n  //               cmp = num.isZero();\n  //               num = ScriptNum.fromBool(cmp);\n  //               break;\n  //             case opcodes.OP_0NOTEQUAL:\n  //               cmp = !num.isZero();\n  //               num = ScriptNum.fromBool(cmp);\n  //               break;\n  //             default:\n  //               assert(false, 'Fatal script error.');\n  //               break;\n  //           }\n  //           stack.pop();\n  //           stack.pushNum(num);\n  //           break;\n  //         }\n  //         case opcodes.OP_ADD:\n  //         case opcodes.OP_SUB:\n  //         case opcodes.OP_DIV:\n  //         case opcodes.OP_MOD:\n  //         case opcodes.OP_BOOLAND:\n  //         case opcodes.OP_BOOLOR:\n  //         case opcodes.OP_NUMEQUAL:\n  //         case opcodes.OP_NUMEQUALVERIFY:\n  //         case opcodes.OP_NUMNOTEQUAL:\n  //         case opcodes.OP_LESSTHAN:\n  //         case opcodes.OP_GREATERTHAN:\n  //         case opcodes.OP_LESSTHANOREQUAL:\n  //         case opcodes.OP_GREATERTHANOREQUAL:\n  //         case opcodes.OP_MIN:\n  //         case opcodes.OP_MAX: {\n  //           if (stack.length < 2)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           const n1 = stack.getNum(-2, minimal, 4);\n  //           const n2 = stack.getNum(-1, minimal, 4);\n  //           let num, cmp;\n  //           switch (op.value) {\n  //             case opcodes.OP_ADD:\n  //               num = n1.iadd(n2);\n  //               break;\n  //             case opcodes.OP_SUB:\n  //               num = n1.isub(n2);\n  //               break;\n  //             case opcodes.OP_DIV:\n  //               if (n2.isZero())\n  //                 throw new ScriptError('DIV_BY_ZERO', op, ip);\n  //               num = n1.div(n2);\n  //               break;\n  //             case opcodes.OP_MOD:\n  //               if (n2.isZero())\n  //                 throw new ScriptError('MOD_BY_ZERO', op, ip);\n  //               num = n1.mod(n2);\n  //               break;\n  //             case opcodes.OP_BOOLAND:\n  //               cmp = n1.toBool() && n2.toBool();\n  //               num = ScriptNum.fromBool(cmp);\n  //               break;\n  //             case opcodes.OP_BOOLOR:\n  //               cmp = n1.toBool() || n2.toBool();\n  //               num = ScriptNum.fromBool(cmp);\n  //               break;\n  //             case opcodes.OP_NUMEQUAL:\n  //               cmp = n1.eq(n2);\n  //               num = ScriptNum.fromBool(cmp);\n  //               break;\n  //             case opcodes.OP_NUMEQUALVERIFY:\n  //               cmp = n1.eq(n2);\n  //               num = ScriptNum.fromBool(cmp);\n  //               break;\n  //             case opcodes.OP_NUMNOTEQUAL:\n  //               cmp = !n1.eq(n2);\n  //               num = ScriptNum.fromBool(cmp);\n  //               break;\n  //             case opcodes.OP_LESSTHAN:\n  //               cmp = n1.lt(n2);\n  //               num = ScriptNum.fromBool(cmp);\n  //               break;\n  //             case opcodes.OP_GREATERTHAN:\n  //               cmp = n1.gt(n2);\n  //               num = ScriptNum.fromBool(cmp);\n  //               break;\n  //             case opcodes.OP_LESSTHANOREQUAL:\n  //               cmp = n1.lte(n2);\n  //               num = ScriptNum.fromBool(cmp);\n  //               break;\n  //             case opcodes.OP_GREATERTHANOREQUAL:\n  //               cmp = n1.gte(n2);\n  //               num = ScriptNum.fromBool(cmp);\n  //               break;\n  //             case opcodes.OP_MIN:\n  //               num = ScriptNum.min(n1, n2);\n  //               break;\n  //             case opcodes.OP_MAX:\n  //               num = ScriptNum.max(n1, n2);\n  //               break;\n  //             default:\n  //               assert(false, 'Fatal script error.');\n  //               break;\n  //           }\n  //           stack.pop();\n  //           stack.pop();\n  //           stack.pushNum(num);\n  //           if (op.value === opcodes.OP_NUMEQUALVERIFY) {\n  //             if (!stack.getBool(-1))\n  //               throw new ScriptError('NUMEQUALVERIFY', op, ip);\n  //             stack.pop();\n  //           }\n  //           break;\n  //         }\n  //         case opcodes.OP_WITHIN: {\n  //           if (stack.length < 3)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           const n1 = stack.getNum(-3, minimal, 4);\n  //           const n2 = stack.getNum(-2, minimal, 4);\n  //           const n3 = stack.getNum(-1, minimal, 4);\n  //           const val = n2.lte(n1) && n1.lt(n3);\n  //           stack.pop();\n  //           stack.pop();\n  //           stack.pop();\n  //           stack.pushBool(val);\n  //           break;\n  //         }\n  //         case opcodes.OP_RIPEMD160: {\n  //           if (stack.length === 0)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           stack.push(ripemd160.digest(stack.pop()));\n  //           break;\n  //         }\n  //         case opcodes.OP_SHA1: {\n  //           if (stack.length === 0)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           stack.push(sha1.digest(stack.pop()));\n  //           break;\n  //         }\n  //         case opcodes.OP_SHA256: {\n  //           if (stack.length === 0)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           stack.push(sha256.digest(stack.pop()));\n  //           break;\n  //         }\n  //         case opcodes.OP_HASH160: {\n  //           if (stack.length === 0)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           stack.push(hash160.digest(stack.pop()));\n  //           break;\n  //         }\n  //         case opcodes.OP_HASH256: {\n  //           if (stack.length === 0)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           stack.push(hash256.digest(stack.pop()));\n  //           break;\n  //         }\n  //         case opcodes.OP_CODESEPARATOR: {\n  //           lastSep = ip + 1;\n  //           break;\n  //         }\n  //         case opcodes.OP_CHECKSIG:\n  //         case opcodes.OP_CHECKSIGVERIFY: {\n  //           if (!tx)\n  //             throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n  //           if (stack.length < 2)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           const sig = stack.get(-2);\n  //           const key = stack.get(-1);\n  //           const subscript = this.getSubscript(lastSep);\n  //           if (!(flags & Script.flags.VERIFY_SIGHASH_FORKID)\n  //             || !(sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID))\n  //             subscript.findAndDelete(sig);\n  //           checkTransactionSignature(sig, flags);\n  //           validateKey(key, flags);\n  //           let res = false;\n  //           if (sig.length > 0) {\n  //             const type = sig[sig.length - 1];\n  //             const hash = tx.signatureHash(\n  //               index,\n  //               subscript,\n  //               value,\n  //               type,\n  //               flags\n  //             );\n  //             res = verifySignature(hash, sig.slice(0, -1), key, flags);\n  //             metrics.sigchecks += 1;\n  //             sigchecks = metrics.sigchecks;\n  //           }\n  //           if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {\n  //             if (sig.length !== 0)\n  //               throw new ScriptError('NULLFAIL', op, ip);\n  //           }\n  //           stack.pop();\n  //           stack.pop();\n  //           stack.pushBool(res);\n  //           if (op.value === opcodes.OP_CHECKSIGVERIFY) {\n  //             if (!res)\n  //               throw new ScriptError('CHECKSIGVERIFY', op, ip);\n  //             stack.pop();\n  //           }\n  //           break;\n  //         }\n  //         case opcodes.OP_CHECKDATASIG:\n  //         case opcodes.OP_CHECKDATASIGVERIFY: {\n  //           // (sig message pubkey -- bool)\n  //           if (stack.length < 3)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           const sig = stack.get(-3);\n  //           const msg = stack.get(-2);\n  //           const key = stack.get(-1);\n  //           validateDataSignature(sig, flags);\n  //           validateKey(key, flags);\n  //           let res = false;\n  //           if (sig.length > 0) {\n  //             const hash = sha256.digest(msg);\n  //             res = verifySignature(hash, sig, key, flags);\n  //             metrics.sigchecks += 1;\n  // \t    sigchecks = metrics.sigchecks;\n  //           }\n  //           if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {\n  //             if (sig.length !== 0)\n  //               throw new ScriptError('NULLFAIL', op, ip);\n  //           }\n  //           stack.pop();\n  //           stack.pop();\n  //           stack.pop();\n  //           stack.pushBool(res);\n  //           if (op.value === opcodes.OP_CHECKDATASIGVERIFY) {\n  //             if (!res)\n  //               throw new ScriptError('CHECKDATASIGVERIFY', op, ip);\n  //             stack.pop();\n  //           }\n  //           break;\n  //         }\n  //         case opcodes.OP_CHECKMULTISIG:\n  //         case opcodes.OP_CHECKMULTISIGVERIFY: {\n  //           if (!tx)\n  //             throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n  //           let keyCount = 1;\n  //           let sigCount = 0;\n  //           let keyTop, sigTop;\n  //           if (stack.length < keyCount)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           let nKeysCount = stack.getInt(-keyCount, minimal, 4);\n  //           let okey = nKeysCount + 2;\n  //           let ikey, isig;\n  //           if (nKeysCount < 0 || nKeysCount > consensus.MAX_MULTISIG_PUBKEYS)\n  //             throw new ScriptError('PUBKEY_COUNT', op, ip);\n  //           opCount += nKeysCount;\n  //           if (opCount > consensus.MAX_SCRIPT_OPS)\n  //             throw new ScriptError('OP_COUNT', op, ip);\n  //           keyCount += 1;\n  //           keyTop = keyCount;\n  //           // stack depth of nSigsCount\n  //           sigCount = keyTop + nKeysCount;\n  //           ikey = keyCount;\n  //           keyCount += nKeysCount;\n  //           if (stack.length < sigCount)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           let nSigsCount = stack.getInt(-sigCount, minimal, 4);\n  //           if (nSigsCount < 0 || nSigsCount > nKeysCount)\n  //             throw new ScriptError('SIG_COUNT', op, ip);\n  //           // stack depth of the top signature\n  //           sigTop = sigCount + 1;\n  //           // stack depth of the dummy element\n  //           const dummy = sigTop + nSigsCount;\n  //           if (stack.length < dummy)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           keyCount += 1;\n  //           isig = keyCount;\n  //           keyCount += nSigsCount;\n  //           const subscript = this.getSubscript(lastSep);\n  //           let res = true;\n  //           if ((flags & Script.flags.VERIFY_SCHNORR_MULTISIG)\n  //              && stack.get(-dummy).length !== 0) {\n  //               assert(consensus.MAX_MULTISIG_PUBKEYS < 32)\n  //             if (nKeysCount > 32)\n  //               throw new ScriptError('INVALID_BITFIELD_SIZE', op, ip);\n  //             const bitfield_size = Math.floor((nKeysCount + 7) / 8);\n  //             const abkam = stack.get(-dummy);\n  //             if (abkam.length !== bitfield_size)\n  //               throw new ScriptError('BITFIELD_SIZE', op, ip);\n  //             checkBits = this.bitcalculator(abkam, nKeysCount);\n  //             const mask = (1 << nKeysCount) - 1;\n  //             const numBits = countBits(checkBits);\n  //             if ((checkBits & mask) !== checkBits)\n  //               throw new ScriptError('BIT_RANGE', op, ip);\n  //             if (numBits !== nSigsCount)\n  //               throw new ScriptError('INVALID_BIT_COUNT', op, ip);\n  //             const bKey = keyTop + nKeysCount - 1;\n  //             const bSig = sigTop + nSigsCount - 1;\n  //             let ik3y = 0;\n  //             for (let is1g = 0; is1g < nSigsCount; is1g++, ik3y++) {\n  //               if ((checkBits >> ik3y) === 0) {\n  //                 throw new ScriptError('INVALID_BIT_RANGE', op, ip);\n  //               }\n  //               while (((checkBits >> ik3y) & 0x01) === 0) {\n  //                 ik3y++;\n  //               }\n  //               if (ik3y >= nKeysCount)\n  //                 throw new ScriptError('PUBKEY_COUNT', op, ip);\n  //               const sig = stack.get(-bSig + is1g);\n  //               const key = stack.get(-bKey + ik3y);\n  //               // Handle checkbits left over\n  //               if (!sig)\n  //                 continue;\n  //               checkTransactionSchnorrSig(sig, flags);\n  //               validateKey(key, flags);\n  //               if (sig.length > 0) {\n  //                 const type = sig[sig.length - 1];\n  //                 const hash = tx.signatureHash(\n  //                   index,\n  //                   subscript,\n  //                   value,\n  //                   type,\n  //                   flags\n  //                 );\n  //                 res = verifySignature(hash, sig.slice(0, -1), key, flags);\n  //                 metrics.sigchecks += 1;\n  // \t\t            sigchecks = metrics.sigchecks;\n  //               }\n  //               while (keyCount > 1) {\n  //                 if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {\n  //                   if (okey === 0 && stack.get(-1).length !== 0)\n  //                     throw new ScriptError('NULLFAIL', op, ip);\n  //                 }\n  //                 if (okey > 0)\n  //                   okey -= 1;\n  //                 stack.pop();\n  //                 keyCount -= 1;\n  //               }\n  //             }\n  //             if ((checkBits >> ik3y) !== 0)\n  //               throw new ScriptError('INVALID_BIT_COUNT', op, ip);\n  //             stack.pop();\n  //             stack.pushBool(res);\n  //           } else {\n  //             // Legacy Multisig (ECDSA / NULL)\n  //             // A bug causes CHECKMULTISIG to consume one extra\n  //             // argument whose contents were not checked in any way.\n  //           for (let j = 0; j < nSigsCount; j++) {\n  //             const sig = stack.get(-sigTop - j);\n  //             if (!(flags & Script.flags.VERIFY_SIGHASH_FORKID)\n  //               || !(sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID))\n  //               subscript.findAndDelete(sig, flags);\n  //           }\n  //           nSigsRemaining = nSigsCount;\n  //           nKeysRemaining = nKeysCount;\n  //           while (res && nSigsCount > 0) {\n  //             const sig = stack.get(-isig);\n  //             const key = stack.get(-ikey);\n  //             checkTransactionECDSASignature(sig, flags);\n  //             validateKey(key, flags);\n  //             if (sig.length > 0) {\n  //               const type = sig[sig.length - 1];\n  //               const hash = tx.signatureHash(\n  //                 index,\n  //                 subscript,\n  //                 value,\n  //                 type,\n  //                 flags\n  //               );\n  //               if (checksig(hash, sig, key)) {\n  //                 isig += 1;\n  //                 nSigsCount -= 1;\n  //               }\n  //             }\n  //             ikey += 1;\n  //             nKeysCount -= 1;\n  //             if (nSigsCount > nKeysCount)\n  //               res = false;\n  //           }\n  //           while (keyCount > 1) {\n  //             if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {\n  //               if (okey === 0 && stack.get(-1).length !== 0)\n  //                 throw new ScriptError('NULLFAIL', op, ip);\n  //             }\n  //             if (okey > 0)\n  //               okey -= 1;\n  //             stack.pop();\n  //             keyCount -= 1;\n  //           }\n  //           if (stack.length < 1)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           stack.pop();\n  //           stack.pushBool(res);\n  //           if (op.value === opcodes.OP_CHECKMULTISIGVERIFY) {\n  //             if (!res)\n  //               throw new ScriptError('CHECKMULTISIGVERIFY', op, ip);\n  //             stack.pop();\n  //            }\n  //           }\n  //           break;\n  //         }\n  //         //\n  //         // Byte string operations\n  //         //\n  //         case opcodes.OP_CAT: {\n  //           // (x1 x2 -- out)\n  //           if (stack.length < 2)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           const v1 = stack.get(-2);\n  //           const v2 = stack.get(-1);\n  //           if (v1.length + v2.length > consensus.MAX_SCRIPT_PUSH) {\n  //             throw new ScriptError('PUSH_SIZE', op, ip);\n  //           }\n  //           stack.pop();\n  //           stack.pop();\n  //           stack.push(Buffer.concat([v1, v2]));\n  //           break;\n  //         }\n  //         case opcodes.OP_SPLIT: {\n  //           // (in position -- x1 x2)\n  //           if (stack.length < 2)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           const data = stack.get(-2);\n  //           // Make sure the split point is appropriate.\n  //           const pos = stack.getInt(-1, minimal, 4);\n  //           if (pos < 0 || pos > data.length)\n  //             throw new ScriptError('INVALID_SPLIT_RANGE', op, ip);\n  //           // Prepare the results in their own buffer as `data`\n  //           // will be invalidated.\n  //           const n1 = data.slice(0, pos);\n  //           const n2 = data.slice(pos);\n  //           // Replace existing stack values by the new values.\n  //           stack.set(-2, n1);\n  //           stack.set(-1, n2);\n  //           break;\n  //         }\n  //         case opcodes.OP_REVERSEBYTES: {\n  //          if (stack.length < 1)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           const data = stack.get(-1);\n  //           data.reverse();\n  //           break;\n  //         }\n  //         //\n  //         // Bitwise logic\n  //         //\n  //         case opcodes.OP_AND:\n  //         case opcodes.OP_OR:\n  //         case opcodes.OP_XOR: {\n  //           // (x1 x2 - out)\n  //           if (stack.length < 2)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           const v1 = stack.get(-2);\n  //           const v2 = stack.get(-1);\n  //           // Inputs must be the same size\n  //           if (v1.length !== v2.length)\n  //             throw new ScriptError('INVALID_OPERAND_SIZE', op, ip);\n  //           const raw = Buffer.alloc(v1.length);\n  //           switch (op.value) {\n  //             case opcodes.OP_AND:\n  //               for (let i = 0; i < v1.length; i++) {\n  //                 raw[i] = v1[i] & v2[i];\n  //               }\n  //               break;\n  //             case opcodes.OP_OR:\n  //               for (let i = 0; i < v1.length; i++) {\n  //                 raw[i] = v1[i] | v2[i];\n  //               }\n  //               break;\n  //             case opcodes.OP_XOR:\n  //               for (let i = 0; i < v1.length; i++) {\n  //                 raw[i] = v1[i] ^ v2[i];\n  //               }\n  //               break;\n  //             default:\n  //               break;\n  //           }\n  //           // And pop v1 and v2.\n  //           stack.pop();\n  //           stack.pop();\n  //           stack.push(raw);\n  //           break;\n  //         }\n  //         //\n  //         // Conversion operations\n  //         //\n  //         case opcodes.OP_NUM2BIN: {\n  //           // (in size -- out)\n  //           if (stack.length < 2)\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           const size = stack.getInt(-1, minimal, 4);\n  //           if (size < 0 || size > consensus.MAX_SCRIPT_PUSH)\n  //             throw new ScriptError('PUSH_SIZE', op, ip);\n  //           stack.pop();\n  //           const n = stack.get(-1);\n  //           const v = ScriptNum.toMinimal(Buffer.from(n));\n  //           // Try to see if we can fit that number in the number of\n  //           // byte requested.\n  //           if (v.length > size)\n  //             // We definitively cannot.\n  //             throw new ScriptError('IMPOSSIBLE_ENCODING', op, ip);\n  //           // We already have an element of the right size, we don't need to do\n  //           // anything.\n  //           if (v.length === size) {\n  //             stack.pop();\n  //             stack.push(v);\n  //             break;\n  //           }\n  //           const raw = Buffer.alloc(size);\n  //           v.copy(raw);\n  //           let signbit = 0x00;\n  //           if (v.length > 0) {\n  //             signbit = v[v.length - 1] & 0x80;\n  //             raw[v.length - 1] &= 0x7f;\n  //           }\n  //           raw[size-1] = signbit;\n  //           stack.pop();\n  //           stack.push(raw);\n  //           break;\n  //         }\n  //         case opcodes.OP_BIN2NUM: {\n  //           // (in -- out)\n  //           if (stack.length < 1) {\n  //             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n  //           }\n  //           const n = stack.get(-1);\n  //           const v = ScriptNum.toMinimal(Buffer.from(n));\n  //           stack.pop();\n  //           stack.push(v);\n  //           // The resulting number must be a valid number.\n  //           if (!ScriptNum.isMinimal(v) || v.length > 4)\n  //             throw new ScriptError('INVALID_NUMBER_RANGE', op, ip);\n  //           break;\n  //         }\n  //         default: {\n  //           throw new ScriptError('BAD_OPCODE', op, ip);\n  //         }\n  //       }\n  //     }\n  //     if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK)\n  //       throw new ScriptError('STACK_SIZE');\n  //     if (state.length !== 0)\n  //       throw new ScriptError('UNBALANCED_CONDITIONAL');\n  //   }\n  //   /**\n  //    * Remove all matched data elements from\n  //    * a script's code (used to remove signatures\n  //    * before verification). Note that this\n  //    * compares and removes data on the _byte level_.\n  //    * It also reserializes the data to a single\n  //    * script with minimaldata encoding beforehand.\n  //    * A signature will _not_ be removed if it is\n  //    * not minimaldata.\n  //    * @see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-November/006878.html\n  //    * @see https://test.webbtc.com/tx/19aa42fee0fa57c45d3b16488198b27caaacc4ff5794510d0c17f173f05587ff\n  //    * @param {Buffer} data - Data element to match against.\n  //    * @returns {Number} Total.\n  //    */\n  //   findAndDelete(data) {\n  //     const target = Opcode.fromPush(data);\n  //     if (this.raw.length < target.getSize())\n  //       return 0;\n  //     let found = false;\n  //     for (const op of this.code) {\n  //       if (op.value === -1)\n  //         break;\n  //       if (op.equals(target)) {\n  //         found = true;\n  //         break;\n  //       }\n  //     }\n  //     if (!found)\n  //       return 0;\n  //     const code = [];\n  //     let total = 0;\n  //     for (const op of this.code) {\n  //       if (op.value === -1)\n  //         break;\n  //       if (op.equals(target)) {\n  //         total += 1;\n  //         continue;\n  //       }\n  //       code.push(op);\n  //     }\n  //     this.code = code;\n  //     this.compile();\n  //     return total;\n  //   }\n  //   /**\n  //    * Find a data element in a script.\n  //    * @param {Buffer} data - Data element to match against.\n  //    * @returns {Number} Index (`-1` if not present).\n  //    */\n  //   indexOf(data) {\n  //     for (let i = 0; i < this.code.length; i++) {\n  //       const op = this.code[i];\n  //       if (op.value === -1)\n  //         break;\n  //       if (!op.data)\n  //         continue;\n  //       if (op.data.equals(data))\n  //         return i;\n  //     }\n  //     return -1;\n  //   }\n  //   /**\n  //    * Test a script to see if it is likely\n  //    * to be script code (no weird opcodes).\n  //    * @param {Number?} flags - Script standard flags.\n  //    * @returns {Boolean}\n  //    */\n  //   isCode(flags) {\n  //     if (flags == null)\n  //       flags = Script.flags.STANDARD_VERIFY_FLAGS;\n  //     for (const op of this.code) {\n  //       if (op.value === -1)\n  //         return false;\n  //       if (op.isDisabled(flags))\n  //         return false;\n  //       switch (op.value) {\n  //         case opcodes.OP_RESERVED:\n  //         case opcodes.OP_NOP:\n  //         case opcodes.OP_VER:\n  //         case opcodes.OP_VERIF:\n  //         case opcodes.OP_VERNOTIF:\n  //         case opcodes.OP_RESERVED1:\n  //         case opcodes.OP_RESERVED2:\n  //         case opcodes.OP_NOP1:\n  //           return false;\n  //       }\n  //       if (op.value > opcodes.OP_CHECKSEQUENCEVERIFY)\n  //         return false;\n  //     }\n  //     return true;\n  //   }\n  //   /**\n  //    * Inject properties from a pay-to-pubkey script.\n  //    * @private\n  //    * @param {Buffer} key\n  //    */\n  //   fromPubkey(key) {\n  //     assert(Buffer.isBuffer(key) && (key.length === 33 || key.length === 65));\n  //     this.raw = Buffer.allocUnsafe(1 + key.length + 1);\n  //     this.raw[0] = key.length;\n  //     key.copy(this.raw, 1);\n  //     this.raw[1 + key.length] = opcodes.OP_CHECKSIG;\n  //     key = this.raw.slice(1, 1 + key.length);\n  //     this.code.length = 0;\n  //     this.code.push(Opcode.fromPush(key));\n  //     this.code.push(Opcode.fromOp(opcodes.OP_CHECKSIG));\n  //     return this;\n  //   }\n  //   /**\n  //    * Create a pay-to-pubkey script.\n  //    * @param {Buffer} key\n  //    * @returns {Script}\n  //    */\n  //   static fromPubkey(key) {\n  //     return new this().fromPubkey(key);\n  //   }\n  //   /**\n  //    * Inject properties from a pay-to-pubkeyhash script.\n  //    * @private\n  //    * @param {Buffer} hash\n  //    */\n  //   fromPubkeyhash(hash) {\n  //     assert(Buffer.isBuffer(hash) && hash.length === 20);\n  //     this.raw = Buffer.allocUnsafe(25);\n  //     this.raw[0] = opcodes.OP_DUP;\n  //     this.raw[1] = opcodes.OP_HASH160;\n  //     this.raw[2] = 0x14;\n  //     hash.copy(this.raw, 3);\n  //     this.raw[23] = opcodes.OP_EQUALVERIFY;\n  //     this.raw[24] = opcodes.OP_CHECKSIG;\n  //     hash = this.raw.slice(3, 23);\n  //     this.code.length = 0;\n  //     this.code.push(Opcode.fromOp(opcodes.OP_DUP));\n  //     this.code.push(Opcode.fromOp(opcodes.OP_HASH160));\n  //     this.code.push(Opcode.fromPush(hash));\n  //     this.code.push(Opcode.fromOp(opcodes.OP_EQUALVERIFY));\n  //     this.code.push(Opcode.fromOp(opcodes.OP_CHECKSIG));\n  //     return this;\n  //   }\n  //   /**\n  //    * Create a pay-to-pubkeyhash script.\n  //    * @param {Buffer} hash\n  //    * @returns {Script}\n  //    */\n  //   static fromPubkeyhash(hash) {\n  //     return new this().fromPubkeyhash(hash);\n  //   }\n  //   /**\n  //    * Inject properties from pay-to-multisig script.\n  //    * @private\n  //    * @param {Number} m\n  //    * @param {Number} n\n  //    * @param {Buffer[]} keys\n  //    */\n  //   fromMultisig(m, n, keys) {\n  //     assert((m & 0xff) === m && (n & 0xff) === n);\n  //     assert(Array.isArray(keys));\n  //     assert(keys.length === n, '`n` keys are required for multisig.');\n  //     assert(m >= 1 && m <= n);\n  //     assert(n >= 1 && n <= 15);\n  //     this.clear();\n  //     this.pushSmall(m);\n  //     for (const key of sortKeys(keys))\n  //       this.pushData(key);\n  //     this.pushSmall(n);\n  //     this.pushOp(opcodes.OP_CHECKMULTISIG);\n  //     return this.compile();\n  //   }\n  //   /**\n  //    * Create a pay-to-multisig script.\n  //    * @param {Number} m\n  //    * @param {Number} n\n  //    * @param {Buffer[]} keys\n  //    * @returns {Script}\n  //    */\n  //   static fromMultisig(m, n, keys) {\n  //     return new this().fromMultisig(m, n, keys);\n  //   }\n  //   /**\n  //    * Inject properties from a pay-to-scripthash script.\n  //    * @private\n  //    * @param {Buffer} hash\n  //    */\n  //   fromScripthash(hash) {\n  //     assert(Buffer.isBuffer(hash) && hash.length === 20);\n  //     this.raw = Buffer.allocUnsafe(23);\n  //     this.raw[0] = opcodes.OP_HASH160;\n  //     this.raw[1] = 0x14;\n  //     hash.copy(this.raw, 2);\n  //     this.raw[22] = opcodes.OP_EQUAL;\n  //     hash = this.raw.slice(2, 22);\n  //     this.code.length = 0;\n  //     this.code.push(Opcode.fromOp(opcodes.OP_HASH160));\n  //     this.code.push(Opcode.fromPush(hash));\n  //     this.code.push(Opcode.fromOp(opcodes.OP_EQUAL));\n  //     return this;\n  //   }\n  //   /**\n  //    * Create a pay-to-scripthash script.\n  //    * @param {Buffer} hash\n  //    * @returns {Script}\n  //    */\n  //   static fromScripthash(hash) {\n  //     return new this().fromScripthash(hash);\n  //   }\n  //   /**\n  //    * Inject properties from a nulldata/opreturn script.\n  //    * @private\n  //    * @param {Buffer} flags\n  //    */\n  //   fromNulldata(flags) {\n  //     assert(Buffer.isBuffer(flags));\n  //     assert(flags.length <= policy.MAX_OP_RETURN, 'Nulldata too large.');\n  //     this.clear();\n  //     this.pushOp(opcodes.OP_RETURN);\n  //     this.pushData(flags);\n  //     return this.compile();\n  //   }\n  //   /**\n  //    * Create a nulldata/opreturn script.\n  //    * @param {Buffer} flags\n  //    * @returns {Script}\n  //    */\n  //   static fromNulldata(flags) {\n  //     return new this().fromNulldata(flags);\n  //   }\n\n  /**\n   * Inject properties from an address.\n   * @private\n   * @param {Address|AddressString} address\n   */\n\n\n  fromAddress(address) {\n    if (typeof address === 'string') address = Address.fromString(address);\n    assert(address instanceof Address, 'Not an address.');\n    if (address.isPubkeyhash()) return this.fromPubkeyhash(address.hash);\n    if (address.isScripthash()) return this.fromScripthash(address.hash);\n    throw new Error('Unknown address type.');\n  }\n  /**\n   * Create an output script from an address.\n   * @param {Address|AddressString} address\n   * @returns {Script}\n   */\n\n\n  static fromAddress(address) {\n    return new this().fromAddress(address);\n  } //   /**\n  //    * Grab and deserialize the redeem script.\n  //    * @returns {Script|null} Redeem script.\n  //    */\n  //   getRedeem() {\n  //     let data = null;\n  //     for (const op of this.code) {\n  //       if (op.value === -1)\n  //         return null;\n  //       if (op.value > opcodes.OP_16)\n  //         return null;\n  //       data = op.data;\n  //     }\n  //     if (!data)\n  //       return null;\n  //     return Script.fromRaw(data);\n  //   }\n  //   /**\n  //    * Get the standard script type.\n  //    * @returns {ScriptType}\n  //    */\n  //   getType() {\n  //     if (this.isPubkey())\n  //       return scriptTypes.PUBKEY;\n  //     if (this.isPubkeyhash())\n  //       return scriptTypes.PUBKEYHASH;\n  //     if (this.isScripthash())\n  //       return scriptTypes.SCRIPTHASH;\n  //     if (this.isMultisig())\n  //       return scriptTypes.MULTISIG;\n  //     if (this.isNulldata())\n  //       return scriptTypes.NULLDATA;\n  //     return scriptTypes.NONSTANDARD;\n  //   }\n  //   /**\n  //    * Test whether a script is of an unknown/non-standard type.\n  //    * @returns {Boolean}\n  //    */\n  //   isUnknown() {\n  //     return this.getType() === scriptTypes.NONSTANDARD;\n  //   }\n  //   /**\n  //    * Test whether the script is standard by policy standards.\n  //    * @returns {Boolean}\n  //    */\n  //   isStandard() {\n  //     const [m, n] = this.getMultisig();\n  //     if (m !== -1) {\n  //       if (n < 1 || n > 3)\n  //         return false;\n  //       if (m < 1 || m > n)\n  //         return false;\n  //       return true;\n  //     }\n  //     if (this.isNulldata())\n  //       return this.raw.length <= policy.MAX_OP_RETURN_BYTES;\n  //     return this.getType() !== scriptTypes.NONSTANDARD;\n  //   }\n  //   /**\n  //    * Calculate the size of the script\n  //    * excluding the varint size bytes.\n  //    * @returns {Number}\n  //    */\n  //   getSize() {\n  //     return this.raw.length;\n  //   }\n  //   /**\n  //    * Calculate the size of the script\n  //    * including the varint size bytes.\n  //    * @returns {Number}\n  //    */\n  //   getVarSize() {\n  //     return encoding.sizeVarBytes(this.raw);\n  //   }\n  //   /**\n  //    * \"Guess\" the address of the input script.\n  //    * This method is not 100% reliable.\n  //    * @returns {Address|null}\n  //    */\n  //   getInputAddress() {\n  //     return Address.fromInputScript(this);\n  //   }\n  //   /**\n  //    * Get the address of the script if present. Note that\n  //    * pubkey and multisig scripts will be treated as though\n  //    * they are pubkeyhash and scripthashes respectively.\n  //    * @returns {Address|null}\n  //    */\n  //   getAddress() {\n  //     return Address.fromScript(this);\n  //   }\n  //   /**\n  //    * Get the hash160 of the raw script.\n  //    * @param {String?} enc\n  //    * @returns {Hash}\n  //    */\n  //   hash160(enc) {\n  //     let hash = hash160.digest(this.toRaw());\n  //     if (enc === 'hex')\n  //       hash = hash.toString('hex');\n  //     return hash;\n  //   }\n  //   /**\n  //    * Get the sha256 of the raw script.\n  //    * @param {String?} enc\n  //    * @returns {Hash}\n  //    */\n  //   sha256(enc) {\n  //     let hash = sha256.digest(this.toRaw());\n  //     if (enc === 'hex')\n  //       hash = hash.toString('hex');\n  //     return hash;\n  //   }\n  //   /**\n  //    * Test whether the output script is pay-to-pubkey.\n  //    * @param {Boolean} [minimal=false] - Minimaldata only.\n  //    * @returns {Boolean}\n  //    */\n  //   isPubkey(minimal) {\n  //     if (minimal) {\n  //       return this.raw.length >= 35\n  //         && (this.raw[0] === 33 || this.raw[0] === 65)\n  //         && this.raw[0] + 2 === this.raw.length\n  //         && this.raw[this.raw.length - 1] === opcodes.OP_CHECKSIG;\n  //     }\n  //     if (this.code.length !== 2)\n  //       return false;\n  //     const size = this.getLength(0);\n  //     return (size === 33 || size === 65)\n  //       && this.getOp(1) === opcodes.OP_CHECKSIG;\n  //   }\n  //   /**\n  //    * Get P2PK key if present.\n  //    * @param {Boolean} [minimal=false] - Minimaldata only.\n  //    * @returns {Buffer|null}\n  //    */\n  //   getPubkey(minimal) {\n  //     if (!this.isPubkey(minimal))\n  //       return null;\n  //     if (minimal)\n  //       return this.raw.slice(1, 1 + this.raw[0]);\n  //     return this.getData(0);\n  //   }\n  //   /**\n  //    * Test whether the output script is pay-to-pubkeyhash.\n  //    * @param {Boolean} [minimal=false] - Minimaldata only.\n  //    * @returns {Boolean}\n  //    */\n  //   isPubkeyhash(minimal) {\n  //     if (minimal || this.raw.length === 25) {\n  //       return this.raw.length === 25\n  //         && this.raw[0] === opcodes.OP_DUP\n  //         && this.raw[1] === opcodes.OP_HASH160\n  //         && this.raw[2] === 0x14\n  //         && this.raw[23] === opcodes.OP_EQUALVERIFY\n  //         && this.raw[24] === opcodes.OP_CHECKSIG;\n  //     }\n  //     if (this.code.length !== 5)\n  //       return false;\n  //     return this.getOp(0) === opcodes.OP_DUP\n  //       && this.getOp(1) === opcodes.OP_HASH160\n  //       && this.getLength(2) === 20\n  //       && this.getOp(3) === opcodes.OP_EQUALVERIFY\n  //       && this.getOp(4) === opcodes.OP_CHECKSIG;\n  //   }\n  //   /**\n  //    * Get P2PKH hash if present.\n  //    * @param {Boolean} [minimal=false] - Minimaldata only.\n  //    * @returns {Buffer|null}\n  //    */\n  //   getPubkeyhash(minimal) {\n  //     if (!this.isPubkeyhash(minimal))\n  //       return null;\n  //     if (minimal)\n  //       return this.raw.slice(3, 23);\n  //     return this.getData(2);\n  //   }\n  // /**\n  //    * Test whether the output script is pay-to-multisig.\n  //    * @param {Boolean} [minimal=true] - Minimaldata only.\n  //    * @returns {Boolean}\n  //    */\n  //   isMultisig(minimal) {\n  //     if (this.code.length < 4 || this.code.length > 19)\n  //       return false;\n  //     if (this.getOp(-1) !== opcodes.OP_CHECKMULTISIG)\n  //       return false;\n  //     const m = this.getSmall(0);\n  //     if (m < 1)\n  //       return false;\n  //     const n = this.getSmall(-2);\n  //     if (n < 1 || m > n)\n  //       return false;\n  //     if (this.code.length !== n + 3)\n  //       return false;\n  //     for (let i = 1; i < n + 1; i++) {\n  //       const op = this.code[i];\n  //       const size = op.toLength();\n  //       if (size !== 33 && size !== 65)\n  //         return false;\n  //       if (minimal && !op.isMinimal())\n  //         return false;\n  //     }\n  //     return true;\n  //   }\n  //   /**\n  //    * Get multisig m and n values if present.\n  //    * @param {Boolean} [minimal=false] - Minimaldata only.\n  //    * @returns {Array} [m, n]\n  //    */\n  //   getMultisig(minimal) {\n  //     if (!this.isMultisig(minimal))\n  //       return [-1, -1];\n  //     return [this.getSmall(0), this.getSmall(-2)];\n  //   }\n  //   /**\n  //    * Test whether the output script is pay-to-scripthash. Note that\n  //    * bitcoin itself requires scripthashes to be in strict minimaldata\n  //    * encoding. Using `OP_HASH160 OP_PUSHDATA1 [hash] OP_EQUAL` will\n  //    * _not_ be recognized as a scripthash.\n  //    * @returns {Boolean}\n  //    */\n  //   isScripthash() {\n  //     return this.raw.length === 23\n  //       && this.raw[0] === opcodes.OP_HASH160\n  //       && this.raw[1] === 0x14\n  //       && this.raw[22] === opcodes.OP_EQUAL;\n  //   }\n  //   /**\n  //    * Get P2SH hash if present.\n  //    * @returns {Buffer|null}\n  //    */\n  //   getScripthash() {\n  //     if (!this.isScripthash())\n  //       return null;\n  //     return this.getData(1);\n  //   }\n  //   /**\n  //    * Test whether the output script is nulldata/opreturn.\n  //    * @param {Boolean} [minimal=false] - Minimaldata only.\n  //    * @returns {Boolean}\n  //    */\n  //   isNulldata(minimal) {\n  //     if (this.code.length === 0)\n  //       return false;\n  //     if (this.getOp(0) !== opcodes.OP_RETURN)\n  //       return false;\n  //     if (this.code.length === 1)\n  //       return true;\n  //     if (minimal) {\n  //       if (this.raw.length > policy.MAX_OP_RETURN_BYTES)\n  //         return false;\n  //     }\n  //     for (let i = 1; i < this.code.length; i++) {\n  //       const op = this.code[i];\n  //       if (op.value === -1)\n  //         return false;\n  //       if (op.value > opcodes.OP_16)\n  //         return false;\n  //       if (minimal && !op.isMinimal())\n  //         return false;\n  //     }\n  //     return true;\n  //   }\n  //   /**\n  //    * Get OP_RETURN data if present.\n  //    * @param {Boolean} [minimal=false] - Minimaldata only.\n  //    * @returns {Buffer|null}\n  //    */\n  //   getNulldata(minimal) {\n  //     if (!this.isNulldata(minimal))\n  //       return null;\n  //     for (let i = 1; i < this.code.length; i++) {\n  //       const op = this.code[i];\n  //       const data = op.toPush();\n  //       if (data)\n  //         return data;\n  //     }\n  //     return EMPTY_BUFFER;\n  //   }\n  //   /**\n  //    * Test whether the output script is a witness program.\n  //    * Note that this will return true even for malformed\n  //    * witness v0 programs.\n  //    * @returns {Boolean}\n  //    */\n  //   isProgram() {\n  //     if (this.raw.length < 4 || this.raw.length > 42)\n  //       return false;\n  //     if (this.raw[0] !== opcodes.OP_0\n  //       && (this.raw[0] < opcodes.OP_1 || this.raw[0] > opcodes.OP_16)) {\n  //       return false;\n  //     }\n  //     if (this.raw[1] + 2 !== this.raw.length)\n  //       return false;\n  //     return true;\n  //   }\n  //   /**\n  //    * Test whether the output script is unspendable.\n  //    * @returns {Boolean}\n  //    */\n  //   isUnspendable() {\n  //     if (this.raw.length > consensus.MAX_SCRIPT_SIZE)\n  //       return true;\n  //     return this.raw.length > 0 && this.raw[0] === opcodes.OP_RETURN;\n  //   }\n  //   /**\n  //    * \"Guess\" the type of the input script.\n  //    * This method is not 100% reliable.\n  //    * @returns {ScriptType}\n  //    */\n  //   getInputType() {\n  //     if (this.isPubkeyInput())\n  //       return scriptTypes.PUBKEY;\n  //     if (this.isPubkeyhashInput())\n  //       return scriptTypes.PUBKEYHASH;\n  //     if (this.isScripthashInput())\n  //       return scriptTypes.SCRIPTHASH;\n  //     if (this.isMultisigInput())\n  //       return scriptTypes.MULTISIG;\n  //     return scriptTypes.NONSTANDARD;\n  //   }\n  //   /**\n  //    * \"Guess\" whether the input script is an unknown/non-standard type.\n  //    * This method is not 100% reliable.\n  //    * @returns {Boolean}\n  //    */\n  //   isUnknownInput() {\n  //     return this.getInputType() === scriptTypes.NONSTANDARD;\n  //   }\n  //   /**\n  //    * \"Guess\" whether the input script is pay-to-pubkey.\n  //    * This method is not 100% reliable.\n  //    * @returns {Boolean}\n  //    */\n  //   isPubkeyInput() {\n  //     if (this.code.length !== 1)\n  //       return false;\n  //     const size = this.getLength(0);\n  //     return size >= 9 && size <= 73;\n  //   }\n  //   /**\n  //    * Get P2PK signature if present.\n  //    * @returns {Buffer|null}\n  //    */\n  //   getPubkeyInput() {\n  //     if (!this.isPubkeyInput())\n  //       return null;\n  //     return this.getData(0);\n  //   }\n  //   /**\n  //    * \"Guess\" whether the input script is pay-to-pubkeyhash.\n  //    * This method is not 100% reliable.\n  //    * @returns {Boolean}\n  //    */\n  //   isPubkeyhashInput() {\n  //     if (this.code.length !== 2)\n  //       return false;\n  //     const sig = this.getLength(0);\n  //     const key = this.getLength(1);\n  //     return sig >= 9 && sig <= 73\n  //       && (key === 33 || key === 65);\n  //   }\n  //   /**\n  //    * Get P2PKH signature and key if present.\n  //    * @returns {Array} [sig, key]\n  //    */\n  //   getPubkeyhashInput() {\n  //     if (!this.isPubkeyhashInput())\n  //       return [null, null];\n  //     return [this.getData(0), this.getData(1)];\n  //   }\n  //   /**\n  //    * \"Guess\" whether the input script is pay-to-multisig.\n  //    * This method is not 100% reliable.\n  //    * @returns {Boolean}\n  //    */\n  //   isMultisigInput() {\n  //     if (this.code.length < 2)\n  //       return false;\n  //     if (this.getOp(0) !== opcodes.OP_0)\n  //       return false;\n  //     if (this.getOp(1) > opcodes.OP_PUSHDATA4)\n  //       return false;\n  //     // We need to rule out scripthash\n  //     // because it may look like multisig.\n  //     if (this.isScripthashInput())\n  //       return false;\n  //     for (let i = 1; i < this.code.length; i++) {\n  //       const size = this.getLength(i);\n  //       if (size < 9 || size > 73)\n  //         return false;\n  //     }\n  //     return true;\n  //   }\n  //   /**\n  //    * Get multisig signatures if present.\n  //    * @returns {Buffer[]|null}\n  //    */\n  //   getMultisigInput() {\n  //     if (!this.isMultisigInput())\n  //       return null;\n  //     const sigs = [];\n  //     for (let i = 1; i < this.code.length; i++)\n  //       sigs.push(this.getData(i));\n  //     return sigs;\n  //   }\n  //   /**\n  //    * \"Guess\" whether the input script is pay-to-scripthash.\n  //    * This method is not 100% reliable.\n  //    * @returns {Boolean}\n  //    */\n  //   isScripthashInput() {\n  //     if (this.code.length < 1)\n  //       return false;\n  //     // Grab the raw redeem script.\n  //     const raw = this.getData(-1);\n  //     // Last data element should be an array\n  //     // for the redeem script.\n  //     if (!raw)\n  //       return false;\n  //     // Testing for scripthash inputs requires\n  //     // some evil magic to work. We do it by\n  //     // ruling things _out_. This test will not\n  //     // be correct 100% of the time. We rule\n  //     // out that the last data element is: a\n  //     // null dummy, a valid signature, a valid\n  //     // key, and we ensure that it is at least\n  //     // a script that does not use undefined\n  //     // opcodes.\n  //     if (raw.length === 0)\n  //       return false;\n  //     if (common.isDERSignatureEncoding(raw.slice(0, -1)))\n  //       return false;\n  //     if (common.isKeyEncoding(raw))\n  //       return false;\n  //     const redeem = Script.fromRaw(raw);\n  //     if (!redeem.isCode())\n  //       return false;\n  //     if (redeem.isUnspendable())\n  //       return false;\n  //     if (!this.isPushOnly())\n  //       return false;\n  //     return true;\n  //   }\n  //   /**\n  //    * Get P2SH redeem script if present.\n  //    * @returns {Buffer|null}\n  //    */\n  //   getScripthashInput() {\n  //     if (!this.isScripthashInput())\n  //       return null;\n  //     return this.getData(-1);\n  //   }\n  //   /**\n  //    * Get coinbase height.\n  //    * @returns {Number} `-1` if not present.\n  //    */\n  //   getCoinbaseHeight() {\n  //     return Script.getCoinbaseHeight(this.raw);\n  //   }\n  //   /**\n  //    * Get coinbase height.\n  //    * @param {Buffer} raw - Raw script.\n  //    * @returns {Number} `-1` if not present.\n  //    */\n  //   static getCoinbaseHeight(raw) {\n  //     if (raw.length === 0)\n  //       return -1;\n  //     if (raw[0] >= opcodes.OP_1 && raw[0] <= opcodes.OP_16)\n  //       return raw[0] - 0x50;\n  //     if (raw[0] > 0x06)\n  //       return -1;\n  //     const op = Opcode.fromRaw(raw);\n  //     const num = op.toNum();\n  //     if (!num)\n  //       return 1;\n  //     if (num.isNeg())\n  //       return -1;\n  //     if (!op.equals(Opcode.fromNum(num)))\n  //       return -1;\n  //     return num.toDouble();\n  //   }\n  //   /**\n  //    * Test the script against a bloom filter.\n  //    * @param {Bloom} filter\n  //    * @returns {Boolean}\n  //    */\n  //   test(filter) {\n  //     for (const op of this.code) {\n  //       if (op.value === -1)\n  //         break;\n  //       if (!op.data || op.data.length === 0)\n  //         continue;\n  //       if (filter.test(op.data))\n  //         return true;\n  //     }\n  //     return false;\n  //   }\n  //   /**\n  //    * Test the script to see if it contains only push ops.\n  //    * Push ops are: OP_1NEGATE, OP_0-OP_16 and all PUSHDATAs.\n  //    * @returns {Boolean}\n  //    */\n  //   isPushOnly() {\n  //     for (const op of this.code) {\n  //       if (op.value === -1)\n  //         return false;\n  //       if (op.value > opcodes.OP_16)\n  //         return false;\n  //     }\n  //     return true;\n  //   }\n  //   /**\n  //    * Count the sigops in the script.\n  //    * @param {Boolean} accurate - Whether to enable accurate counting. This will\n  //    * take into account the `n` value for OP_CHECKMULTISIG(VERIFY).\n  //    * @returns {Number} sigop count\n  //    */\n  //   getSigops(accurate, flags) {\n  //     if (flags & Script.flags.VERIFY_ZERO_SIGOPS)\n  //       return 0;\n  //     let total = 0;\n  //     let lastOp = -1;\n  //     for (const op of this.code) {\n  //       if (op.value === -1)\n  //         break;\n  //       switch (op.value) {\n  //         case opcodes.OP_CHECKSIG:\n  //         case opcodes.OP_CHECKSIGVERIFY:\n  //           total += 1;\n  //           break;\n  //         case opcodes.OP_CHECKSDATAIG:\n  //         case opcodes.OP_CHECKDATASIGVERIFY:\n  //           if (flags & Script.flags.VERIFY_CHECKDATASIG) {\n  //             total += 1;\n  //           }\n  //           break;\n  //         case opcodes.OP_CHECKMULTISIG:\n  //         case opcodes.OP_CHECKMULTISIGVERIFY:\n  //           if (accurate && lastOp >= opcodes.OP_1 && lastOp <= opcodes.OP_16)\n  //             total += lastOp - 0x50;\n  //           else\n  //             total += consensus.MAX_MULTISIG_PUBKEYS;\n  //           break;\n  //       }\n  //       lastOp = op.value;\n  //     }\n  //     return total;\n  //   }\n  //   /**\n  //    * Count the sigops in the script, taking into account redeem scripts.\n  //    * @param {Script} input - Input script, needed for access to redeem script.\n  //    * @param {VerifyFlags} flags\n  //    * @returns {Number} sigop count\n  //    */\n  //   getScripthashSigops(input, flags) {\n  //     if (!this.isScripthash())\n  //       return this.getSigops(true, flags);\n  //     const redeem = input.getRedeem();\n  //     if (!redeem)\n  //       return 0;\n  //     return redeem.getSigops(true, flags);\n  //   }\n  //   /*\n  //    * Mutation\n  //    */\n  //   get(index) {\n  //     if (index < 0)\n  //       index += this.code.length;\n  //     if (index < 0 || index >= this.code.length)\n  //       return null;\n  //     return this.code[index];\n  //   }\n  //   pop() {\n  //     const op = this.code.pop();\n  //     return op || null;\n  //   }\n  //   shift() {\n  //     const op = this.code.shift();\n  //     return op || null;\n  //   }\n  //   remove(index) {\n  //     if (index < 0)\n  //       index += this.code.length;\n  //     if (index < 0 || index >= this.code.length)\n  //       return null;\n  //     const items = this.code.splice(index, 1);\n  //     if (items.length === 0)\n  //       return null;\n  //     return items[0];\n  //   }\n  //   set(index, op) {\n  //     if (index < 0)\n  //       index += this.code.length;\n  //     assert(Opcode.isOpcode(op));\n  //     assert(index >= 0 && index <= this.code.length);\n  //     this.code[index] = op;\n  //     return this;\n  //   }\n  //   push(op) {\n  //     assert(Opcode.isOpcode(op));\n  //     this.code.push(op);\n  //     return this;\n  //   }\n  //   unshift(op) {\n  //     assert(Opcode.isOpcode(op));\n  //     this.code.unshift(op);\n  //     return this;\n  //   }\n  //   insert(index, op) {\n  //     if (index < 0)\n  //       index += this.code.length;\n  //     assert(Opcode.isOpcode(op));\n  //     assert(index >= 0 && index <= this.code.length);\n  //     this.code.splice(index, 0, op);\n  //     return this;\n  //   }\n  //   /*\n  //    * Op\n  //    */\n  //   getOp(index) {\n  //     const op = this.get(index);\n  //     return op ? op.value : -1;\n  //   }\n  //   popOp() {\n  //     const op = this.pop();\n  //     return op ? op.value : -1;\n  //   }\n  //   shiftOp() {\n  //     const op = this.shift();\n  //     return op ? op.value : -1;\n  //   }\n  //   removeOp(index) {\n  //     const op = this.remove(index);\n  //     return op ? op.value : -1;\n  //   }\n  //   setOp(index, value) {\n  //     return this.set(index, Opcode.fromOp(value));\n  //   }\n  //   pushOp(value) {\n  //     return this.push(Opcode.fromOp(value));\n  //   }\n  //   unshiftOp(value) {\n  //     return this.unshift(Opcode.fromOp(value));\n  //   }\n  //   insertOp(index, value) {\n  //     return this.insert(index, Opcode.fromOp(value));\n  //   }\n  //   /*\n  //    * Data\n  //    */\n  //   getData(index) {\n  //     const op = this.get(index);\n  //     return op ? op.data : null;\n  //   }\n  //   popData() {\n  //     const op = this.pop();\n  //     return op ? op.data : null;\n  //   }\n  //   shiftData() {\n  //     const op = this.shift();\n  //     return op ? op.data : null;\n  //   }\n  //   removeData(index) {\n  //     const op = this.remove(index);\n  //     return op ? op.data : null;\n  //   }\n  //   setData(index, data) {\n  //     return this.set(index, Opcode.fromData(data));\n  //   }\n  //   pushData(data) {\n  //     return this.push(Opcode.fromData(data));\n  //   }\n  //   unshiftData(data) {\n  //     return this.unshift(Opcode.fromData(data));\n  //   }\n  //   insertData(index, data) {\n  //     return this.insert(index, Opcode.fromData(data));\n  //   }\n  //   /*\n  //    * Length\n  //    */\n  //   getLength(index) {\n  //     const op = this.get(index);\n  //     return op ? op.toLength() : -1;\n  //   }\n  //   /*\n  //    * Push\n  //    */\n  //   getPush(index) {\n  //     const op = this.get(index);\n  //     return op ? op.toPush() : null;\n  //   }\n  //   popPush() {\n  //     const op = this.pop();\n  //     return op ? op.toPush() : null;\n  //   }\n  //   shiftPush() {\n  //     const op = this.shift();\n  //     return op ? op.toPush() : null;\n  //   }\n  //   removePush(index) {\n  //     const op = this.remove(index);\n  //     return op ? op.toPush() : null;\n  //   }\n  //   setPush(index, data) {\n  //     return this.set(index, Opcode.fromPush(data));\n  //   }\n  //   pushPush(data) {\n  //     return this.push(Opcode.fromPush(data));\n  //   }\n  //   unshiftPush(data) {\n  //     return this.unshift(Opcode.fromPush(data));\n  //   }\n  //   insertPush(index, data) {\n  //     return this.insert(index, Opcode.fromPush(data));\n  //   }\n  //   /*\n  //    * String\n  //    */\n  //   getString(index, enc) {\n  //     const op = this.get(index);\n  //     return op ? op.toString(enc) : null;\n  //   }\n  //   popString(enc) {\n  //     const op = this.pop();\n  //     return op ? op.toString(enc) : null;\n  //   }\n  //   shiftString(enc) {\n  //     const op = this.shift();\n  //     return op ? op.toString(enc) : null;\n  //   }\n  //   removeString(index, enc) {\n  //     const op = this.remove(index);\n  //     return op ? op.toString(enc) : null;\n  //   }\n  //   setString(index, str, enc) {\n  //     return this.set(index, Opcode.fromString(str, enc));\n  //   }\n  //   pushString(str, enc) {\n  //     return this.push(Opcode.fromString(str, enc));\n  //   }\n  //   unshiftString(str, enc) {\n  //     return this.unshift(Opcode.fromString(str, enc));\n  //   }\n  //   insertString(index, str, enc) {\n  //     return this.insert(index, Opcode.fromString(str, enc));\n  //   }\n  //   /*\n  //    * Small\n  //    */\n  //   getSmall(index) {\n  //     const op = this.get(index);\n  //     return op ? op.toSmall() : -1;\n  //   }\n  //   popSmall() {\n  //     const op = this.pop();\n  //     return op ? op.toSmall() : -1;\n  //   }\n  //   shiftSmall() {\n  //     const op = this.shift();\n  //     return op ? op.toSmall() : -1;\n  //   }\n  //   removeSmall(index) {\n  //     const op = this.remove(index);\n  //     return op ? op.toSmall() : -1;\n  //   }\n  //   setSmall(index, num) {\n  //     return this.set(index, Opcode.fromSmall(num));\n  //   }\n  //   pushSmall(num) {\n  //     return this.push(Opcode.fromSmall(num));\n  //   }\n  //   unshiftSmall(num) {\n  //     return this.unshift(Opcode.fromSmall(num));\n  //   }\n  //   insertSmall(index, num) {\n  //     return this.insert(index, Opcode.fromSmall(num));\n  //   }\n  //   /*\n  //    * Num\n  //    */\n  //   getNum(index, minimal, limit) {\n  //     const op = this.get(index);\n  //     return op ? op.toNum(minimal, limit) : null;\n  //   }\n  //   popNum(minimal, limit) {\n  //     const op = this.pop();\n  //     return op ? op.toNum(minimal, limit) : null;\n  //   }\n  //   shiftNum(minimal, limit) {\n  //     const op = this.shift();\n  //     return op ? op.toNum(minimal, limit) : null;\n  //   }\n  //   removeNum(index, minimal, limit) {\n  //     const op = this.remove(index);\n  //     return op ? op.toNum(minimal, limit) : null;\n  //   }\n  //   setNum(index, num) {\n  //     return this.set(index, Opcode.fromNum(num));\n  //   }\n  //   pushNum(num) {\n  //     return this.push(Opcode.fromNum(num));\n  //   }\n  //   unshiftNum(num) {\n  //     return this.unshift(Opcode.fromNum(num));\n  //   }\n  //   insertNum(index, num) {\n  //     return this.insert(index, Opcode.fromNum(num));\n  //   }\n  //   /*\n  //    * Int\n  //    */\n  //   getInt(index, minimal, limit) {\n  //     const op = this.get(index);\n  //     return op ? op.toInt(minimal, limit) : -1;\n  //   }\n  //   popInt(minimal, limit) {\n  //     const op = this.pop();\n  //     return op ? op.toInt(minimal, limit) : -1;\n  //   }\n  //   shiftInt(minimal, limit) {\n  //     const op = this.shift();\n  //     return op ? op.toInt(minimal, limit) : -1;\n  //   }\n  //   removeInt(index, minimal, limit) {\n  //     const op = this.remove(index);\n  //     return op ? op.toInt(minimal, limit) : -1;\n  //   }\n  //   setInt(index, num) {\n  //     return this.set(index, Opcode.fromInt(num));\n  //   }\n  //   pushInt(num) {\n  //     return this.push(Opcode.fromInt(num));\n  //   }\n  //   unshiftInt(num) {\n  //     return this.unshift(Opcode.fromInt(num));\n  //   }\n  //   insertInt(index, num) {\n  //     return this.insert(index, Opcode.fromInt(num));\n  //   }\n  //   /*\n  //    * Bool\n  //    */\n  //   getBool(index) {\n  //     const op = this.get(index);\n  //     return op ? op.toBool() : false;\n  //   }\n  //   popBool() {\n  //     const op = this.pop();\n  //     return op ? op.toBool() : false;\n  //   }\n  //   shiftBool() {\n  //     const op = this.shift();\n  //     return op ? op.toBool() : false;\n  //   }\n  //   removeBool(index) {\n  //     const op = this.remove(index);\n  //     return op ? op.toBool() : false;\n  //   }\n  //   setBool(index, value) {\n  //     return this.set(index, Opcode.fromBool(value));\n  //   }\n  //   pushBool(value) {\n  //     return this.push(Opcode.fromBool(value));\n  //   }\n  //   unshiftBool(value) {\n  //     return this.unshift(Opcode.fromBool(value));\n  //   }\n  //   insertBool(index, value) {\n  //     return this.insert(index, Opcode.fromBool(value));\n  //   }\n  //   /*\n  //    * Symbol\n  //    */\n  //   getSym(index) {\n  //     const op = this.get(index);\n  //     return op ? op.toSymbol() : null;\n  //   }\n  //   popSym() {\n  //     const op = this.pop();\n  //     return op ? op.toSymbol() : null;\n  //   }\n  //   shiftSym() {\n  //     const op = this.shift();\n  //     return op ? op.toSymbol() : null;\n  //   }\n  //   removeSym(index) {\n  //     const op = this.remove(index);\n  //     return op ? op.toSymbol() : null;\n  //   }\n  //   setSym(index, symbol) {\n  //     return this.set(index, Opcode.fromSymbol(symbol));\n  //   }\n  //   pushSym(symbol) {\n  //     return this.push(Opcode.fromSymbol(symbol));\n  //   }\n  //   unshiftSym(symbol) {\n  //     return this.unshift(Opcode.fromSymbol(symbol));\n  //   }\n  //   insertSym(index, symbol) {\n  //     return this.insert(index, Opcode.fromSymbol(symbol));\n  //   }\n  //   /**\n  //    * Inject properties from bitcoind test string.\n  //    * @private\n  //    * @param {String} items - Script string.\n  //    * @throws Parse error.\n  //    */\n  //   fromString(code) {\n  //     assert(typeof code === 'string');\n  //     code = code.trim();\n  //     if (code.length === 0)\n  //       return this;\n  //     const items = code.split(/\\s+/);\n  //     const bw = bio.write();\n  //     for (const item of items) {\n  //       let symbol = item;\n  //       if (symbol.charCodeAt(0) & 32)\n  //         symbol = symbol.toUpperCase();\n  //       if (!/^OP_/.test(symbol))\n  //         symbol = `OP_${symbol}`;\n  //       const value = opcodes[symbol];\n  //       if (value == null) {\n  //         if (item[0] === '\\'') {\n  //           assert(item[item.length - 1] === '\\'', 'Invalid string.');\n  //           const str = item.slice(1, -1);\n  //           const op = Opcode.fromString(str);\n  //           bw.writeBytes(op.toRaw());\n  //           continue;\n  //         }\n  //         if (/^-?\\d+$/.test(item)) {\n  //           const num = ScriptNum.fromString(item, 10);\n  //           const op = Opcode.fromNum(num);\n  //           bw.writeBytes(op.toRaw());\n  //           continue;\n  //         }\n  //         assert(item.indexOf('0x') === 0, 'Unknown opcode.');\n  //         const hex = item.substring(2);\n  //         const data = Buffer.from(hex, 'hex');\n  //         assert(data.length === hex.length / 2, 'Invalid hex string.');\n  //         bw.writeBytes(data);\n  //         continue;\n  //       }\n  //       bw.writeU8(value);\n  //     }\n  //     return this.fromRaw(bw.render());\n  //   }\n  //   /**\n  //    * Parse a bitcoind test script\n  //    * string into a script object.\n  //    * @param {String} items - Script string.\n  //    * @returns {Script}\n  //    * @throws Parse error.\n  //    */\n  //   static fromString(code) {\n  //     return new this().fromString(code);\n  //   }\n  //   /**\n  //    * Verify an input and output script, and a witness if present.\n  //    * @param {Script} input\n  //    * @param {Null} witness\n  //    * @param {Script} output\n  //    * @param {TX} tx\n  //    * @param {Number} index\n  //    * @param {Amount} value\n  //    * @param {VerifyFlags} flags\n  //    * @param {Number?} sigchecks\n  //    * @throws {ScriptError}\n  //    */\n  //   static verify(input, witness, output, tx, index, value, flags, sigchecks) {\n  //     if (flags == null)\n  //       flags = Script.flags.STANDARD_VERIFY_FLAGS;\n  //     if (flags & Script.flags.VERIFY_SIGPUSHONLY) {\n  //       if (!input.isPushOnly())\n  //         throw new ScriptError('SIG_PUSHONLY');\n  //     }\n  //     if (flags & Script.flags.VERIFY_SIGHASH_FORKID)\n  //       flags |= Script.flags.VERIFY_STRICTENC;\n  //     // Setup a stack.\n  //     let stack = new Stack();\n  //     // Execute the input script\n  //     input.execute(stack, flags, tx, index, value, metrics.sigchecks);\n  //     // Copy the stack for P2SH\n  //     let copy;\n  //     if (flags & Script.flags.VERIFY_P2SH)\n  //       copy = stack.clone();\n  //     // Execute the previous output script.\n  //     output.execute(stack, flags, tx, index, value, metrics.sigchecks);\n  //     // Verify the stack values.\n  //     if (stack.length === 0 || !stack.getBool(-1))\n  //       throw new ScriptError('EVAL_FALSE');\n  //     // If the script is P2SH, execute the real output script\n  //     if ((flags & Script.flags.VERIFY_P2SH) && output.isScripthash()) {\n  //       // P2SH can only have push ops in the scriptSig\n  //       if (!input.isPushOnly())\n  //         throw new ScriptError('SIG_PUSHONLY');\n  //       // Reset the stack\n  //       stack = copy;\n  //       // Stack should not be empty at this point\n  //       if (stack.length === 0)\n  //         throw new ScriptError('EVAL_FALSE');\n  //       // Grab the real redeem script\n  //       const raw = stack.pop();\n  //       const redeem = Script.fromRaw(raw);\n  //       if ((flags & Script.flags.VERIFY_DISALLOW_SEGWIT_RECOVERY) === 0\n  //          && stack.length === 0 && redeem.isProgram()) {\n  //         // Before activation all transaction count a value of 0\n  //         if (!(flags & Script.flags.REPORT_SIGCHECKS)) {\n  //           metrics.sigchecks = 0;\n  //         }\n  //         return;\n  //       }\n  //         // Execute the redeem script.\n  //       redeem.execute(stack, flags, tx, index, value, 0, metrics.sigchecks);\n  //       // Verify the the stack values.\n  //       if (stack.length === 0 || !stack.getBool(-1))\n  //         throw new ScriptError('EVAL_FALSE');\n  //     }\n  //     // Ensure there is nothing left on the stack.\n  //     if (flags & Script.flags.VERIFY_CLEANSTACK) {\n  //       assert((flags & Script.flags.VERIFY_P2SH) !== 0);\n  //       if (stack.length !== 1)\n  //         throw new ScriptError('CLEANSTACK');\n  //     }\n  //     if (flags & Script.flags.VERIFY_INPUT_SIGCHECKS) {\n  //       if (input.getSize() < metrics.sigchecks * 43 - 60)\n  //         throw new ScriptError('INPUT_SIGCHECKS');\n  //     }\n  //     if (!(flags & Script.flags.REPORT_SIGCHECKS)) {\n  //       metrics.sigchecks = 0;\n  //     }\n  //   }\n  //   /**\n  //    * Inject properties from buffer reader.\n  //    * @private\n  //    * @param {BufferReader} br\n  //    */\n  //   fromReader(br) {\n  //     return this.fromRaw(br.readVarBytes());\n  //   }\n\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer}\n   */\n\n\n  fromRaw(data) {\n    const br = bio.read(data);\n    this.raw = data;\n\n    while (br.left()) this.code.push(Opcode.fromReader(br));\n\n    return this;\n  } //   /**\n  //    * Create a script from buffer reader.\n  //    * @param {BufferReader} br\n  //    * @param {String?} enc - Either `\"hex\"` or `null`.\n  //    * @returns {Script}\n  //    */\n  //   static fromReader(br) {\n  //     return new this().fromReader(br);\n  //   }\n  //   /**\n  //    * Create a script from a serialized buffer.\n  //    * @param {Buffer|String} data - Serialized script.\n  //    * @param {String?} enc - Either `\"hex\"` or `null`.\n  //    * @returns {Script}\n  //    */\n\n\n  static fromRaw(data, enc) {\n    if (typeof data === 'string') data = Buffer.from(data, enc);\n    return new this().fromRaw(data);\n  } //   /**\n  //    * Test whether an object a Script.\n  //    * @param {Object} obj\n  //    * @returns {Boolean}\n  //    */\n  //   static isScript(obj) {\n  //     return obj instanceof Script;\n  //   }\n\n\n} // /**\n//  * Script opcodes.\n//  * @enum {Number}\n//  * @default\n//  */\n// Script.opcodes = common.opcodes;\n// /**\n//  * Opcodes by value.\n//  * @const {RevMap}\n//  */\n// Script.opcodesByVal = common.opcodesByVal;\n// /**\n//  * Script and locktime flags. See {@link VerifyFlags}.\n//  * @enum {Number}\n//  */\n// Script.flags = common.flags;\n// /**\n//  * Sighash Types.\n//  * @enum {SighashType}\n//  * @default\n//  */\n// Script.hashType = common.hashType;\n// /**\n//  * Sighash types by value.\n//  * @const {RevMap}\n//  */\n// Script.hashTypeByVal = common.hashTypeByVal;\n// /**\n//  * Output script types.\n//  * @enum {Number}\n//  */\n// Script.types = common.types;\n// /**\n//  * Output script types by value.\n//  * @const {RevMap}\n//  */\n// Script.typesByVal = common.typesByVal;\n// /*\n//  * Helpers\n//  */\n// function sortKeys(keys) {\n//   return keys.slice().sort((a, b) => {\n//     return a.compare(b);\n//   });\n// }\n// /**\n//  * Test whether the data element is a valid key if VERIFY_STRICTENC is enabled.\n//  * @param {Buffer} key\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n// function validateKey(key, flags) {\n//   assert(Buffer.isBuffer(key));\n//   assert(typeof flags === 'number');\n//   if (flags & Script.flags.VERIFY_STRICTENC) {\n//     if (!common.isKeyEncoding(key))\n//       throw new ScriptError('PUBKEYTYPE');\n//   }\n//   if ((flags & Script.flags.VERIFY_COMPRESSED_PUBKEYTYPE)\n//     && !common.isCompressedEncoding(key)) {\n//     throw new ScriptError('NONCOMPRESSED_PUBKEY');\n//   };\n//   return true;\n// }\n// /**\n//  * Test whether the raw element is a valid signature based\n//  * on the encoding, S value, and sighash type.\n//  * In an ECDSA-only context, 64-byte signatures are bannned\n//  * when Schnorr Flag is set.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n// function validateECDSASignature(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n//   if (common.isSchnorr(sig))\n//     throw new ScriptError('SIG_BADLENGTH');\n//   if ((flags & Script.flags.VERIFY_DERSIG)\n//       || (flags & Script.flags.VERIFY_LOW_S)\n//       || (flags & Script.flags.VERIFY_STRICTENC)) {\n//     if (!common.isDERSignatureEncoding(sig))\n//       throw new ScriptError('SIG_DER');\n//   }\n//   if (flags & Script.flags.VERIFY_LOW_S) {\n//     if (!common.isLowDER(sig))\n//       throw new ScriptError('SIG_HIGH_S');\n//   }\n//   return true;\n// }\n// /**\n//  * Test whether the tx element is a valid signature based\n//  * on the encoding, S value, and sighash type. Requires\n//  * VERIFY_STRICTENC, VERIFY_SIGHASH_FORKID to be enabled respectively.\n//  * Note that this will allow zero-length signatures.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n// function checkSighashEncoding(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n//   if (flags & Script.flags.VERIFY_STRICTENC) {\n//     if (!common.isHashType(sig))\n//       throw new ScriptError('SIG_HASHTYPE');\n//     const usesFork = sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID;\n//     const forkEnabled = flags & Script.flags.VERIFY_SIGHASH_FORKID;\n//     if (!forkEnabled && usesFork)\n//       throw new ScriptError('ILLEGAL_FORKID');\n//     if (forkEnabled && !usesFork)\n//       throw new ScriptError('MUST_USE_FORKID');\n//   }\n//   return true;\n// }\n// /**\n//  * Test whether the transaction tested against\n//  * the Sighash Encoding is a valid Schnorr Signature.\n//  * Requires Sighash\n//  * @param {Buffer} sig\n//  * @param {VeirfyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n// function checkTransactionSignature(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n//   // allow empty sigs\n//   if (sig.length === 0)\n//     return true;\n//   validateSchnorrSignature(sig.slice(0, -1), flags);\n//   return checkSighashEncoding(sig, flags);\n// }\n// /**\n//  * Test whether the transaction is tested\n//  * against the sighash encoding w schnorr / ecdsa\n//  * for multisig opcodes.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  */\n// function checkTransactionSchnorrSig(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n//   // Allow empty sigs.\n//   if (sig.length === 0)\n//     return true;\n//   if (!isSchnorrEncoded(sig.slice(0, -1), flags))\n//     return validateECDSASignature(sig.slice(0, -1), flags);\n//   return checkSighashEncoding(sig, flags);\n// }\n// /**\n//  * Test whether the transaction tested against\n//  * the Sighash Encoding is a valid ECDSA Signature.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n// function checkTransactionECDSASignature(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n//   // Allow empty sigs\n//   if (sig.length === 0)\n//     return true;\n//   validateECDSASignature(sig.slice(0, -1), flags);\n//   return checkSighashEncoding(sig, flags);\n// }\n// /**\n//  * Test whether the data element is a valid signature based\n//  * on the encoding, S value, and sighash type. Requires\n//  * VERIFY_DERSIG|VERIFY_LOW_S|VERIFY_STRICTENC, and VERIFY_LOW_S\n//  * to be enabled respectively. Note that this will allow zero-length\n//  * signatures.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n// function validateDataSignature(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n//   // Allow empty sigs\n//   if (sig.length === 0)\n//     return true;\n//   return validateSchnorrSignature(sig.slice(0, sig.length), flags);\n// }\n// /**\n//  * Test whether the Signature is valid in context\n//  * 64-byte signatures are interpreted as schnorr signatures.\n//  * Always correctly encoded when Verify_SCHNORR flag is set.\n//  * @param {Buffer} sig\n//  * @param {Buffer} msg - Signature hash.\n//  * @param {VerifyFlags?} flags\n//  * @returns {Promise}\n//  * @throws {ScriptError}\n//  */\n// function validateSchnorrSignature(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n//   if (common.isSchnorr(sig))\n//     return true;\n//   return validateECDSASignature(sig, flags);\n// }\n// /**\n//  * Test whether the current signature is schnorr encoded.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n// function isSchnorrEncoded(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n//   if (common.isSchnorr(sig))\n//     return true;\n//   throw new ScriptError('SIG_NONSCHNORR');\n// }\n// /**\n//  * Test whether the signature from the stack\n//  * is valid in either Schnorr or DER Format.\n//  * Always encoded correctly when Schnorr flag is set.\n//  * @param {Buffer} hash\n//  * @param {Buffer} sig\n//  * @param {Buffer} key\n//  * @param {Number} flags\n//  */\n// function verifySignature(hash, sig, key, flags) {\n//   assert(Buffer.isBuffer(hash));\n//   assert(Buffer.isBuffer(sig));\n//   assert(Buffer.isBuffer(key));\n//   assert(typeof flags === 'number');\n//   let res = false;\n//   if (sig.length === 64) {\n//     res = secp256k1.schnorrVerify(hash, sig, key, flags);\n//   } else {\n//     res = secp256k1.verifyDER(hash, sig, key, flags);\n//   }\n//   return res;\n// }\n// /**\n//  * Verify a signature, taking into account sighash type.\n//  * @param {Buffer} msg - Signature hash.\n//  * @param {Buffer} sig\n//  * @param {Buffer} key\n//  * @returns {Boolean}\n//  */\n// function checksig(msg, sig, key) {\n//   return secp256k1.verifyDER(msg, sig.slice(0, -1), key);\n// }\n\n/*\n * Expose\n */\n\n\nmodule.exports = Script;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/script/script.js"],"names":["assert","require","bio","ripemd160","sha1","sha256","hash160","hash256","secp256k1","consensus","policy","Opcode","Stack","ScriptError","ScriptNum","common","Address","Metrics","opcodes","scriptTypes","types","countBits","encoding","EMPTY_BUFFER","Buffer","alloc","metrics","Script","constructor","options","raw","code","fromOptions","fromJSON","json","fromRaw","from","fromAddress","address","fromString","isPubkeyhash","fromPubkeyhash","hash","isScripthash","fromScripthash","Error","data","br","read","left","push","fromReader","enc","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,OAAD,CAAtB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAME,SAAS,GAAGF,OAAO,CAAC,uBAAD,CAAzB;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,kBAAD,CAApB;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,oBAAD,CAAtB;;AACA,MAAMK,OAAO,GAAGL,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMM,OAAO,GAAGN,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMO,SAAS,GAAGP,OAAO,CAAC,uBAAD,CAAzB;;AACA,MAAMQ,SAAS,GAAGR,OAAO,CAAC,uBAAD,CAAzB;;AACA,MAAMS,MAAM,GAAGT,OAAO,CAAC,oBAAD,CAAtB;;AACA,MAAMU,MAAM,GAAGV,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMW,KAAK,GAAGX,OAAO,CAAC,SAAD,CAArB;;AACA,MAAMY,WAAW,GAAGZ,OAAO,CAAC,eAAD,CAA3B;;AACA,MAAMa,SAAS,GAAGb,OAAO,CAAC,aAAD,CAAzB;;AACA,MAAMc,MAAM,GAAGd,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMe,OAAO,GAAGf,OAAO,CAAC,uBAAD,CAAvB;;AACA,MAAMgB,OAAO,GAAGhB,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAMiB,OAAO,GAAGH,MAAM,CAACG,OAAvB;AACA,MAAMC,WAAW,GAAGJ,MAAM,CAACK,KAA3B;AACA,MAAMC,SAAS,GAAGN,MAAM,CAACM,SAAzB;AACA,MAAM;AAACC,EAAAA;AAAD,IAAapB,GAAnB;AAGA;AACA;AACA;;AAEA,MAAMqB,YAAY,GAAGC,MAAM,CAACC,KAAP,CAAa,CAAb,CAArB;AACA,MAAMC,OAAO,GAAG,IAAIT,OAAJ,EAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMU,MAAN,CAAa;AACX;AACF;AACA;AACA;AACA;AAEEC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB,SAAKC,GAAL,GAAWP,YAAX;AACA,SAAKQ,IAAL,GAAY,EAAZ;AAEA,QAAIF,OAAJ,EACE,KAAKG,WAAL,CAAiBH,OAAjB;AACH,GAbU,CAeb;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAEEI,EAAAA,QAAQ,CAACC,IAAD,EAAO;AACblC,IAAAA,MAAM,CAAC,OAAOkC,IAAP,KAAgB,QAAjB,EAA2B,wBAA3B,CAAN;AACA,WAAO,KAAKC,OAAL,CAAaX,MAAM,CAACY,IAAP,CAAYF,IAAZ,EAAkB,KAAlB,CAAb,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEiB,SAARD,QAAQ,CAACC,IAAD,EAAO;AACpB,WAAO,IAAI,IAAJ,GAAWD,QAAX,CAAoBC,IAApB,CAAP;AACD,GAvYU,CAyYb;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;;;AAEEG,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB,QAAI,OAAOA,OAAP,KAAmB,QAAvB,EACEA,OAAO,GAAGtB,OAAO,CAACuB,UAAR,CAAmBD,OAAnB,CAAV;AAEFtC,IAAAA,MAAM,CAACsC,OAAO,YAAYtB,OAApB,EAA6B,iBAA7B,CAAN;AAEA,QAAIsB,OAAO,CAACE,YAAR,EAAJ,EACE,OAAO,KAAKC,cAAL,CAAoBH,OAAO,CAACI,IAA5B,CAAP;AAEF,QAAIJ,OAAO,CAACK,YAAR,EAAJ,EACE,OAAO,KAAKC,cAAL,CAAoBN,OAAO,CAACI,IAA5B,CAAP;AAEF,UAAM,IAAIG,KAAJ,CAAU,uBAAV,CAAN;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEoB,SAAXR,WAAW,CAACC,OAAD,EAAU;AAC1B,WAAO,IAAI,IAAJ,GAAWD,WAAX,CAAuBC,OAAvB,CAAP;AACD,GA33DU,CA63Db;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;;;AAEEH,EAAAA,OAAO,CAACW,IAAD,EAAO;AACZ,UAAMC,EAAE,GAAG7C,GAAG,CAAC8C,IAAJ,CAASF,IAAT,CAAX;AAEA,SAAKhB,GAAL,GAAWgB,IAAX;;AAEA,WAAOC,EAAE,CAACE,IAAH,EAAP,EACE,KAAKlB,IAAL,CAAUmB,IAAV,CAAevC,MAAM,CAACwC,UAAP,CAAkBJ,EAAlB,CAAf;;AAEF,WAAO,IAAP;AACD,GAhuGU,CAkuGb;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAEgB,SAAPZ,OAAO,CAACW,IAAD,EAAOM,GAAP,EAAY;AACxB,QAAI,OAAON,IAAP,KAAgB,QAApB,EACEA,IAAI,GAAGtB,MAAM,CAACY,IAAP,CAAYU,IAAZ,EAAkBM,GAAlB,CAAP;AACF,WAAO,IAAI,IAAJ,GAAWjB,OAAX,CAAmBW,IAAnB,CAAP;AACD,GAxvGU,CA0vGb;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAlwGa,C,CAqwGb;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAEAO,MAAM,CAACC,OAAP,GAAiB3B,MAAjB","sourcesContent":["/*!\n * script.js - script interpreter for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bio = require('bufio');\nconst ripemd160 = require('bcrypto/lib/ripemd160');\nconst sha1 = require('bcrypto/lib/sha1');\nconst sha256 = require('bcrypto/lib/sha256');\nconst hash160 = require('bcrypto/lib/hash160');\nconst hash256 = require('bcrypto/lib/hash256');\nconst secp256k1 = require('bcrypto/lib/secp256k1');\nconst consensus = require('../protocol/consensus');\nconst policy = require('../protocol/policy');\nconst Opcode = require('./opcode');\nconst Stack = require('./stack');\nconst ScriptError = require('./scripterror');\nconst ScriptNum = require('./scriptnum');\nconst common = require('./common');\nconst Address = require('../primitives/address');\nconst Metrics = require('./metrics');\nconst opcodes = common.opcodes;\nconst scriptTypes = common.types;\nconst countBits = common.countBits;\nconst {encoding} = bio;\n\n\n/*\n * Constants\n */\n\nconst EMPTY_BUFFER = Buffer.alloc(0);\nconst metrics = new Metrics();\n\n/**\n * Script\n * Represents a input or output script.\n * @alias module:script.Script\n * @property {Array} code - Parsed script code.\n * @property {Buffer?} raw - Serialized script.\n * @property {Number} length - Number of parsed opcodes.\n */\n\nclass Script {\n  /**\n   * Create a script.\n   * @constructor\n   * @param {Buffer|Array|Object} code\n   */\n\n  constructor(options) {\n    this.raw = EMPTY_BUFFER;\n    this.code = [];\n\n    if (options)\n      this.fromOptions(options);\n  }\n\n//   /**\n//    * Get length.\n//    * @returns {Number}\n//    */\n\n//   get length() {\n//     return this.code.length;\n//   }\n\n//   /**\n//    * Set length.\n//    * @param {Number} value\n//    */\n\n//   set length(value) {\n//     this.code.length = value;\n//   }\n\n//   /**\n//    * Inject properties from options object.\n//    * @private\n//    * @param {Object} options\n//    */\n\n//   fromOptions(options) {\n//     assert(options, 'Script data is required.');\n\n//     if (Buffer.isBuffer(options))\n//       return this.fromRaw(options);\n\n//     if (Array.isArray(options))\n//       return this.fromArray(options);\n\n//     if (options.raw) {\n//       if (!options.code)\n//         return this.fromRaw(options.raw);\n//       assert(Buffer.isBuffer(options.raw), 'Raw must be a Buffer.');\n//       this.raw = options.raw;\n//     }\n\n//     if (options.code) {\n//       if (!options.raw)\n//         return this.fromArray(options.code);\n//       assert(Array.isArray(options.code), 'Code must be an array.');\n//       this.code = options.code;\n//     }\n\n//     return this;\n//   }\n\n//   /**\n//    * Insantiate script from options object.\n//    * @param {Object} options\n//    * @returns {Script}\n//    */\n\n//   static fromOptions(options) {\n//     return new this().fromOptions(options);\n//   }\n\n//   /**\n//    * Instantiate a value-only iterator.\n//    * @returns {ScriptIterator}\n//    */\n\n//   values() {\n//     return this.code.values();\n//   }\n\n//   /**\n//    * Instantiate a key and value iterator.\n//    * @returns {ScriptIterator}\n//    */\n\n//   entries() {\n//     return this.code.entries();\n//   }\n\n//   /**\n//    * Instantiate a value-only iterator.\n//    * @returns {ScriptIterator}\n//    */\n\n//   [Symbol.iterator]() {\n//     return this.code[Symbol.iterator]();\n//   }\n\n//   /**\n//    * Convert the script to an array of\n//    * Buffers (pushdatas) and Numbers\n//    * (opcodes).\n//    * @returns {Array}\n//    */\n\n//   toArray() {\n//     return this.code.slice();\n//   }\n\n//   /**\n//    * Inject properties from an array of\n//    * of buffers and numbers.\n//    * @private\n//    * @param {Array} code\n//    * @returns {Script}\n//    */\n\n//   fromArray(code) {\n//     assert(Array.isArray(code));\n\n//     this.clear();\n\n//     for (const op of code)\n//       this.push(op);\n\n//     return this.compile();\n//   }\n\n//   /**\n//    * Instantiate script from an array\n//    * of buffers and numbers.\n//    * @param {Array} code\n//    * @returns {Script}\n//    */\n\n//   static fromArray(code) {\n//     return new this().fromArray(code);\n//   }\n\n//   /**\n//    * Convert script to stack items.\n//    * @returns {Buffer[]}\n//    */\n\n//   toItems() {\n//     const items = [];\n\n//     for (const op of this.code) {\n//       const data = op.toPush();\n\n//       if (!data)\n//         throw new Error('Non-push opcode in script.');\n\n//       items.push(data);\n//     }\n\n//     return items;\n//   }\n\n//   /**\n//    * Inject data from stack items.\n//    * @private\n//    * @param {Buffer[]} items\n//    * @returns {Script}\n//    */\n\n//   fromItems(items) {\n//     assert(Array.isArray(items));\n\n//     this.clear();\n\n//     for (const item of items)\n//       this.pushData(item);\n\n//     return this.compile();\n//   }\n\n//   /**\n//    * Instantiate script from stack items.\n//    * @param {Buffer[]} items\n//    * @returns {Script}\n//    */\n\n//   static fromItems(items) {\n//     return new this().fromItems(items);\n//   }\n\n//   /**\n//    * Convert script to stack.\n//    * @returns {Stack}\n//    */\n\n//   toStack() {\n//     return new Stack(this.toItems());\n//   }\n\n//   /**\n//    * Inject data from stack.\n//    * @private\n//    * @param {Stack} stack\n//    * @returns {Script}\n//    */\n\n//   fromStack(stack) {\n//     return this.fromItems(stack.items);\n//   }\n\n//   /**\n//    * Instantiate script from stack.\n//    * @param {Stack} stack\n//    * @returns {Script}\n//    */\n\n//   static fromStack(stack) {\n//     return new this().fromStack(stack);\n//   }\n\n//   /**\n//    * Clone the script.\n//    * @returns {Script} Cloned script.\n//    */\n\n//   clone() {\n//     return new this.constructor().inject(this);\n//   }\n\n//   /**\n//    * Inject properties from script.\n//    * Used for cloning.\n//    * @private\n//    * @param {Script} script\n//    * @returns {Script}\n//    */\n\n//   inject(script) {\n//     this.raw = script.raw;\n//     this.code = script.code.slice();\n//     return this;\n//   }\n\n//   /**\n//    * Test equality against script.\n//    * @param {Script} script\n//    * @returns {Boolean}\n//    */\n\n//   equals(script) {\n//     assert(Script.isScript(script));\n//     return this.raw.equals(script.raw);\n//   }\n\n//   /**\n//    * Compare against another script.\n//    * @param {Script} script\n//    * @returns {Number}\n//    */\n\n//   compare(script) {\n//     assert(Script.isScript(script));\n//     return this.raw.compare(script.raw);\n//   }\n\n//   /**\n//    * Clear the script.\n//    * @returns {Script}\n//    */\n\n//   clear() {\n//     this.raw = EMPTY_BUFFER;\n//     this.code.length = 0;\n//     return this;\n//   }\n\n//   /**\n//    * Inspect the script.\n//    * @returns {String} Human-readable script code.\n//    */\n\n//   inspect() {\n//     return `<Script: ${this.toString()}>`;\n//   }\n\n//   /**\n//    * Convert the script to a bitcoind test string.\n//    * @returns {String} Human-readable script code.\n//    */\n\n//   toString() {\n//     const out = [];\n\n//     for (const op of this.code)\n//       out.push(op.toFormat());\n\n//     return out.join(' ');\n//   }\n\n//   /**\n//    * Format the script as bitcoind asm.\n//    * @param {Boolean?} decode - Attempt to decode hash types.\n//    * @returns {String} Human-readable script.\n//    */\n\n//   toASM(decode) {\n//     if (this.isNulldata())\n//       decode = false;\n\n//     const out = [];\n\n//     for (const op of this.code)\n//       out.push(op.toASM(decode));\n\n//     return out.join(' ');\n//   }\n\n//   /**\n//    * Re-encode the script internally. Useful if you\n//    * changed something manually in the `code` array.\n//    * @returns {Script}\n//    */\n\n//   compile() {\n//     if (this.code.length === 0)\n//       return this.clear();\n\n//     let size = 0;\n\n//     for (const op of this.code)\n//       size += op.getSize();\n\n//     const bw = bio.write(size);\n\n//     for (const op of this.code)\n//       op.toWriter(bw);\n\n//     this.raw = bw.render();\n\n//     return this;\n//   }\n\n//   /**\n//    * Write the script to a buffer writer.\n//    * @param {BufferWriter} bw\n//    */\n\n//   toWriter(bw) {\n//     bw.writeVarBytes(this.raw);\n//     return bw;\n//   }\n\n//   /**\n//    * Encode the script to a Buffer. See {@link Script#encode}.\n//    * @param {String} enc - Encoding, either `'hex'` or `null`.\n//    * @returns {Buffer|String} Serialized script.\n//    */\n\n//   toRaw() {\n//     return this.raw;\n//   }\n\n//   /**\n//    * Convert script to a hex string.\n//    * @returns {String}\n//    */\n\n//   toJSON() {\n//     return this.toRaw().toString('hex');\n//   }\n\n//   /**\n//    * Inject properties from json object.\n//    * @private\n//    * @param {String} json\n//    */\n\n  fromJSON(json) {\n    assert(typeof json === 'string', 'Code must be a string.');\n    return this.fromRaw(Buffer.from(json, 'hex'));\n  }\n\n  /**\n   * Instantiate script from a hex string.\n   * @params {String} json\n   * @returns {Script}\n   */\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n\n//   /**\n//    * Get the script's \"subscript\" starting at a separator.\n//    * @param {Number} index - The last separator to sign/verify beyond.\n//    * @returns {Script} Subscript.\n//    */\n\n//   getSubscript(index) {\n//     if (index === 0)\n//       return this.clone();\n\n//     const script = new Script();\n\n//     for (let i = index; i < this.code.length; i++) {\n//       const op = this.code[i];\n\n//       if (op.value === -1)\n//         break;\n\n//       script.code.push(op);\n//     }\n\n//     return script.compile();\n//   }\n\n//   /**\n//    * Get the script's \"subscript\" starting at a separator.\n//    * Remove all OP_CODESEPARATORs if present. This bizarre\n//    * behavior is necessary for signing and verification when\n//    * code separators are present.\n//    * @returns {Script} Subscript.\n//    */\n\n//   removeSeparators() {\n//     let found = false;\n\n//     // Optimizing for the common case:\n//     // Check for any separators first.\n//     for (const op of this.code) {\n//       if (op.value === -1)\n//         break;\n\n//       if (op.value === opcodes.OP_CODESEPARATOR) {\n//         found = true;\n//         break;\n//       }\n//     }\n\n//     if (!found)\n//       return this;\n\n//     // Uncommon case: someone actually\n//     // has a code separator. Go through\n//     // and remove them all.\n//     const script = new Script();\n\n//     for (const op of this.code) {\n//       if (op.value === -1)\n//         break;\n\n//       if (op.value !== opcodes.OP_CODESEPARATOR)\n//         script.code.push(op);\n//     }\n\n//     return script.compile();\n//   }\n\n//   /**\n//    * Get the value of the checkBits while calculated as little endian.\n//    * @param {Buffer} abkam - Stack depth of the dummy element.\n//    * @param {Number?} nKeysCount - Stack depth of the top pubkeys.\n//    * @returns {Number}\n//    */\n\n//   bitcalculator(abkam, nKeysCount) {\n//     let checkBits = 0;\n\n//     const bitfield_size = ((nKeysCount + 7) / 8);\n\n//     for (let i = 0; i < bitfield_size; i++) {\n//       checkBits |= abkam[i] << (8 * i);\n//     }\n\n//     return checkBits;\n//   }\n\n//   /**\n//    * Execute and interpret the script.\n//    * @param {Stack} stack - Script execution stack.\n//    * @param {Number?} flags - Script standard flags.\n//    * @param {TX?} tx - Transaction being verified.\n//    * @param {Number?} index - Index of input being verified.\n//    * @param {Amount?} value - Previous output value.\n//    * @param {Number?} sigchecks\n//    * @throws {ScriptError} Will be thrown on VERIFY failures.\n//    */\n\n//   execute(stack, flags, tx, index, value, sigchecks) {\n//     if (flags == null)\n//       flags = Script.flags.STANDARD_VERIFY_FLAGS;\n\n//     if (this.getSize() > consensus.MAX_SCRIPT_SIZE)\n//       throw new ScriptError('SCRIPT_SIZE');\n\n//     const state = [];\n//     const alt = [];\n\n//     let lastSep = 0;\n//     let opCount = 0;\n//     let negate = 0;\n//     let nSigsRemaining = 0;\n//     let nKeysRemaining = 0;\n//     let checkBits;\n//     let minimal = false;\n\n//     if (flags & Script.flags.VERIFY_MINIMALDATA)\n//       minimal = true;\n\n//     for (let ip = 0; ip < this.code.length; ip++) {\n//       const op = this.code[ip];\n\n//       if (op.value === -1)\n//         throw new ScriptError('BAD_OPCODE', op, ip);\n\n//       if (op.data && op.data.length > consensus.MAX_SCRIPT_PUSH)\n//         throw new ScriptError('PUSH_SIZE', op, ip);\n\n//       if (op.value > opcodes.OP_16 && ++opCount > consensus.MAX_SCRIPT_OPS)\n//         throw new ScriptError('OP_COUNT', op, ip);\n\n//       if (op.isDisabled(flags))\n//         throw new ScriptError('DISABLED_OPCODE', op, ip);\n\n//       if (negate && !op.isBranch()) {\n//         if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK)\n//           throw new ScriptError('STACK_SIZE', op, ip);\n//         continue;\n//       }\n\n//       if (op.data && 0 <= op.value <= opcodes.OP_PUSHDATA4) {\n//         if (minimal && !op.isMinimal())\n//           throw new ScriptError('MINIMALDATA', op, ip);\n\n//         stack.push(op.data);\n\n//         if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK)\n//           throw new ScriptError('STACK_SIZE', op, ip);\n\n//         continue;\n//       }\n\n//       switch (op.value) {\n//         case opcodes.OP_0: {\n//           stack.pushInt(0);\n//           break;\n//         }\n//         case opcodes.OP_1NEGATE: {\n//           stack.pushInt(-1);\n//           break;\n//         }\n//         case opcodes.OP_1:\n//         case opcodes.OP_2:\n//         case opcodes.OP_3:\n//         case opcodes.OP_4:\n//         case opcodes.OP_5:\n//         case opcodes.OP_6:\n//         case opcodes.OP_7:\n//         case opcodes.OP_8:\n//         case opcodes.OP_9:\n//         case opcodes.OP_10:\n//         case opcodes.OP_11:\n//         case opcodes.OP_12:\n//         case opcodes.OP_13:\n//         case opcodes.OP_14:\n//         case opcodes.OP_15:\n//         case opcodes.OP_16: {\n//           stack.pushInt(op.value - 0x50);\n//           break;\n//         }\n//         case opcodes.OP_NOP: {\n//           break;\n//         }\n//         case opcodes.OP_CHECKLOCKTIMEVERIFY: {\n//           // OP_CHECKLOCKTIMEVERIFY = OP_NOP2\n//           if (!(flags & Script.flags.VERIFY_CHECKLOCKTIMEVERIFY)) {\n//             if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n//               throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);\n//             break;\n//           }\n\n//           if (!tx)\n//             throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n\n//           if (stack.length === 0)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           const num = stack.getNum(-1, minimal, 5);\n\n//           if (num.isNeg())\n//             throw new ScriptError('NEGATIVE_LOCKTIME', op, ip);\n\n//           const locktime = num.toDouble();\n\n//           if (!tx.verifyLocktime(index, locktime))\n//             throw new ScriptError('UNSATISFIED_LOCKTIME', op, ip);\n\n//           break;\n//         }\n//         case opcodes.OP_CHECKSEQUENCEVERIFY: {\n//           // OP_CHECKSEQUENCEVERIFY = OP_NOP3\n//           if (!(flags & Script.flags.VERIFY_CHECKSEQUENCEVERIFY)) {\n//             if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n//               throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);\n//             break;\n//           }\n\n//           if (!tx)\n//             throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n\n//           if (stack.length === 0)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           const num = stack.getNum(-1, minimal, 5);\n\n//           if (num.isNeg())\n//             throw new ScriptError('NEGATIVE_LOCKTIME', op, ip);\n\n//           const locktime = num.toDouble();\n\n//           if (!tx.verifySequence(index, locktime))\n//             throw new ScriptError('UNSATISFIED_LOCKTIME', op, ip);\n\n//           break;\n//         }\n//         case opcodes.OP_NOP1:\n//         case opcodes.OP_NOP4:\n//         case opcodes.OP_NOP5:\n//         case opcodes.OP_NOP6:\n//         case opcodes.OP_NOP7:\n//         case opcodes.OP_NOP8:\n//         case opcodes.OP_NOP9:\n//         case opcodes.OP_NOP10: {\n//           if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n//             throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);\n//           break;\n//         }\n//         case opcodes.OP_IF:\n//         case opcodes.OP_NOTIF: {\n//           let val = false;\n\n//           if (!negate) {\n//             if (stack.length < 1)\n//               throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);\n\n//             if (flags & Script.flags.VERIFY_MINIMALIF) {\n//               const item = stack.get(-1);\n\n//               if (item.length > 1)\n//                 throw new ScriptError('MINIMALIF');\n\n//               if (item.length === 1 && item[0] !== 1)\n//                 throw new ScriptError('MINIMALIF');\n//             }\n\n//             val = stack.getBool(-1);\n\n//             if (op.value === opcodes.OP_NOTIF)\n//               val = !val;\n\n//             stack.pop();\n//           }\n\n//           state.push(val);\n\n//           if (!val)\n//             negate += 1;\n\n//           break;\n//         }\n//         case opcodes.OP_ELSE: {\n//           if (state.length === 0)\n//             throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);\n\n//           state[state.length - 1] = !state[state.length - 1];\n\n//           if (!state[state.length - 1])\n//             negate += 1;\n//           else\n//             negate -= 1;\n\n//           break;\n//         }\n//         case opcodes.OP_ENDIF: {\n//           if (state.length === 0)\n//             throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);\n\n//           if (!state.pop())\n//             negate -= 1;\n\n//           break;\n//         }\n//         case opcodes.OP_VERIFY: {\n//           if (stack.length === 0)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           if (!stack.getBool(-1))\n//             throw new ScriptError('VERIFY', op, ip);\n\n//           stack.pop();\n\n//           break;\n//         }\n//         case opcodes.OP_RETURN: {\n//           throw new ScriptError('OP_RETURN', op, ip);\n//         }\n//         case opcodes.OP_TOALTSTACK: {\n//           if (stack.length === 0)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           alt.push(stack.pop());\n//           break;\n//         }\n//         case opcodes.OP_FROMALTSTACK: {\n//           if (alt.length === 0)\n//             throw new ScriptError('INVALID_ALTSTACK_OPERATION', op, ip);\n\n//           stack.push(alt.pop());\n//           break;\n//         }\n//         case opcodes.OP_2DROP: {\n//           if (stack.length < 2)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           stack.pop();\n//           stack.pop();\n//           break;\n//         }\n//         case opcodes.OP_2DUP: {\n//           if (stack.length < 2)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           const v1 = stack.get(-2);\n//           const v2 = stack.get(-1);\n\n//           stack.push(v1);\n//           stack.push(v2);\n//           break;\n//         }\n//         case opcodes.OP_3DUP: {\n//           if (stack.length < 3)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           const v1 = stack.get(-3);\n//           const v2 = stack.get(-2);\n//           const v3 = stack.get(-1);\n\n//           stack.push(v1);\n//           stack.push(v2);\n//           stack.push(v3);\n//           break;\n//         }\n//         case opcodes.OP_2OVER: {\n//           if (stack.length < 4)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           const v1 = stack.get(-4);\n//           const v2 = stack.get(-3);\n\n//           stack.push(v1);\n//           stack.push(v2);\n//           break;\n//         }\n//         case opcodes.OP_2ROT: {\n//           if (stack.length < 6)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           const v1 = stack.get(-6);\n//           const v2 = stack.get(-5);\n\n//           stack.erase(-6, -4);\n//           stack.push(v1);\n//           stack.push(v2);\n//           break;\n//         }\n//         case opcodes.OP_2SWAP: {\n//           if (stack.length < 4)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           stack.swap(-4, -2);\n//           stack.swap(-3, -1);\n//           break;\n//         }\n//         case opcodes.OP_IFDUP: {\n//           if (stack.length === 0)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           if (stack.getBool(-1)) {\n//             const val = stack.get(-1);\n//             stack.push(val);\n//           }\n\n//           break;\n//         }\n//         case opcodes.OP_DEPTH: {\n//           stack.pushInt(stack.length);\n//           break;\n//         }\n//         case opcodes.OP_DROP: {\n//           if (stack.length === 0)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           stack.pop();\n//           break;\n//         }\n//         case opcodes.OP_DUP: {\n//           if (stack.length === 0)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           stack.push(stack.get(-1));\n//           break;\n//         }\n//         case opcodes.OP_NIP: {\n//           if (stack.length < 2)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           stack.remove(-2);\n//           break;\n//         }\n//         case opcodes.OP_OVER: {\n//           if (stack.length < 2)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           stack.push(stack.get(-2));\n//           break;\n//         }\n//         case opcodes.OP_PICK:\n//         case opcodes.OP_ROLL: {\n//           if (stack.length < 2)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           const num = stack.getInt(-1, minimal, 4);\n//           stack.pop();\n\n//           if (num < 0 || num >= stack.length)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           const val = stack.get(-num - 1);\n\n//           if (op.value === opcodes.OP_ROLL)\n//             stack.remove(-num - 1);\n\n//           stack.push(val);\n//           break;\n//         }\n//         case opcodes.OP_ROT: {\n//           if (stack.length < 3)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           stack.swap(-3, -2);\n//           stack.swap(-2, -1);\n//           break;\n//         }\n//         case opcodes.OP_SWAP: {\n//           if (stack.length < 2)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           stack.swap(-2, -1);\n//           break;\n//         }\n//         case opcodes.OP_TUCK: {\n//           if (stack.length < 2)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           stack.insert(-2, stack.get(-1));\n//           break;\n//         }\n//         case opcodes.OP_SIZE: {\n//           if (stack.length < 1)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           stack.pushInt(stack.get(-1).length);\n//           break;\n//         }\n//         case opcodes.OP_EQUAL:\n//         case opcodes.OP_EQUALVERIFY: {\n//           if (stack.length < 2)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           const v1 = stack.get(-2);\n//           const v2 = stack.get(-1);\n\n//           const res = v1.equals(v2);\n\n//           stack.pop();\n//           stack.pop();\n\n//           stack.pushBool(res);\n\n//           if (op.value === opcodes.OP_EQUALVERIFY) {\n//             if (!res)\n//               throw new ScriptError('EQUALVERIFY', op, ip);\n//             stack.pop();\n//           }\n\n//           break;\n//         }\n//         case opcodes.OP_1ADD:\n//         case opcodes.OP_1SUB:\n//         case opcodes.OP_NEGATE:\n//         case opcodes.OP_ABS:\n//         case opcodes.OP_NOT:\n//         case opcodes.OP_0NOTEQUAL: {\n//           if (stack.length < 1)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           let num = stack.getNum(-1, minimal, 4);\n//           let cmp;\n\n//           switch (op.value) {\n//             case opcodes.OP_1ADD:\n//               num.iaddn(1);\n//               break;\n//             case opcodes.OP_1SUB:\n//               num.isubn(1);\n//               break;\n//             case opcodes.OP_NEGATE:\n//               num.ineg();\n//               break;\n//             case opcodes.OP_ABS:\n//               num.iabs();\n//               break;\n//             case opcodes.OP_NOT:\n//               cmp = num.isZero();\n//               num = ScriptNum.fromBool(cmp);\n//               break;\n//             case opcodes.OP_0NOTEQUAL:\n//               cmp = !num.isZero();\n//               num = ScriptNum.fromBool(cmp);\n//               break;\n//             default:\n//               assert(false, 'Fatal script error.');\n//               break;\n//           }\n\n//           stack.pop();\n//           stack.pushNum(num);\n\n//           break;\n//         }\n//         case opcodes.OP_ADD:\n//         case opcodes.OP_SUB:\n//         case opcodes.OP_DIV:\n//         case opcodes.OP_MOD:\n//         case opcodes.OP_BOOLAND:\n//         case opcodes.OP_BOOLOR:\n//         case opcodes.OP_NUMEQUAL:\n//         case opcodes.OP_NUMEQUALVERIFY:\n//         case opcodes.OP_NUMNOTEQUAL:\n//         case opcodes.OP_LESSTHAN:\n//         case opcodes.OP_GREATERTHAN:\n//         case opcodes.OP_LESSTHANOREQUAL:\n//         case opcodes.OP_GREATERTHANOREQUAL:\n//         case opcodes.OP_MIN:\n//         case opcodes.OP_MAX: {\n//           if (stack.length < 2)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           const n1 = stack.getNum(-2, minimal, 4);\n//           const n2 = stack.getNum(-1, minimal, 4);\n//           let num, cmp;\n\n//           switch (op.value) {\n//             case opcodes.OP_ADD:\n//               num = n1.iadd(n2);\n//               break;\n//             case opcodes.OP_SUB:\n//               num = n1.isub(n2);\n//               break;\n//             case opcodes.OP_DIV:\n//               if (n2.isZero())\n//                 throw new ScriptError('DIV_BY_ZERO', op, ip);\n//               num = n1.div(n2);\n//               break;\n//             case opcodes.OP_MOD:\n//               if (n2.isZero())\n//                 throw new ScriptError('MOD_BY_ZERO', op, ip);\n//               num = n1.mod(n2);\n//               break;\n//             case opcodes.OP_BOOLAND:\n//               cmp = n1.toBool() && n2.toBool();\n//               num = ScriptNum.fromBool(cmp);\n//               break;\n//             case opcodes.OP_BOOLOR:\n//               cmp = n1.toBool() || n2.toBool();\n//               num = ScriptNum.fromBool(cmp);\n//               break;\n//             case opcodes.OP_NUMEQUAL:\n//               cmp = n1.eq(n2);\n//               num = ScriptNum.fromBool(cmp);\n//               break;\n//             case opcodes.OP_NUMEQUALVERIFY:\n//               cmp = n1.eq(n2);\n//               num = ScriptNum.fromBool(cmp);\n//               break;\n//             case opcodes.OP_NUMNOTEQUAL:\n//               cmp = !n1.eq(n2);\n//               num = ScriptNum.fromBool(cmp);\n//               break;\n//             case opcodes.OP_LESSTHAN:\n//               cmp = n1.lt(n2);\n//               num = ScriptNum.fromBool(cmp);\n//               break;\n//             case opcodes.OP_GREATERTHAN:\n//               cmp = n1.gt(n2);\n//               num = ScriptNum.fromBool(cmp);\n//               break;\n//             case opcodes.OP_LESSTHANOREQUAL:\n//               cmp = n1.lte(n2);\n//               num = ScriptNum.fromBool(cmp);\n//               break;\n//             case opcodes.OP_GREATERTHANOREQUAL:\n//               cmp = n1.gte(n2);\n//               num = ScriptNum.fromBool(cmp);\n//               break;\n//             case opcodes.OP_MIN:\n//               num = ScriptNum.min(n1, n2);\n//               break;\n//             case opcodes.OP_MAX:\n//               num = ScriptNum.max(n1, n2);\n//               break;\n//             default:\n//               assert(false, 'Fatal script error.');\n//               break;\n//           }\n\n//           stack.pop();\n//           stack.pop();\n//           stack.pushNum(num);\n\n//           if (op.value === opcodes.OP_NUMEQUALVERIFY) {\n//             if (!stack.getBool(-1))\n//               throw new ScriptError('NUMEQUALVERIFY', op, ip);\n//             stack.pop();\n//           }\n\n//           break;\n//         }\n//         case opcodes.OP_WITHIN: {\n//           if (stack.length < 3)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           const n1 = stack.getNum(-3, minimal, 4);\n//           const n2 = stack.getNum(-2, minimal, 4);\n//           const n3 = stack.getNum(-1, minimal, 4);\n\n//           const val = n2.lte(n1) && n1.lt(n3);\n\n//           stack.pop();\n//           stack.pop();\n//           stack.pop();\n\n//           stack.pushBool(val);\n//           break;\n//         }\n//         case opcodes.OP_RIPEMD160: {\n//           if (stack.length === 0)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           stack.push(ripemd160.digest(stack.pop()));\n//           break;\n//         }\n//         case opcodes.OP_SHA1: {\n//           if (stack.length === 0)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           stack.push(sha1.digest(stack.pop()));\n//           break;\n//         }\n//         case opcodes.OP_SHA256: {\n//           if (stack.length === 0)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           stack.push(sha256.digest(stack.pop()));\n//           break;\n//         }\n//         case opcodes.OP_HASH160: {\n//           if (stack.length === 0)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           stack.push(hash160.digest(stack.pop()));\n//           break;\n//         }\n//         case opcodes.OP_HASH256: {\n//           if (stack.length === 0)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           stack.push(hash256.digest(stack.pop()));\n//           break;\n//         }\n//         case opcodes.OP_CODESEPARATOR: {\n//           lastSep = ip + 1;\n//           break;\n//         }\n//         case opcodes.OP_CHECKSIG:\n//         case opcodes.OP_CHECKSIGVERIFY: {\n//           if (!tx)\n//             throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n\n//           if (stack.length < 2)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           const sig = stack.get(-2);\n//           const key = stack.get(-1);\n\n//           const subscript = this.getSubscript(lastSep);\n\n//           if (!(flags & Script.flags.VERIFY_SIGHASH_FORKID)\n//             || !(sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID))\n//             subscript.findAndDelete(sig);\n\n//           checkTransactionSignature(sig, flags);\n//           validateKey(key, flags);\n\n//           let res = false;\n\n//           if (sig.length > 0) {\n//             const type = sig[sig.length - 1];\n//             const hash = tx.signatureHash(\n//               index,\n//               subscript,\n//               value,\n//               type,\n//               flags\n//             );\n//             res = verifySignature(hash, sig.slice(0, -1), key, flags);\n//             metrics.sigchecks += 1;\n//             sigchecks = metrics.sigchecks;\n//           }\n\n//           if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {\n//             if (sig.length !== 0)\n//               throw new ScriptError('NULLFAIL', op, ip);\n//           }\n\n//           stack.pop();\n//           stack.pop();\n\n//           stack.pushBool(res);\n\n//           if (op.value === opcodes.OP_CHECKSIGVERIFY) {\n//             if (!res)\n//               throw new ScriptError('CHECKSIGVERIFY', op, ip);\n//             stack.pop();\n//           }\n\n//           break;\n//         }\n//         case opcodes.OP_CHECKDATASIG:\n//         case opcodes.OP_CHECKDATASIGVERIFY: {\n//           // (sig message pubkey -- bool)\n//           if (stack.length < 3)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           const sig = stack.get(-3);\n//           const msg = stack.get(-2);\n//           const key = stack.get(-1);\n\n//           validateDataSignature(sig, flags);\n//           validateKey(key, flags);\n\n//           let res = false;\n\n//           if (sig.length > 0) {\n//             const hash = sha256.digest(msg);\n//             res = verifySignature(hash, sig, key, flags);\n//             metrics.sigchecks += 1;\n// \t    sigchecks = metrics.sigchecks;\n//           }\n\n//           if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {\n//             if (sig.length !== 0)\n//               throw new ScriptError('NULLFAIL', op, ip);\n//           }\n\n//           stack.pop();\n//           stack.pop();\n//           stack.pop();\n\n//           stack.pushBool(res);\n\n//           if (op.value === opcodes.OP_CHECKDATASIGVERIFY) {\n//             if (!res)\n//               throw new ScriptError('CHECKDATASIGVERIFY', op, ip);\n//             stack.pop();\n//           }\n\n//           break;\n//         }\n//         case opcodes.OP_CHECKMULTISIG:\n//         case opcodes.OP_CHECKMULTISIGVERIFY: {\n//           if (!tx)\n//             throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n\n//           let keyCount = 1;\n//           let sigCount = 0;\n//           let keyTop, sigTop;\n\n//           if (stack.length < keyCount)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           let nKeysCount = stack.getInt(-keyCount, minimal, 4);\n//           let okey = nKeysCount + 2;\n//           let ikey, isig;\n\n//           if (nKeysCount < 0 || nKeysCount > consensus.MAX_MULTISIG_PUBKEYS)\n//             throw new ScriptError('PUBKEY_COUNT', op, ip);\n\n//           opCount += nKeysCount;\n\n//           if (opCount > consensus.MAX_SCRIPT_OPS)\n//             throw new ScriptError('OP_COUNT', op, ip);\n\n//           keyCount += 1;\n//           keyTop = keyCount;\n\n//           // stack depth of nSigsCount\n//           sigCount = keyTop + nKeysCount;\n\n//           ikey = keyCount;\n//           keyCount += nKeysCount;\n\n//           if (stack.length < sigCount)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           let nSigsCount = stack.getInt(-sigCount, minimal, 4);\n\n//           if (nSigsCount < 0 || nSigsCount > nKeysCount)\n//             throw new ScriptError('SIG_COUNT', op, ip);\n\n//           // stack depth of the top signature\n//           sigTop = sigCount + 1;\n\n//           // stack depth of the dummy element\n//           const dummy = sigTop + nSigsCount;\n\n//           if (stack.length < dummy)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           keyCount += 1;\n//           isig = keyCount;\n//           keyCount += nSigsCount;\n\n//           const subscript = this.getSubscript(lastSep);\n//           let res = true;\n\n//           if ((flags & Script.flags.VERIFY_SCHNORR_MULTISIG)\n//              && stack.get(-dummy).length !== 0) {\n//               assert(consensus.MAX_MULTISIG_PUBKEYS < 32)\n\n//             if (nKeysCount > 32)\n//               throw new ScriptError('INVALID_BITFIELD_SIZE', op, ip);\n\n//             const bitfield_size = Math.floor((nKeysCount + 7) / 8);\n//             const abkam = stack.get(-dummy);\n\n//             if (abkam.length !== bitfield_size)\n//               throw new ScriptError('BITFIELD_SIZE', op, ip);\n\n//             checkBits = this.bitcalculator(abkam, nKeysCount);\n\n//             const mask = (1 << nKeysCount) - 1;\n//             const numBits = countBits(checkBits);\n\n//             if ((checkBits & mask) !== checkBits)\n//               throw new ScriptError('BIT_RANGE', op, ip);\n\n//             if (numBits !== nSigsCount)\n//               throw new ScriptError('INVALID_BIT_COUNT', op, ip);\n\n//             const bKey = keyTop + nKeysCount - 1;\n//             const bSig = sigTop + nSigsCount - 1;\n\n//             let ik3y = 0;\n\n//             for (let is1g = 0; is1g < nSigsCount; is1g++, ik3y++) {\n//               if ((checkBits >> ik3y) === 0) {\n//                 throw new ScriptError('INVALID_BIT_RANGE', op, ip);\n//               }\n\n//               while (((checkBits >> ik3y) & 0x01) === 0) {\n//                 ik3y++;\n//               }\n\n//               if (ik3y >= nKeysCount)\n//                 throw new ScriptError('PUBKEY_COUNT', op, ip);\n\n//               const sig = stack.get(-bSig + is1g);\n//               const key = stack.get(-bKey + ik3y);\n\n//               // Handle checkbits left over\n//               if (!sig)\n//                 continue;\n\n//               checkTransactionSchnorrSig(sig, flags);\n//               validateKey(key, flags);\n\n//               if (sig.length > 0) {\n//                 const type = sig[sig.length - 1];\n//                 const hash = tx.signatureHash(\n//                   index,\n//                   subscript,\n//                   value,\n//                   type,\n//                   flags\n//                 );\n\n//                 res = verifySignature(hash, sig.slice(0, -1), key, flags);\n//                 metrics.sigchecks += 1;\n// \t\t            sigchecks = metrics.sigchecks;\n//               }\n\n//               while (keyCount > 1) {\n//                 if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {\n//                   if (okey === 0 && stack.get(-1).length !== 0)\n//                     throw new ScriptError('NULLFAIL', op, ip);\n//                 }\n    \n//                 if (okey > 0)\n//                   okey -= 1;\n    \n//                 stack.pop();\n    \n//                 keyCount -= 1;\n//               }\n\n//             }\n\n\n//             if ((checkBits >> ik3y) !== 0)\n//               throw new ScriptError('INVALID_BIT_COUNT', op, ip);\n\n//             stack.pop();\n//             stack.pushBool(res);\n\n//           } else {\n//             // Legacy Multisig (ECDSA / NULL)\n//             // A bug causes CHECKMULTISIG to consume one extra\n//             // argument whose contents were not checked in any way.\n\n//           for (let j = 0; j < nSigsCount; j++) {\n//             const sig = stack.get(-sigTop - j);\n//             if (!(flags & Script.flags.VERIFY_SIGHASH_FORKID)\n//               || !(sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID))\n//               subscript.findAndDelete(sig, flags);\n//           }\n\n//           nSigsRemaining = nSigsCount;\n//           nKeysRemaining = nKeysCount;\n\n//           while (res && nSigsCount > 0) {\n//             const sig = stack.get(-isig);\n//             const key = stack.get(-ikey);\n\n//             checkTransactionECDSASignature(sig, flags);\n//             validateKey(key, flags);\n\n//             if (sig.length > 0) {\n//               const type = sig[sig.length - 1];\n//               const hash = tx.signatureHash(\n//                 index,\n//                 subscript,\n//                 value,\n//                 type,\n//                 flags\n//               );\n\n//               if (checksig(hash, sig, key)) {\n//                 isig += 1;\n//                 nSigsCount -= 1;\n//               }\n//             }\n\n//             ikey += 1;\n//             nKeysCount -= 1;\n\n//             if (nSigsCount > nKeysCount)\n//               res = false;\n//           }\n\n//           while (keyCount > 1) {\n//             if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {\n//               if (okey === 0 && stack.get(-1).length !== 0)\n//                 throw new ScriptError('NULLFAIL', op, ip);\n//             }\n\n//             if (okey > 0)\n//               okey -= 1;\n\n//             stack.pop();\n\n//             keyCount -= 1;\n//           }\n\n//           if (stack.length < 1)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           stack.pop();\n\n//           stack.pushBool(res);\n\n//           if (op.value === opcodes.OP_CHECKMULTISIGVERIFY) {\n//             if (!res)\n//               throw new ScriptError('CHECKMULTISIGVERIFY', op, ip);\n//             stack.pop();\n//            }\n//           }\n\n//           break;\n//         }\n\n//         //\n//         // Byte string operations\n//         //\n//         case opcodes.OP_CAT: {\n//           // (x1 x2 -- out)\n//           if (stack.length < 2)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           const v1 = stack.get(-2);\n//           const v2 = stack.get(-1);\n//           if (v1.length + v2.length > consensus.MAX_SCRIPT_PUSH) {\n//             throw new ScriptError('PUSH_SIZE', op, ip);\n//           }\n//           stack.pop();\n//           stack.pop();\n\n//           stack.push(Buffer.concat([v1, v2]));\n\n//           break;\n//         }\n\n//         case opcodes.OP_SPLIT: {\n//           // (in position -- x1 x2)\n//           if (stack.length < 2)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           const data = stack.get(-2);\n\n//           // Make sure the split point is appropriate.\n//           const pos = stack.getInt(-1, minimal, 4);\n//           if (pos < 0 || pos > data.length)\n//             throw new ScriptError('INVALID_SPLIT_RANGE', op, ip);\n\n//           // Prepare the results in their own buffer as `data`\n//           // will be invalidated.\n//           const n1 = data.slice(0, pos);\n//           const n2 = data.slice(pos);\n\n//           // Replace existing stack values by the new values.\n//           stack.set(-2, n1);\n//           stack.set(-1, n2);\n//           break;\n//         }\n//         case opcodes.OP_REVERSEBYTES: {\n//          if (stack.length < 1)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           const data = stack.get(-1);\n\n//           data.reverse();\n\n//           break;\n//         }\n\n//         //\n//         // Bitwise logic\n//         //\n//         case opcodes.OP_AND:\n//         case opcodes.OP_OR:\n//         case opcodes.OP_XOR: {\n//           // (x1 x2 - out)\n//           if (stack.length < 2)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           const v1 = stack.get(-2);\n//           const v2 = stack.get(-1);\n\n//           // Inputs must be the same size\n//           if (v1.length !== v2.length)\n//             throw new ScriptError('INVALID_OPERAND_SIZE', op, ip);\n\n//           const raw = Buffer.alloc(v1.length);\n\n//           switch (op.value) {\n//             case opcodes.OP_AND:\n//               for (let i = 0; i < v1.length; i++) {\n//                 raw[i] = v1[i] & v2[i];\n//               }\n//               break;\n//             case opcodes.OP_OR:\n//               for (let i = 0; i < v1.length; i++) {\n//                 raw[i] = v1[i] | v2[i];\n//               }\n//               break;\n//             case opcodes.OP_XOR:\n//               for (let i = 0; i < v1.length; i++) {\n//                 raw[i] = v1[i] ^ v2[i];\n//               }\n//               break;\n//             default:\n//               break;\n//           }\n\n//           // And pop v1 and v2.\n//           stack.pop();\n//           stack.pop();\n\n//           stack.push(raw);\n\n//           break;\n//         }\n\n//         //\n//         // Conversion operations\n//         //\n//         case opcodes.OP_NUM2BIN: {\n//           // (in size -- out)\n//           if (stack.length < 2)\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n//           const size = stack.getInt(-1, minimal, 4);\n//           if (size < 0 || size > consensus.MAX_SCRIPT_PUSH)\n//             throw new ScriptError('PUSH_SIZE', op, ip);\n\n//           stack.pop();\n\n//           const n = stack.get(-1);\n//           const v = ScriptNum.toMinimal(Buffer.from(n));\n\n//           // Try to see if we can fit that number in the number of\n//           // byte requested.\n//           if (v.length > size)\n//             // We definitively cannot.\n//             throw new ScriptError('IMPOSSIBLE_ENCODING', op, ip);\n\n//           // We already have an element of the right size, we don't need to do\n//           // anything.\n//           if (v.length === size) {\n//             stack.pop();\n//             stack.push(v);\n//             break;\n//           }\n\n//           const raw = Buffer.alloc(size);\n//           v.copy(raw);\n\n//           let signbit = 0x00;\n//           if (v.length > 0) {\n//             signbit = v[v.length - 1] & 0x80;\n//             raw[v.length - 1] &= 0x7f;\n//           }\n\n//           raw[size-1] = signbit;\n\n//           stack.pop();\n//           stack.push(raw);\n\n//           break;\n//         }\n\n//         case opcodes.OP_BIN2NUM: {\n//           // (in -- out)\n//           if (stack.length < 1) {\n//             throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n//           }\n\n//           const n = stack.get(-1);\n//           const v = ScriptNum.toMinimal(Buffer.from(n));\n\n//           stack.pop();\n//           stack.push(v);\n\n//           // The resulting number must be a valid number.\n//           if (!ScriptNum.isMinimal(v) || v.length > 4)\n//             throw new ScriptError('INVALID_NUMBER_RANGE', op, ip);\n\n//           break;\n//         }\n\n//         default: {\n//           throw new ScriptError('BAD_OPCODE', op, ip);\n//         }\n//       }\n//     }\n\n//     if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK)\n//       throw new ScriptError('STACK_SIZE');\n\n//     if (state.length !== 0)\n//       throw new ScriptError('UNBALANCED_CONDITIONAL');\n//   }\n\n//   /**\n//    * Remove all matched data elements from\n//    * a script's code (used to remove signatures\n//    * before verification). Note that this\n//    * compares and removes data on the _byte level_.\n//    * It also reserializes the data to a single\n//    * script with minimaldata encoding beforehand.\n//    * A signature will _not_ be removed if it is\n//    * not minimaldata.\n//    * @see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-November/006878.html\n//    * @see https://test.webbtc.com/tx/19aa42fee0fa57c45d3b16488198b27caaacc4ff5794510d0c17f173f05587ff\n//    * @param {Buffer} data - Data element to match against.\n//    * @returns {Number} Total.\n//    */\n\n//   findAndDelete(data) {\n//     const target = Opcode.fromPush(data);\n\n//     if (this.raw.length < target.getSize())\n//       return 0;\n\n//     let found = false;\n\n//     for (const op of this.code) {\n//       if (op.value === -1)\n//         break;\n\n//       if (op.equals(target)) {\n//         found = true;\n//         break;\n//       }\n//     }\n\n//     if (!found)\n//       return 0;\n\n//     const code = [];\n\n//     let total = 0;\n\n//     for (const op of this.code) {\n//       if (op.value === -1)\n//         break;\n\n//       if (op.equals(target)) {\n//         total += 1;\n//         continue;\n//       }\n\n//       code.push(op);\n//     }\n\n//     this.code = code;\n//     this.compile();\n\n//     return total;\n//   }\n\n//   /**\n//    * Find a data element in a script.\n//    * @param {Buffer} data - Data element to match against.\n//    * @returns {Number} Index (`-1` if not present).\n//    */\n\n//   indexOf(data) {\n//     for (let i = 0; i < this.code.length; i++) {\n//       const op = this.code[i];\n\n//       if (op.value === -1)\n//         break;\n\n//       if (!op.data)\n//         continue;\n\n//       if (op.data.equals(data))\n//         return i;\n//     }\n\n//     return -1;\n//   }\n\n//   /**\n//    * Test a script to see if it is likely\n//    * to be script code (no weird opcodes).\n//    * @param {Number?} flags - Script standard flags.\n//    * @returns {Boolean}\n//    */\n\n//   isCode(flags) {\n//     if (flags == null)\n//       flags = Script.flags.STANDARD_VERIFY_FLAGS;\n\n//     for (const op of this.code) {\n//       if (op.value === -1)\n//         return false;\n\n//       if (op.isDisabled(flags))\n//         return false;\n\n//       switch (op.value) {\n//         case opcodes.OP_RESERVED:\n//         case opcodes.OP_NOP:\n//         case opcodes.OP_VER:\n//         case opcodes.OP_VERIF:\n//         case opcodes.OP_VERNOTIF:\n//         case opcodes.OP_RESERVED1:\n//         case opcodes.OP_RESERVED2:\n//         case opcodes.OP_NOP1:\n//           return false;\n//       }\n\n//       if (op.value > opcodes.OP_CHECKSEQUENCEVERIFY)\n//         return false;\n//     }\n\n//     return true;\n//   }\n\n//   /**\n//    * Inject properties from a pay-to-pubkey script.\n//    * @private\n//    * @param {Buffer} key\n//    */\n\n//   fromPubkey(key) {\n//     assert(Buffer.isBuffer(key) && (key.length === 33 || key.length === 65));\n\n//     this.raw = Buffer.allocUnsafe(1 + key.length + 1);\n//     this.raw[0] = key.length;\n//     key.copy(this.raw, 1);\n//     this.raw[1 + key.length] = opcodes.OP_CHECKSIG;\n\n//     key = this.raw.slice(1, 1 + key.length);\n\n//     this.code.length = 0;\n//     this.code.push(Opcode.fromPush(key));\n//     this.code.push(Opcode.fromOp(opcodes.OP_CHECKSIG));\n\n//     return this;\n//   }\n\n//   /**\n//    * Create a pay-to-pubkey script.\n//    * @param {Buffer} key\n//    * @returns {Script}\n//    */\n\n//   static fromPubkey(key) {\n//     return new this().fromPubkey(key);\n//   }\n\n//   /**\n//    * Inject properties from a pay-to-pubkeyhash script.\n//    * @private\n//    * @param {Buffer} hash\n//    */\n\n//   fromPubkeyhash(hash) {\n//     assert(Buffer.isBuffer(hash) && hash.length === 20);\n\n//     this.raw = Buffer.allocUnsafe(25);\n//     this.raw[0] = opcodes.OP_DUP;\n//     this.raw[1] = opcodes.OP_HASH160;\n//     this.raw[2] = 0x14;\n//     hash.copy(this.raw, 3);\n//     this.raw[23] = opcodes.OP_EQUALVERIFY;\n//     this.raw[24] = opcodes.OP_CHECKSIG;\n\n//     hash = this.raw.slice(3, 23);\n\n//     this.code.length = 0;\n//     this.code.push(Opcode.fromOp(opcodes.OP_DUP));\n//     this.code.push(Opcode.fromOp(opcodes.OP_HASH160));\n//     this.code.push(Opcode.fromPush(hash));\n//     this.code.push(Opcode.fromOp(opcodes.OP_EQUALVERIFY));\n//     this.code.push(Opcode.fromOp(opcodes.OP_CHECKSIG));\n\n//     return this;\n//   }\n\n//   /**\n//    * Create a pay-to-pubkeyhash script.\n//    * @param {Buffer} hash\n//    * @returns {Script}\n//    */\n\n//   static fromPubkeyhash(hash) {\n//     return new this().fromPubkeyhash(hash);\n//   }\n\n//   /**\n//    * Inject properties from pay-to-multisig script.\n//    * @private\n//    * @param {Number} m\n//    * @param {Number} n\n//    * @param {Buffer[]} keys\n//    */\n\n//   fromMultisig(m, n, keys) {\n//     assert((m & 0xff) === m && (n & 0xff) === n);\n//     assert(Array.isArray(keys));\n//     assert(keys.length === n, '`n` keys are required for multisig.');\n//     assert(m >= 1 && m <= n);\n//     assert(n >= 1 && n <= 15);\n\n//     this.clear();\n\n//     this.pushSmall(m);\n\n//     for (const key of sortKeys(keys))\n//       this.pushData(key);\n\n//     this.pushSmall(n);\n//     this.pushOp(opcodes.OP_CHECKMULTISIG);\n\n//     return this.compile();\n//   }\n\n//   /**\n//    * Create a pay-to-multisig script.\n//    * @param {Number} m\n//    * @param {Number} n\n//    * @param {Buffer[]} keys\n//    * @returns {Script}\n//    */\n\n//   static fromMultisig(m, n, keys) {\n//     return new this().fromMultisig(m, n, keys);\n//   }\n\n//   /**\n//    * Inject properties from a pay-to-scripthash script.\n//    * @private\n//    * @param {Buffer} hash\n//    */\n\n//   fromScripthash(hash) {\n//     assert(Buffer.isBuffer(hash) && hash.length === 20);\n\n//     this.raw = Buffer.allocUnsafe(23);\n//     this.raw[0] = opcodes.OP_HASH160;\n//     this.raw[1] = 0x14;\n//     hash.copy(this.raw, 2);\n//     this.raw[22] = opcodes.OP_EQUAL;\n\n//     hash = this.raw.slice(2, 22);\n\n//     this.code.length = 0;\n//     this.code.push(Opcode.fromOp(opcodes.OP_HASH160));\n//     this.code.push(Opcode.fromPush(hash));\n//     this.code.push(Opcode.fromOp(opcodes.OP_EQUAL));\n\n//     return this;\n//   }\n\n//   /**\n//    * Create a pay-to-scripthash script.\n//    * @param {Buffer} hash\n//    * @returns {Script}\n//    */\n\n//   static fromScripthash(hash) {\n//     return new this().fromScripthash(hash);\n//   }\n\n//   /**\n//    * Inject properties from a nulldata/opreturn script.\n//    * @private\n//    * @param {Buffer} flags\n//    */\n\n//   fromNulldata(flags) {\n//     assert(Buffer.isBuffer(flags));\n//     assert(flags.length <= policy.MAX_OP_RETURN, 'Nulldata too large.');\n\n//     this.clear();\n//     this.pushOp(opcodes.OP_RETURN);\n//     this.pushData(flags);\n\n//     return this.compile();\n//   }\n\n//   /**\n//    * Create a nulldata/opreturn script.\n//    * @param {Buffer} flags\n//    * @returns {Script}\n//    */\n\n//   static fromNulldata(flags) {\n//     return new this().fromNulldata(flags);\n//   }\n\n  /**\n   * Inject properties from an address.\n   * @private\n   * @param {Address|AddressString} address\n   */\n\n  fromAddress(address) {\n    if (typeof address === 'string')\n      address = Address.fromString(address);\n\n    assert(address instanceof Address, 'Not an address.');\n\n    if (address.isPubkeyhash())\n      return this.fromPubkeyhash(address.hash);\n\n    if (address.isScripthash())\n      return this.fromScripthash(address.hash);\n\n    throw new Error('Unknown address type.');\n  }\n\n  /**\n   * Create an output script from an address.\n   * @param {Address|AddressString} address\n   * @returns {Script}\n   */\n\n  static fromAddress(address) {\n    return new this().fromAddress(address);\n  }\n\n//   /**\n//    * Grab and deserialize the redeem script.\n//    * @returns {Script|null} Redeem script.\n//    */\n\n//   getRedeem() {\n//     let data = null;\n\n//     for (const op of this.code) {\n//       if (op.value === -1)\n//         return null;\n\n//       if (op.value > opcodes.OP_16)\n//         return null;\n\n//       data = op.data;\n//     }\n\n//     if (!data)\n//       return null;\n\n//     return Script.fromRaw(data);\n//   }\n\n//   /**\n//    * Get the standard script type.\n//    * @returns {ScriptType}\n//    */\n\n//   getType() {\n//     if (this.isPubkey())\n//       return scriptTypes.PUBKEY;\n\n//     if (this.isPubkeyhash())\n//       return scriptTypes.PUBKEYHASH;\n\n//     if (this.isScripthash())\n//       return scriptTypes.SCRIPTHASH;\n\n//     if (this.isMultisig())\n//       return scriptTypes.MULTISIG;\n\n//     if (this.isNulldata())\n//       return scriptTypes.NULLDATA;\n\n//     return scriptTypes.NONSTANDARD;\n//   }\n\n//   /**\n//    * Test whether a script is of an unknown/non-standard type.\n//    * @returns {Boolean}\n//    */\n\n//   isUnknown() {\n//     return this.getType() === scriptTypes.NONSTANDARD;\n//   }\n\n//   /**\n//    * Test whether the script is standard by policy standards.\n//    * @returns {Boolean}\n//    */\n\n//   isStandard() {\n//     const [m, n] = this.getMultisig();\n\n//     if (m !== -1) {\n//       if (n < 1 || n > 3)\n//         return false;\n\n//       if (m < 1 || m > n)\n//         return false;\n\n//       return true;\n//     }\n\n//     if (this.isNulldata())\n//       return this.raw.length <= policy.MAX_OP_RETURN_BYTES;\n\n//     return this.getType() !== scriptTypes.NONSTANDARD;\n//   }\n\n//   /**\n//    * Calculate the size of the script\n//    * excluding the varint size bytes.\n//    * @returns {Number}\n//    */\n\n//   getSize() {\n//     return this.raw.length;\n//   }\n\n//   /**\n//    * Calculate the size of the script\n//    * including the varint size bytes.\n//    * @returns {Number}\n//    */\n\n//   getVarSize() {\n//     return encoding.sizeVarBytes(this.raw);\n//   }\n\n//   /**\n//    * \"Guess\" the address of the input script.\n//    * This method is not 100% reliable.\n//    * @returns {Address|null}\n//    */\n\n//   getInputAddress() {\n//     return Address.fromInputScript(this);\n//   }\n\n//   /**\n//    * Get the address of the script if present. Note that\n//    * pubkey and multisig scripts will be treated as though\n//    * they are pubkeyhash and scripthashes respectively.\n//    * @returns {Address|null}\n//    */\n\n//   getAddress() {\n//     return Address.fromScript(this);\n//   }\n\n//   /**\n//    * Get the hash160 of the raw script.\n//    * @param {String?} enc\n//    * @returns {Hash}\n//    */\n\n//   hash160(enc) {\n//     let hash = hash160.digest(this.toRaw());\n//     if (enc === 'hex')\n//       hash = hash.toString('hex');\n//     return hash;\n//   }\n\n//   /**\n//    * Get the sha256 of the raw script.\n//    * @param {String?} enc\n//    * @returns {Hash}\n//    */\n\n//   sha256(enc) {\n//     let hash = sha256.digest(this.toRaw());\n//     if (enc === 'hex')\n//       hash = hash.toString('hex');\n//     return hash;\n//   }\n\n//   /**\n//    * Test whether the output script is pay-to-pubkey.\n//    * @param {Boolean} [minimal=false] - Minimaldata only.\n//    * @returns {Boolean}\n//    */\n\n//   isPubkey(minimal) {\n//     if (minimal) {\n//       return this.raw.length >= 35\n//         && (this.raw[0] === 33 || this.raw[0] === 65)\n//         && this.raw[0] + 2 === this.raw.length\n//         && this.raw[this.raw.length - 1] === opcodes.OP_CHECKSIG;\n//     }\n\n//     if (this.code.length !== 2)\n//       return false;\n\n//     const size = this.getLength(0);\n\n//     return (size === 33 || size === 65)\n//       && this.getOp(1) === opcodes.OP_CHECKSIG;\n//   }\n\n//   /**\n//    * Get P2PK key if present.\n//    * @param {Boolean} [minimal=false] - Minimaldata only.\n//    * @returns {Buffer|null}\n//    */\n\n//   getPubkey(minimal) {\n//     if (!this.isPubkey(minimal))\n//       return null;\n\n//     if (minimal)\n//       return this.raw.slice(1, 1 + this.raw[0]);\n\n//     return this.getData(0);\n//   }\n\n//   /**\n//    * Test whether the output script is pay-to-pubkeyhash.\n//    * @param {Boolean} [minimal=false] - Minimaldata only.\n//    * @returns {Boolean}\n//    */\n\n//   isPubkeyhash(minimal) {\n//     if (minimal || this.raw.length === 25) {\n//       return this.raw.length === 25\n//         && this.raw[0] === opcodes.OP_DUP\n//         && this.raw[1] === opcodes.OP_HASH160\n//         && this.raw[2] === 0x14\n//         && this.raw[23] === opcodes.OP_EQUALVERIFY\n//         && this.raw[24] === opcodes.OP_CHECKSIG;\n//     }\n\n//     if (this.code.length !== 5)\n//       return false;\n\n//     return this.getOp(0) === opcodes.OP_DUP\n//       && this.getOp(1) === opcodes.OP_HASH160\n//       && this.getLength(2) === 20\n//       && this.getOp(3) === opcodes.OP_EQUALVERIFY\n//       && this.getOp(4) === opcodes.OP_CHECKSIG;\n//   }\n\n//   /**\n//    * Get P2PKH hash if present.\n//    * @param {Boolean} [minimal=false] - Minimaldata only.\n//    * @returns {Buffer|null}\n//    */\n\n//   getPubkeyhash(minimal) {\n//     if (!this.isPubkeyhash(minimal))\n//       return null;\n\n//     if (minimal)\n//       return this.raw.slice(3, 23);\n\n//     return this.getData(2);\n//   }\n\n// /**\n//    * Test whether the output script is pay-to-multisig.\n//    * @param {Boolean} [minimal=true] - Minimaldata only.\n//    * @returns {Boolean}\n//    */\n\n//   isMultisig(minimal) {\n//     if (this.code.length < 4 || this.code.length > 19)\n//       return false;\n\n//     if (this.getOp(-1) !== opcodes.OP_CHECKMULTISIG)\n//       return false;\n\n//     const m = this.getSmall(0);\n\n//     if (m < 1)\n//       return false;\n\n//     const n = this.getSmall(-2);\n\n\n//     if (n < 1 || m > n)\n//       return false;\n\n//     if (this.code.length !== n + 3)\n//       return false;\n\n//     for (let i = 1; i < n + 1; i++) {\n//       const op = this.code[i];\n//       const size = op.toLength();\n\n//       if (size !== 33 && size !== 65)\n//         return false;\n\n//       if (minimal && !op.isMinimal())\n//         return false;\n//     }\n\n//     return true;\n//   }\n\n//   /**\n//    * Get multisig m and n values if present.\n//    * @param {Boolean} [minimal=false] - Minimaldata only.\n//    * @returns {Array} [m, n]\n//    */\n\n//   getMultisig(minimal) {\n//     if (!this.isMultisig(minimal))\n//       return [-1, -1];\n\n//     return [this.getSmall(0), this.getSmall(-2)];\n//   }\n\n//   /**\n//    * Test whether the output script is pay-to-scripthash. Note that\n//    * bitcoin itself requires scripthashes to be in strict minimaldata\n//    * encoding. Using `OP_HASH160 OP_PUSHDATA1 [hash] OP_EQUAL` will\n//    * _not_ be recognized as a scripthash.\n//    * @returns {Boolean}\n//    */\n\n//   isScripthash() {\n//     return this.raw.length === 23\n//       && this.raw[0] === opcodes.OP_HASH160\n//       && this.raw[1] === 0x14\n//       && this.raw[22] === opcodes.OP_EQUAL;\n//   }\n\n//   /**\n//    * Get P2SH hash if present.\n//    * @returns {Buffer|null}\n//    */\n\n//   getScripthash() {\n//     if (!this.isScripthash())\n//       return null;\n\n//     return this.getData(1);\n//   }\n\n//   /**\n//    * Test whether the output script is nulldata/opreturn.\n//    * @param {Boolean} [minimal=false] - Minimaldata only.\n//    * @returns {Boolean}\n//    */\n\n//   isNulldata(minimal) {\n//     if (this.code.length === 0)\n//       return false;\n\n//     if (this.getOp(0) !== opcodes.OP_RETURN)\n//       return false;\n\n//     if (this.code.length === 1)\n//       return true;\n\n//     if (minimal) {\n//       if (this.raw.length > policy.MAX_OP_RETURN_BYTES)\n//         return false;\n//     }\n\n//     for (let i = 1; i < this.code.length; i++) {\n//       const op = this.code[i];\n\n//       if (op.value === -1)\n//         return false;\n\n//       if (op.value > opcodes.OP_16)\n//         return false;\n\n//       if (minimal && !op.isMinimal())\n//         return false;\n//     }\n\n//     return true;\n//   }\n\n//   /**\n//    * Get OP_RETURN data if present.\n//    * @param {Boolean} [minimal=false] - Minimaldata only.\n//    * @returns {Buffer|null}\n//    */\n\n//   getNulldata(minimal) {\n//     if (!this.isNulldata(minimal))\n//       return null;\n\n//     for (let i = 1; i < this.code.length; i++) {\n//       const op = this.code[i];\n//       const data = op.toPush();\n//       if (data)\n//         return data;\n//     }\n\n//     return EMPTY_BUFFER;\n//   }\n\n//   /**\n//    * Test whether the output script is a witness program.\n//    * Note that this will return true even for malformed\n//    * witness v0 programs.\n//    * @returns {Boolean}\n//    */\n\n//   isProgram() {\n//     if (this.raw.length < 4 || this.raw.length > 42)\n//       return false;\n\n//     if (this.raw[0] !== opcodes.OP_0\n//       && (this.raw[0] < opcodes.OP_1 || this.raw[0] > opcodes.OP_16)) {\n//       return false;\n//     }\n\n//     if (this.raw[1] + 2 !== this.raw.length)\n//       return false;\n\n//     return true;\n//   }\n\n//   /**\n//    * Test whether the output script is unspendable.\n//    * @returns {Boolean}\n//    */\n\n//   isUnspendable() {\n//     if (this.raw.length > consensus.MAX_SCRIPT_SIZE)\n//       return true;\n\n//     return this.raw.length > 0 && this.raw[0] === opcodes.OP_RETURN;\n//   }\n\n//   /**\n//    * \"Guess\" the type of the input script.\n//    * This method is not 100% reliable.\n//    * @returns {ScriptType}\n//    */\n\n//   getInputType() {\n//     if (this.isPubkeyInput())\n//       return scriptTypes.PUBKEY;\n\n//     if (this.isPubkeyhashInput())\n//       return scriptTypes.PUBKEYHASH;\n\n//     if (this.isScripthashInput())\n//       return scriptTypes.SCRIPTHASH;\n\n//     if (this.isMultisigInput())\n//       return scriptTypes.MULTISIG;\n\n//     return scriptTypes.NONSTANDARD;\n//   }\n\n//   /**\n//    * \"Guess\" whether the input script is an unknown/non-standard type.\n//    * This method is not 100% reliable.\n//    * @returns {Boolean}\n//    */\n\n//   isUnknownInput() {\n//     return this.getInputType() === scriptTypes.NONSTANDARD;\n//   }\n\n//   /**\n//    * \"Guess\" whether the input script is pay-to-pubkey.\n//    * This method is not 100% reliable.\n//    * @returns {Boolean}\n//    */\n\n//   isPubkeyInput() {\n//     if (this.code.length !== 1)\n//       return false;\n\n//     const size = this.getLength(0);\n\n//     return size >= 9 && size <= 73;\n//   }\n\n//   /**\n//    * Get P2PK signature if present.\n//    * @returns {Buffer|null}\n//    */\n\n//   getPubkeyInput() {\n//     if (!this.isPubkeyInput())\n//       return null;\n\n//     return this.getData(0);\n//   }\n\n//   /**\n//    * \"Guess\" whether the input script is pay-to-pubkeyhash.\n//    * This method is not 100% reliable.\n//    * @returns {Boolean}\n//    */\n\n//   isPubkeyhashInput() {\n//     if (this.code.length !== 2)\n//       return false;\n\n//     const sig = this.getLength(0);\n//     const key = this.getLength(1);\n\n//     return sig >= 9 && sig <= 73\n//       && (key === 33 || key === 65);\n//   }\n\n//   /**\n//    * Get P2PKH signature and key if present.\n//    * @returns {Array} [sig, key]\n//    */\n\n//   getPubkeyhashInput() {\n//     if (!this.isPubkeyhashInput())\n//       return [null, null];\n\n//     return [this.getData(0), this.getData(1)];\n//   }\n\n//   /**\n//    * \"Guess\" whether the input script is pay-to-multisig.\n//    * This method is not 100% reliable.\n//    * @returns {Boolean}\n//    */\n\n//   isMultisigInput() {\n//     if (this.code.length < 2)\n//       return false;\n\n//     if (this.getOp(0) !== opcodes.OP_0)\n//       return false;\n\n//     if (this.getOp(1) > opcodes.OP_PUSHDATA4)\n//       return false;\n\n//     // We need to rule out scripthash\n//     // because it may look like multisig.\n//     if (this.isScripthashInput())\n//       return false;\n\n//     for (let i = 1; i < this.code.length; i++) {\n//       const size = this.getLength(i);\n//       if (size < 9 || size > 73)\n//         return false;\n//     }\n\n//     return true;\n//   }\n\n//   /**\n//    * Get multisig signatures if present.\n//    * @returns {Buffer[]|null}\n//    */\n\n//   getMultisigInput() {\n//     if (!this.isMultisigInput())\n//       return null;\n\n//     const sigs = [];\n\n//     for (let i = 1; i < this.code.length; i++)\n//       sigs.push(this.getData(i));\n\n//     return sigs;\n//   }\n\n//   /**\n//    * \"Guess\" whether the input script is pay-to-scripthash.\n//    * This method is not 100% reliable.\n//    * @returns {Boolean}\n//    */\n\n//   isScripthashInput() {\n//     if (this.code.length < 1)\n//       return false;\n\n//     // Grab the raw redeem script.\n//     const raw = this.getData(-1);\n\n//     // Last data element should be an array\n//     // for the redeem script.\n//     if (!raw)\n//       return false;\n\n//     // Testing for scripthash inputs requires\n//     // some evil magic to work. We do it by\n//     // ruling things _out_. This test will not\n//     // be correct 100% of the time. We rule\n//     // out that the last data element is: a\n//     // null dummy, a valid signature, a valid\n//     // key, and we ensure that it is at least\n//     // a script that does not use undefined\n//     // opcodes.\n//     if (raw.length === 0)\n//       return false;\n\n//     if (common.isDERSignatureEncoding(raw.slice(0, -1)))\n//       return false;\n\n//     if (common.isKeyEncoding(raw))\n//       return false;\n\n//     const redeem = Script.fromRaw(raw);\n\n//     if (!redeem.isCode())\n//       return false;\n\n//     if (redeem.isUnspendable())\n//       return false;\n\n//     if (!this.isPushOnly())\n//       return false;\n\n//     return true;\n//   }\n\n//   /**\n//    * Get P2SH redeem script if present.\n//    * @returns {Buffer|null}\n//    */\n\n//   getScripthashInput() {\n//     if (!this.isScripthashInput())\n//       return null;\n\n//     return this.getData(-1);\n//   }\n\n//   /**\n//    * Get coinbase height.\n//    * @returns {Number} `-1` if not present.\n//    */\n\n//   getCoinbaseHeight() {\n//     return Script.getCoinbaseHeight(this.raw);\n//   }\n\n//   /**\n//    * Get coinbase height.\n//    * @param {Buffer} raw - Raw script.\n//    * @returns {Number} `-1` if not present.\n//    */\n\n//   static getCoinbaseHeight(raw) {\n//     if (raw.length === 0)\n//       return -1;\n\n//     if (raw[0] >= opcodes.OP_1 && raw[0] <= opcodes.OP_16)\n//       return raw[0] - 0x50;\n\n//     if (raw[0] > 0x06)\n//       return -1;\n\n//     const op = Opcode.fromRaw(raw);\n//     const num = op.toNum();\n\n//     if (!num)\n//       return 1;\n\n//     if (num.isNeg())\n//       return -1;\n\n//     if (!op.equals(Opcode.fromNum(num)))\n//       return -1;\n\n//     return num.toDouble();\n//   }\n\n//   /**\n//    * Test the script against a bloom filter.\n//    * @param {Bloom} filter\n//    * @returns {Boolean}\n//    */\n\n//   test(filter) {\n//     for (const op of this.code) {\n//       if (op.value === -1)\n//         break;\n\n//       if (!op.data || op.data.length === 0)\n//         continue;\n\n//       if (filter.test(op.data))\n//         return true;\n//     }\n\n//     return false;\n//   }\n\n//   /**\n//    * Test the script to see if it contains only push ops.\n//    * Push ops are: OP_1NEGATE, OP_0-OP_16 and all PUSHDATAs.\n//    * @returns {Boolean}\n//    */\n\n//   isPushOnly() {\n//     for (const op of this.code) {\n//       if (op.value === -1)\n//         return false;\n\n//       if (op.value > opcodes.OP_16)\n//         return false;\n//     }\n\n//     return true;\n//   }\n\n//   /**\n//    * Count the sigops in the script.\n//    * @param {Boolean} accurate - Whether to enable accurate counting. This will\n//    * take into account the `n` value for OP_CHECKMULTISIG(VERIFY).\n//    * @returns {Number} sigop count\n//    */\n\n//   getSigops(accurate, flags) {\n//     if (flags & Script.flags.VERIFY_ZERO_SIGOPS)\n//       return 0;\n\n//     let total = 0;\n//     let lastOp = -1;\n\n//     for (const op of this.code) {\n//       if (op.value === -1)\n//         break;\n\n//       switch (op.value) {\n//         case opcodes.OP_CHECKSIG:\n//         case opcodes.OP_CHECKSIGVERIFY:\n//           total += 1;\n//           break;\n//         case opcodes.OP_CHECKSDATAIG:\n//         case opcodes.OP_CHECKDATASIGVERIFY:\n//           if (flags & Script.flags.VERIFY_CHECKDATASIG) {\n//             total += 1;\n//           }\n//           break;\n//         case opcodes.OP_CHECKMULTISIG:\n//         case opcodes.OP_CHECKMULTISIGVERIFY:\n//           if (accurate && lastOp >= opcodes.OP_1 && lastOp <= opcodes.OP_16)\n//             total += lastOp - 0x50;\n//           else\n//             total += consensus.MAX_MULTISIG_PUBKEYS;\n//           break;\n//       }\n\n//       lastOp = op.value;\n//     }\n\n//     return total;\n//   }\n\n//   /**\n//    * Count the sigops in the script, taking into account redeem scripts.\n//    * @param {Script} input - Input script, needed for access to redeem script.\n//    * @param {VerifyFlags} flags\n//    * @returns {Number} sigop count\n//    */\n\n//   getScripthashSigops(input, flags) {\n//     if (!this.isScripthash())\n//       return this.getSigops(true, flags);\n\n//     const redeem = input.getRedeem();\n\n//     if (!redeem)\n//       return 0;\n\n//     return redeem.getSigops(true, flags);\n//   }\n\n//   /*\n//    * Mutation\n//    */\n\n//   get(index) {\n//     if (index < 0)\n//       index += this.code.length;\n\n//     if (index < 0 || index >= this.code.length)\n//       return null;\n\n//     return this.code[index];\n//   }\n\n//   pop() {\n//     const op = this.code.pop();\n//     return op || null;\n//   }\n\n//   shift() {\n//     const op = this.code.shift();\n//     return op || null;\n//   }\n\n//   remove(index) {\n//     if (index < 0)\n//       index += this.code.length;\n\n//     if (index < 0 || index >= this.code.length)\n//       return null;\n\n//     const items = this.code.splice(index, 1);\n\n//     if (items.length === 0)\n//       return null;\n\n//     return items[0];\n//   }\n\n//   set(index, op) {\n//     if (index < 0)\n//       index += this.code.length;\n\n//     assert(Opcode.isOpcode(op));\n//     assert(index >= 0 && index <= this.code.length);\n\n//     this.code[index] = op;\n\n//     return this;\n//   }\n\n//   push(op) {\n//     assert(Opcode.isOpcode(op));\n//     this.code.push(op);\n//     return this;\n//   }\n\n//   unshift(op) {\n//     assert(Opcode.isOpcode(op));\n//     this.code.unshift(op);\n//     return this;\n//   }\n\n//   insert(index, op) {\n//     if (index < 0)\n//       index += this.code.length;\n\n//     assert(Opcode.isOpcode(op));\n//     assert(index >= 0 && index <= this.code.length);\n\n//     this.code.splice(index, 0, op);\n\n//     return this;\n//   }\n\n//   /*\n//    * Op\n//    */\n\n//   getOp(index) {\n//     const op = this.get(index);\n//     return op ? op.value : -1;\n//   }\n\n//   popOp() {\n//     const op = this.pop();\n//     return op ? op.value : -1;\n//   }\n\n//   shiftOp() {\n//     const op = this.shift();\n//     return op ? op.value : -1;\n//   }\n\n//   removeOp(index) {\n//     const op = this.remove(index);\n//     return op ? op.value : -1;\n//   }\n\n//   setOp(index, value) {\n//     return this.set(index, Opcode.fromOp(value));\n//   }\n\n//   pushOp(value) {\n//     return this.push(Opcode.fromOp(value));\n//   }\n\n//   unshiftOp(value) {\n//     return this.unshift(Opcode.fromOp(value));\n//   }\n\n//   insertOp(index, value) {\n//     return this.insert(index, Opcode.fromOp(value));\n//   }\n\n//   /*\n//    * Data\n//    */\n\n//   getData(index) {\n//     const op = this.get(index);\n//     return op ? op.data : null;\n//   }\n\n//   popData() {\n//     const op = this.pop();\n//     return op ? op.data : null;\n//   }\n\n//   shiftData() {\n//     const op = this.shift();\n//     return op ? op.data : null;\n//   }\n\n//   removeData(index) {\n//     const op = this.remove(index);\n//     return op ? op.data : null;\n//   }\n\n//   setData(index, data) {\n//     return this.set(index, Opcode.fromData(data));\n//   }\n\n//   pushData(data) {\n//     return this.push(Opcode.fromData(data));\n//   }\n\n//   unshiftData(data) {\n//     return this.unshift(Opcode.fromData(data));\n//   }\n\n//   insertData(index, data) {\n//     return this.insert(index, Opcode.fromData(data));\n//   }\n\n//   /*\n//    * Length\n//    */\n\n//   getLength(index) {\n//     const op = this.get(index);\n//     return op ? op.toLength() : -1;\n//   }\n\n//   /*\n//    * Push\n//    */\n\n//   getPush(index) {\n//     const op = this.get(index);\n//     return op ? op.toPush() : null;\n//   }\n\n//   popPush() {\n//     const op = this.pop();\n//     return op ? op.toPush() : null;\n//   }\n\n//   shiftPush() {\n//     const op = this.shift();\n//     return op ? op.toPush() : null;\n//   }\n\n//   removePush(index) {\n//     const op = this.remove(index);\n//     return op ? op.toPush() : null;\n//   }\n\n//   setPush(index, data) {\n//     return this.set(index, Opcode.fromPush(data));\n//   }\n\n//   pushPush(data) {\n//     return this.push(Opcode.fromPush(data));\n//   }\n\n//   unshiftPush(data) {\n//     return this.unshift(Opcode.fromPush(data));\n//   }\n\n//   insertPush(index, data) {\n//     return this.insert(index, Opcode.fromPush(data));\n//   }\n\n//   /*\n//    * String\n//    */\n\n//   getString(index, enc) {\n//     const op = this.get(index);\n//     return op ? op.toString(enc) : null;\n//   }\n\n//   popString(enc) {\n//     const op = this.pop();\n//     return op ? op.toString(enc) : null;\n//   }\n\n//   shiftString(enc) {\n//     const op = this.shift();\n//     return op ? op.toString(enc) : null;\n//   }\n\n//   removeString(index, enc) {\n//     const op = this.remove(index);\n//     return op ? op.toString(enc) : null;\n//   }\n\n//   setString(index, str, enc) {\n//     return this.set(index, Opcode.fromString(str, enc));\n//   }\n\n//   pushString(str, enc) {\n//     return this.push(Opcode.fromString(str, enc));\n//   }\n\n//   unshiftString(str, enc) {\n//     return this.unshift(Opcode.fromString(str, enc));\n//   }\n\n//   insertString(index, str, enc) {\n//     return this.insert(index, Opcode.fromString(str, enc));\n//   }\n\n//   /*\n//    * Small\n//    */\n\n//   getSmall(index) {\n//     const op = this.get(index);\n//     return op ? op.toSmall() : -1;\n//   }\n\n//   popSmall() {\n//     const op = this.pop();\n//     return op ? op.toSmall() : -1;\n//   }\n\n//   shiftSmall() {\n//     const op = this.shift();\n//     return op ? op.toSmall() : -1;\n//   }\n\n//   removeSmall(index) {\n//     const op = this.remove(index);\n//     return op ? op.toSmall() : -1;\n//   }\n\n//   setSmall(index, num) {\n//     return this.set(index, Opcode.fromSmall(num));\n//   }\n\n//   pushSmall(num) {\n//     return this.push(Opcode.fromSmall(num));\n//   }\n\n//   unshiftSmall(num) {\n//     return this.unshift(Opcode.fromSmall(num));\n//   }\n\n//   insertSmall(index, num) {\n//     return this.insert(index, Opcode.fromSmall(num));\n//   }\n\n//   /*\n//    * Num\n//    */\n\n//   getNum(index, minimal, limit) {\n//     const op = this.get(index);\n//     return op ? op.toNum(minimal, limit) : null;\n//   }\n\n//   popNum(minimal, limit) {\n//     const op = this.pop();\n//     return op ? op.toNum(minimal, limit) : null;\n//   }\n\n//   shiftNum(minimal, limit) {\n//     const op = this.shift();\n//     return op ? op.toNum(minimal, limit) : null;\n//   }\n\n//   removeNum(index, minimal, limit) {\n//     const op = this.remove(index);\n//     return op ? op.toNum(minimal, limit) : null;\n//   }\n\n//   setNum(index, num) {\n//     return this.set(index, Opcode.fromNum(num));\n//   }\n\n//   pushNum(num) {\n//     return this.push(Opcode.fromNum(num));\n//   }\n\n//   unshiftNum(num) {\n//     return this.unshift(Opcode.fromNum(num));\n//   }\n\n//   insertNum(index, num) {\n//     return this.insert(index, Opcode.fromNum(num));\n//   }\n\n//   /*\n//    * Int\n//    */\n\n//   getInt(index, minimal, limit) {\n//     const op = this.get(index);\n//     return op ? op.toInt(minimal, limit) : -1;\n//   }\n\n//   popInt(minimal, limit) {\n//     const op = this.pop();\n//     return op ? op.toInt(minimal, limit) : -1;\n//   }\n\n//   shiftInt(minimal, limit) {\n//     const op = this.shift();\n//     return op ? op.toInt(minimal, limit) : -1;\n//   }\n\n//   removeInt(index, minimal, limit) {\n//     const op = this.remove(index);\n//     return op ? op.toInt(minimal, limit) : -1;\n//   }\n\n//   setInt(index, num) {\n//     return this.set(index, Opcode.fromInt(num));\n//   }\n\n//   pushInt(num) {\n//     return this.push(Opcode.fromInt(num));\n//   }\n\n//   unshiftInt(num) {\n//     return this.unshift(Opcode.fromInt(num));\n//   }\n\n//   insertInt(index, num) {\n//     return this.insert(index, Opcode.fromInt(num));\n//   }\n\n//   /*\n//    * Bool\n//    */\n\n//   getBool(index) {\n//     const op = this.get(index);\n//     return op ? op.toBool() : false;\n//   }\n\n//   popBool() {\n//     const op = this.pop();\n//     return op ? op.toBool() : false;\n//   }\n\n//   shiftBool() {\n//     const op = this.shift();\n//     return op ? op.toBool() : false;\n//   }\n\n//   removeBool(index) {\n//     const op = this.remove(index);\n//     return op ? op.toBool() : false;\n//   }\n\n//   setBool(index, value) {\n//     return this.set(index, Opcode.fromBool(value));\n//   }\n\n//   pushBool(value) {\n//     return this.push(Opcode.fromBool(value));\n//   }\n\n//   unshiftBool(value) {\n//     return this.unshift(Opcode.fromBool(value));\n//   }\n\n//   insertBool(index, value) {\n//     return this.insert(index, Opcode.fromBool(value));\n//   }\n\n//   /*\n//    * Symbol\n//    */\n\n//   getSym(index) {\n//     const op = this.get(index);\n//     return op ? op.toSymbol() : null;\n//   }\n\n//   popSym() {\n//     const op = this.pop();\n//     return op ? op.toSymbol() : null;\n//   }\n\n//   shiftSym() {\n//     const op = this.shift();\n//     return op ? op.toSymbol() : null;\n//   }\n\n//   removeSym(index) {\n//     const op = this.remove(index);\n//     return op ? op.toSymbol() : null;\n//   }\n\n//   setSym(index, symbol) {\n//     return this.set(index, Opcode.fromSymbol(symbol));\n//   }\n\n//   pushSym(symbol) {\n//     return this.push(Opcode.fromSymbol(symbol));\n//   }\n\n//   unshiftSym(symbol) {\n//     return this.unshift(Opcode.fromSymbol(symbol));\n//   }\n\n//   insertSym(index, symbol) {\n//     return this.insert(index, Opcode.fromSymbol(symbol));\n//   }\n\n//   /**\n//    * Inject properties from bitcoind test string.\n//    * @private\n//    * @param {String} items - Script string.\n//    * @throws Parse error.\n//    */\n\n//   fromString(code) {\n//     assert(typeof code === 'string');\n\n//     code = code.trim();\n\n//     if (code.length === 0)\n//       return this;\n\n//     const items = code.split(/\\s+/);\n//     const bw = bio.write();\n\n//     for (const item of items) {\n//       let symbol = item;\n\n//       if (symbol.charCodeAt(0) & 32)\n//         symbol = symbol.toUpperCase();\n\n//       if (!/^OP_/.test(symbol))\n//         symbol = `OP_${symbol}`;\n\n//       const value = opcodes[symbol];\n\n//       if (value == null) {\n//         if (item[0] === '\\'') {\n//           assert(item[item.length - 1] === '\\'', 'Invalid string.');\n//           const str = item.slice(1, -1);\n//           const op = Opcode.fromString(str);\n//           bw.writeBytes(op.toRaw());\n//           continue;\n//         }\n\n//         if (/^-?\\d+$/.test(item)) {\n//           const num = ScriptNum.fromString(item, 10);\n//           const op = Opcode.fromNum(num);\n//           bw.writeBytes(op.toRaw());\n//           continue;\n//         }\n\n//         assert(item.indexOf('0x') === 0, 'Unknown opcode.');\n\n//         const hex = item.substring(2);\n//         const data = Buffer.from(hex, 'hex');\n\n//         assert(data.length === hex.length / 2, 'Invalid hex string.');\n\n//         bw.writeBytes(data);\n\n//         continue;\n//       }\n\n//       bw.writeU8(value);\n//     }\n\n//     return this.fromRaw(bw.render());\n//   }\n\n//   /**\n//    * Parse a bitcoind test script\n//    * string into a script object.\n//    * @param {String} items - Script string.\n//    * @returns {Script}\n//    * @throws Parse error.\n//    */\n\n//   static fromString(code) {\n//     return new this().fromString(code);\n//   }\n\n//   /**\n//    * Verify an input and output script, and a witness if present.\n//    * @param {Script} input\n//    * @param {Null} witness\n//    * @param {Script} output\n//    * @param {TX} tx\n//    * @param {Number} index\n//    * @param {Amount} value\n//    * @param {VerifyFlags} flags\n//    * @param {Number?} sigchecks\n//    * @throws {ScriptError}\n//    */\n\n//   static verify(input, witness, output, tx, index, value, flags, sigchecks) {\n//     if (flags == null)\n//       flags = Script.flags.STANDARD_VERIFY_FLAGS;\n\n//     if (flags & Script.flags.VERIFY_SIGPUSHONLY) {\n//       if (!input.isPushOnly())\n//         throw new ScriptError('SIG_PUSHONLY');\n//     }\n\n//     if (flags & Script.flags.VERIFY_SIGHASH_FORKID)\n//       flags |= Script.flags.VERIFY_STRICTENC;\n\n//     // Setup a stack.\n//     let stack = new Stack();\n\n//     // Execute the input script\n//     input.execute(stack, flags, tx, index, value, metrics.sigchecks);\n\n//     // Copy the stack for P2SH\n//     let copy;\n//     if (flags & Script.flags.VERIFY_P2SH)\n//       copy = stack.clone();\n\n//     // Execute the previous output script.\n//     output.execute(stack, flags, tx, index, value, metrics.sigchecks);\n\n//     // Verify the stack values.\n//     if (stack.length === 0 || !stack.getBool(-1))\n//       throw new ScriptError('EVAL_FALSE');\n\n//     // If the script is P2SH, execute the real output script\n//     if ((flags & Script.flags.VERIFY_P2SH) && output.isScripthash()) {\n//       // P2SH can only have push ops in the scriptSig\n//       if (!input.isPushOnly())\n//         throw new ScriptError('SIG_PUSHONLY');\n\n//       // Reset the stack\n//       stack = copy;\n\n//       // Stack should not be empty at this point\n//       if (stack.length === 0)\n//         throw new ScriptError('EVAL_FALSE');\n\n//       // Grab the real redeem script\n//       const raw = stack.pop();\n//       const redeem = Script.fromRaw(raw);\n\n//       if ((flags & Script.flags.VERIFY_DISALLOW_SEGWIT_RECOVERY) === 0\n//          && stack.length === 0 && redeem.isProgram()) {\n\n//         // Before activation all transaction count a value of 0\n//         if (!(flags & Script.flags.REPORT_SIGCHECKS)) {\n//           metrics.sigchecks = 0;\n//         }\n//         return;\n//       }\n\n//         // Execute the redeem script.\n//       redeem.execute(stack, flags, tx, index, value, 0, metrics.sigchecks);\n\n//       // Verify the the stack values.\n//       if (stack.length === 0 || !stack.getBool(-1))\n//         throw new ScriptError('EVAL_FALSE');\n//     }\n\n//     // Ensure there is nothing left on the stack.\n//     if (flags & Script.flags.VERIFY_CLEANSTACK) {\n//       assert((flags & Script.flags.VERIFY_P2SH) !== 0);\n//       if (stack.length !== 1)\n//         throw new ScriptError('CLEANSTACK');\n//     }\n\n//     if (flags & Script.flags.VERIFY_INPUT_SIGCHECKS) {\n//       if (input.getSize() < metrics.sigchecks * 43 - 60)\n//         throw new ScriptError('INPUT_SIGCHECKS');\n//     }\n\n//     if (!(flags & Script.flags.REPORT_SIGCHECKS)) {\n//       metrics.sigchecks = 0;\n//     }\n//   }\n\n//   /**\n//    * Inject properties from buffer reader.\n//    * @private\n//    * @param {BufferReader} br\n//    */\n\n//   fromReader(br) {\n//     return this.fromRaw(br.readVarBytes());\n//   }\n\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer}\n   */\n\n  fromRaw(data) {\n    const br = bio.read(data);\n\n    this.raw = data;\n\n    while (br.left())\n      this.code.push(Opcode.fromReader(br));\n\n    return this;\n  }\n\n//   /**\n//    * Create a script from buffer reader.\n//    * @param {BufferReader} br\n//    * @param {String?} enc - Either `\"hex\"` or `null`.\n//    * @returns {Script}\n//    */\n\n//   static fromReader(br) {\n//     return new this().fromReader(br);\n//   }\n\n//   /**\n//    * Create a script from a serialized buffer.\n//    * @param {Buffer|String} data - Serialized script.\n//    * @param {String?} enc - Either `\"hex\"` or `null`.\n//    * @returns {Script}\n//    */\n\n  static fromRaw(data, enc) {\n    if (typeof data === 'string')\n      data = Buffer.from(data, enc);\n    return new this().fromRaw(data);\n  }\n\n//   /**\n//    * Test whether an object a Script.\n//    * @param {Object} obj\n//    * @returns {Boolean}\n//    */\n\n//   static isScript(obj) {\n//     return obj instanceof Script;\n//   }\n}\n\n// /**\n//  * Script opcodes.\n//  * @enum {Number}\n//  * @default\n//  */\n\n// Script.opcodes = common.opcodes;\n\n// /**\n//  * Opcodes by value.\n//  * @const {RevMap}\n//  */\n\n// Script.opcodesByVal = common.opcodesByVal;\n\n// /**\n//  * Script and locktime flags. See {@link VerifyFlags}.\n//  * @enum {Number}\n//  */\n\n// Script.flags = common.flags;\n\n// /**\n//  * Sighash Types.\n//  * @enum {SighashType}\n//  * @default\n//  */\n\n// Script.hashType = common.hashType;\n\n// /**\n//  * Sighash types by value.\n//  * @const {RevMap}\n//  */\n\n// Script.hashTypeByVal = common.hashTypeByVal;\n\n// /**\n//  * Output script types.\n//  * @enum {Number}\n//  */\n\n// Script.types = common.types;\n\n// /**\n//  * Output script types by value.\n//  * @const {RevMap}\n//  */\n\n// Script.typesByVal = common.typesByVal;\n\n// /*\n//  * Helpers\n//  */\n\n// function sortKeys(keys) {\n//   return keys.slice().sort((a, b) => {\n//     return a.compare(b);\n//   });\n// }\n\n// /**\n//  * Test whether the data element is a valid key if VERIFY_STRICTENC is enabled.\n//  * @param {Buffer} key\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n\n// function validateKey(key, flags) {\n//   assert(Buffer.isBuffer(key));\n//   assert(typeof flags === 'number');\n\n//   if (flags & Script.flags.VERIFY_STRICTENC) {\n//     if (!common.isKeyEncoding(key))\n//       throw new ScriptError('PUBKEYTYPE');\n//   }\n\n//   if ((flags & Script.flags.VERIFY_COMPRESSED_PUBKEYTYPE)\n//     && !common.isCompressedEncoding(key)) {\n//     throw new ScriptError('NONCOMPRESSED_PUBKEY');\n//   };\n\n//   return true;\n// }\n\n// /**\n//  * Test whether the raw element is a valid signature based\n//  * on the encoding, S value, and sighash type.\n//  * In an ECDSA-only context, 64-byte signatures are bannned\n//  * when Schnorr Flag is set.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n\n// function validateECDSASignature(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n\n//   if (common.isSchnorr(sig))\n//     throw new ScriptError('SIG_BADLENGTH');\n\n//   if ((flags & Script.flags.VERIFY_DERSIG)\n//       || (flags & Script.flags.VERIFY_LOW_S)\n//       || (flags & Script.flags.VERIFY_STRICTENC)) {\n//     if (!common.isDERSignatureEncoding(sig))\n//       throw new ScriptError('SIG_DER');\n//   }\n\n//   if (flags & Script.flags.VERIFY_LOW_S) {\n//     if (!common.isLowDER(sig))\n//       throw new ScriptError('SIG_HIGH_S');\n//   }\n\n//   return true;\n// }\n\n// /**\n//  * Test whether the tx element is a valid signature based\n//  * on the encoding, S value, and sighash type. Requires\n//  * VERIFY_STRICTENC, VERIFY_SIGHASH_FORKID to be enabled respectively.\n//  * Note that this will allow zero-length signatures.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n\n// function checkSighashEncoding(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n\n//   if (flags & Script.flags.VERIFY_STRICTENC) {\n//     if (!common.isHashType(sig))\n//       throw new ScriptError('SIG_HASHTYPE');\n\n//     const usesFork = sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID;\n//     const forkEnabled = flags & Script.flags.VERIFY_SIGHASH_FORKID;\n\n//     if (!forkEnabled && usesFork)\n//       throw new ScriptError('ILLEGAL_FORKID');\n\n//     if (forkEnabled && !usesFork)\n//       throw new ScriptError('MUST_USE_FORKID');\n//   }\n\n//   return true;\n// }\n\n// /**\n//  * Test whether the transaction tested against\n//  * the Sighash Encoding is a valid Schnorr Signature.\n//  * Requires Sighash\n//  * @param {Buffer} sig\n//  * @param {VeirfyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n\n// function checkTransactionSignature(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n\n//   // allow empty sigs\n//   if (sig.length === 0)\n//     return true;\n\n//   validateSchnorrSignature(sig.slice(0, -1), flags);\n\n//   return checkSighashEncoding(sig, flags);\n// }\n\n// /**\n//  * Test whether the transaction is tested\n//  * against the sighash encoding w schnorr / ecdsa\n//  * for multisig opcodes.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  */\n\n// function checkTransactionSchnorrSig(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n\n//   // Allow empty sigs.\n//   if (sig.length === 0)\n//     return true;\n\n//   if (!isSchnorrEncoded(sig.slice(0, -1), flags))\n//     return validateECDSASignature(sig.slice(0, -1), flags);\n\n//   return checkSighashEncoding(sig, flags);\n// }\n\n// /**\n//  * Test whether the transaction tested against\n//  * the Sighash Encoding is a valid ECDSA Signature.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n\n// function checkTransactionECDSASignature(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n\n//   // Allow empty sigs\n//   if (sig.length === 0)\n//     return true;\n\n//   validateECDSASignature(sig.slice(0, -1), flags);\n\n//   return checkSighashEncoding(sig, flags);\n// }\n\n// /**\n//  * Test whether the data element is a valid signature based\n//  * on the encoding, S value, and sighash type. Requires\n//  * VERIFY_DERSIG|VERIFY_LOW_S|VERIFY_STRICTENC, and VERIFY_LOW_S\n//  * to be enabled respectively. Note that this will allow zero-length\n//  * signatures.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n\n// function validateDataSignature(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n\n//   // Allow empty sigs\n//   if (sig.length === 0)\n//     return true;\n\n//   return validateSchnorrSignature(sig.slice(0, sig.length), flags);\n// }\n\n// /**\n//  * Test whether the Signature is valid in context\n//  * 64-byte signatures are interpreted as schnorr signatures.\n//  * Always correctly encoded when Verify_SCHNORR flag is set.\n//  * @param {Buffer} sig\n//  * @param {Buffer} msg - Signature hash.\n//  * @param {VerifyFlags?} flags\n//  * @returns {Promise}\n//  * @throws {ScriptError}\n//  */\n\n// function validateSchnorrSignature(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n\n//   if (common.isSchnorr(sig))\n//     return true;\n\n//   return validateECDSASignature(sig, flags);\n// }\n\n// /**\n//  * Test whether the current signature is schnorr encoded.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n\n// function isSchnorrEncoded(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n\n//   if (common.isSchnorr(sig))\n//     return true;\n\n//   throw new ScriptError('SIG_NONSCHNORR');\n// }\n\n// /**\n//  * Test whether the signature from the stack\n//  * is valid in either Schnorr or DER Format.\n//  * Always encoded correctly when Schnorr flag is set.\n//  * @param {Buffer} hash\n//  * @param {Buffer} sig\n//  * @param {Buffer} key\n//  * @param {Number} flags\n//  */\n\n// function verifySignature(hash, sig, key, flags) {\n//   assert(Buffer.isBuffer(hash));\n//   assert(Buffer.isBuffer(sig));\n//   assert(Buffer.isBuffer(key));\n//   assert(typeof flags === 'number');\n\n//   let res = false;\n\n//   if (sig.length === 64) {\n//     res = secp256k1.schnorrVerify(hash, sig, key, flags);\n//   } else {\n//     res = secp256k1.verifyDER(hash, sig, key, flags);\n//   }\n\n//   return res;\n// }\n\n// /**\n//  * Verify a signature, taking into account sighash type.\n//  * @param {Buffer} msg - Signature hash.\n//  * @param {Buffer} sig\n//  * @param {Buffer} key\n//  * @returns {Boolean}\n//  */\n\n// function checksig(msg, sig, key) {\n//   return secp256k1.verifyDER(msg, sig.slice(0, -1), key);\n// }\n\n/*\n * Expose\n */\n\nmodule.exports = Script;\n"]},"metadata":{},"sourceType":"module"}