{"ast":null,"code":"/*!\n * mrkl.js - merkle trees for bcrypto\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n */\n'use strict';\n\nconst assert = require('./internal/assert');\n/*\n * Constants\n */\n\n\nconst EMPTY = Buffer.alloc(0);\nconst INTERNAL = Buffer.from([0x01]);\nconst LEAF = Buffer.from([0x00]);\n/**\n * Build a merkle tree from leaves.\n * @param {Object} alg\n * @param {Buffer[]} leaves\n * @returns {Buffer[]} nodes\n */\n\nfunction createTree(alg, leaves) {\n  assert(alg && typeof alg.multi === 'function');\n  assert(Array.isArray(leaves));\n  const nodes = [];\n  const sentinel = hashEmpty(alg);\n\n  for (const data of leaves) {\n    const leaf = hashLeaf(alg, data);\n    nodes.push(leaf);\n  }\n\n  let size = nodes.length;\n  let i = 0;\n\n  if (size === 0) {\n    nodes.push(sentinel);\n    return nodes;\n  }\n\n  while (size > 1) {\n    for (let j = 0; j < size; j += 2) {\n      const l = j;\n      const r = j + 1;\n      const left = nodes[i + l];\n      let right;\n      if (r < size) right = nodes[i + r];else right = sentinel;\n      const hash = hashInternal(alg, left, right);\n      nodes.push(hash);\n    }\n\n    i += size;\n    size = size + 1 >>> 1;\n  }\n\n  return nodes;\n}\n/**\n * Calculate merkle root from leaves.\n * @param {Object} alg\n * @param {Buffer[]} leaves\n * @returns {Buffer} root\n */\n\n\nfunction createRoot(alg, leaves) {\n  const nodes = createTree(alg, leaves);\n  const root = nodes[nodes.length - 1];\n  return root;\n}\n/**\n * Collect a merkle branch from vector index.\n * @param {Object} alg\n * @param {Number} index\n * @param {Buffer[]} leaves\n * @returns {Buffer[]} branch\n */\n\n\nfunction createBranch(alg, index, leaves) {\n  assert(index >>> 0 === index);\n  const nodes = createTree(alg, leaves);\n  const sentinel = hashEmpty(alg);\n  const branch = [];\n  let size = leaves.length;\n  let i = 0;\n  assert(index < leaves.length);\n\n  while (size > 1) {\n    const j = index ^ 1;\n    if (j < size) branch.push(nodes[i + j]);else branch.push(sentinel);\n    index >>>= 1;\n    i += size;\n    size = size + 1 >>> 1;\n  }\n\n  return branch;\n}\n/**\n * Derive merkle root from branch.\n * @param {Object} alg\n * @param {Buffer} leaf\n * @param {Buffer[]} branch\n * @param {Number} index\n * @returns {Buffer} root\n */\n\n\nfunction deriveRoot(alg, leaf, branch, index) {\n  assert(alg && typeof alg.multi === 'function');\n  assert(Buffer.isBuffer(leaf));\n  assert(Array.isArray(branch));\n  assert(index >>> 0 === index);\n  let root = hashLeaf(alg, leaf);\n\n  for (const hash of branch) {\n    if (index & 1) root = hashInternal(alg, hash, root);else root = hashInternal(alg, root, hash);\n    index >>>= 1;\n  }\n\n  return root;\n}\n/**\n * Get sentinel hash.\n * @param {Object} alg\n * @returns {Buffer}\n */\n\n\nfunction hashEmpty(alg) {\n  return alg.digest(EMPTY);\n}\n/**\n * Hash a leaf node.\n * @param {Object} alg\n * @param {Buffer} data\n * @returns {Buffer}\n */\n\n\nfunction hashLeaf(alg, data) {\n  return alg.multi(LEAF, data);\n}\n/**\n * Hash an internal node.\n * @param {Object} alg\n * @param {Buffer} left\n * @param {Buffer} right\n * @returns {Buffer}\n */\n\n\nfunction hashInternal(alg, left, right) {\n  assert(right != null);\n  return alg.multi(INTERNAL, left, right);\n}\n/*\n * Expose\n */\n\n\nexports.createTree = createTree;\nexports.createRoot = createRoot;\nexports.createBranch = createBranch;\nexports.deriveRoot = deriveRoot;\nexports.hashEmpty = hashEmpty;\nexports.hashLeaf = hashLeaf;\nexports.hashInternal = hashInternal;","map":null,"metadata":{},"sourceType":"script"}