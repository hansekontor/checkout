{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.qrcode.detector {*/\n\nvar ResultPoint_1 = require(\"../../ResultPoint\");\n/**\r\n * <p>Encapsulates a finder pattern, which are the three square patterns found in\r\n * the corners of QR Codes. It also encapsulates a count of similar finder patterns,\r\n * as a convenience to the finder's bookkeeping.</p>\r\n *\r\n * @author Sean Owen\r\n */\n\n\nvar FinderPattern =\n/** @class */\nfunction (_super) {\n  __extends(FinderPattern, _super); // FinderPattern(posX: number/*float*/, posY: number/*float*/, estimatedModuleSize: number/*float*/) {\n  //   this(posX, posY, estimatedModuleSize, 1)\n  // }\n\n\n  function FinderPattern(posX\n  /*float*/\n  , posY\n  /*float*/\n  , estimatedModuleSize\n  /*float*/\n  , count\n  /*int*/\n  ) {\n    var _this = _super.call(this, posX, posY) || this;\n\n    _this.estimatedModuleSize = estimatedModuleSize;\n    _this.count = count;\n\n    if (undefined === count) {\n      _this.count = 1;\n    }\n\n    return _this;\n  }\n\n  FinderPattern.prototype.getEstimatedModuleSize = function () {\n    return this.estimatedModuleSize;\n  };\n\n  FinderPattern.prototype.getCount = function () {\n    return this.count;\n  };\n  /*\r\n  void incrementCount() {\r\n    this.count++\r\n  }\r\n   */\n\n  /**\r\n   * <p>Determines if this finder pattern \"about equals\" a finder pattern at the stated\r\n   * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>\r\n   */\n\n\n  FinderPattern.prototype.aboutEquals = function (moduleSize\n  /*float*/\n  , i\n  /*float*/\n  , j\n  /*float*/\n  ) {\n    if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {\n      var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);\n      return moduleSizeDiff <= 1.0 || moduleSizeDiff <= this.estimatedModuleSize;\n    }\n\n    return false;\n  };\n  /**\r\n   * Combines this object's current estimate of a finder pattern position and module size\r\n   * with a new estimate. It returns a new {@code FinderPattern} containing a weighted average\r\n   * based on count.\r\n   */\n\n\n  FinderPattern.prototype.combineEstimate = function (i\n  /*float*/\n  , j\n  /*float*/\n  , newModuleSize\n  /*float*/\n  ) {\n    var combinedCount = this.count + 1;\n    var combinedX = (this.count * this.getX() + j) / combinedCount;\n    var combinedY = (this.count * this.getY() + i) / combinedCount;\n    var combinedModuleSize = (this.count * this.estimatedModuleSize + newModuleSize) / combinedCount;\n    return new FinderPattern(combinedX, combinedY, combinedModuleSize, combinedCount);\n  };\n\n  return FinderPattern;\n}(ResultPoint_1.default);\n\nexports.default = FinderPattern;","map":null,"metadata":{},"sourceType":"script"}