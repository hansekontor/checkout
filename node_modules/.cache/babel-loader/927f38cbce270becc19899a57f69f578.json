{"ast":null,"code":"/*!\n * opcode.js - opcode object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bio = require('bufio');\n\nconst ScriptNum = require('./scriptnum');\n\nconst common = require('./common');\n\nconst opcodes = common.opcodes;\nconst opCache = [];\nlet PARSE_ERROR = null;\n/**\n * Opcode\n * A simple struct which contains\n * an opcode and pushdata buffer.\n * @alias module:script.Opcode\n * @property {Number} value\n * @property {Buffer|null} data\n */\n\nclass Opcode {\n  /**\n   * Create an opcode.\n   * Note: this should not be called directly.\n   * @constructor\n   * @param {Number} value - Opcode.\n   * @param {Buffer?} data - Pushdata buffer.\n   */\n  constructor(value, data) {\n    this.value = value || 0;\n    this.data = data || null;\n  } //   /**\n  //    * Test whether a pushdata abides by minimaldata.\n  //    * @returns {Boolean}\n  //    */\n  //   isMinimal() {\n  //     assert(0 <= this.value && this.value <= opcodes.OP_PUSHDATA4);\n  //     if (!this.data)\n  //       return true;\n  //     if (this.data.length === 1) {\n  //       if (this.data[0] === 0x81)\n  //         return false;\n  //       if (this.data[0] >= 1 && this.data[0] <= 16)\n  //         return false;\n  //     }\n  //     if (this.data.length <= 0x4b)\n  //       return this.value === this.data.length;\n  //     if (this.data.length <= 0xff)\n  //       return this.value === opcodes.OP_PUSHDATA1;\n  //     if (this.data.length <= 0xffff)\n  //       return this.value === opcodes.OP_PUSHDATA2;\n  //     return true;\n  //   }\n  //   /**\n  //    * Test whether opcode is a disabled opcode.\n  //    * @param {Number?} flags - Script standard flags.\n  //    * @returns {Boolean}\n  //    */\n  //   isDisabled(flags) {\n  //     switch (this.value) {\n  //       case opcodes.OP_INVERT:\n  //       case opcodes.OP_2MUL:\n  //       case opcodes.OP_2DIV:\n  //       case opcodes.OP_MUL:\n  //       case opcodes.OP_LSHIFT:\n  //       case opcodes.OP_RSHIFT:\n  //         return true;\n  //     }\n  //     return false;\n  //   }\n  //   /**\n  //    * Test whether opcode is a branch (if/else/endif).\n  //    * @returns {Boolean}\n  //    */\n  //   isBranch() {\n  //     return this.value >= opcodes.OP_IF && this.value <= opcodes.OP_ENDIF;\n  //   }\n  //   /**\n  //    * Test opcode equality.\n  //    * @param {Opcode} op\n  //    * @returns {Boolean}\n  //    */\n  //   equals(op) {\n  //     assert(Opcode.isOpcode(op));\n  //     if (this.value !== op.value)\n  //       return false;\n  //     if (!this.data) {\n  //       assert(!op.data);\n  //       return true;\n  //     }\n  //     assert(op.data);\n  //     return this.data.equals(op.data);\n  //   }\n  //   /**\n  //    * Convert Opcode to opcode value.\n  //    * @returns {Number}\n  //    */\n  //   toOp() {\n  //     return this.value;\n  //   }\n  //   /**\n  //    * Covert opcode to data push.\n  //    * @returns {Buffer|null}\n  //    */\n  //   toData() {\n  //     return this.data;\n  //   }\n  //   /**\n  //    * Covert opcode to data length.\n  //    * @returns {Number}\n  //    */\n  //   toLength() {\n  //     return this.data ? this.data.length : -1;\n  //   }\n  //   /**\n  //    * Covert and _cast_ opcode to data push.\n  //    * @returns {Buffer|null}\n  //    */\n  //   toPush() {\n  //     if (this.value === opcodes.OP_0)\n  //       return common.small[0 + 1];\n  //     if (this.value === opcodes.OP_1NEGATE)\n  //       return common.small[-1 + 1];\n  //     if (this.value >= opcodes.OP_1 && this.value <= opcodes.OP_16)\n  //       return common.small[this.value - 0x50 + 1];\n  //     return this.toData();\n  //   }\n  //   /**\n  //    * Get string for opcode.\n  //    * @param {String?} enc\n  //    * @returns {Buffer|null}\n  //    */\n  //   toString(enc) {\n  //     const data = this.toPush();\n  //     if (!data)\n  //       return null;\n  //     return data.toString(enc || 'utf8');\n  //   }\n  //   /**\n  //    * Convert opcode to small integer.\n  //    * @returns {Number}\n  //    */\n  //   toSmall() {\n  //     if (this.value === opcodes.OP_0)\n  //       return 0;\n  //     if (this.value >= opcodes.OP_1 && this.value <= opcodes.OP_16)\n  //       return this.value - 0x50;\n  //     return -1;\n  //   }\n  //   /**\n  //    * Convert opcode to script number.\n  //    * @param {Boolean?} minimal\n  //    * @param {Number?} limit\n  //    * @returns {ScriptNum|null}\n  //    */\n  //   toNum(minimal, limit) {\n  //     if (this.value === opcodes.OP_0)\n  //       return ScriptNum.fromInt(0);\n  //     if (this.value === opcodes.OP_1NEGATE)\n  //       return ScriptNum.fromInt(-1);\n  //     if (this.value >= opcodes.OP_1 && this.value <= opcodes.OP_16)\n  //       return ScriptNum.fromInt(this.value - 0x50);\n  //     if (!this.data)\n  //       return null;\n  //     return ScriptNum.decode(this.data, minimal, limit);\n  //   }\n  //   /**\n  //    * Convert opcode to integer.\n  //    * @param {Boolean?} minimal\n  //    * @param {Number?} limit\n  //    * @returns {Number}\n  //    */\n  //   toInt(minimal, limit) {\n  //     const num = this.toNum(minimal, limit);\n  //     if (!num)\n  //       return -1;\n  //     return num.getInt();\n  //   }\n  //   /**\n  //    * Convert opcode to boolean.\n  //    * @returns {Boolean}\n  //    */\n  //   toBool() {\n  //     const smi = this.toSmall();\n  //     if (smi === -1)\n  //       return false;\n  //     return smi === 1;\n  //   }\n  //   /**\n  //    * Convert opcode to its symbolic representation.\n  //    * @returns {String}\n  //    */\n  //   toSymbol() {\n  //     if (this.value === -1)\n  //       return 'OP_INVALIDOPCODE';\n  //     const symbol = common.opcodesByVal[this.value];\n  //     if (!symbol)\n  //       return `0x${hex8(this.value)}`;\n  //     return symbol;\n  //   }\n  //   /**\n  //    * Calculate opcode size.\n  //    * @returns {Number}\n  //    */\n  //   getSize() {\n  //     if (!this.data)\n  //       return 1;\n  //     switch (this.value) {\n  //       case opcodes.OP_PUSHDATA1:\n  //         return 2 + this.data.length;\n  //       case opcodes.OP_PUSHDATA2:\n  //         return 3 + this.data.length;\n  //       case opcodes.OP_PUSHDATA4:\n  //         return 5 + this.data.length;\n  //       default:\n  //         return 1 + this.data.length;\n  //     }\n  //   }\n  //   /**\n  //    * Encode the opcode to a buffer writer.\n  //    * @param {BufferWriter} bw\n  //    */\n  //   toWriter(bw) {\n  //     if (this.value === -1)\n  //       throw new Error('Cannot reserialize a parse error.');\n  //     if (!this.data) {\n  //       bw.writeU8(this.value);\n  //       return bw;\n  //     }\n  //     switch (this.value) {\n  //       case opcodes.OP_PUSHDATA1:\n  //         bw.writeU8(this.value);\n  //         bw.writeU8(this.data.length);\n  //         bw.writeBytes(this.data);\n  //         break;\n  //       case opcodes.OP_PUSHDATA2:\n  //         bw.writeU8(this.value);\n  //         bw.writeU16(this.data.length);\n  //         bw.writeBytes(this.data);\n  //         break;\n  //       case opcodes.OP_PUSHDATA4:\n  //         bw.writeU8(this.value);\n  //         bw.writeU32(this.data.length);\n  //         bw.writeBytes(this.data);\n  //         break;\n  //       default:\n  //         assert(this.value === this.data.length);\n  //         bw.writeU8(this.value);\n  //         bw.writeBytes(this.data);\n  //         break;\n  //     }\n  //     return bw;\n  //   }\n  //   /**\n  //    * Encode the opcode.\n  //    * @returns {Buffer}\n  //    */\n  //   toRaw() {\n  //     const size = this.getSize();\n  //     return this.toWriter(bio.write(size)).render();\n  //   }\n  //   /**\n  //    * Convert the opcode to a bitcoind test string.\n  //    * @returns {String} Human-readable script code.\n  //    */\n  //   toFormat() {\n  //     if (this.value === -1)\n  //       return '0x01';\n  //     if (this.data) {\n  //       // Numbers\n  //       if (this.data.length <= 4) {\n  //         const num = this.toNum();\n  //         if (this.equals(Opcode.fromNum(num)))\n  //           return num.toString(10);\n  //       }\n  //       const symbol = common.opcodesByVal[this.value];\n  //       const data = this.data.toString('hex');\n  //       // Direct push\n  //       if (!symbol) {\n  //         const size = hex8(this.value);\n  //         return `0x${size} 0x${data}`;\n  //       }\n  //       // Pushdatas\n  //       let size = this.data.length.toString(16);\n  //       while (size.length % 2 !== 0)\n  //         size = '0' + size;\n  //       return `${symbol} 0x${size} 0x${data}`;\n  //     }\n  //     // Opcodes\n  //     const symbol = common.opcodesByVal[this.value];\n  //     if (symbol)\n  //       return symbol;\n  //     // Unknown opcodes\n  //     const value = hex8(this.value);\n  //     return `0x${value}`;\n  //   }\n  //   /**\n  //    * Format the opcode as bitcoind asm.\n  //    * @param {Boolean?} decode - Attempt to decode hash types.\n  //    * @returns {String} Human-readable script.\n  //    */\n  //   toASM(decode) {\n  //     if (this.value === -1)\n  //       return '[error]';\n  //     if (this.data)\n  //       return common.toASM(this.data, decode);\n  //     return common.opcodesByVal[this.value] || 'OP_UNKNOWN';\n  //   }\n  //   /**\n  //    * Instantiate an opcode from a number opcode.\n  //    * @param {Number} op\n  //    * @returns {Opcode}\n  //    */\n  //   static fromOp(op) {\n  //     assert(typeof op === 'number');\n  //     const cached = opCache[op];\n  //     assert(cached, 'Bad opcode.');\n  //     return cached;\n  //   }\n  //   /**\n  //    * Instantiate a pushdata opcode from\n  //    * a buffer (will encode minimaldata).\n  //    * @param {Buffer} data\n  //    * @returns {Opcode}\n  //    */\n  //   static fromData(data) {\n  //     assert(Buffer.isBuffer(data));\n  //     if (data.length === 1) {\n  //       if (data[0] === 0x81)\n  //         return this.fromOp(opcodes.OP_1NEGATE);\n  //       if (data[0] >= 1 && data[0] <= 16)\n  //         return this.fromOp(data[0] + 0x50);\n  //     }\n  //     return this.fromPush(data);\n  //   }\n  //   /**\n  //    * Instantiate a pushdata opcode from a\n  //    * buffer (this differs from fromData in\n  //    * that it will _always_ be a pushdata op).\n  //    * @param {Buffer} data\n  //    * @returns {Opcode}\n  //    */\n  //   static fromPush(data) {\n  //     assert(Buffer.isBuffer(data));\n  //     if (data.length === 0)\n  //       return this.fromOp(opcodes.OP_0);\n  //     if (data.length <= 0x4b)\n  //       return new this(data.length, data);\n  //     if (data.length <= 0xff)\n  //       return new this(opcodes.OP_PUSHDATA1, data);\n  //     if (data.length <= 0xffff)\n  //       return new this(opcodes.OP_PUSHDATA2, data);\n  //     if (data.length <= 0xffffffff)\n  //       return new this(opcodes.OP_PUSHDATA4, data);\n  //     throw new Error('Pushdata size too large.');\n  //   }\n  //   /**\n  //    * Instantiate a pushdata opcode from a string.\n  //    * @param {String} str\n  //    * @param {String} [enc=utf8]\n  //    * @returns {Opcode}\n  //    */\n  //   static fromString(str, enc) {\n  //     assert(typeof str === 'string');\n  //     const data = Buffer.from(str, enc || 'utf8');\n  //     return this.fromData(data);\n  //   }\n  //   /**\n  //    * Instantiate an opcode from a small number.\n  //    * @param {Number} num\n  //    * @returns {Opcode}\n  //    */\n  //   static fromSmall(num) {\n  //     assert((num & 0xff) === num && num >= 0 && num <= 16);\n  //     return this.fromOp(num === 0 ? 0 : num + 0x50);\n  //   }\n  //   /**\n  //    * Instantiate an opcode from a ScriptNum.\n  //    * @param {ScriptNumber} num\n  //    * @returns {Opcode}\n  //    */\n  //   static fromNum(num) {\n  //     assert(ScriptNum.isScriptNum(num));\n  //     return this.fromData(num.encode());\n  //   }\n  //   /**\n  //    * Instantiate an opcode from a Number.\n  //    * @param {Number} num\n  //    * @returns {Opcode}\n  //    */\n  //   static fromInt(num) {\n  //     assert(Number.isSafeInteger(num));\n  //     if (num === 0)\n  //       return this.fromOp(opcodes.OP_0);\n  //     if (num === -1)\n  //       return this.fromOp(opcodes.OP_1NEGATE);\n  //     if (num >= 1 && num <= 16)\n  //       return this.fromOp(num + 0x50);\n  //     return this.fromNum(ScriptNum.fromNumber(num));\n  //   }\n  //   /**\n  //    * Instantiate an opcode from a Number.\n  //    * @param {Boolean} value\n  //    * @returns {Opcode}\n  //    */\n  //   static fromBool(value) {\n  //     assert(typeof value === 'boolean');\n  //     return this.fromSmall(value ? 1 : 0);\n  //   }\n  //   /**\n  //    * Instantiate a pushdata opcode from symbolic name.\n  //    * @example\n  //    *   Opcode.fromSymbol('checksequenceverify')\n  //    * @param {String} name\n  //    * @returns {Opcode}\n  //    */\n  //   static fromSymbol(name) {\n  //     assert(typeof name === 'string');\n  //     assert(name.length > 0);\n  //     if (name.charCodeAt(0) & 32)\n  //       name = name.toUpperCase();\n  //     if (!/^OP_/.test(name))\n  //       name = `OP_${name}`;\n  //     const op = common.opcodes[name];\n  //     if (op != null)\n  //       return this.fromOp(op);\n  //     assert(/^OP_0X/.test(name), 'Unknown opcode.');\n  //     assert(name.length === 7, 'Unknown opcode.');\n  //     const value = parseInt(name.substring(5), 16);\n  //     assert((value & 0xff) === value, 'Unknown opcode.');\n  //     return this.fromOp(value);\n  //   }\n  //   /**\n  //    * Instantiate opcode from buffer reader.\n  //    * @param {BufferReader} br\n  //    * @returns {Opcode}\n  //    */\n\n\n  static fromReader(br) {\n    const value = br.readU8();\n    const op = opCache[value];\n    if (op) return op;\n\n    switch (value) {\n      case opcodes.OP_PUSHDATA1:\n        {\n          if (br.left() < 1) return PARSE_ERROR;\n          const size = br.readU8();\n\n          if (br.left() < size) {\n            br.seek(br.left());\n            return PARSE_ERROR;\n          }\n\n          const data = br.readBytes(size);\n          return new this(value, data);\n        }\n\n      case opcodes.OP_PUSHDATA2:\n        {\n          if (br.left() < 2) {\n            br.seek(br.left());\n            return PARSE_ERROR;\n          }\n\n          const size = br.readU16();\n\n          if (br.left() < size) {\n            br.seek(br.left());\n            return PARSE_ERROR;\n          }\n\n          const data = br.readBytes(size);\n          return new this(value, data);\n        }\n\n      case opcodes.OP_PUSHDATA4:\n        {\n          if (br.left() < 4) {\n            br.seek(br.left());\n            return PARSE_ERROR;\n          }\n\n          const size = br.readU32();\n\n          if (br.left() < size) {\n            br.seek(br.left());\n            return PARSE_ERROR;\n          }\n\n          const data = br.readBytes(size);\n          return new this(value, data);\n        }\n\n      default:\n        {\n          if (br.left() < value) {\n            br.seek(br.left());\n            return PARSE_ERROR;\n          }\n\n          const data = br.readBytes(value);\n          return new this(value, data);\n        }\n    }\n  } //   /**\n  //    * Instantiate opcode from serialized data.\n  //    * @param {Buffer} data\n  //    * @returns {Opcode}\n  //    */\n  //   static fromRaw(data) {\n  //     return this.fromReader(bio.read(data));\n  //   }\n  //   /**\n  //    * Test whether an object an Opcode.\n  //    * @param {Object} obj\n  //    * @returns {Boolean}\n  //    */\n  //   static isOpcode(obj) {\n  //     return obj instanceof Opcode;\n  //   }\n\n\n} // /*\n//  * Helpers\n//  */\n// function hex8(num) {\n//   if (num <= 0x0f)\n//     return '0' + num.toString(16);\n//   return num.toString(16);\n// }\n// /*\n//  * Fill Cache\n//  */\n// PARSE_ERROR = Object.freeze(new Opcode(-1));\n// for (let value = 0x00; value <= 0xff; value++) {\n//   if (value >= 0x01 && value <= 0x4e) {\n//     opCache.push(null);\n//     continue;\n//   }\n//   const op = new Opcode(value);\n//   opCache.push(Object.freeze(op));\n// }\n\n/*\n * Expose\n */\n\n\nmodule.exports = Opcode;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/script/opcode.js"],"names":["assert","require","bio","ScriptNum","common","opcodes","opCache","PARSE_ERROR","Opcode","constructor","value","data","fromReader","br","readU8","op","OP_PUSHDATA1","left","size","seek","readBytes","OP_PUSHDATA2","readU16","OP_PUSHDATA4","readU32","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,OAAD,CAAtB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAME,SAAS,GAAGF,OAAO,CAAC,aAAD,CAAzB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMI,OAAO,GAAGD,MAAM,CAACC,OAAvB;AAEA,MAAMC,OAAO,GAAG,EAAhB;AAEA,IAAIC,WAAW,GAAG,IAAlB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,MAAN,CAAa;AACX;AACF;AACA;AACA;AACA;AACA;AACA;AAEEC,EAAAA,WAAW,CAACC,KAAD,EAAQC,IAAR,EAAc;AACvB,SAAKD,KAAL,GAAaA,KAAK,IAAI,CAAtB;AACA,SAAKC,IAAL,GAAYA,IAAI,IAAI,IAApB;AACD,GAZU,CAcb;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AA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","sourcesContent":["/*!\n * opcode.js - opcode object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bio = require('bufio');\nconst ScriptNum = require('./scriptnum');\nconst common = require('./common');\nconst opcodes = common.opcodes;\n\nconst opCache = [];\n\nlet PARSE_ERROR = null;\n\n/**\n * Opcode\n * A simple struct which contains\n * an opcode and pushdata buffer.\n * @alias module:script.Opcode\n * @property {Number} value\n * @property {Buffer|null} data\n */\n\nclass Opcode {\n  /**\n   * Create an opcode.\n   * Note: this should not be called directly.\n   * @constructor\n   * @param {Number} value - Opcode.\n   * @param {Buffer?} data - Pushdata buffer.\n   */\n\n  constructor(value, data) {\n    this.value = value || 0;\n    this.data = data || null;\n  }\n\n//   /**\n//    * Test whether a pushdata abides by minimaldata.\n//    * @returns {Boolean}\n//    */\n\n//   isMinimal() {\n//     assert(0 <= this.value && this.value <= opcodes.OP_PUSHDATA4);\n\n//     if (!this.data)\n//       return true;\n\n//     if (this.data.length === 1) {\n//       if (this.data[0] === 0x81)\n//         return false;\n\n//       if (this.data[0] >= 1 && this.data[0] <= 16)\n//         return false;\n//     }\n\n//     if (this.data.length <= 0x4b)\n//       return this.value === this.data.length;\n\n//     if (this.data.length <= 0xff)\n//       return this.value === opcodes.OP_PUSHDATA1;\n\n//     if (this.data.length <= 0xffff)\n//       return this.value === opcodes.OP_PUSHDATA2;\n\n//     return true;\n//   }\n\n//   /**\n//    * Test whether opcode is a disabled opcode.\n//    * @param {Number?} flags - Script standard flags.\n//    * @returns {Boolean}\n//    */\n\n//   isDisabled(flags) {\n//     switch (this.value) {\n//       case opcodes.OP_INVERT:\n//       case opcodes.OP_2MUL:\n//       case opcodes.OP_2DIV:\n//       case opcodes.OP_MUL:\n//       case opcodes.OP_LSHIFT:\n//       case opcodes.OP_RSHIFT:\n//         return true;\n//     }\n\n//     return false;\n//   }\n\n//   /**\n//    * Test whether opcode is a branch (if/else/endif).\n//    * @returns {Boolean}\n//    */\n\n//   isBranch() {\n//     return this.value >= opcodes.OP_IF && this.value <= opcodes.OP_ENDIF;\n//   }\n\n//   /**\n//    * Test opcode equality.\n//    * @param {Opcode} op\n//    * @returns {Boolean}\n//    */\n\n//   equals(op) {\n//     assert(Opcode.isOpcode(op));\n\n//     if (this.value !== op.value)\n//       return false;\n\n//     if (!this.data) {\n//       assert(!op.data);\n//       return true;\n//     }\n\n//     assert(op.data);\n\n//     return this.data.equals(op.data);\n//   }\n\n//   /**\n//    * Convert Opcode to opcode value.\n//    * @returns {Number}\n//    */\n\n//   toOp() {\n//     return this.value;\n//   }\n\n//   /**\n//    * Covert opcode to data push.\n//    * @returns {Buffer|null}\n//    */\n\n//   toData() {\n//     return this.data;\n//   }\n\n//   /**\n//    * Covert opcode to data length.\n//    * @returns {Number}\n//    */\n\n//   toLength() {\n//     return this.data ? this.data.length : -1;\n//   }\n\n//   /**\n//    * Covert and _cast_ opcode to data push.\n//    * @returns {Buffer|null}\n//    */\n\n//   toPush() {\n//     if (this.value === opcodes.OP_0)\n//       return common.small[0 + 1];\n\n//     if (this.value === opcodes.OP_1NEGATE)\n//       return common.small[-1 + 1];\n\n//     if (this.value >= opcodes.OP_1 && this.value <= opcodes.OP_16)\n//       return common.small[this.value - 0x50 + 1];\n\n//     return this.toData();\n//   }\n\n//   /**\n//    * Get string for opcode.\n//    * @param {String?} enc\n//    * @returns {Buffer|null}\n//    */\n\n//   toString(enc) {\n//     const data = this.toPush();\n\n//     if (!data)\n//       return null;\n\n//     return data.toString(enc || 'utf8');\n//   }\n\n//   /**\n//    * Convert opcode to small integer.\n//    * @returns {Number}\n//    */\n\n//   toSmall() {\n//     if (this.value === opcodes.OP_0)\n//       return 0;\n\n//     if (this.value >= opcodes.OP_1 && this.value <= opcodes.OP_16)\n//       return this.value - 0x50;\n\n//     return -1;\n//   }\n\n//   /**\n//    * Convert opcode to script number.\n//    * @param {Boolean?} minimal\n//    * @param {Number?} limit\n//    * @returns {ScriptNum|null}\n//    */\n\n//   toNum(minimal, limit) {\n//     if (this.value === opcodes.OP_0)\n//       return ScriptNum.fromInt(0);\n\n//     if (this.value === opcodes.OP_1NEGATE)\n//       return ScriptNum.fromInt(-1);\n\n//     if (this.value >= opcodes.OP_1 && this.value <= opcodes.OP_16)\n//       return ScriptNum.fromInt(this.value - 0x50);\n\n//     if (!this.data)\n//       return null;\n\n//     return ScriptNum.decode(this.data, minimal, limit);\n//   }\n\n//   /**\n//    * Convert opcode to integer.\n//    * @param {Boolean?} minimal\n//    * @param {Number?} limit\n//    * @returns {Number}\n//    */\n\n//   toInt(minimal, limit) {\n//     const num = this.toNum(minimal, limit);\n\n//     if (!num)\n//       return -1;\n\n//     return num.getInt();\n//   }\n\n//   /**\n//    * Convert opcode to boolean.\n//    * @returns {Boolean}\n//    */\n\n//   toBool() {\n//     const smi = this.toSmall();\n\n//     if (smi === -1)\n//       return false;\n\n//     return smi === 1;\n//   }\n\n//   /**\n//    * Convert opcode to its symbolic representation.\n//    * @returns {String}\n//    */\n\n//   toSymbol() {\n//     if (this.value === -1)\n//       return 'OP_INVALIDOPCODE';\n\n//     const symbol = common.opcodesByVal[this.value];\n\n//     if (!symbol)\n//       return `0x${hex8(this.value)}`;\n\n//     return symbol;\n//   }\n\n//   /**\n//    * Calculate opcode size.\n//    * @returns {Number}\n//    */\n\n//   getSize() {\n//     if (!this.data)\n//       return 1;\n\n//     switch (this.value) {\n//       case opcodes.OP_PUSHDATA1:\n//         return 2 + this.data.length;\n//       case opcodes.OP_PUSHDATA2:\n//         return 3 + this.data.length;\n//       case opcodes.OP_PUSHDATA4:\n//         return 5 + this.data.length;\n//       default:\n//         return 1 + this.data.length;\n//     }\n//   }\n\n//   /**\n//    * Encode the opcode to a buffer writer.\n//    * @param {BufferWriter} bw\n//    */\n\n//   toWriter(bw) {\n//     if (this.value === -1)\n//       throw new Error('Cannot reserialize a parse error.');\n\n//     if (!this.data) {\n//       bw.writeU8(this.value);\n//       return bw;\n//     }\n\n//     switch (this.value) {\n//       case opcodes.OP_PUSHDATA1:\n//         bw.writeU8(this.value);\n//         bw.writeU8(this.data.length);\n//         bw.writeBytes(this.data);\n//         break;\n//       case opcodes.OP_PUSHDATA2:\n//         bw.writeU8(this.value);\n//         bw.writeU16(this.data.length);\n//         bw.writeBytes(this.data);\n//         break;\n//       case opcodes.OP_PUSHDATA4:\n//         bw.writeU8(this.value);\n//         bw.writeU32(this.data.length);\n//         bw.writeBytes(this.data);\n//         break;\n//       default:\n//         assert(this.value === this.data.length);\n//         bw.writeU8(this.value);\n//         bw.writeBytes(this.data);\n//         break;\n//     }\n\n//     return bw;\n//   }\n\n//   /**\n//    * Encode the opcode.\n//    * @returns {Buffer}\n//    */\n\n//   toRaw() {\n//     const size = this.getSize();\n//     return this.toWriter(bio.write(size)).render();\n//   }\n\n//   /**\n//    * Convert the opcode to a bitcoind test string.\n//    * @returns {String} Human-readable script code.\n//    */\n\n//   toFormat() {\n//     if (this.value === -1)\n//       return '0x01';\n\n//     if (this.data) {\n//       // Numbers\n//       if (this.data.length <= 4) {\n//         const num = this.toNum();\n//         if (this.equals(Opcode.fromNum(num)))\n//           return num.toString(10);\n//       }\n\n//       const symbol = common.opcodesByVal[this.value];\n//       const data = this.data.toString('hex');\n\n//       // Direct push\n//       if (!symbol) {\n//         const size = hex8(this.value);\n//         return `0x${size} 0x${data}`;\n//       }\n\n//       // Pushdatas\n//       let size = this.data.length.toString(16);\n\n//       while (size.length % 2 !== 0)\n//         size = '0' + size;\n\n//       return `${symbol} 0x${size} 0x${data}`;\n//     }\n\n//     // Opcodes\n//     const symbol = common.opcodesByVal[this.value];\n//     if (symbol)\n//       return symbol;\n\n//     // Unknown opcodes\n//     const value = hex8(this.value);\n\n//     return `0x${value}`;\n//   }\n\n//   /**\n//    * Format the opcode as bitcoind asm.\n//    * @param {Boolean?} decode - Attempt to decode hash types.\n//    * @returns {String} Human-readable script.\n//    */\n\n//   toASM(decode) {\n//     if (this.value === -1)\n//       return '[error]';\n\n//     if (this.data)\n//       return common.toASM(this.data, decode);\n\n//     return common.opcodesByVal[this.value] || 'OP_UNKNOWN';\n//   }\n\n//   /**\n//    * Instantiate an opcode from a number opcode.\n//    * @param {Number} op\n//    * @returns {Opcode}\n//    */\n\n//   static fromOp(op) {\n//     assert(typeof op === 'number');\n\n//     const cached = opCache[op];\n\n//     assert(cached, 'Bad opcode.');\n\n//     return cached;\n//   }\n\n//   /**\n//    * Instantiate a pushdata opcode from\n//    * a buffer (will encode minimaldata).\n//    * @param {Buffer} data\n//    * @returns {Opcode}\n//    */\n\n//   static fromData(data) {\n//     assert(Buffer.isBuffer(data));\n\n//     if (data.length === 1) {\n//       if (data[0] === 0x81)\n//         return this.fromOp(opcodes.OP_1NEGATE);\n\n//       if (data[0] >= 1 && data[0] <= 16)\n//         return this.fromOp(data[0] + 0x50);\n//     }\n\n//     return this.fromPush(data);\n//   }\n\n//   /**\n//    * Instantiate a pushdata opcode from a\n//    * buffer (this differs from fromData in\n//    * that it will _always_ be a pushdata op).\n//    * @param {Buffer} data\n//    * @returns {Opcode}\n//    */\n\n//   static fromPush(data) {\n//     assert(Buffer.isBuffer(data));\n\n//     if (data.length === 0)\n//       return this.fromOp(opcodes.OP_0);\n\n//     if (data.length <= 0x4b)\n//       return new this(data.length, data);\n\n//     if (data.length <= 0xff)\n//       return new this(opcodes.OP_PUSHDATA1, data);\n\n//     if (data.length <= 0xffff)\n//       return new this(opcodes.OP_PUSHDATA2, data);\n\n//     if (data.length <= 0xffffffff)\n//       return new this(opcodes.OP_PUSHDATA4, data);\n\n//     throw new Error('Pushdata size too large.');\n//   }\n\n//   /**\n//    * Instantiate a pushdata opcode from a string.\n//    * @param {String} str\n//    * @param {String} [enc=utf8]\n//    * @returns {Opcode}\n//    */\n\n//   static fromString(str, enc) {\n//     assert(typeof str === 'string');\n//     const data = Buffer.from(str, enc || 'utf8');\n//     return this.fromData(data);\n//   }\n\n//   /**\n//    * Instantiate an opcode from a small number.\n//    * @param {Number} num\n//    * @returns {Opcode}\n//    */\n\n//   static fromSmall(num) {\n//     assert((num & 0xff) === num && num >= 0 && num <= 16);\n//     return this.fromOp(num === 0 ? 0 : num + 0x50);\n//   }\n\n//   /**\n//    * Instantiate an opcode from a ScriptNum.\n//    * @param {ScriptNumber} num\n//    * @returns {Opcode}\n//    */\n\n//   static fromNum(num) {\n//     assert(ScriptNum.isScriptNum(num));\n//     return this.fromData(num.encode());\n//   }\n\n//   /**\n//    * Instantiate an opcode from a Number.\n//    * @param {Number} num\n//    * @returns {Opcode}\n//    */\n\n//   static fromInt(num) {\n//     assert(Number.isSafeInteger(num));\n\n//     if (num === 0)\n//       return this.fromOp(opcodes.OP_0);\n\n//     if (num === -1)\n//       return this.fromOp(opcodes.OP_1NEGATE);\n\n//     if (num >= 1 && num <= 16)\n//       return this.fromOp(num + 0x50);\n\n//     return this.fromNum(ScriptNum.fromNumber(num));\n//   }\n\n//   /**\n//    * Instantiate an opcode from a Number.\n//    * @param {Boolean} value\n//    * @returns {Opcode}\n//    */\n\n//   static fromBool(value) {\n//     assert(typeof value === 'boolean');\n//     return this.fromSmall(value ? 1 : 0);\n//   }\n\n//   /**\n//    * Instantiate a pushdata opcode from symbolic name.\n//    * @example\n//    *   Opcode.fromSymbol('checksequenceverify')\n//    * @param {String} name\n//    * @returns {Opcode}\n//    */\n\n//   static fromSymbol(name) {\n//     assert(typeof name === 'string');\n//     assert(name.length > 0);\n\n//     if (name.charCodeAt(0) & 32)\n//       name = name.toUpperCase();\n\n//     if (!/^OP_/.test(name))\n//       name = `OP_${name}`;\n\n//     const op = common.opcodes[name];\n\n//     if (op != null)\n//       return this.fromOp(op);\n\n//     assert(/^OP_0X/.test(name), 'Unknown opcode.');\n//     assert(name.length === 7, 'Unknown opcode.');\n\n//     const value = parseInt(name.substring(5), 16);\n\n//     assert((value & 0xff) === value, 'Unknown opcode.');\n\n//     return this.fromOp(value);\n//   }\n\n//   /**\n//    * Instantiate opcode from buffer reader.\n//    * @param {BufferReader} br\n//    * @returns {Opcode}\n//    */\n\n  static fromReader(br) {\n    const value = br.readU8();\n    const op = opCache[value];\n\n    if (op)\n      return op;\n\n    switch (value) {\n      case opcodes.OP_PUSHDATA1: {\n        if (br.left() < 1)\n          return PARSE_ERROR;\n\n        const size = br.readU8();\n\n        if (br.left() < size) {\n          br.seek(br.left());\n          return PARSE_ERROR;\n        }\n\n        const data = br.readBytes(size);\n\n        return new this(value, data);\n      }\n      case opcodes.OP_PUSHDATA2: {\n        if (br.left() < 2) {\n          br.seek(br.left());\n          return PARSE_ERROR;\n        }\n\n        const size = br.readU16();\n\n        if (br.left() < size) {\n          br.seek(br.left());\n          return PARSE_ERROR;\n        }\n\n        const data = br.readBytes(size);\n\n        return new this(value, data);\n      }\n      case opcodes.OP_PUSHDATA4: {\n        if (br.left() < 4) {\n          br.seek(br.left());\n          return PARSE_ERROR;\n        }\n\n        const size = br.readU32();\n\n        if (br.left() < size) {\n          br.seek(br.left());\n          return PARSE_ERROR;\n        }\n\n        const data = br.readBytes(size);\n\n        return new this(value, data);\n      }\n      default: {\n        if (br.left() < value) {\n          br.seek(br.left());\n          return PARSE_ERROR;\n        }\n\n        const data = br.readBytes(value);\n\n        return new this(value, data);\n      }\n    }\n  }\n\n//   /**\n//    * Instantiate opcode from serialized data.\n//    * @param {Buffer} data\n//    * @returns {Opcode}\n//    */\n\n//   static fromRaw(data) {\n//     return this.fromReader(bio.read(data));\n//   }\n\n//   /**\n//    * Test whether an object an Opcode.\n//    * @param {Object} obj\n//    * @returns {Boolean}\n//    */\n\n//   static isOpcode(obj) {\n//     return obj instanceof Opcode;\n//   }\n}\n\n// /*\n//  * Helpers\n//  */\n\n// function hex8(num) {\n//   if (num <= 0x0f)\n//     return '0' + num.toString(16);\n//   return num.toString(16);\n// }\n\n// /*\n//  * Fill Cache\n//  */\n\n// PARSE_ERROR = Object.freeze(new Opcode(-1));\n\n// for (let value = 0x00; value <= 0xff; value++) {\n//   if (value >= 0x01 && value <= 0x4e) {\n//     opCache.push(null);\n//     continue;\n//   }\n//   const op = new Opcode(value);\n//   opCache.push(Object.freeze(op));\n// }\n\n/*\n * Expose\n */\n\nmodule.exports = Opcode;\n"]},"metadata":{},"sourceType":"module"}