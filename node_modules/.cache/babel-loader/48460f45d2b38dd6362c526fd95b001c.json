{"ast":null,"code":"/*!\n * coin.js - coin object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bio = require('bufio');\n\nconst util = require('../utils/util');\n\nconst Amount = require('../btc/amount');\n\nconst Output = require('./output');\n\nconst Network = require('../protocol/network');\n\nconst consensus = require('../protocol/consensus');\n\nconst Outpoint = require('./outpoint');\n\nconst SLP = require('../script/slp');\n\nconst {\n  inspectSymbol\n} = require('../utils');\n/**\n * Coin\n * Represents an unspent output.\n * @alias module:primitives.Coin\n * @extends Output\n * @property {Number} version\n * @property {Number} height\n * @property {Amount} value\n * @property {Script} script\n * @property {Boolean} coinbase\n * @property {Hash} hash\n * @property {Number} index\n */\n\n\nclass Coin extends Output {\n  /**\n   * Create a coin.\n   * @constructor\n   * @param {Object} options\n   */\n  constructor(options) {\n    super();\n    this.version = 1;\n    this.height = -1;\n    this.coinbase = false;\n    this.hash = consensus.ZERO_HASH;\n    this.index = 0; // if (options)\n    //   this.fromOptions(options);\n  } //   /**\n  //    * Inject options into coin.\n  //    * @private\n  //    * @param {Object} options\n  //    */\n  //   fromOptions(options) {\n  //     assert(options, 'Coin data is required.');\n  //     if (options.version != null) {\n  //       assert((options.version >>> 0) === options.version,\n  //         'Version must be a uint32.');\n  //       this.version = options.version;\n  //     }\n  //     if (options.height != null) {\n  //       if (options.height !== -1) {\n  //         assert((options.height >>> 0) === options.height,\n  //           'Height must be a uint32.');\n  //         this.height = options.height;\n  //       } else {\n  //         this.height = -1;\n  //       }\n  //     }\n  //     if (options.value != null) {\n  //       assert(Number.isSafeInteger(options.value) && options.value >= 0,\n  //         'Value must be a uint64.');\n  //       this.value = options.value;\n  //     }\n  //     if (options.script)\n  //       this.script.fromOptions(options.script);\n  //     if (options.coinbase != null) {\n  //       assert(typeof options.coinbase === 'boolean',\n  //         'Coinbase must be a boolean.');\n  //       this.coinbase = options.coinbase;\n  //     }\n  //     if (options.hash != null) {\n  //       assert(Buffer.isBuffer(options.hash));\n  //       this.hash = options.hash;\n  //     }\n  //     if (options.index != null) {\n  //       assert((options.index >>> 0) === options.index,\n  //         'Index must be a uint32.');\n  //       this.index = options.index;\n  //     }\n  //     return this;\n  //   }\n  //   /**\n  //    * Instantiate Coin from options object.\n  //    * @private\n  //    * @param {Object} options\n  //    */\n  //   static fromOptions(options) {\n  //     return new this().fromOptions(options);\n  //   }\n  //   /**\n  //    * Clone the coin.\n  //    * @private\n  //    * @returns {Coin}\n  //    */\n  //   clone() {\n  //     assert(false, 'Coins are not cloneable.');\n  //   }\n  //   /**\n  //    * Calculate number of confirmations since coin was created.\n  //    * @param {Number?} height - Current chain height. Network\n  //    * height is used if not passed in.\n  //    * @return {Number}\n  //    */\n  //   getDepth(height) {\n  //     assert(typeof height === 'number', 'Must pass a height.');\n  //     if (this.height === -1)\n  //       return 0;\n  //     if (height === -1)\n  //       return 0;\n  //     if (height < this.height)\n  //       return 0;\n  //     return height - this.height + 1;\n  //   }\n  //   /**\n  //    * Serialize coin to a key\n  //    * suitable for a hash table.\n  //    * @returns {String}\n  //    */\n  //   toKey() {\n  //     return Outpoint.toKey(this.hash, this.index);\n  //   }\n  //   /**\n  //    * Inject properties from hash table key.\n  //    * @private\n  //    * @param {String} key\n  //    * @returns {Coin}\n  //    */\n  //   fromKey(key) {\n  //     const {hash, index} = Outpoint.fromKey(key);\n  //     this.hash = hash;\n  //     this.index = index;\n  //     return this;\n  //   }\n  //   /**\n  //    * Instantiate coin from hash table key.\n  //    * @param {String} key\n  //    * @returns {Coin}\n  //    */\n  //   static fromKey(key) {\n  //     return new this().fromKey(key);\n  //   }\n  //   /**\n  //    * Get little-endian hash.\n  //    * @returns {Hash}\n  //    */\n  //   rhash() {\n  //     return util.revHex(this.hash);\n  //   }\n  //   /**\n  //    * Get little-endian hash.\n  //    * @returns {Hash}\n  //    */\n  //   txid() {\n  //     return this.rhash();\n  //   }\n  //   /**\n  //    * Convert the coin to a more user-friendly object.\n  //    * @returns {Object}\n  //    */\n  //   [inspectSymbol]() {\n  //     const hr = {\n  //       type: this.getType(),\n  //       version: this.version,\n  //       height: this.height,\n  //       value: Amount.btc(this.value),\n  //       script: this.script,\n  //       coinbase: this.coinbase,\n  //       hash: this.hash ? util.revHex(this.hash) : null,\n  //       index: this.index,\n  //       address: this.getAddress()\n  //     };\n  //     if (this.slp) {\n  //       return {\n  //         ...hr,\n  //         slp: this.slp\n  //       }\n  //     }\n  //     return hr;\n  //   }\n  //   /**\n  //    * Convert the coin to an object suitable\n  //    * for JSON serialization.\n  //    * @returns {Object}\n  //    */\n  //   toJSON() {\n  //     return this.getJSON();\n  //   }\n  //   /**\n  //    * Convert the coin to an object suitable\n  //    * for JSON serialization. Note that the hash\n  //    * will be reversed to abide by bitcoind's legacy\n  //    * of little-endian uint256s.\n  //    * @param {Network} network\n  //    * @param {Boolean} minimal\n  //    * @returns {Object}\n  //    */\n  //   getJSON(network, minimal) {\n  //     let addr = this.getAddress();\n  //     network = Network.get(network);\n  //     if (addr)\n  //       addr = addr.toString(network);\n  //     const json = {\n  //       version: this.version,\n  //       height: this.height,\n  //       value: this.value,\n  //       script: this.script.toJSON(),\n  //       address: addr,\n  //       coinbase: this.coinbase,\n  //       hash: !minimal ? this.rhash() : undefined,\n  //       index: !minimal ? this.index : undefined\n  //     };\n  //     if (this.slp) {\n  //       return {\n  //         ...json,\n  //         slp: this.slp.getJSON()\n  //       }\n  //     }\n  //     return json;\n  //   }\n  //   /**\n  //    * Inject JSON properties into coin.\n  //    * @private\n  //    * @param {Object} json\n  //    */\n\n\n  fromJSON(json) {\n    assert(json, 'Coin data required.');\n    assert(json.version >>> 0 === json.version, 'Version must be a uint32.');\n    assert(json.height === -1 || json.height >>> 0 === json.height, 'Height must be a uint32.');\n    assert(Number.isSafeInteger(json.value) && json.value >= 0, 'Value must be a uint64.');\n    assert(typeof json.coinbase === 'boolean', 'Coinbase must be a boolean.');\n    this.version = json.version;\n    this.height = json.height;\n    this.value = json.value;\n    this.script.fromJSON(json.script);\n    this.coinbase = json.coinbase;\n\n    if (json.hash != null) {\n      assert(typeof json.hash === 'string', 'Hash must be a string.');\n      assert(json.hash.length === 64, 'Hash must be a string.');\n      assert(json.index >>> 0 === json.index, 'Index must be a uint32.');\n      this.hash = util.fromRev(json.hash);\n      this.index = json.index;\n    }\n\n    if (json.slp) {\n      json.slp.hash = json.hash;\n      this.slp = SLP.SlpCoinRecord().fromJSON(json.slp);\n    }\n\n    return this;\n  }\n  /**\n   * Instantiate an Coin from a jsonified coin object.\n   * @param {Object} json - The jsonified coin object.\n   * @returns {Coin}\n   */\n\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  } //   /**\n  //    * Calculate size of coin.\n  //    * @returns {Number}\n  //    */\n  //   getSize() {\n  //     return 17 + this.script.getVarSize();\n  //   }\n  //   /**\n  //    * Write the coin to a buffer writer.\n  //    * @param {BufferWriter} bw\n  //    */\n  //   toWriter(bw) {\n  //     let height = this.height;\n  //     if (height === -1)\n  //       height = 0x7fffffff;\n  //     bw.writeU32(this.version);\n  //     bw.writeU32(height);\n  //     bw.writeI64(this.value);\n  //     bw.writeVarBytes(this.script.toRaw());\n  //     bw.writeU8(this.coinbase ? 1 : 0);\n  //     return bw;\n  //   }\n  //   /**\n  //    * Serialize the coin.\n  //    * @returns {Buffer|String}\n  //    */\n  //   toRaw() {\n  //     const size = this.getSize();\n  //     return this.toWriter(bio.write(size)).render();\n  //   }\n  //   /**\n  //    * Inject properties from serialized buffer writer.\n  //    * @private\n  //    * @param {BufferReader} br\n  //    */\n  //   fromReader(br) {\n  //     this.version = br.readU32();\n  //     this.height = br.readU32();\n  //     this.value = br.readI64();\n  //     this.script.fromRaw(br.readVarBytes());\n  //     this.coinbase = br.readU8() === 1;\n  //     if (this.height === 0x7fffffff)\n  //       this.height = -1;\n  //     return this;\n  //   }\n  //   /**\n  //    * Inject properties from serialized data.\n  //    * @private\n  //    * @param {Buffer} data\n  //    */\n  //   fromRaw(data) {\n  //     return this.fromReader(bio.read(data));\n  //   }\n  //   /**\n  //    * Instantiate a coin from a buffer reader.\n  //    * @param {BufferReader} br\n  //    * @returns {Coin}\n  //    */\n  //   static fromReader(br) {\n  //     return new this().fromReader(br);\n  //   }\n  //   /**\n  //    * Instantiate a coin from a serialized Buffer.\n  //    * @param {Buffer} data\n  //    * @param {String?} enc - Encoding, can be `'hex'` or null.\n  //    * @returns {Coin}\n  //    */\n  //   static fromRaw(data, enc) {\n  //     if (typeof data === 'string')\n  //       data = Buffer.from(data, enc);\n  //     return new this().fromRaw(data);\n  //   }\n  //   /**\n  //    * Inject properties from TX.\n  //    * @param {TX} tx\n  //    * @param {Number} index\n  //    */\n  //   fromTX(tx, index, height) {\n  //     assert(typeof index === 'number');\n  //     assert(typeof height === 'number');\n  //     assert(index >= 0 && index < tx.outputs.length);\n  //     this.version = tx.version;\n  //     this.height = height;\n  //     this.value = tx.outputs[index].value;\n  //     this.script = tx.outputs[index].script;\n  //     this.coinbase = tx.isCoinbase();\n  //     this.hash = tx.hash();\n  //     this.index = index;\n  //     return this;\n  //   }\n  //   /**\n  //    * Instantiate a coin from a TX\n  //    * @param {TX} tx\n  //    * @param {Number} index - Output index.\n  //    * @returns {Coin}\n  //    */\n  //   static fromTX(tx, index, height) {\n  //     return new this().fromTX(tx, index, height);\n  //   }\n  //   /**\n  //    * Test an object to see if it is a Coin.\n  //    * @param {Object} obj\n  //    * @returns {Boolean}\n  //    */\n  //   static isCoin(obj) {\n  //     return obj instanceof Coin;\n  //   }\n\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = Coin;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/primitives/coin.js"],"names":["assert","require","bio","util","Amount","Output","Network","consensus","Outpoint","SLP","inspectSymbol","Coin","constructor","options","version","height","coinbase","hash","ZERO_HASH","index","fromJSON","json","Number","isSafeInteger","value","script","length","fromRev","slp","SlpCoinRecord","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,OAAD,CAAtB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAME,IAAI,GAAGF,OAAO,CAAC,eAAD,CAApB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,eAAD,CAAtB;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMK,OAAO,GAAGL,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMM,SAAS,GAAGN,OAAO,CAAC,uBAAD,CAAzB;;AACA,MAAMO,QAAQ,GAAGP,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAMQ,GAAG,GAAGR,OAAO,CAAC,eAAD,CAAnB;;AACA,MAAM;AAACS,EAAAA;AAAD,IAAkBT,OAAO,CAAC,UAAD,CAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMU,IAAN,SAAmBN,MAAnB,CAA0B;AACxB;AACF;AACA;AACA;AACA;AAEEO,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB;AAEA,SAAKC,OAAL,GAAe,CAAf;AACA,SAAKC,MAAL,GAAc,CAAC,CAAf;AACA,SAAKC,QAAL,GAAgB,KAAhB;AACA,SAAKC,IAAL,GAAYV,SAAS,CAACW,SAAtB;AACA,SAAKC,KAAL,GAAa,CAAb,CAPmB,CASnB;AACA;AACD,GAlBuB,CAoB1B;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAEEC,EAAAA,QAAQ,CAACC,IAAD,EAAO;AACbrB,IAAAA,MAAM,CAACqB,IAAD,EAAO,qBAAP,CAAN;AACArB,IAAAA,MAAM,CAAEqB,IAAI,CAACP,OAAL,KAAiB,CAAlB,KAAyBO,IAAI,CAACP,OAA/B,EAAwC,2BAAxC,CAAN;AACAd,IAAAA,MAAM,CAACqB,IAAI,CAACN,MAAL,KAAgB,CAAC,CAAjB,IAAuBM,IAAI,CAACN,MAAL,KAAgB,CAAjB,KAAwBM,IAAI,CAACN,MAApD,EACJ,0BADI,CAAN;AAEAf,IAAAA,MAAM,CAACsB,MAAM,CAACC,aAAP,CAAqBF,IAAI,CAACG,KAA1B,KAAoCH,IAAI,CAACG,KAAL,IAAc,CAAnD,EACJ,yBADI,CAAN;AAEAxB,IAAAA,MAAM,CAAC,OAAOqB,IAAI,CAACL,QAAZ,KAAyB,SAA1B,EAAqC,6BAArC,CAAN;AAEA,SAAKF,OAAL,GAAeO,IAAI,CAACP,OAApB;AACA,SAAKC,MAAL,GAAcM,IAAI,CAACN,MAAnB;AACA,SAAKS,KAAL,GAAaH,IAAI,CAACG,KAAlB;AACA,SAAKC,MAAL,CAAYL,QAAZ,CAAqBC,IAAI,CAACI,MAA1B;AACA,SAAKT,QAAL,GAAgBK,IAAI,CAACL,QAArB;;AAEA,QAAIK,IAAI,CAACJ,IAAL,IAAa,IAAjB,EAAuB;AACrBjB,MAAAA,MAAM,CAAC,OAAOqB,IAAI,CAACJ,IAAZ,KAAqB,QAAtB,EAAgC,wBAAhC,CAAN;AACAjB,MAAAA,MAAM,CAACqB,IAAI,CAACJ,IAAL,CAAUS,MAAV,KAAqB,EAAtB,EAA0B,wBAA1B,CAAN;AACA1B,MAAAA,MAAM,CAAEqB,IAAI,CAACF,KAAL,KAAe,CAAhB,KAAuBE,IAAI,CAACF,KAA7B,EAAoC,yBAApC,CAAN;AACA,WAAKF,IAAL,GAAYd,IAAI,CAACwB,OAAL,CAAaN,IAAI,CAACJ,IAAlB,CAAZ;AACA,WAAKE,KAAL,GAAaE,IAAI,CAACF,KAAlB;AACD;;AAED,QAAIE,IAAI,CAACO,GAAT,EAAc;AACZP,MAAAA,IAAI,CAACO,GAAL,CAASX,IAAT,GAAgBI,IAAI,CAACJ,IAArB;AACA,WAAKW,GAAL,GAAWnB,GAAG,CAACoB,aAAJ,GAAoBT,QAApB,CAA6BC,IAAI,CAACO,GAAlC,CAAX;AACD;;AAED,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEiB,SAARR,QAAQ,CAACC,IAAD,EAAO;AACpB,WAAO,IAAI,IAAJ,GAAWD,QAAX,CAAoBC,IAApB,CAAP;AACD,GA/RuB,CAiS1B;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAna0B;AAsa1B;AACA;AACA;;;AAEAS,MAAM,CAACC,OAAP,GAAiBpB,IAAjB","sourcesContent":["/*!\n * coin.js - coin object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bio = require('bufio');\nconst util = require('../utils/util');\nconst Amount = require('../btc/amount');\nconst Output = require('./output');\nconst Network = require('../protocol/network');\nconst consensus = require('../protocol/consensus');\nconst Outpoint = require('./outpoint');\nconst SLP = require('../script/slp');\nconst {inspectSymbol} = require('../utils');\n\n/**\n * Coin\n * Represents an unspent output.\n * @alias module:primitives.Coin\n * @extends Output\n * @property {Number} version\n * @property {Number} height\n * @property {Amount} value\n * @property {Script} script\n * @property {Boolean} coinbase\n * @property {Hash} hash\n * @property {Number} index\n */\n\nclass Coin extends Output {\n  /**\n   * Create a coin.\n   * @constructor\n   * @param {Object} options\n   */\n\n  constructor(options) {\n    super();\n\n    this.version = 1;\n    this.height = -1;\n    this.coinbase = false;\n    this.hash = consensus.ZERO_HASH;\n    this.index = 0;\n\n    // if (options)\n    //   this.fromOptions(options);\n  }\n\n//   /**\n//    * Inject options into coin.\n//    * @private\n//    * @param {Object} options\n//    */\n\n//   fromOptions(options) {\n//     assert(options, 'Coin data is required.');\n\n//     if (options.version != null) {\n//       assert((options.version >>> 0) === options.version,\n//         'Version must be a uint32.');\n//       this.version = options.version;\n//     }\n\n//     if (options.height != null) {\n//       if (options.height !== -1) {\n//         assert((options.height >>> 0) === options.height,\n//           'Height must be a uint32.');\n//         this.height = options.height;\n//       } else {\n//         this.height = -1;\n//       }\n//     }\n\n//     if (options.value != null) {\n//       assert(Number.isSafeInteger(options.value) && options.value >= 0,\n//         'Value must be a uint64.');\n//       this.value = options.value;\n//     }\n\n//     if (options.script)\n//       this.script.fromOptions(options.script);\n\n//     if (options.coinbase != null) {\n//       assert(typeof options.coinbase === 'boolean',\n//         'Coinbase must be a boolean.');\n//       this.coinbase = options.coinbase;\n//     }\n\n//     if (options.hash != null) {\n//       assert(Buffer.isBuffer(options.hash));\n//       this.hash = options.hash;\n//     }\n\n//     if (options.index != null) {\n//       assert((options.index >>> 0) === options.index,\n//         'Index must be a uint32.');\n//       this.index = options.index;\n//     }\n\n//     return this;\n//   }\n\n//   /**\n//    * Instantiate Coin from options object.\n//    * @private\n//    * @param {Object} options\n//    */\n\n//   static fromOptions(options) {\n//     return new this().fromOptions(options);\n//   }\n\n//   /**\n//    * Clone the coin.\n//    * @private\n//    * @returns {Coin}\n//    */\n\n//   clone() {\n//     assert(false, 'Coins are not cloneable.');\n//   }\n\n//   /**\n//    * Calculate number of confirmations since coin was created.\n//    * @param {Number?} height - Current chain height. Network\n//    * height is used if not passed in.\n//    * @return {Number}\n//    */\n\n//   getDepth(height) {\n//     assert(typeof height === 'number', 'Must pass a height.');\n\n//     if (this.height === -1)\n//       return 0;\n\n//     if (height === -1)\n//       return 0;\n\n//     if (height < this.height)\n//       return 0;\n\n//     return height - this.height + 1;\n//   }\n\n//   /**\n//    * Serialize coin to a key\n//    * suitable for a hash table.\n//    * @returns {String}\n//    */\n\n//   toKey() {\n//     return Outpoint.toKey(this.hash, this.index);\n//   }\n\n//   /**\n//    * Inject properties from hash table key.\n//    * @private\n//    * @param {String} key\n//    * @returns {Coin}\n//    */\n\n//   fromKey(key) {\n//     const {hash, index} = Outpoint.fromKey(key);\n//     this.hash = hash;\n//     this.index = index;\n//     return this;\n//   }\n\n//   /**\n//    * Instantiate coin from hash table key.\n//    * @param {String} key\n//    * @returns {Coin}\n//    */\n\n//   static fromKey(key) {\n//     return new this().fromKey(key);\n//   }\n\n//   /**\n//    * Get little-endian hash.\n//    * @returns {Hash}\n//    */\n\n//   rhash() {\n//     return util.revHex(this.hash);\n//   }\n\n//   /**\n//    * Get little-endian hash.\n//    * @returns {Hash}\n//    */\n\n//   txid() {\n//     return this.rhash();\n//   }\n\n//   /**\n//    * Convert the coin to a more user-friendly object.\n//    * @returns {Object}\n//    */\n\n//   [inspectSymbol]() {\n//     const hr = {\n//       type: this.getType(),\n//       version: this.version,\n//       height: this.height,\n//       value: Amount.btc(this.value),\n//       script: this.script,\n//       coinbase: this.coinbase,\n//       hash: this.hash ? util.revHex(this.hash) : null,\n//       index: this.index,\n//       address: this.getAddress()\n//     };\n//     if (this.slp) {\n//       return {\n//         ...hr,\n//         slp: this.slp\n//       }\n//     }\n//     return hr;\n//   }\n\n//   /**\n//    * Convert the coin to an object suitable\n//    * for JSON serialization.\n//    * @returns {Object}\n//    */\n\n//   toJSON() {\n//     return this.getJSON();\n//   }\n\n//   /**\n//    * Convert the coin to an object suitable\n//    * for JSON serialization. Note that the hash\n//    * will be reversed to abide by bitcoind's legacy\n//    * of little-endian uint256s.\n//    * @param {Network} network\n//    * @param {Boolean} minimal\n//    * @returns {Object}\n//    */\n\n//   getJSON(network, minimal) {\n//     let addr = this.getAddress();\n\n//     network = Network.get(network);\n\n//     if (addr)\n//       addr = addr.toString(network);\n\n//     const json = {\n//       version: this.version,\n//       height: this.height,\n//       value: this.value,\n//       script: this.script.toJSON(),\n//       address: addr,\n//       coinbase: this.coinbase,\n//       hash: !minimal ? this.rhash() : undefined,\n//       index: !minimal ? this.index : undefined\n//     };\n\n//     if (this.slp) {\n//       return {\n//         ...json,\n//         slp: this.slp.getJSON()\n//       }\n//     }\n//     return json;\n//   }\n\n//   /**\n//    * Inject JSON properties into coin.\n//    * @private\n//    * @param {Object} json\n//    */\n\n  fromJSON(json) {\n    assert(json, 'Coin data required.');\n    assert((json.version >>> 0) === json.version, 'Version must be a uint32.');\n    assert(json.height === -1 || (json.height >>> 0) === json.height,\n      'Height must be a uint32.');\n    assert(Number.isSafeInteger(json.value) && json.value >= 0,\n      'Value must be a uint64.');\n    assert(typeof json.coinbase === 'boolean', 'Coinbase must be a boolean.');\n\n    this.version = json.version;\n    this.height = json.height;\n    this.value = json.value;\n    this.script.fromJSON(json.script);\n    this.coinbase = json.coinbase;\n\n    if (json.hash != null) {\n      assert(typeof json.hash === 'string', 'Hash must be a string.');\n      assert(json.hash.length === 64, 'Hash must be a string.');\n      assert((json.index >>> 0) === json.index, 'Index must be a uint32.');\n      this.hash = util.fromRev(json.hash);\n      this.index = json.index;\n    }\n\n    if (json.slp) {\n      json.slp.hash = json.hash;\n      this.slp = SLP.SlpCoinRecord().fromJSON(json.slp);\n    }\n\n    return this;\n  }\n\n  /**\n   * Instantiate an Coin from a jsonified coin object.\n   * @param {Object} json - The jsonified coin object.\n   * @returns {Coin}\n   */\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n\n//   /**\n//    * Calculate size of coin.\n//    * @returns {Number}\n//    */\n\n//   getSize() {\n//     return 17 + this.script.getVarSize();\n//   }\n\n//   /**\n//    * Write the coin to a buffer writer.\n//    * @param {BufferWriter} bw\n//    */\n\n//   toWriter(bw) {\n//     let height = this.height;\n\n//     if (height === -1)\n//       height = 0x7fffffff;\n\n//     bw.writeU32(this.version);\n//     bw.writeU32(height);\n//     bw.writeI64(this.value);\n//     bw.writeVarBytes(this.script.toRaw());\n//     bw.writeU8(this.coinbase ? 1 : 0);\n\n//     return bw;\n//   }\n\n//   /**\n//    * Serialize the coin.\n//    * @returns {Buffer|String}\n//    */\n\n//   toRaw() {\n//     const size = this.getSize();\n//     return this.toWriter(bio.write(size)).render();\n//   }\n\n//   /**\n//    * Inject properties from serialized buffer writer.\n//    * @private\n//    * @param {BufferReader} br\n//    */\n\n//   fromReader(br) {\n//     this.version = br.readU32();\n//     this.height = br.readU32();\n//     this.value = br.readI64();\n//     this.script.fromRaw(br.readVarBytes());\n//     this.coinbase = br.readU8() === 1;\n\n//     if (this.height === 0x7fffffff)\n//       this.height = -1;\n\n//     return this;\n//   }\n\n//   /**\n//    * Inject properties from serialized data.\n//    * @private\n//    * @param {Buffer} data\n//    */\n\n//   fromRaw(data) {\n//     return this.fromReader(bio.read(data));\n//   }\n\n//   /**\n//    * Instantiate a coin from a buffer reader.\n//    * @param {BufferReader} br\n//    * @returns {Coin}\n//    */\n\n//   static fromReader(br) {\n//     return new this().fromReader(br);\n//   }\n\n//   /**\n//    * Instantiate a coin from a serialized Buffer.\n//    * @param {Buffer} data\n//    * @param {String?} enc - Encoding, can be `'hex'` or null.\n//    * @returns {Coin}\n//    */\n\n//   static fromRaw(data, enc) {\n//     if (typeof data === 'string')\n//       data = Buffer.from(data, enc);\n//     return new this().fromRaw(data);\n//   }\n\n//   /**\n//    * Inject properties from TX.\n//    * @param {TX} tx\n//    * @param {Number} index\n//    */\n\n//   fromTX(tx, index, height) {\n//     assert(typeof index === 'number');\n//     assert(typeof height === 'number');\n//     assert(index >= 0 && index < tx.outputs.length);\n//     this.version = tx.version;\n//     this.height = height;\n//     this.value = tx.outputs[index].value;\n//     this.script = tx.outputs[index].script;\n//     this.coinbase = tx.isCoinbase();\n//     this.hash = tx.hash();\n//     this.index = index;\n//     return this;\n//   }\n\n//   /**\n//    * Instantiate a coin from a TX\n//    * @param {TX} tx\n//    * @param {Number} index - Output index.\n//    * @returns {Coin}\n//    */\n\n//   static fromTX(tx, index, height) {\n//     return new this().fromTX(tx, index, height);\n//   }\n\n//   /**\n//    * Test an object to see if it is a Coin.\n//    * @param {Object} obj\n//    * @returns {Boolean}\n//    */\n\n//   static isCoin(obj) {\n//     return obj instanceof Coin;\n//   }\n}\n\n/*\n * Expose\n */\n\nmodule.exports = Coin;\n"]},"metadata":{},"sourceType":"module"}