{"ast":null,"code":"/*!\n * output.js - output object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bio = require('bufio');\n\nconst Amount = require('../btc/amount');\n\nconst Network = require('../protocol/network');\n\nconst Address = require('../primitives/address');\n\nconst Script = require('../script/script');\n\nconst SLP = require('../script/slp');\n\nconst policy = require('../protocol/policy');\n\nconst {\n  inspectSymbol\n} = require('../utils');\n/**\n * Represents a transaction output.\n * @alias module:primitives.Output\n * @property {Amount} value\n * @property {Script} script\n * @property {SlpCoinRecord?} slp\n */\n\n\nclass Output {\n  /**\n   * Create an output.\n   * @constructor\n   * @param {Object?} options\n   */\n  constructor(options) {\n    this.value = 0;\n    this.script = new Script();\n    if (options) this.fromOptions(options);\n  }\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n\n  fromOptions(options) {\n    assert(options, 'Output data is required.');\n\n    if (options.value) {\n      assert(Number.isSafeInteger(options.value) && options.value >= 0, 'Value must be a uint64.');\n      this.value = options.value;\n    }\n\n    if (options.script) this.script.fromOptions(options.script);\n    if (options.address) this.script.fromAddress(options.address);\n\n    if (options.slp) {\n      if (options.slp.constructor === SLP.SlpCoinRecord().constructor) this.slp = options.slp;\n    }\n\n    return this;\n  }\n  /**\n   * Instantiate output from options object.\n   * @param {Object} options\n   * @returns {Output}\n   */\n\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n  /**\n   * Inject properties from script/value pair.\n   * @private\n   * @param {Script|Address} script\n   * @param {Amount} value\n   * @returns {Output}\n   */\n\n\n  fromScript(script, value) {\n    if (typeof script === 'string') script = Address.fromString(script);\n    if (script instanceof Address) script = Script.fromAddress(script);\n    assert(script instanceof Script, 'Script must be a Script.');\n    assert(Number.isSafeInteger(value) && value >= 0, 'Value must be a uint64.');\n    this.script = script;\n    this.value = value;\n    return this;\n  }\n  /**\n   * Instantiate output from script/value pair.\n   * @param {Script|Address} script\n   * @param {Amount} value\n   * @returns {Output}\n   */\n\n\n  static fromScript(script, value) {\n    return new this().fromScript(script, value);\n  }\n  /**\n   * Clone the output.\n   * @returns {Output}\n   */\n\n\n  clone() {\n    const output = new this.constructor();\n    output.value = this.value;\n    output.script.inject(this.script);\n    return output;\n  }\n  /**\n   * Test equality against another output.\n   * @param {Output} output\n   * @returns {Boolean}\n   */\n\n\n  equals(output) {\n    assert(Output.isOutput(output));\n    return this.value === output.value && this.script.equals(output.script);\n  }\n  /**\n   * Compare against another output (BIP69).\n   * @param {Output} output\n   * @returns {Number}\n   */\n\n\n  compare(output) {\n    assert(Output.isOutput(output));\n    const cmp = this.value - output.value;\n    if (cmp !== 0) return cmp;\n    return this.script.compare(output.script);\n  }\n  /**\n   * Get the script type as a string.\n   * @returns {ScriptType} type\n   */\n\n\n  getType() {\n    return Script.typesByVal[this.script.getType()].toLowerCase();\n  }\n  /**\n   * Get the address.\n   * @returns {Address} address\n   */\n\n\n  getAddress() {\n    return this.script.getAddress();\n  }\n  /**\n   * Get the address hash.\n   * @param {String?} enc\n   * @returns {Hash} hash\n   */\n\n\n  getHash(enc) {\n    const addr = this.getAddress();\n    if (!addr) return null;\n    return addr.getHash(enc);\n  }\n  /**\n   * Convert the input to a more user-friendly object.\n   * @returns {Object}\n   */\n\n\n  [inspectSymbol]() {\n    const hr = {\n      type: this.getType(),\n      value: Amount.btc(this.value),\n      script: this.script,\n      address: this.getAddress()\n    };\n\n    if (this.slp) {\n      return { ...hr,\n        slp: this.slp\n      };\n    }\n\n    return hr;\n  }\n  /**\n   * Convert the output to an object suitable\n   * for JSON serialization.\n   * @returns {Object}\n   */\n\n\n  toJSON() {\n    return this.getJSON();\n  }\n  /**\n   * Convert the output to an object suitable\n   * for JSON serialization.\n   * @param {Network} network\n   * @returns {Object}\n   */\n\n\n  getJSON(network) {\n    let addr = this.getAddress();\n    network = Network.get(network);\n    if (addr) addr = addr.toString(network);\n    const json = {\n      value: this.value,\n      script: this.script.toJSON(),\n      address: addr\n    };\n\n    if (this.slp) {\n      return { ...json,\n        slp: this.slp.getJSON()\n      };\n    }\n\n    return json;\n  }\n  /**\n   * Calculate the dust threshold for this\n   * output, based on serialize size and rate.\n   * @param {Rate?} rate\n   * @returns {Amount}\n   */\n\n\n  getDustThreshold(rate) {\n    if (this.script.isUnspendable()) return 0;\n    let size = this.getSize();\n    size += 32 + 4 + 1 + 107 + 4;\n    return 3 * policy.getMinFee(size, rate);\n  }\n  /**\n   * Calculate size of serialized output.\n   * @returns {Number}\n   */\n\n\n  getSize() {\n    return 8 + this.script.getVarSize();\n  }\n  /**\n   * Test whether the output should be considered dust.\n   * @param {Rate?} rate\n   * @returns {Boolean}\n   */\n\n\n  isDust(rate) {\n    return this.value < this.getDustThreshold(rate);\n  }\n  /**\n   * Inject properties from a JSON object.\n   * @private\n   * @param {Object} json\n   */\n\n\n  fromJSON(json) {\n    assert(json, 'Output data is required.');\n    assert(Number.isSafeInteger(json.value) && json.value >= 0, 'Value must be a uint64.');\n    this.value = json.value;\n    this.script.fromJSON(json.script);\n\n    if (json.slp) {\n      this.slp = SLP.SlpCoinRecord().fromJSON(json.slp);\n    }\n\n    return this;\n  }\n  /**\n   * Instantiate an Output from a jsonified output object.\n   * @param {Object} json - The jsonified output object.\n   * @returns {Output}\n   */\n\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n  /**\n   * Write the output to a buffer writer.\n   * @param {BufferWriter} bw\n   */\n\n\n  toWriter(bw) {\n    bw.writeI64(this.value);\n    bw.writeVarBytes(this.script.toRaw());\n    return bw;\n  }\n  /**\n   * Serialize the output.\n   * @param {String?} enc - Encoding, can be `'hex'` or null.\n   * @returns {Buffer|String}\n   */\n\n\n  toRaw() {\n    const size = this.getSize();\n    return this.toWriter(bio.write(size)).render();\n  }\n  /**\n   * Inject properties from buffer reader.\n   * @private\n   * @param {BufferReader} br\n   */\n\n\n  fromReader(br) {\n    this.value = br.readI64();\n    this.script.fromRaw(br.readVarBytes());\n    return this;\n  }\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   */\n\n\n  fromRaw(data) {\n    return this.fromReader(bio.read(data));\n  }\n  /**\n   * Instantiate an output from a buffer reader.\n   * @param {BufferReader} br\n   * @returns {Output}\n   */\n\n\n  static fromReader(br) {\n    return new this().fromReader(br);\n  }\n  /**\n   * Instantiate an output from a serialized Buffer.\n   * @param {Buffer} data\n   * @param {String?} enc - Encoding, can be `'hex'` or null.\n   * @returns {Output}\n   */\n\n\n  static fromRaw(data, enc) {\n    if (typeof data === 'string') data = Buffer.from(data, enc);\n    return new this().fromRaw(data);\n  }\n  /**\n   * Test an object to see if it is an Output.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n\n  static isOutput(obj) {\n    return obj instanceof Output;\n  }\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = Output;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/primitives/output.js"],"names":["assert","require","bio","Amount","Network","Address","Script","SLP","policy","inspectSymbol","Output","constructor","options","value","script","fromOptions","Number","isSafeInteger","address","fromAddress","slp","SlpCoinRecord","fromScript","fromString","clone","output","inject","equals","isOutput","compare","cmp","getType","typesByVal","toLowerCase","getAddress","getHash","enc","addr","hr","type","btc","toJSON","getJSON","network","get","toString","json","getDustThreshold","rate","isUnspendable","size","getSize","getMinFee","getVarSize","isDust","fromJSON","toWriter","bw","writeI64","writeVarBytes","toRaw","write","render","fromReader","br","readI64","fromRaw","readVarBytes","data","read","Buffer","from","obj","module","exports"],"mappings":"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","sourcesContent":["/*!\n * output.js - output object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bio = require('bufio');\nconst Amount = require('../btc/amount');\nconst Network = require('../protocol/network');\nconst Address = require('../primitives/address');\nconst Script = require('../script/script');\nconst SLP = require('../script/slp');\nconst policy = require('../protocol/policy');\nconst {inspectSymbol} = require('../utils');\n\n/**\n * Represents a transaction output.\n * @alias module:primitives.Output\n * @property {Amount} value\n * @property {Script} script\n * @property {SlpCoinRecord?} slp\n */\n\nclass Output {\n  /**\n   * Create an output.\n   * @constructor\n   * @param {Object?} options\n   */\n\n  constructor(options) {\n    this.value = 0;\n    this.script = new Script();\n\n    if (options)\n      this.fromOptions(options);\n  }\n\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n  fromOptions(options) {\n    assert(options, 'Output data is required.');\n\n    if (options.value) {\n      assert(Number.isSafeInteger(options.value) && options.value >= 0,\n        'Value must be a uint64.');\n      this.value = options.value;\n    }\n\n    if (options.script)\n      this.script.fromOptions(options.script);\n\n    if (options.address)\n      this.script.fromAddress(options.address);\n\n    if (options.slp) {\n      if (options.slp.constructor === SLP.SlpCoinRecord().constructor)\n        this.slp = options.slp\n    }\n\n    return this;\n  }\n\n  /**\n   * Instantiate output from options object.\n   * @param {Object} options\n   * @returns {Output}\n   */\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n\n  /**\n   * Inject properties from script/value pair.\n   * @private\n   * @param {Script|Address} script\n   * @param {Amount} value\n   * @returns {Output}\n   */\n\n  fromScript(script, value) {\n    if (typeof script === 'string')\n      script = Address.fromString(script);\n\n    if (script instanceof Address)\n      script = Script.fromAddress(script);\n\n    assert(script instanceof Script, 'Script must be a Script.');\n    assert(Number.isSafeInteger(value) && value >= 0,\n      'Value must be a uint64.');\n\n    this.script = script;\n    this.value = value;\n\n    return this;\n  }\n\n  /**\n   * Instantiate output from script/value pair.\n   * @param {Script|Address} script\n   * @param {Amount} value\n   * @returns {Output}\n   */\n\n  static fromScript(script, value) {\n    return new this().fromScript(script, value);\n  }\n\n  /**\n   * Clone the output.\n   * @returns {Output}\n   */\n\n  clone() {\n    const output = new this.constructor();\n    output.value = this.value;\n    output.script.inject(this.script);\n    return output;\n  }\n\n  /**\n   * Test equality against another output.\n   * @param {Output} output\n   * @returns {Boolean}\n   */\n\n  equals(output) {\n    assert(Output.isOutput(output));\n    return this.value === output.value\n      && this.script.equals(output.script);\n  }\n\n  /**\n   * Compare against another output (BIP69).\n   * @param {Output} output\n   * @returns {Number}\n   */\n\n  compare(output) {\n    assert(Output.isOutput(output));\n\n    const cmp = this.value - output.value;\n\n    if (cmp !== 0)\n      return cmp;\n\n    return this.script.compare(output.script);\n  }\n\n  /**\n   * Get the script type as a string.\n   * @returns {ScriptType} type\n   */\n\n  getType() {\n    return Script.typesByVal[this.script.getType()].toLowerCase();\n  }\n\n  /**\n   * Get the address.\n   * @returns {Address} address\n   */\n\n  getAddress() {\n    return this.script.getAddress();\n  }\n\n  /**\n   * Get the address hash.\n   * @param {String?} enc\n   * @returns {Hash} hash\n   */\n\n  getHash(enc) {\n    const addr = this.getAddress();\n\n    if (!addr)\n      return null;\n\n    return addr.getHash(enc);\n  }\n\n  /**\n   * Convert the input to a more user-friendly object.\n   * @returns {Object}\n   */\n\n  [inspectSymbol]() {\n    const hr = {\n      type: this.getType(),\n      value: Amount.btc(this.value),\n      script: this.script,\n      address: this.getAddress()\n    };\n    if (this.slp) {\n      return {\n        ...hr,\n        slp: this.slp\n      }\n    }\n    return hr;\n  }\n\n  /**\n   * Convert the output to an object suitable\n   * for JSON serialization.\n   * @returns {Object}\n   */\n\n  toJSON() {\n    return this.getJSON();\n  }\n\n  /**\n   * Convert the output to an object suitable\n   * for JSON serialization.\n   * @param {Network} network\n   * @returns {Object}\n   */\n\n  getJSON(network) {\n    let addr = this.getAddress();\n\n    network = Network.get(network);\n\n    if (addr)\n      addr = addr.toString(network);\n\n    const json = {\n      value: this.value,\n      script: this.script.toJSON(),\n      address: addr\n    };\n\n    if (this.slp) {\n      return {\n        ...json,\n        slp: this.slp.getJSON()\n      }\n    }\n    return json;\n  }\n\n  /**\n   * Calculate the dust threshold for this\n   * output, based on serialize size and rate.\n   * @param {Rate?} rate\n   * @returns {Amount}\n   */\n\n  getDustThreshold(rate) {\n    if (this.script.isUnspendable())\n      return 0;\n\n    let size = this.getSize();\n\n    size += 32 + 4 + 1 + 107 + 4;\n\n    return 3 * policy.getMinFee(size, rate);\n  }\n\n  /**\n   * Calculate size of serialized output.\n   * @returns {Number}\n   */\n\n  getSize() {\n    return 8 + this.script.getVarSize();\n  }\n\n  /**\n   * Test whether the output should be considered dust.\n   * @param {Rate?} rate\n   * @returns {Boolean}\n   */\n\n  isDust(rate) {\n    return this.value < this.getDustThreshold(rate);\n  }\n\n  /**\n   * Inject properties from a JSON object.\n   * @private\n   * @param {Object} json\n   */\n\n  fromJSON(json) {\n    assert(json, 'Output data is required.');\n    assert(Number.isSafeInteger(json.value) && json.value >= 0,\n      'Value must be a uint64.');\n    this.value = json.value;\n    this.script.fromJSON(json.script);\n    if (json.slp) {\n      this.slp = SLP.SlpCoinRecord().fromJSON(json.slp)\n    }\n    return this;\n  }\n\n  /**\n   * Instantiate an Output from a jsonified output object.\n   * @param {Object} json - The jsonified output object.\n   * @returns {Output}\n   */\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n\n  /**\n   * Write the output to a buffer writer.\n   * @param {BufferWriter} bw\n   */\n\n  toWriter(bw) {\n    bw.writeI64(this.value);\n    bw.writeVarBytes(this.script.toRaw());\n    return bw;\n  }\n\n  /**\n   * Serialize the output.\n   * @param {String?} enc - Encoding, can be `'hex'` or null.\n   * @returns {Buffer|String}\n   */\n\n  toRaw() {\n    const size = this.getSize();\n    return this.toWriter(bio.write(size)).render();\n  }\n\n  /**\n   * Inject properties from buffer reader.\n   * @private\n   * @param {BufferReader} br\n   */\n\n  fromReader(br) {\n    this.value = br.readI64();\n    this.script.fromRaw(br.readVarBytes());\n    return this;\n  }\n\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   */\n\n  fromRaw(data) {\n    return this.fromReader(bio.read(data));\n  }\n\n  /**\n   * Instantiate an output from a buffer reader.\n   * @param {BufferReader} br\n   * @returns {Output}\n   */\n\n  static fromReader(br) {\n    return new this().fromReader(br);\n  }\n\n  /**\n   * Instantiate an output from a serialized Buffer.\n   * @param {Buffer} data\n   * @param {String?} enc - Encoding, can be `'hex'` or null.\n   * @returns {Output}\n   */\n\n  static fromRaw(data, enc) {\n    if (typeof data === 'string')\n      data = Buffer.from(data, enc);\n    return new this().fromRaw(data);\n  }\n\n  /**\n   * Test an object to see if it is an Output.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n  static isOutput(obj) {\n    return obj instanceof Output;\n  }\n}\n\n/*\n * Expose\n */\n\nmodule.exports = Output;\n"]},"metadata":{},"sourceType":"module"}