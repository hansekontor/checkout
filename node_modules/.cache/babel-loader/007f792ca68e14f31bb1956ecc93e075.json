{"ast":null,"code":"/*!\n * script.js - script interpreter for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bio = require('bufio');\n\nconst ripemd160 = require('bcrypto/lib/ripemd160');\n\nconst sha1 = require('bcrypto/lib/sha1');\n\nconst sha256 = require('bcrypto/lib/sha256');\n\nconst hash160 = require('bcrypto/lib/hash160');\n\nconst hash256 = require('bcrypto/lib/hash256');\n\nconst secp256k1 = require('bcrypto/lib/secp256k1');\n\nconst consensus = require('../protocol/consensus');\n\nconst policy = require('../protocol/policy');\n\nconst Opcode = require('./opcode');\n\nconst Stack = require('./stack');\n\nconst ScriptError = require('./scripterror');\n\nconst ScriptNum = require('./scriptnum');\n\nconst common = require('./common');\n\nconst Address = require('../primitives/address');\n\nconst Metrics = require('./metrics');\n\nconst opcodes = common.opcodes;\nconst scriptTypes = common.types;\nconst countBits = common.countBits;\nconst {\n  encoding\n} = bio;\n/*\n * Constants\n */\n\nconst EMPTY_BUFFER = Buffer.alloc(0);\nconst metrics = new Metrics();\n/**\n * Script\n * Represents a input or output script.\n * @alias module:script.Script\n * @property {Array} code - Parsed script code.\n * @property {Buffer?} raw - Serialized script.\n * @property {Number} length - Number of parsed opcodes.\n */\n\nclass Script {\n  /**\n   * Create a script.\n   * @constructor\n   * @param {Buffer|Array|Object} code\n   */\n  constructor(options) {\n    this.raw = EMPTY_BUFFER;\n    this.code = [];\n    if (options) this.fromOptions(options);\n  }\n  /**\n   * Get length.\n   * @returns {Number}\n   */\n\n\n  get length() {\n    return this.code.length;\n  }\n  /**\n   * Set length.\n   * @param {Number} value\n   */\n\n\n  set length(value) {\n    this.code.length = value;\n  }\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n\n  fromOptions(options) {\n    assert(options, 'Script data is required.');\n    if (Buffer.isBuffer(options)) return this.fromRaw(options);\n    if (Array.isArray(options)) return this.fromArray(options);\n\n    if (options.raw) {\n      if (!options.code) return this.fromRaw(options.raw);\n      assert(Buffer.isBuffer(options.raw), 'Raw must be a Buffer.');\n      this.raw = options.raw;\n    }\n\n    if (options.code) {\n      if (!options.raw) return this.fromArray(options.code);\n      assert(Array.isArray(options.code), 'Code must be an array.');\n      this.code = options.code;\n    }\n\n    return this;\n  }\n  /**\n   * Insantiate script from options object.\n   * @param {Object} options\n   * @returns {Script}\n   */\n\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n  /**\n   * Instantiate a value-only iterator.\n   * @returns {ScriptIterator}\n   */\n\n\n  values() {\n    return this.code.values();\n  }\n  /**\n   * Instantiate a key and value iterator.\n   * @returns {ScriptIterator}\n   */\n\n\n  entries() {\n    return this.code.entries();\n  }\n  /**\n   * Instantiate a value-only iterator.\n   * @returns {ScriptIterator}\n   */\n\n\n  [Symbol.iterator]() {\n    return this.code[Symbol.iterator]();\n  }\n  /**\n   * Convert the script to an array of\n   * Buffers (pushdatas) and Numbers\n   * (opcodes).\n   * @returns {Array}\n   */\n\n\n  toArray() {\n    return this.code.slice();\n  }\n  /**\n   * Inject properties from an array of\n   * of buffers and numbers.\n   * @private\n   * @param {Array} code\n   * @returns {Script}\n   */\n\n\n  fromArray(code) {\n    assert(Array.isArray(code));\n    this.clear();\n\n    for (const op of code) this.push(op);\n\n    return this.compile();\n  }\n  /**\n   * Instantiate script from an array\n   * of buffers and numbers.\n   * @param {Array} code\n   * @returns {Script}\n   */\n\n\n  static fromArray(code) {\n    return new this().fromArray(code);\n  }\n  /**\n   * Convert script to stack items.\n   * @returns {Buffer[]}\n   */\n\n\n  toItems() {\n    const items = [];\n\n    for (const op of this.code) {\n      const data = op.toPush();\n      if (!data) throw new Error('Non-push opcode in script.');\n      items.push(data);\n    }\n\n    return items;\n  }\n  /**\n   * Inject data from stack items.\n   * @private\n   * @param {Buffer[]} items\n   * @returns {Script}\n   */\n\n\n  fromItems(items) {\n    assert(Array.isArray(items));\n    this.clear();\n\n    for (const item of items) this.pushData(item);\n\n    return this.compile();\n  }\n  /**\n   * Instantiate script from stack items.\n   * @param {Buffer[]} items\n   * @returns {Script}\n   */\n\n\n  static fromItems(items) {\n    return new this().fromItems(items);\n  }\n  /**\n   * Convert script to stack.\n   * @returns {Stack}\n   */\n\n\n  toStack() {\n    return new Stack(this.toItems());\n  }\n  /**\n   * Inject data from stack.\n   * @private\n   * @param {Stack} stack\n   * @returns {Script}\n   */\n\n\n  fromStack(stack) {\n    return this.fromItems(stack.items);\n  }\n  /**\n   * Instantiate script from stack.\n   * @param {Stack} stack\n   * @returns {Script}\n   */\n\n\n  static fromStack(stack) {\n    return new this().fromStack(stack);\n  }\n  /**\n   * Clone the script.\n   * @returns {Script} Cloned script.\n   */\n\n\n  clone() {\n    return new this.constructor().inject(this);\n  }\n  /**\n   * Inject properties from script.\n   * Used for cloning.\n   * @private\n   * @param {Script} script\n   * @returns {Script}\n   */\n\n\n  inject(script) {\n    this.raw = script.raw;\n    this.code = script.code.slice();\n    return this;\n  }\n  /**\n   * Test equality against script.\n   * @param {Script} script\n   * @returns {Boolean}\n   */\n\n\n  equals(script) {\n    assert(Script.isScript(script));\n    return this.raw.equals(script.raw);\n  }\n  /**\n   * Compare against another script.\n   * @param {Script} script\n   * @returns {Number}\n   */\n\n\n  compare(script) {\n    assert(Script.isScript(script));\n    return this.raw.compare(script.raw);\n  }\n  /**\n   * Clear the script.\n   * @returns {Script}\n   */\n\n\n  clear() {\n    this.raw = EMPTY_BUFFER;\n    this.code.length = 0;\n    return this;\n  }\n  /**\n   * Inspect the script.\n   * @returns {String} Human-readable script code.\n   */\n\n\n  inspect() {\n    return `<Script: ${this.toString()}>`;\n  }\n  /**\n   * Convert the script to a bitcoind test string.\n   * @returns {String} Human-readable script code.\n   */\n\n\n  toString() {\n    const out = [];\n\n    for (const op of this.code) out.push(op.toFormat());\n\n    return out.join(' ');\n  }\n  /**\n   * Format the script as bitcoind asm.\n   * @param {Boolean?} decode - Attempt to decode hash types.\n   * @returns {String} Human-readable script.\n   */\n\n\n  toASM(decode) {\n    if (this.isNulldata()) decode = false;\n    const out = [];\n\n    for (const op of this.code) out.push(op.toASM(decode));\n\n    return out.join(' ');\n  }\n  /**\n   * Re-encode the script internally. Useful if you\n   * changed something manually in the `code` array.\n   * @returns {Script}\n   */\n\n\n  compile() {\n    if (this.code.length === 0) return this.clear();\n    let size = 0;\n\n    for (const op of this.code) size += op.getSize();\n\n    const bw = bio.write(size);\n\n    for (const op of this.code) op.toWriter(bw);\n\n    this.raw = bw.render();\n    return this;\n  }\n  /**\n   * Write the script to a buffer writer.\n   * @param {BufferWriter} bw\n   */\n\n\n  toWriter(bw) {\n    bw.writeVarBytes(this.raw);\n    return bw;\n  }\n  /**\n   * Encode the script to a Buffer. See {@link Script#encode}.\n   * @param {String} enc - Encoding, either `'hex'` or `null`.\n   * @returns {Buffer|String} Serialized script.\n   */\n\n\n  toRaw() {\n    return this.raw;\n  }\n  /**\n   * Convert script to a hex string.\n   * @returns {String}\n   */\n\n\n  toJSON() {\n    return this.toRaw().toString('hex');\n  }\n  /**\n   * Inject properties from json object.\n   * @private\n   * @param {String} json\n   */\n\n\n  fromJSON(json) {\n    assert(typeof json === 'string', 'Code must be a string.');\n    return this.fromRaw(Buffer.from(json, 'hex'));\n  }\n  /**\n   * Instantiate script from a hex string.\n   * @params {String} json\n   * @returns {Script}\n   */\n\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n  /**\n   * Get the script's \"subscript\" starting at a separator.\n   * @param {Number} index - The last separator to sign/verify beyond.\n   * @returns {Script} Subscript.\n   */\n\n\n  getSubscript(index) {\n    if (index === 0) return this.clone();\n    const script = new Script();\n\n    for (let i = index; i < this.code.length; i++) {\n      const op = this.code[i];\n      if (op.value === -1) break;\n      script.code.push(op);\n    }\n\n    return script.compile();\n  }\n  /**\n   * Get the script's \"subscript\" starting at a separator.\n   * Remove all OP_CODESEPARATORs if present. This bizarre\n   * behavior is necessary for signing and verification when\n   * code separators are present.\n   * @returns {Script} Subscript.\n   */\n\n\n  removeSeparators() {\n    let found = false; // Optimizing for the common case:\n    // Check for any separators first.\n\n    for (const op of this.code) {\n      if (op.value === -1) break;\n\n      if (op.value === opcodes.OP_CODESEPARATOR) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) return this; // Uncommon case: someone actually\n    // has a code separator. Go through\n    // and remove them all.\n\n    const script = new Script();\n\n    for (const op of this.code) {\n      if (op.value === -1) break;\n      if (op.value !== opcodes.OP_CODESEPARATOR) script.code.push(op);\n    }\n\n    return script.compile();\n  }\n  /**\n   * Get the value of the checkBits while calculated as little endian.\n   * @param {Buffer} abkam - Stack depth of the dummy element.\n   * @param {Number?} nKeysCount - Stack depth of the top pubkeys.\n   * @returns {Number}\n   */\n\n\n  bitcalculator(abkam, nKeysCount) {\n    let checkBits = 0;\n    const bitfield_size = (nKeysCount + 7) / 8;\n\n    for (let i = 0; i < bitfield_size; i++) {\n      checkBits |= abkam[i] << 8 * i;\n    }\n\n    return checkBits;\n  }\n  /**\n   * Execute and interpret the script.\n   * @param {Stack} stack - Script execution stack.\n   * @param {Number?} flags - Script standard flags.\n   * @param {TX?} tx - Transaction being verified.\n   * @param {Number?} index - Index of input being verified.\n   * @param {Amount?} value - Previous output value.\n   * @param {Number?} sigchecks\n   * @throws {ScriptError} Will be thrown on VERIFY failures.\n   */\n\n\n  execute(stack, flags, tx, index, value, sigchecks) {\n    if (flags == null) flags = Script.flags.STANDARD_VERIFY_FLAGS;\n    if (this.getSize() > consensus.MAX_SCRIPT_SIZE) throw new ScriptError('SCRIPT_SIZE');\n    const state = [];\n    const alt = [];\n    let lastSep = 0;\n    let opCount = 0;\n    let negate = 0;\n    let nSigsRemaining = 0;\n    let nKeysRemaining = 0;\n    let checkBits;\n    let minimal = false;\n    if (flags & Script.flags.VERIFY_MINIMALDATA) minimal = true;\n\n    for (let ip = 0; ip < this.code.length; ip++) {\n      const op = this.code[ip];\n      if (op.value === -1) throw new ScriptError('BAD_OPCODE', op, ip);\n      if (op.data && op.data.length > consensus.MAX_SCRIPT_PUSH) throw new ScriptError('PUSH_SIZE', op, ip);\n      if (op.value > opcodes.OP_16 && ++opCount > consensus.MAX_SCRIPT_OPS) throw new ScriptError('OP_COUNT', op, ip);\n      if (op.isDisabled(flags)) throw new ScriptError('DISABLED_OPCODE', op, ip);\n\n      if (negate && !op.isBranch()) {\n        if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK) throw new ScriptError('STACK_SIZE', op, ip);\n        continue;\n      }\n\n      if (op.data && 0 <= op.value <= opcodes.OP_PUSHDATA4) {\n        if (minimal && !op.isMinimal()) throw new ScriptError('MINIMALDATA', op, ip);\n        stack.push(op.data);\n        if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK) throw new ScriptError('STACK_SIZE', op, ip);\n        continue;\n      }\n\n      switch (op.value) {\n        case opcodes.OP_0:\n          {\n            stack.pushInt(0);\n            break;\n          }\n\n        case opcodes.OP_1NEGATE:\n          {\n            stack.pushInt(-1);\n            break;\n          }\n\n        case opcodes.OP_1:\n        case opcodes.OP_2:\n        case opcodes.OP_3:\n        case opcodes.OP_4:\n        case opcodes.OP_5:\n        case opcodes.OP_6:\n        case opcodes.OP_7:\n        case opcodes.OP_8:\n        case opcodes.OP_9:\n        case opcodes.OP_10:\n        case opcodes.OP_11:\n        case opcodes.OP_12:\n        case opcodes.OP_13:\n        case opcodes.OP_14:\n        case opcodes.OP_15:\n        case opcodes.OP_16:\n          {\n            stack.pushInt(op.value - 0x50);\n            break;\n          }\n\n        case opcodes.OP_NOP:\n          {\n            break;\n          }\n\n        case opcodes.OP_CHECKLOCKTIMEVERIFY:\n          {\n            // OP_CHECKLOCKTIMEVERIFY = OP_NOP2\n            if (!(flags & Script.flags.VERIFY_CHECKLOCKTIMEVERIFY)) {\n              if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS) throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);\n              break;\n            }\n\n            if (!tx) throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const num = stack.getNum(-1, minimal, 5);\n            if (num.isNeg()) throw new ScriptError('NEGATIVE_LOCKTIME', op, ip);\n            const locktime = num.toDouble();\n            if (!tx.verifyLocktime(index, locktime)) throw new ScriptError('UNSATISFIED_LOCKTIME', op, ip);\n            break;\n          }\n\n        case opcodes.OP_CHECKSEQUENCEVERIFY:\n          {\n            // OP_CHECKSEQUENCEVERIFY = OP_NOP3\n            if (!(flags & Script.flags.VERIFY_CHECKSEQUENCEVERIFY)) {\n              if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS) throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);\n              break;\n            }\n\n            if (!tx) throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const num = stack.getNum(-1, minimal, 5);\n            if (num.isNeg()) throw new ScriptError('NEGATIVE_LOCKTIME', op, ip);\n            const locktime = num.toDouble();\n            if (!tx.verifySequence(index, locktime)) throw new ScriptError('UNSATISFIED_LOCKTIME', op, ip);\n            break;\n          }\n\n        case opcodes.OP_NOP1:\n        case opcodes.OP_NOP4:\n        case opcodes.OP_NOP5:\n        case opcodes.OP_NOP6:\n        case opcodes.OP_NOP7:\n        case opcodes.OP_NOP8:\n        case opcodes.OP_NOP9:\n        case opcodes.OP_NOP10:\n          {\n            if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS) throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);\n            break;\n          }\n\n        case opcodes.OP_IF:\n        case opcodes.OP_NOTIF:\n          {\n            let val = false;\n\n            if (!negate) {\n              if (stack.length < 1) throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);\n\n              if (flags & Script.flags.VERIFY_MINIMALIF) {\n                const item = stack.get(-1);\n                if (item.length > 1) throw new ScriptError('MINIMALIF');\n                if (item.length === 1 && item[0] !== 1) throw new ScriptError('MINIMALIF');\n              }\n\n              val = stack.getBool(-1);\n              if (op.value === opcodes.OP_NOTIF) val = !val;\n              stack.pop();\n            }\n\n            state.push(val);\n            if (!val) negate += 1;\n            break;\n          }\n\n        case opcodes.OP_ELSE:\n          {\n            if (state.length === 0) throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);\n            state[state.length - 1] = !state[state.length - 1];\n            if (!state[state.length - 1]) negate += 1;else negate -= 1;\n            break;\n          }\n\n        case opcodes.OP_ENDIF:\n          {\n            if (state.length === 0) throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);\n            if (!state.pop()) negate -= 1;\n            break;\n          }\n\n        case opcodes.OP_VERIFY:\n          {\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            if (!stack.getBool(-1)) throw new ScriptError('VERIFY', op, ip);\n            stack.pop();\n            break;\n          }\n\n        case opcodes.OP_RETURN:\n          {\n            throw new ScriptError('OP_RETURN', op, ip);\n          }\n\n        case opcodes.OP_TOALTSTACK:\n          {\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            alt.push(stack.pop());\n            break;\n          }\n\n        case opcodes.OP_FROMALTSTACK:\n          {\n            if (alt.length === 0) throw new ScriptError('INVALID_ALTSTACK_OPERATION', op, ip);\n            stack.push(alt.pop());\n            break;\n          }\n\n        case opcodes.OP_2DROP:\n          {\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.pop();\n            stack.pop();\n            break;\n          }\n\n        case opcodes.OP_2DUP:\n          {\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const v1 = stack.get(-2);\n            const v2 = stack.get(-1);\n            stack.push(v1);\n            stack.push(v2);\n            break;\n          }\n\n        case opcodes.OP_3DUP:\n          {\n            if (stack.length < 3) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const v1 = stack.get(-3);\n            const v2 = stack.get(-2);\n            const v3 = stack.get(-1);\n            stack.push(v1);\n            stack.push(v2);\n            stack.push(v3);\n            break;\n          }\n\n        case opcodes.OP_2OVER:\n          {\n            if (stack.length < 4) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const v1 = stack.get(-4);\n            const v2 = stack.get(-3);\n            stack.push(v1);\n            stack.push(v2);\n            break;\n          }\n\n        case opcodes.OP_2ROT:\n          {\n            if (stack.length < 6) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const v1 = stack.get(-6);\n            const v2 = stack.get(-5);\n            stack.erase(-6, -4);\n            stack.push(v1);\n            stack.push(v2);\n            break;\n          }\n\n        case opcodes.OP_2SWAP:\n          {\n            if (stack.length < 4) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.swap(-4, -2);\n            stack.swap(-3, -1);\n            break;\n          }\n\n        case opcodes.OP_IFDUP:\n          {\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n            if (stack.getBool(-1)) {\n              const val = stack.get(-1);\n              stack.push(val);\n            }\n\n            break;\n          }\n\n        case opcodes.OP_DEPTH:\n          {\n            stack.pushInt(stack.length);\n            break;\n          }\n\n        case opcodes.OP_DROP:\n          {\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.pop();\n            break;\n          }\n\n        case opcodes.OP_DUP:\n          {\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.push(stack.get(-1));\n            break;\n          }\n\n        case opcodes.OP_NIP:\n          {\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.remove(-2);\n            break;\n          }\n\n        case opcodes.OP_OVER:\n          {\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.push(stack.get(-2));\n            break;\n          }\n\n        case opcodes.OP_PICK:\n        case opcodes.OP_ROLL:\n          {\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const num = stack.getInt(-1, minimal, 4);\n            stack.pop();\n            if (num < 0 || num >= stack.length) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const val = stack.get(-num - 1);\n            if (op.value === opcodes.OP_ROLL) stack.remove(-num - 1);\n            stack.push(val);\n            break;\n          }\n\n        case opcodes.OP_ROT:\n          {\n            if (stack.length < 3) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.swap(-3, -2);\n            stack.swap(-2, -1);\n            break;\n          }\n\n        case opcodes.OP_SWAP:\n          {\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.swap(-2, -1);\n            break;\n          }\n\n        case opcodes.OP_TUCK:\n          {\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.insert(-2, stack.get(-1));\n            break;\n          }\n\n        case opcodes.OP_SIZE:\n          {\n            if (stack.length < 1) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.pushInt(stack.get(-1).length);\n            break;\n          }\n\n        case opcodes.OP_EQUAL:\n        case opcodes.OP_EQUALVERIFY:\n          {\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const v1 = stack.get(-2);\n            const v2 = stack.get(-1);\n            const res = v1.equals(v2);\n            stack.pop();\n            stack.pop();\n            stack.pushBool(res);\n\n            if (op.value === opcodes.OP_EQUALVERIFY) {\n              if (!res) throw new ScriptError('EQUALVERIFY', op, ip);\n              stack.pop();\n            }\n\n            break;\n          }\n\n        case opcodes.OP_1ADD:\n        case opcodes.OP_1SUB:\n        case opcodes.OP_NEGATE:\n        case opcodes.OP_ABS:\n        case opcodes.OP_NOT:\n        case opcodes.OP_0NOTEQUAL:\n          {\n            if (stack.length < 1) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            let num = stack.getNum(-1, minimal, 4);\n            let cmp;\n\n            switch (op.value) {\n              case opcodes.OP_1ADD:\n                num.iaddn(1);\n                break;\n\n              case opcodes.OP_1SUB:\n                num.isubn(1);\n                break;\n\n              case opcodes.OP_NEGATE:\n                num.ineg();\n                break;\n\n              case opcodes.OP_ABS:\n                num.iabs();\n                break;\n\n              case opcodes.OP_NOT:\n                cmp = num.isZero();\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              case opcodes.OP_0NOTEQUAL:\n                cmp = !num.isZero();\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              default:\n                assert(false, 'Fatal script error.');\n                break;\n            }\n\n            stack.pop();\n            stack.pushNum(num);\n            break;\n          }\n\n        case opcodes.OP_ADD:\n        case opcodes.OP_SUB:\n        case opcodes.OP_DIV:\n        case opcodes.OP_MOD:\n        case opcodes.OP_BOOLAND:\n        case opcodes.OP_BOOLOR:\n        case opcodes.OP_NUMEQUAL:\n        case opcodes.OP_NUMEQUALVERIFY:\n        case opcodes.OP_NUMNOTEQUAL:\n        case opcodes.OP_LESSTHAN:\n        case opcodes.OP_GREATERTHAN:\n        case opcodes.OP_LESSTHANOREQUAL:\n        case opcodes.OP_GREATERTHANOREQUAL:\n        case opcodes.OP_MIN:\n        case opcodes.OP_MAX:\n          {\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const n1 = stack.getNum(-2, minimal, 4);\n            const n2 = stack.getNum(-1, minimal, 4);\n            let num, cmp;\n\n            switch (op.value) {\n              case opcodes.OP_ADD:\n                num = n1.iadd(n2);\n                break;\n\n              case opcodes.OP_SUB:\n                num = n1.isub(n2);\n                break;\n\n              case opcodes.OP_DIV:\n                if (n2.isZero()) throw new ScriptError('DIV_BY_ZERO', op, ip);\n                num = n1.div(n2);\n                break;\n\n              case opcodes.OP_MOD:\n                if (n2.isZero()) throw new ScriptError('MOD_BY_ZERO', op, ip);\n                num = n1.mod(n2);\n                break;\n\n              case opcodes.OP_BOOLAND:\n                cmp = n1.toBool() && n2.toBool();\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              case opcodes.OP_BOOLOR:\n                cmp = n1.toBool() || n2.toBool();\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              case opcodes.OP_NUMEQUAL:\n                cmp = n1.eq(n2);\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              case opcodes.OP_NUMEQUALVERIFY:\n                cmp = n1.eq(n2);\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              case opcodes.OP_NUMNOTEQUAL:\n                cmp = !n1.eq(n2);\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              case opcodes.OP_LESSTHAN:\n                cmp = n1.lt(n2);\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              case opcodes.OP_GREATERTHAN:\n                cmp = n1.gt(n2);\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              case opcodes.OP_LESSTHANOREQUAL:\n                cmp = n1.lte(n2);\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              case opcodes.OP_GREATERTHANOREQUAL:\n                cmp = n1.gte(n2);\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              case opcodes.OP_MIN:\n                num = ScriptNum.min(n1, n2);\n                break;\n\n              case opcodes.OP_MAX:\n                num = ScriptNum.max(n1, n2);\n                break;\n\n              default:\n                assert(false, 'Fatal script error.');\n                break;\n            }\n\n            stack.pop();\n            stack.pop();\n            stack.pushNum(num);\n\n            if (op.value === opcodes.OP_NUMEQUALVERIFY) {\n              if (!stack.getBool(-1)) throw new ScriptError('NUMEQUALVERIFY', op, ip);\n              stack.pop();\n            }\n\n            break;\n          }\n\n        case opcodes.OP_WITHIN:\n          {\n            if (stack.length < 3) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const n1 = stack.getNum(-3, minimal, 4);\n            const n2 = stack.getNum(-2, minimal, 4);\n            const n3 = stack.getNum(-1, minimal, 4);\n            const val = n2.lte(n1) && n1.lt(n3);\n            stack.pop();\n            stack.pop();\n            stack.pop();\n            stack.pushBool(val);\n            break;\n          }\n\n        case opcodes.OP_RIPEMD160:\n          {\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.push(ripemd160.digest(stack.pop()));\n            break;\n          }\n\n        case opcodes.OP_SHA1:\n          {\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.push(sha1.digest(stack.pop()));\n            break;\n          }\n\n        case opcodes.OP_SHA256:\n          {\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.push(sha256.digest(stack.pop()));\n            break;\n          }\n\n        case opcodes.OP_HASH160:\n          {\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.push(hash160.digest(stack.pop()));\n            break;\n          }\n\n        case opcodes.OP_HASH256:\n          {\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.push(hash256.digest(stack.pop()));\n            break;\n          }\n\n        case opcodes.OP_CODESEPARATOR:\n          {\n            lastSep = ip + 1;\n            break;\n          }\n\n        case opcodes.OP_CHECKSIG:\n        case opcodes.OP_CHECKSIGVERIFY:\n          {\n            if (!tx) throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const sig = stack.get(-2);\n            const key = stack.get(-1);\n            const subscript = this.getSubscript(lastSep);\n            if (!(flags & Script.flags.VERIFY_SIGHASH_FORKID) || !(sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID)) subscript.findAndDelete(sig);\n            checkTransactionSignature(sig, flags);\n            validateKey(key, flags);\n            let res = false;\n\n            if (sig.length > 0) {\n              const type = sig[sig.length - 1];\n              const hash = tx.signatureHash(index, subscript, value, type, flags);\n              res = verifySignature(hash, sig.slice(0, -1), key, flags);\n              metrics.sigchecks += 1;\n              sigchecks = metrics.sigchecks;\n            }\n\n            if (!res && flags & Script.flags.VERIFY_NULLFAIL) {\n              if (sig.length !== 0) throw new ScriptError('NULLFAIL', op, ip);\n            }\n\n            stack.pop();\n            stack.pop();\n            stack.pushBool(res);\n\n            if (op.value === opcodes.OP_CHECKSIGVERIFY) {\n              if (!res) throw new ScriptError('CHECKSIGVERIFY', op, ip);\n              stack.pop();\n            }\n\n            break;\n          }\n\n        case opcodes.OP_CHECKDATASIG:\n        case opcodes.OP_CHECKDATASIGVERIFY:\n          {\n            // (sig message pubkey -- bool)\n            if (stack.length < 3) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const sig = stack.get(-3);\n            const msg = stack.get(-2);\n            const key = stack.get(-1);\n            validateDataSignature(sig, flags);\n            validateKey(key, flags);\n            let res = false;\n\n            if (sig.length > 0) {\n              const hash = sha256.digest(msg);\n              res = verifySignature(hash, sig, key, flags);\n              metrics.sigchecks += 1;\n              sigchecks = metrics.sigchecks;\n            }\n\n            if (!res && flags & Script.flags.VERIFY_NULLFAIL) {\n              if (sig.length !== 0) throw new ScriptError('NULLFAIL', op, ip);\n            }\n\n            stack.pop();\n            stack.pop();\n            stack.pop();\n            stack.pushBool(res);\n\n            if (op.value === opcodes.OP_CHECKDATASIGVERIFY) {\n              if (!res) throw new ScriptError('CHECKDATASIGVERIFY', op, ip);\n              stack.pop();\n            }\n\n            break;\n          }\n\n        case opcodes.OP_CHECKMULTISIG:\n        case opcodes.OP_CHECKMULTISIGVERIFY:\n          {\n            if (!tx) throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n            let keyCount = 1;\n            let sigCount = 0;\n            let keyTop, sigTop;\n            if (stack.length < keyCount) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            let nKeysCount = stack.getInt(-keyCount, minimal, 4);\n            let okey = nKeysCount + 2;\n            let ikey, isig;\n            if (nKeysCount < 0 || nKeysCount > consensus.MAX_MULTISIG_PUBKEYS) throw new ScriptError('PUBKEY_COUNT', op, ip);\n            opCount += nKeysCount;\n            if (opCount > consensus.MAX_SCRIPT_OPS) throw new ScriptError('OP_COUNT', op, ip);\n            keyCount += 1;\n            keyTop = keyCount; // stack depth of nSigsCount\n\n            sigCount = keyTop + nKeysCount;\n            ikey = keyCount;\n            keyCount += nKeysCount;\n            if (stack.length < sigCount) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            let nSigsCount = stack.getInt(-sigCount, minimal, 4);\n            if (nSigsCount < 0 || nSigsCount > nKeysCount) throw new ScriptError('SIG_COUNT', op, ip); // stack depth of the top signature\n\n            sigTop = sigCount + 1; // stack depth of the dummy element\n\n            const dummy = sigTop + nSigsCount;\n            if (stack.length < dummy) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            keyCount += 1;\n            isig = keyCount;\n            keyCount += nSigsCount;\n            const subscript = this.getSubscript(lastSep);\n            let res = true;\n\n            if (flags & Script.flags.VERIFY_SCHNORR_MULTISIG && stack.get(-dummy).length !== 0) {\n              assert(consensus.MAX_MULTISIG_PUBKEYS < 32);\n              if (nKeysCount > 32) throw new ScriptError('INVALID_BITFIELD_SIZE', op, ip);\n              const bitfield_size = Math.floor((nKeysCount + 7) / 8);\n              const abkam = stack.get(-dummy);\n              if (abkam.length !== bitfield_size) throw new ScriptError('BITFIELD_SIZE', op, ip);\n              checkBits = this.bitcalculator(abkam, nKeysCount);\n              const mask = (1 << nKeysCount) - 1;\n              const numBits = countBits(checkBits);\n              if ((checkBits & mask) !== checkBits) throw new ScriptError('BIT_RANGE', op, ip);\n              if (numBits !== nSigsCount) throw new ScriptError('INVALID_BIT_COUNT', op, ip);\n              const bKey = keyTop + nKeysCount - 1;\n              const bSig = sigTop + nSigsCount - 1;\n              let ik3y = 0;\n\n              for (let is1g = 0; is1g < nSigsCount; is1g++, ik3y++) {\n                if (checkBits >> ik3y === 0) {\n                  throw new ScriptError('INVALID_BIT_RANGE', op, ip);\n                }\n\n                while ((checkBits >> ik3y & 0x01) === 0) {\n                  ik3y++;\n                }\n\n                if (ik3y >= nKeysCount) throw new ScriptError('PUBKEY_COUNT', op, ip);\n                const sig = stack.get(-bSig + is1g);\n                const key = stack.get(-bKey + ik3y); // Handle checkbits left over\n\n                if (!sig) continue;\n                checkTransactionSchnorrSig(sig, flags);\n                validateKey(key, flags);\n\n                if (sig.length > 0) {\n                  const type = sig[sig.length - 1];\n                  const hash = tx.signatureHash(index, subscript, value, type, flags);\n                  res = verifySignature(hash, sig.slice(0, -1), key, flags);\n                  metrics.sigchecks += 1;\n                  sigchecks = metrics.sigchecks;\n                }\n\n                while (keyCount > 1) {\n                  if (!res && flags & Script.flags.VERIFY_NULLFAIL) {\n                    if (okey === 0 && stack.get(-1).length !== 0) throw new ScriptError('NULLFAIL', op, ip);\n                  }\n\n                  if (okey > 0) okey -= 1;\n                  stack.pop();\n                  keyCount -= 1;\n                }\n              }\n\n              if (checkBits >> ik3y !== 0) throw new ScriptError('INVALID_BIT_COUNT', op, ip);\n              stack.pop();\n              stack.pushBool(res);\n            } else {\n              // Legacy Multisig (ECDSA / NULL)\n              // A bug causes CHECKMULTISIG to consume one extra\n              // argument whose contents were not checked in any way.\n              for (let j = 0; j < nSigsCount; j++) {\n                const sig = stack.get(-sigTop - j);\n                if (!(flags & Script.flags.VERIFY_SIGHASH_FORKID) || !(sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID)) subscript.findAndDelete(sig, flags);\n              }\n\n              nSigsRemaining = nSigsCount;\n              nKeysRemaining = nKeysCount;\n\n              while (res && nSigsCount > 0) {\n                const sig = stack.get(-isig);\n                const key = stack.get(-ikey);\n                checkTransactionECDSASignature(sig, flags);\n                validateKey(key, flags);\n\n                if (sig.length > 0) {\n                  const type = sig[sig.length - 1];\n                  const hash = tx.signatureHash(index, subscript, value, type, flags);\n\n                  if (checksig(hash, sig, key)) {\n                    isig += 1;\n                    nSigsCount -= 1;\n                  }\n                }\n\n                ikey += 1;\n                nKeysCount -= 1;\n                if (nSigsCount > nKeysCount) res = false;\n              }\n\n              while (keyCount > 1) {\n                if (!res && flags & Script.flags.VERIFY_NULLFAIL) {\n                  if (okey === 0 && stack.get(-1).length !== 0) throw new ScriptError('NULLFAIL', op, ip);\n                }\n\n                if (okey > 0) okey -= 1;\n                stack.pop();\n                keyCount -= 1;\n              }\n\n              if (stack.length < 1) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n              stack.pop();\n              stack.pushBool(res);\n\n              if (op.value === opcodes.OP_CHECKMULTISIGVERIFY) {\n                if (!res) throw new ScriptError('CHECKMULTISIGVERIFY', op, ip);\n                stack.pop();\n              }\n            }\n\n            break;\n          }\n        //\n        // Byte string operations\n        //\n\n        case opcodes.OP_CAT:\n          {\n            // (x1 x2 -- out)\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const v1 = stack.get(-2);\n            const v2 = stack.get(-1);\n\n            if (v1.length + v2.length > consensus.MAX_SCRIPT_PUSH) {\n              throw new ScriptError('PUSH_SIZE', op, ip);\n            }\n\n            stack.pop();\n            stack.pop();\n            stack.push(Buffer.concat([v1, v2]));\n            break;\n          }\n\n        case opcodes.OP_SPLIT:\n          {\n            // (in position -- x1 x2)\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const data = stack.get(-2); // Make sure the split point is appropriate.\n\n            const pos = stack.getInt(-1, minimal, 4);\n            if (pos < 0 || pos > data.length) throw new ScriptError('INVALID_SPLIT_RANGE', op, ip); // Prepare the results in their own buffer as `data`\n            // will be invalidated.\n\n            const n1 = data.slice(0, pos);\n            const n2 = data.slice(pos); // Replace existing stack values by the new values.\n\n            stack.set(-2, n1);\n            stack.set(-1, n2);\n            break;\n          }\n\n        case opcodes.OP_REVERSEBYTES:\n          {\n            if (stack.length < 1) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const data = stack.get(-1);\n            data.reverse();\n            break;\n          }\n        //\n        // Bitwise logic\n        //\n\n        case opcodes.OP_AND:\n        case opcodes.OP_OR:\n        case opcodes.OP_XOR:\n          {\n            // (x1 x2 - out)\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const v1 = stack.get(-2);\n            const v2 = stack.get(-1); // Inputs must be the same size\n\n            if (v1.length !== v2.length) throw new ScriptError('INVALID_OPERAND_SIZE', op, ip);\n            const raw = Buffer.alloc(v1.length);\n\n            switch (op.value) {\n              case opcodes.OP_AND:\n                for (let i = 0; i < v1.length; i++) {\n                  raw[i] = v1[i] & v2[i];\n                }\n\n                break;\n\n              case opcodes.OP_OR:\n                for (let i = 0; i < v1.length; i++) {\n                  raw[i] = v1[i] | v2[i];\n                }\n\n                break;\n\n              case opcodes.OP_XOR:\n                for (let i = 0; i < v1.length; i++) {\n                  raw[i] = v1[i] ^ v2[i];\n                }\n\n                break;\n\n              default:\n                break;\n            } // And pop v1 and v2.\n\n\n            stack.pop();\n            stack.pop();\n            stack.push(raw);\n            break;\n          }\n        //\n        // Conversion operations\n        //\n\n        case opcodes.OP_NUM2BIN:\n          {\n            // (in size -- out)\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const size = stack.getInt(-1, minimal, 4);\n            if (size < 0 || size > consensus.MAX_SCRIPT_PUSH) throw new ScriptError('PUSH_SIZE', op, ip);\n            stack.pop();\n            const n = stack.get(-1);\n            const v = ScriptNum.toMinimal(Buffer.from(n)); // Try to see if we can fit that number in the number of\n            // byte requested.\n\n            if (v.length > size) // We definitively cannot.\n              throw new ScriptError('IMPOSSIBLE_ENCODING', op, ip); // We already have an element of the right size, we don't need to do\n            // anything.\n\n            if (v.length === size) {\n              stack.pop();\n              stack.push(v);\n              break;\n            }\n\n            const raw = Buffer.alloc(size);\n            v.copy(raw);\n            let signbit = 0x00;\n\n            if (v.length > 0) {\n              signbit = v[v.length - 1] & 0x80;\n              raw[v.length - 1] &= 0x7f;\n            }\n\n            raw[size - 1] = signbit;\n            stack.pop();\n            stack.push(raw);\n            break;\n          }\n\n        case opcodes.OP_BIN2NUM:\n          {\n            // (in -- out)\n            if (stack.length < 1) {\n              throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            }\n\n            const n = stack.get(-1);\n            const v = ScriptNum.toMinimal(Buffer.from(n));\n            stack.pop();\n            stack.push(v); // The resulting number must be a valid number.\n\n            if (!ScriptNum.isMinimal(v) || v.length > 4) throw new ScriptError('INVALID_NUMBER_RANGE', op, ip);\n            break;\n          }\n\n        default:\n          {\n            throw new ScriptError('BAD_OPCODE', op, ip);\n          }\n      }\n    }\n\n    if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK) throw new ScriptError('STACK_SIZE');\n    if (state.length !== 0) throw new ScriptError('UNBALANCED_CONDITIONAL');\n  }\n  /**\n   * Remove all matched data elements from\n   * a script's code (used to remove signatures\n   * before verification). Note that this\n   * compares and removes data on the _byte level_.\n   * It also reserializes the data to a single\n   * script with minimaldata encoding beforehand.\n   * A signature will _not_ be removed if it is\n   * not minimaldata.\n   * @see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-November/006878.html\n   * @see https://test.webbtc.com/tx/19aa42fee0fa57c45d3b16488198b27caaacc4ff5794510d0c17f173f05587ff\n   * @param {Buffer} data - Data element to match against.\n   * @returns {Number} Total.\n   */\n\n\n  findAndDelete(data) {\n    const target = Opcode.fromPush(data);\n    if (this.raw.length < target.getSize()) return 0;\n    let found = false;\n\n    for (const op of this.code) {\n      if (op.value === -1) break;\n\n      if (op.equals(target)) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) return 0;\n    const code = [];\n    let total = 0;\n\n    for (const op of this.code) {\n      if (op.value === -1) break;\n\n      if (op.equals(target)) {\n        total += 1;\n        continue;\n      }\n\n      code.push(op);\n    }\n\n    this.code = code;\n    this.compile();\n    return total;\n  }\n  /**\n   * Find a data element in a script.\n   * @param {Buffer} data - Data element to match against.\n   * @returns {Number} Index (`-1` if not present).\n   */\n\n\n  indexOf(data) {\n    for (let i = 0; i < this.code.length; i++) {\n      const op = this.code[i];\n      if (op.value === -1) break;\n      if (!op.data) continue;\n      if (op.data.equals(data)) return i;\n    }\n\n    return -1;\n  }\n  /**\n   * Test a script to see if it is likely\n   * to be script code (no weird opcodes).\n   * @param {Number?} flags - Script standard flags.\n   * @returns {Boolean}\n   */\n\n\n  isCode(flags) {\n    if (flags == null) flags = Script.flags.STANDARD_VERIFY_FLAGS;\n\n    for (const op of this.code) {\n      if (op.value === -1) return false;\n      if (op.isDisabled(flags)) return false;\n\n      switch (op.value) {\n        case opcodes.OP_RESERVED:\n        case opcodes.OP_NOP:\n        case opcodes.OP_VER:\n        case opcodes.OP_VERIF:\n        case opcodes.OP_VERNOTIF:\n        case opcodes.OP_RESERVED1:\n        case opcodes.OP_RESERVED2:\n        case opcodes.OP_NOP1:\n          return false;\n      }\n\n      if (op.value > opcodes.OP_CHECKSEQUENCEVERIFY) return false;\n    }\n\n    return true;\n  }\n  /**\n   * Inject properties from a pay-to-pubkey script.\n   * @private\n   * @param {Buffer} key\n   */\n\n\n  fromPubkey(key) {\n    assert(Buffer.isBuffer(key) && (key.length === 33 || key.length === 65));\n    this.raw = Buffer.allocUnsafe(1 + key.length + 1);\n    this.raw[0] = key.length;\n    key.copy(this.raw, 1);\n    this.raw[1 + key.length] = opcodes.OP_CHECKSIG;\n    key = this.raw.slice(1, 1 + key.length);\n    this.code.length = 0;\n    this.code.push(Opcode.fromPush(key));\n    this.code.push(Opcode.fromOp(opcodes.OP_CHECKSIG));\n    return this;\n  }\n  /**\n   * Create a pay-to-pubkey script.\n   * @param {Buffer} key\n   * @returns {Script}\n   */\n\n\n  static fromPubkey(key) {\n    return new this().fromPubkey(key);\n  }\n  /**\n   * Inject properties from a pay-to-pubkeyhash script.\n   * @private\n   * @param {Buffer} hash\n   */\n\n\n  fromPubkeyhash(hash) {\n    assert(Buffer.isBuffer(hash) && hash.length === 20);\n    this.raw = Buffer.allocUnsafe(25);\n    this.raw[0] = opcodes.OP_DUP;\n    this.raw[1] = opcodes.OP_HASH160;\n    this.raw[2] = 0x14;\n    hash.copy(this.raw, 3);\n    this.raw[23] = opcodes.OP_EQUALVERIFY;\n    this.raw[24] = opcodes.OP_CHECKSIG;\n    hash = this.raw.slice(3, 23);\n    this.code.length = 0;\n    this.code.push(Opcode.fromOp(opcodes.OP_DUP));\n    this.code.push(Opcode.fromOp(opcodes.OP_HASH160));\n    this.code.push(Opcode.fromPush(hash));\n    this.code.push(Opcode.fromOp(opcodes.OP_EQUALVERIFY));\n    this.code.push(Opcode.fromOp(opcodes.OP_CHECKSIG));\n    return this;\n  }\n  /**\n   * Create a pay-to-pubkeyhash script.\n   * @param {Buffer} hash\n   * @returns {Script}\n   */\n\n\n  static fromPubkeyhash(hash) {\n    return new this().fromPubkeyhash(hash);\n  }\n  /**\n   * Inject properties from pay-to-multisig script.\n   * @private\n   * @param {Number} m\n   * @param {Number} n\n   * @param {Buffer[]} keys\n   */\n\n\n  fromMultisig(m, n, keys) {\n    assert((m & 0xff) === m && (n & 0xff) === n);\n    assert(Array.isArray(keys));\n    assert(keys.length === n, '`n` keys are required for multisig.');\n    assert(m >= 1 && m <= n);\n    assert(n >= 1 && n <= 15);\n    this.clear();\n    this.pushSmall(m);\n\n    for (const key of sortKeys(keys)) this.pushData(key);\n\n    this.pushSmall(n);\n    this.pushOp(opcodes.OP_CHECKMULTISIG);\n    return this.compile();\n  }\n  /**\n   * Create a pay-to-multisig script.\n   * @param {Number} m\n   * @param {Number} n\n   * @param {Buffer[]} keys\n   * @returns {Script}\n   */\n\n\n  static fromMultisig(m, n, keys) {\n    return new this().fromMultisig(m, n, keys);\n  }\n  /**\n   * Inject properties from a pay-to-scripthash script.\n   * @private\n   * @param {Buffer} hash\n   */\n\n\n  fromScripthash(hash) {\n    assert(Buffer.isBuffer(hash) && hash.length === 20);\n    this.raw = Buffer.allocUnsafe(23);\n    this.raw[0] = opcodes.OP_HASH160;\n    this.raw[1] = 0x14;\n    hash.copy(this.raw, 2);\n    this.raw[22] = opcodes.OP_EQUAL;\n    hash = this.raw.slice(2, 22);\n    this.code.length = 0;\n    this.code.push(Opcode.fromOp(opcodes.OP_HASH160));\n    this.code.push(Opcode.fromPush(hash));\n    this.code.push(Opcode.fromOp(opcodes.OP_EQUAL));\n    return this;\n  }\n  /**\n   * Create a pay-to-scripthash script.\n   * @param {Buffer} hash\n   * @returns {Script}\n   */\n\n\n  static fromScripthash(hash) {\n    return new this().fromScripthash(hash);\n  }\n  /**\n   * Inject properties from a nulldata/opreturn script.\n   * @private\n   * @param {Buffer} flags\n   */\n\n\n  fromNulldata(flags) {\n    assert(Buffer.isBuffer(flags));\n    assert(flags.length <= policy.MAX_OP_RETURN, 'Nulldata too large.');\n    this.clear();\n    this.pushOp(opcodes.OP_RETURN);\n    this.pushData(flags);\n    return this.compile();\n  }\n  /**\n   * Create a nulldata/opreturn script.\n   * @param {Buffer} flags\n   * @returns {Script}\n   */\n\n\n  static fromNulldata(flags) {\n    return new this().fromNulldata(flags);\n  }\n  /**\n   * Inject properties from an address.\n   * @private\n   * @param {Address|AddressString} address\n   */\n\n\n  fromAddress(address) {\n    if (typeof address === 'string') address = Address.fromString(address);\n    assert(address instanceof Address, 'Not an address.');\n    if (address.isPubkeyhash()) return this.fromPubkeyhash(address.hash);\n    if (address.isScripthash()) return this.fromScripthash(address.hash);\n    throw new Error('Unknown address type.');\n  }\n  /**\n   * Create an output script from an address.\n   * @param {Address|AddressString} address\n   * @returns {Script}\n   */\n\n\n  static fromAddress(address) {\n    return new this().fromAddress(address);\n  }\n  /**\n   * Grab and deserialize the redeem script.\n   * @returns {Script|null} Redeem script.\n   */\n\n\n  getRedeem() {\n    let data = null;\n\n    for (const op of this.code) {\n      if (op.value === -1) return null;\n      if (op.value > opcodes.OP_16) return null;\n      data = op.data;\n    }\n\n    if (!data) return null;\n    return Script.fromRaw(data);\n  }\n  /**\n   * Get the standard script type.\n   * @returns {ScriptType}\n   */\n\n\n  getType() {\n    if (this.isPubkey()) return scriptTypes.PUBKEY;\n    if (this.isPubkeyhash()) return scriptTypes.PUBKEYHASH;\n    if (this.isScripthash()) return scriptTypes.SCRIPTHASH;\n    if (this.isMultisig()) return scriptTypes.MULTISIG;\n    if (this.isNulldata()) return scriptTypes.NULLDATA;\n    return scriptTypes.NONSTANDARD;\n  }\n  /**\n   * Test whether a script is of an unknown/non-standard type.\n   * @returns {Boolean}\n   */\n\n\n  isUnknown() {\n    return this.getType() === scriptTypes.NONSTANDARD;\n  }\n  /**\n   * Test whether the script is standard by policy standards.\n   * @returns {Boolean}\n   */\n\n\n  isStandard() {\n    const [m, n] = this.getMultisig();\n\n    if (m !== -1) {\n      if (n < 1 || n > 3) return false;\n      if (m < 1 || m > n) return false;\n      return true;\n    }\n\n    if (this.isNulldata()) return this.raw.length <= policy.MAX_OP_RETURN_BYTES;\n    return this.getType() !== scriptTypes.NONSTANDARD;\n  }\n  /**\n   * Calculate the size of the script\n   * excluding the varint size bytes.\n   * @returns {Number}\n   */\n\n\n  getSize() {\n    return this.raw.length;\n  }\n  /**\n   * Calculate the size of the script\n   * including the varint size bytes.\n   * @returns {Number}\n   */\n\n\n  getVarSize() {\n    return encoding.sizeVarBytes(this.raw);\n  }\n  /**\n   * \"Guess\" the address of the input script.\n   * This method is not 100% reliable.\n   * @returns {Address|null}\n   */\n\n\n  getInputAddress() {\n    return Address.fromInputScript(this);\n  }\n  /**\n   * Get the address of the script if present. Note that\n   * pubkey and multisig scripts will be treated as though\n   * they are pubkeyhash and scripthashes respectively.\n   * @returns {Address|null}\n   */\n\n\n  getAddress() {\n    return Address.fromScript(this);\n  }\n  /**\n   * Get the hash160 of the raw script.\n   * @param {String?} enc\n   * @returns {Hash}\n   */\n\n\n  hash160(enc) {\n    let hash = hash160.digest(this.toRaw());\n    if (enc === 'hex') hash = hash.toString('hex');\n    return hash;\n  }\n  /**\n   * Get the sha256 of the raw script.\n   * @param {String?} enc\n   * @returns {Hash}\n   */\n\n\n  sha256(enc) {\n    let hash = sha256.digest(this.toRaw());\n    if (enc === 'hex') hash = hash.toString('hex');\n    return hash;\n  }\n  /**\n   * Test whether the output script is pay-to-pubkey.\n   * @param {Boolean} [minimal=false] - Minimaldata only.\n   * @returns {Boolean}\n   */\n\n\n  isPubkey(minimal) {\n    if (minimal) {\n      return this.raw.length >= 35 && (this.raw[0] === 33 || this.raw[0] === 65) && this.raw[0] + 2 === this.raw.length && this.raw[this.raw.length - 1] === opcodes.OP_CHECKSIG;\n    }\n\n    if (this.code.length !== 2) return false;\n    const size = this.getLength(0);\n    return (size === 33 || size === 65) && this.getOp(1) === opcodes.OP_CHECKSIG;\n  }\n  /**\n   * Get P2PK key if present.\n   * @param {Boolean} [minimal=false] - Minimaldata only.\n   * @returns {Buffer|null}\n   */\n\n\n  getPubkey(minimal) {\n    if (!this.isPubkey(minimal)) return null;\n    if (minimal) return this.raw.slice(1, 1 + this.raw[0]);\n    return this.getData(0);\n  }\n  /**\n   * Test whether the output script is pay-to-pubkeyhash.\n   * @param {Boolean} [minimal=false] - Minimaldata only.\n   * @returns {Boolean}\n   */\n\n\n  isPubkeyhash(minimal) {\n    if (minimal || this.raw.length === 25) {\n      return this.raw.length === 25 && this.raw[0] === opcodes.OP_DUP && this.raw[1] === opcodes.OP_HASH160 && this.raw[2] === 0x14 && this.raw[23] === opcodes.OP_EQUALVERIFY && this.raw[24] === opcodes.OP_CHECKSIG;\n    }\n\n    if (this.code.length !== 5) return false;\n    return this.getOp(0) === opcodes.OP_DUP && this.getOp(1) === opcodes.OP_HASH160 && this.getLength(2) === 20 && this.getOp(3) === opcodes.OP_EQUALVERIFY && this.getOp(4) === opcodes.OP_CHECKSIG;\n  }\n  /**\n   * Get P2PKH hash if present.\n   * @param {Boolean} [minimal=false] - Minimaldata only.\n   * @returns {Buffer|null}\n   */\n\n\n  getPubkeyhash(minimal) {\n    if (!this.isPubkeyhash(minimal)) return null;\n    if (minimal) return this.raw.slice(3, 23);\n    return this.getData(2);\n  }\n  /**\n     * Test whether the output script is pay-to-multisig.\n     * @param {Boolean} [minimal=true] - Minimaldata only.\n     * @returns {Boolean}\n     */\n\n\n  isMultisig(minimal) {\n    if (this.code.length < 4 || this.code.length > 19) return false;\n    if (this.getOp(-1) !== opcodes.OP_CHECKMULTISIG) return false;\n    const m = this.getSmall(0);\n    if (m < 1) return false;\n    const n = this.getSmall(-2);\n    if (n < 1 || m > n) return false;\n    if (this.code.length !== n + 3) return false;\n\n    for (let i = 1; i < n + 1; i++) {\n      const op = this.code[i];\n      const size = op.toLength();\n      if (size !== 33 && size !== 65) return false;\n      if (minimal && !op.isMinimal()) return false;\n    }\n\n    return true;\n  }\n  /**\n   * Get multisig m and n values if present.\n   * @param {Boolean} [minimal=false] - Minimaldata only.\n   * @returns {Array} [m, n]\n   */\n\n\n  getMultisig(minimal) {\n    if (!this.isMultisig(minimal)) return [-1, -1];\n    return [this.getSmall(0), this.getSmall(-2)];\n  }\n  /**\n   * Test whether the output script is pay-to-scripthash. Note that\n   * bitcoin itself requires scripthashes to be in strict minimaldata\n   * encoding. Using `OP_HASH160 OP_PUSHDATA1 [hash] OP_EQUAL` will\n   * _not_ be recognized as a scripthash.\n   * @returns {Boolean}\n   */\n\n\n  isScripthash() {\n    return this.raw.length === 23 && this.raw[0] === opcodes.OP_HASH160 && this.raw[1] === 0x14 && this.raw[22] === opcodes.OP_EQUAL;\n  }\n  /**\n   * Get P2SH hash if present.\n   * @returns {Buffer|null}\n   */\n\n\n  getScripthash() {\n    if (!this.isScripthash()) return null;\n    return this.getData(1);\n  }\n  /**\n   * Test whether the output script is nulldata/opreturn.\n   * @param {Boolean} [minimal=false] - Minimaldata only.\n   * @returns {Boolean}\n   */\n\n\n  isNulldata(minimal) {\n    if (this.code.length === 0) return false;\n    if (this.getOp(0) !== opcodes.OP_RETURN) return false;\n    if (this.code.length === 1) return true;\n\n    if (minimal) {\n      if (this.raw.length > policy.MAX_OP_RETURN_BYTES) return false;\n    }\n\n    for (let i = 1; i < this.code.length; i++) {\n      const op = this.code[i];\n      if (op.value === -1) return false;\n      if (op.value > opcodes.OP_16) return false;\n      if (minimal && !op.isMinimal()) return false;\n    }\n\n    return true;\n  }\n  /**\n   * Get OP_RETURN data if present.\n   * @param {Boolean} [minimal=false] - Minimaldata only.\n   * @returns {Buffer|null}\n   */\n\n\n  getNulldata(minimal) {\n    if (!this.isNulldata(minimal)) return null;\n\n    for (let i = 1; i < this.code.length; i++) {\n      const op = this.code[i];\n      const data = op.toPush();\n      if (data) return data;\n    }\n\n    return EMPTY_BUFFER;\n  }\n  /**\n   * Test whether the output script is a witness program.\n   * Note that this will return true even for malformed\n   * witness v0 programs.\n   * @returns {Boolean}\n   */\n\n\n  isProgram() {\n    if (this.raw.length < 4 || this.raw.length > 42) return false;\n\n    if (this.raw[0] !== opcodes.OP_0 && (this.raw[0] < opcodes.OP_1 || this.raw[0] > opcodes.OP_16)) {\n      return false;\n    }\n\n    if (this.raw[1] + 2 !== this.raw.length) return false;\n    return true;\n  }\n  /**\n   * Test whether the output script is unspendable.\n   * @returns {Boolean}\n   */\n\n\n  isUnspendable() {\n    if (this.raw.length > consensus.MAX_SCRIPT_SIZE) return true;\n    return this.raw.length > 0 && this.raw[0] === opcodes.OP_RETURN;\n  }\n  /**\n   * \"Guess\" the type of the input script.\n   * This method is not 100% reliable.\n   * @returns {ScriptType}\n   */\n\n\n  getInputType() {\n    if (this.isPubkeyInput()) return scriptTypes.PUBKEY;\n    if (this.isPubkeyhashInput()) return scriptTypes.PUBKEYHASH;\n    if (this.isScripthashInput()) return scriptTypes.SCRIPTHASH;\n    if (this.isMultisigInput()) return scriptTypes.MULTISIG;\n    return scriptTypes.NONSTANDARD;\n  }\n  /**\n   * \"Guess\" whether the input script is an unknown/non-standard type.\n   * This method is not 100% reliable.\n   * @returns {Boolean}\n   */\n\n\n  isUnknownInput() {\n    return this.getInputType() === scriptTypes.NONSTANDARD;\n  }\n  /**\n   * \"Guess\" whether the input script is pay-to-pubkey.\n   * This method is not 100% reliable.\n   * @returns {Boolean}\n   */\n\n\n  isPubkeyInput() {\n    if (this.code.length !== 1) return false;\n    const size = this.getLength(0);\n    return size >= 9 && size <= 73;\n  }\n  /**\n   * Get P2PK signature if present.\n   * @returns {Buffer|null}\n   */\n\n\n  getPubkeyInput() {\n    if (!this.isPubkeyInput()) return null;\n    return this.getData(0);\n  }\n  /**\n   * \"Guess\" whether the input script is pay-to-pubkeyhash.\n   * This method is not 100% reliable.\n   * @returns {Boolean}\n   */\n\n\n  isPubkeyhashInput() {\n    if (this.code.length !== 2) return false;\n    const sig = this.getLength(0);\n    const key = this.getLength(1);\n    return sig >= 9 && sig <= 73 && (key === 33 || key === 65);\n  }\n  /**\n   * Get P2PKH signature and key if present.\n   * @returns {Array} [sig, key]\n   */\n\n\n  getPubkeyhashInput() {\n    if (!this.isPubkeyhashInput()) return [null, null];\n    return [this.getData(0), this.getData(1)];\n  }\n  /**\n   * \"Guess\" whether the input script is pay-to-multisig.\n   * This method is not 100% reliable.\n   * @returns {Boolean}\n   */\n\n\n  isMultisigInput() {\n    if (this.code.length < 2) return false;\n    if (this.getOp(0) !== opcodes.OP_0) return false;\n    if (this.getOp(1) > opcodes.OP_PUSHDATA4) return false; // We need to rule out scripthash\n    // because it may look like multisig.\n\n    if (this.isScripthashInput()) return false;\n\n    for (let i = 1; i < this.code.length; i++) {\n      const size = this.getLength(i);\n      if (size < 9 || size > 73) return false;\n    }\n\n    return true;\n  }\n  /**\n   * Get multisig signatures if present.\n   * @returns {Buffer[]|null}\n   */\n\n\n  getMultisigInput() {\n    if (!this.isMultisigInput()) return null;\n    const sigs = [];\n\n    for (let i = 1; i < this.code.length; i++) sigs.push(this.getData(i));\n\n    return sigs;\n  }\n  /**\n   * \"Guess\" whether the input script is pay-to-scripthash.\n   * This method is not 100% reliable.\n   * @returns {Boolean}\n   */\n\n\n  isScripthashInput() {\n    if (this.code.length < 1) return false; // Grab the raw redeem script.\n\n    const raw = this.getData(-1); // Last data element should be an array\n    // for the redeem script.\n\n    if (!raw) return false; // Testing for scripthash inputs requires\n    // some evil magic to work. We do it by\n    // ruling things _out_. This test will not\n    // be correct 100% of the time. We rule\n    // out that the last data element is: a\n    // null dummy, a valid signature, a valid\n    // key, and we ensure that it is at least\n    // a script that does not use undefined\n    // opcodes.\n\n    if (raw.length === 0) return false;\n    if (common.isDERSignatureEncoding(raw.slice(0, -1))) return false;\n    if (common.isKeyEncoding(raw)) return false;\n    const redeem = Script.fromRaw(raw);\n    if (!redeem.isCode()) return false;\n    if (redeem.isUnspendable()) return false;\n    if (!this.isPushOnly()) return false;\n    return true;\n  }\n  /**\n   * Get P2SH redeem script if present.\n   * @returns {Buffer|null}\n   */\n\n\n  getScripthashInput() {\n    if (!this.isScripthashInput()) return null;\n    return this.getData(-1);\n  }\n  /**\n   * Get coinbase height.\n   * @returns {Number} `-1` if not present.\n   */\n\n\n  getCoinbaseHeight() {\n    return Script.getCoinbaseHeight(this.raw);\n  }\n  /**\n   * Get coinbase height.\n   * @param {Buffer} raw - Raw script.\n   * @returns {Number} `-1` if not present.\n   */\n\n\n  static getCoinbaseHeight(raw) {\n    if (raw.length === 0) return -1;\n    if (raw[0] >= opcodes.OP_1 && raw[0] <= opcodes.OP_16) return raw[0] - 0x50;\n    if (raw[0] > 0x06) return -1;\n    const op = Opcode.fromRaw(raw);\n    const num = op.toNum();\n    if (!num) return 1;\n    if (num.isNeg()) return -1;\n    if (!op.equals(Opcode.fromNum(num))) return -1;\n    return num.toDouble();\n  }\n  /**\n   * Test the script against a bloom filter.\n   * @param {Bloom} filter\n   * @returns {Boolean}\n   */\n\n\n  test(filter) {\n    for (const op of this.code) {\n      if (op.value === -1) break;\n      if (!op.data || op.data.length === 0) continue;\n      if (filter.test(op.data)) return true;\n    }\n\n    return false;\n  }\n  /**\n   * Test the script to see if it contains only push ops.\n   * Push ops are: OP_1NEGATE, OP_0-OP_16 and all PUSHDATAs.\n   * @returns {Boolean}\n   */\n\n\n  isPushOnly() {\n    for (const op of this.code) {\n      if (op.value === -1) return false;\n      if (op.value > opcodes.OP_16) return false;\n    }\n\n    return true;\n  }\n  /**\n   * Count the sigops in the script.\n   * @param {Boolean} accurate - Whether to enable accurate counting. This will\n   * take into account the `n` value for OP_CHECKMULTISIG(VERIFY).\n   * @returns {Number} sigop count\n   */\n\n\n  getSigops(accurate, flags) {\n    if (flags & Script.flags.VERIFY_ZERO_SIGOPS) return 0;\n    let total = 0;\n    let lastOp = -1;\n\n    for (const op of this.code) {\n      if (op.value === -1) break;\n\n      switch (op.value) {\n        case opcodes.OP_CHECKSIG:\n        case opcodes.OP_CHECKSIGVERIFY:\n          total += 1;\n          break;\n\n        case opcodes.OP_CHECKSDATAIG:\n        case opcodes.OP_CHECKDATASIGVERIFY:\n          if (flags & Script.flags.VERIFY_CHECKDATASIG) {\n            total += 1;\n          }\n\n          break;\n\n        case opcodes.OP_CHECKMULTISIG:\n        case opcodes.OP_CHECKMULTISIGVERIFY:\n          if (accurate && lastOp >= opcodes.OP_1 && lastOp <= opcodes.OP_16) total += lastOp - 0x50;else total += consensus.MAX_MULTISIG_PUBKEYS;\n          break;\n      }\n\n      lastOp = op.value;\n    }\n\n    return total;\n  }\n  /**\n   * Count the sigops in the script, taking into account redeem scripts.\n   * @param {Script} input - Input script, needed for access to redeem script.\n   * @param {VerifyFlags} flags\n   * @returns {Number} sigop count\n   */\n\n\n  getScripthashSigops(input, flags) {\n    if (!this.isScripthash()) return this.getSigops(true, flags);\n    const redeem = input.getRedeem();\n    if (!redeem) return 0;\n    return redeem.getSigops(true, flags);\n  }\n  /*\n   * Mutation\n   */\n\n\n  get(index) {\n    if (index < 0) index += this.code.length;\n    if (index < 0 || index >= this.code.length) return null;\n    return this.code[index];\n  }\n\n  pop() {\n    const op = this.code.pop();\n    return op || null;\n  }\n\n  shift() {\n    const op = this.code.shift();\n    return op || null;\n  }\n\n  remove(index) {\n    if (index < 0) index += this.code.length;\n    if (index < 0 || index >= this.code.length) return null;\n    const items = this.code.splice(index, 1);\n    if (items.length === 0) return null;\n    return items[0];\n  }\n\n  set(index, op) {\n    if (index < 0) index += this.code.length;\n    assert(Opcode.isOpcode(op));\n    assert(index >= 0 && index <= this.code.length);\n    this.code[index] = op;\n    return this;\n  }\n\n  push(op) {\n    assert(Opcode.isOpcode(op));\n    this.code.push(op);\n    return this;\n  }\n\n  unshift(op) {\n    assert(Opcode.isOpcode(op));\n    this.code.unshift(op);\n    return this;\n  }\n\n  insert(index, op) {\n    if (index < 0) index += this.code.length;\n    assert(Opcode.isOpcode(op));\n    assert(index >= 0 && index <= this.code.length);\n    this.code.splice(index, 0, op);\n    return this;\n  }\n  /*\n   * Op\n   */\n\n\n  getOp(index) {\n    const op = this.get(index);\n    return op ? op.value : -1;\n  }\n\n  popOp() {\n    const op = this.pop();\n    return op ? op.value : -1;\n  }\n\n  shiftOp() {\n    const op = this.shift();\n    return op ? op.value : -1;\n  }\n\n  removeOp(index) {\n    const op = this.remove(index);\n    return op ? op.value : -1;\n  }\n\n  setOp(index, value) {\n    return this.set(index, Opcode.fromOp(value));\n  }\n\n  pushOp(value) {\n    return this.push(Opcode.fromOp(value));\n  }\n\n  unshiftOp(value) {\n    return this.unshift(Opcode.fromOp(value));\n  }\n\n  insertOp(index, value) {\n    return this.insert(index, Opcode.fromOp(value));\n  }\n  /*\n   * Data\n   */\n\n\n  getData(index) {\n    const op = this.get(index);\n    return op ? op.data : null;\n  }\n\n  popData() {\n    const op = this.pop();\n    return op ? op.data : null;\n  }\n\n  shiftData() {\n    const op = this.shift();\n    return op ? op.data : null;\n  }\n\n  removeData(index) {\n    const op = this.remove(index);\n    return op ? op.data : null;\n  }\n\n  setData(index, data) {\n    return this.set(index, Opcode.fromData(data));\n  }\n\n  pushData(data) {\n    return this.push(Opcode.fromData(data));\n  }\n\n  unshiftData(data) {\n    return this.unshift(Opcode.fromData(data));\n  }\n\n  insertData(index, data) {\n    return this.insert(index, Opcode.fromData(data));\n  }\n  /*\n   * Length\n   */\n\n\n  getLength(index) {\n    const op = this.get(index);\n    return op ? op.toLength() : -1;\n  }\n  /*\n   * Push\n   */\n\n\n  getPush(index) {\n    const op = this.get(index);\n    return op ? op.toPush() : null;\n  }\n\n  popPush() {\n    const op = this.pop();\n    return op ? op.toPush() : null;\n  }\n\n  shiftPush() {\n    const op = this.shift();\n    return op ? op.toPush() : null;\n  }\n\n  removePush(index) {\n    const op = this.remove(index);\n    return op ? op.toPush() : null;\n  }\n\n  setPush(index, data) {\n    return this.set(index, Opcode.fromPush(data));\n  }\n\n  pushPush(data) {\n    return this.push(Opcode.fromPush(data));\n  }\n\n  unshiftPush(data) {\n    return this.unshift(Opcode.fromPush(data));\n  }\n\n  insertPush(index, data) {\n    return this.insert(index, Opcode.fromPush(data));\n  }\n  /*\n   * String\n   */\n\n\n  getString(index, enc) {\n    const op = this.get(index);\n    return op ? op.toString(enc) : null;\n  }\n\n  popString(enc) {\n    const op = this.pop();\n    return op ? op.toString(enc) : null;\n  }\n\n  shiftString(enc) {\n    const op = this.shift();\n    return op ? op.toString(enc) : null;\n  }\n\n  removeString(index, enc) {\n    const op = this.remove(index);\n    return op ? op.toString(enc) : null;\n  }\n\n  setString(index, str, enc) {\n    return this.set(index, Opcode.fromString(str, enc));\n  }\n\n  pushString(str, enc) {\n    return this.push(Opcode.fromString(str, enc));\n  }\n\n  unshiftString(str, enc) {\n    return this.unshift(Opcode.fromString(str, enc));\n  }\n\n  insertString(index, str, enc) {\n    return this.insert(index, Opcode.fromString(str, enc));\n  }\n  /*\n   * Small\n   */\n\n\n  getSmall(index) {\n    const op = this.get(index);\n    return op ? op.toSmall() : -1;\n  }\n\n  popSmall() {\n    const op = this.pop();\n    return op ? op.toSmall() : -1;\n  }\n\n  shiftSmall() {\n    const op = this.shift();\n    return op ? op.toSmall() : -1;\n  }\n\n  removeSmall(index) {\n    const op = this.remove(index);\n    return op ? op.toSmall() : -1;\n  }\n\n  setSmall(index, num) {\n    return this.set(index, Opcode.fromSmall(num));\n  }\n\n  pushSmall(num) {\n    return this.push(Opcode.fromSmall(num));\n  }\n\n  unshiftSmall(num) {\n    return this.unshift(Opcode.fromSmall(num));\n  }\n\n  insertSmall(index, num) {\n    return this.insert(index, Opcode.fromSmall(num));\n  }\n  /*\n   * Num\n   */\n\n\n  getNum(index, minimal, limit) {\n    const op = this.get(index);\n    return op ? op.toNum(minimal, limit) : null;\n  }\n\n  popNum(minimal, limit) {\n    const op = this.pop();\n    return op ? op.toNum(minimal, limit) : null;\n  }\n\n  shiftNum(minimal, limit) {\n    const op = this.shift();\n    return op ? op.toNum(minimal, limit) : null;\n  }\n\n  removeNum(index, minimal, limit) {\n    const op = this.remove(index);\n    return op ? op.toNum(minimal, limit) : null;\n  }\n\n  setNum(index, num) {\n    return this.set(index, Opcode.fromNum(num));\n  }\n\n  pushNum(num) {\n    return this.push(Opcode.fromNum(num));\n  }\n\n  unshiftNum(num) {\n    return this.unshift(Opcode.fromNum(num));\n  }\n\n  insertNum(index, num) {\n    return this.insert(index, Opcode.fromNum(num));\n  }\n  /*\n   * Int\n   */\n\n\n  getInt(index, minimal, limit) {\n    const op = this.get(index);\n    return op ? op.toInt(minimal, limit) : -1;\n  }\n\n  popInt(minimal, limit) {\n    const op = this.pop();\n    return op ? op.toInt(minimal, limit) : -1;\n  }\n\n  shiftInt(minimal, limit) {\n    const op = this.shift();\n    return op ? op.toInt(minimal, limit) : -1;\n  }\n\n  removeInt(index, minimal, limit) {\n    const op = this.remove(index);\n    return op ? op.toInt(minimal, limit) : -1;\n  }\n\n  setInt(index, num) {\n    return this.set(index, Opcode.fromInt(num));\n  }\n\n  pushInt(num) {\n    return this.push(Opcode.fromInt(num));\n  }\n\n  unshiftInt(num) {\n    return this.unshift(Opcode.fromInt(num));\n  }\n\n  insertInt(index, num) {\n    return this.insert(index, Opcode.fromInt(num));\n  }\n  /*\n   * Bool\n   */\n\n\n  getBool(index) {\n    const op = this.get(index);\n    return op ? op.toBool() : false;\n  }\n\n  popBool() {\n    const op = this.pop();\n    return op ? op.toBool() : false;\n  }\n\n  shiftBool() {\n    const op = this.shift();\n    return op ? op.toBool() : false;\n  }\n\n  removeBool(index) {\n    const op = this.remove(index);\n    return op ? op.toBool() : false;\n  }\n\n  setBool(index, value) {\n    return this.set(index, Opcode.fromBool(value));\n  }\n\n  pushBool(value) {\n    return this.push(Opcode.fromBool(value));\n  }\n\n  unshiftBool(value) {\n    return this.unshift(Opcode.fromBool(value));\n  }\n\n  insertBool(index, value) {\n    return this.insert(index, Opcode.fromBool(value));\n  }\n  /*\n   * Symbol\n   */\n\n\n  getSym(index) {\n    const op = this.get(index);\n    return op ? op.toSymbol() : null;\n  }\n\n  popSym() {\n    const op = this.pop();\n    return op ? op.toSymbol() : null;\n  }\n\n  shiftSym() {\n    const op = this.shift();\n    return op ? op.toSymbol() : null;\n  }\n\n  removeSym(index) {\n    const op = this.remove(index);\n    return op ? op.toSymbol() : null;\n  }\n\n  setSym(index, symbol) {\n    return this.set(index, Opcode.fromSymbol(symbol));\n  }\n\n  pushSym(symbol) {\n    return this.push(Opcode.fromSymbol(symbol));\n  }\n\n  unshiftSym(symbol) {\n    return this.unshift(Opcode.fromSymbol(symbol));\n  }\n\n  insertSym(index, symbol) {\n    return this.insert(index, Opcode.fromSymbol(symbol));\n  }\n  /**\n   * Inject properties from bitcoind test string.\n   * @private\n   * @param {String} items - Script string.\n   * @throws Parse error.\n   */\n\n\n  fromString(code) {\n    assert(typeof code === 'string');\n    code = code.trim();\n    if (code.length === 0) return this;\n    const items = code.split(/\\s+/);\n    const bw = bio.write();\n\n    for (const item of items) {\n      let symbol = item;\n      if (symbol.charCodeAt(0) & 32) symbol = symbol.toUpperCase();\n      if (!/^OP_/.test(symbol)) symbol = `OP_${symbol}`;\n      const value = opcodes[symbol];\n\n      if (value == null) {\n        if (item[0] === '\\'') {\n          assert(item[item.length - 1] === '\\'', 'Invalid string.');\n          const str = item.slice(1, -1);\n          const op = Opcode.fromString(str);\n          bw.writeBytes(op.toRaw());\n          continue;\n        }\n\n        if (/^-?\\d+$/.test(item)) {\n          const num = ScriptNum.fromString(item, 10);\n          const op = Opcode.fromNum(num);\n          bw.writeBytes(op.toRaw());\n          continue;\n        }\n\n        assert(item.indexOf('0x') === 0, 'Unknown opcode.');\n        const hex = item.substring(2);\n        const data = Buffer.from(hex, 'hex');\n        assert(data.length === hex.length / 2, 'Invalid hex string.');\n        bw.writeBytes(data);\n        continue;\n      }\n\n      bw.writeU8(value);\n    }\n\n    return this.fromRaw(bw.render());\n  }\n  /**\n   * Parse a bitcoind test script\n   * string into a script object.\n   * @param {String} items - Script string.\n   * @returns {Script}\n   * @throws Parse error.\n   */\n\n\n  static fromString(code) {\n    return new this().fromString(code);\n  }\n  /**\n   * Verify an input and output script, and a witness if present.\n   * @param {Script} input\n   * @param {Null} witness\n   * @param {Script} output\n   * @param {TX} tx\n   * @param {Number} index\n   * @param {Amount} value\n   * @param {VerifyFlags} flags\n   * @param {Number?} sigchecks\n   * @throws {ScriptError}\n   */\n\n\n  static verify(input, witness, output, tx, index, value, flags, sigchecks) {\n    if (flags == null) flags = Script.flags.STANDARD_VERIFY_FLAGS;\n\n    if (flags & Script.flags.VERIFY_SIGPUSHONLY) {\n      if (!input.isPushOnly()) throw new ScriptError('SIG_PUSHONLY');\n    }\n\n    if (flags & Script.flags.VERIFY_SIGHASH_FORKID) flags |= Script.flags.VERIFY_STRICTENC; // Setup a stack.\n\n    let stack = new Stack(); // Execute the input script\n\n    input.execute(stack, flags, tx, index, value, metrics.sigchecks); // Copy the stack for P2SH\n\n    let copy;\n    if (flags & Script.flags.VERIFY_P2SH) copy = stack.clone(); // Execute the previous output script.\n\n    output.execute(stack, flags, tx, index, value, metrics.sigchecks); // Verify the stack values.\n\n    if (stack.length === 0 || !stack.getBool(-1)) throw new ScriptError('EVAL_FALSE'); // If the script is P2SH, execute the real output script\n\n    if (flags & Script.flags.VERIFY_P2SH && output.isScripthash()) {\n      // P2SH can only have push ops in the scriptSig\n      if (!input.isPushOnly()) throw new ScriptError('SIG_PUSHONLY'); // Reset the stack\n\n      stack = copy; // Stack should not be empty at this point\n\n      if (stack.length === 0) throw new ScriptError('EVAL_FALSE'); // Grab the real redeem script\n\n      const raw = stack.pop();\n      const redeem = Script.fromRaw(raw);\n\n      if ((flags & Script.flags.VERIFY_DISALLOW_SEGWIT_RECOVERY) === 0 && stack.length === 0 && redeem.isProgram()) {\n        // Before activation all transaction count a value of 0\n        if (!(flags & Script.flags.REPORT_SIGCHECKS)) {\n          metrics.sigchecks = 0;\n        }\n\n        return;\n      } // Execute the redeem script.\n\n\n      redeem.execute(stack, flags, tx, index, value, 0, metrics.sigchecks); // Verify the the stack values.\n\n      if (stack.length === 0 || !stack.getBool(-1)) throw new ScriptError('EVAL_FALSE');\n    } // Ensure there is nothing left on the stack.\n\n\n    if (flags & Script.flags.VERIFY_CLEANSTACK) {\n      assert((flags & Script.flags.VERIFY_P2SH) !== 0);\n      if (stack.length !== 1) throw new ScriptError('CLEANSTACK');\n    }\n\n    if (flags & Script.flags.VERIFY_INPUT_SIGCHECKS) {\n      if (input.getSize() < metrics.sigchecks * 43 - 60) throw new ScriptError('INPUT_SIGCHECKS');\n    }\n\n    if (!(flags & Script.flags.REPORT_SIGCHECKS)) {\n      metrics.sigchecks = 0;\n    }\n  }\n  /**\n   * Inject properties from buffer reader.\n   * @private\n   * @param {BufferReader} br\n   */\n\n\n  fromReader(br) {\n    return this.fromRaw(br.readVarBytes());\n  }\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer}\n   */\n\n\n  fromRaw(data) {\n    const br = bio.read(data);\n    this.raw = data;\n\n    while (br.left()) this.code.push(Opcode.fromReader(br));\n\n    return this;\n  }\n  /**\n   * Create a script from buffer reader.\n   * @param {BufferReader} br\n   * @param {String?} enc - Either `\"hex\"` or `null`.\n   * @returns {Script}\n   */\n\n\n  static fromReader(br) {\n    return new this().fromReader(br);\n  }\n  /**\n   * Create a script from a serialized buffer.\n   * @param {Buffer|String} data - Serialized script.\n   * @param {String?} enc - Either `\"hex\"` or `null`.\n   * @returns {Script}\n   */\n\n\n  static fromRaw(data, enc) {\n    if (typeof data === 'string') data = Buffer.from(data, enc);\n    return new this().fromRaw(data);\n  }\n  /**\n   * Test whether an object a Script.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n\n  static isScript(obj) {\n    return obj instanceof Script;\n  }\n\n}\n/**\n * Script opcodes.\n * @enum {Number}\n * @default\n */\n\n\nScript.opcodes = common.opcodes;\n/**\n * Opcodes by value.\n * @const {RevMap}\n */\n\nScript.opcodesByVal = common.opcodesByVal;\n/**\n * Script and locktime flags. See {@link VerifyFlags}.\n * @enum {Number}\n */\n\nScript.flags = common.flags;\n/**\n * Sighash Types.\n * @enum {SighashType}\n * @default\n */\n\nScript.hashType = common.hashType;\n/**\n * Sighash types by value.\n * @const {RevMap}\n */\n\nScript.hashTypeByVal = common.hashTypeByVal;\n/**\n * Output script types.\n * @enum {Number}\n */\n\nScript.types = common.types;\n/**\n * Output script types by value.\n * @const {RevMap}\n */\n\nScript.typesByVal = common.typesByVal;\n/*\n * Helpers\n */\n\nfunction sortKeys(keys) {\n  return keys.slice().sort((a, b) => {\n    return a.compare(b);\n  });\n}\n/**\n * Test whether the data element is a valid key if VERIFY_STRICTENC is enabled.\n * @param {Buffer} key\n * @param {VerifyFlags?} flags\n * @returns {Boolean}\n * @throws {ScriptError}\n */\n\n\nfunction validateKey(key, flags) {\n  assert(Buffer.isBuffer(key));\n  assert(typeof flags === 'number');\n\n  if (flags & Script.flags.VERIFY_STRICTENC) {\n    if (!common.isKeyEncoding(key)) throw new ScriptError('PUBKEYTYPE');\n  }\n\n  if (flags & Script.flags.VERIFY_COMPRESSED_PUBKEYTYPE && !common.isCompressedEncoding(key)) {\n    throw new ScriptError('NONCOMPRESSED_PUBKEY');\n  }\n\n  ;\n  return true;\n}\n/**\n * Test whether the raw element is a valid signature based\n * on the encoding, S value, and sighash type.\n * In an ECDSA-only context, 64-byte signatures are bannned\n * when Schnorr Flag is set.\n * @param {Buffer} sig\n * @param {VerifyFlags?} flags\n * @returns {Boolean}\n * @throws {ScriptError}\n */\n\n\nfunction validateECDSASignature(sig, flags) {\n  assert(Buffer.isBuffer(sig));\n  assert(typeof flags === 'number');\n  if (common.isSchnorr(sig)) throw new ScriptError('SIG_BADLENGTH');\n\n  if (flags & Script.flags.VERIFY_DERSIG || flags & Script.flags.VERIFY_LOW_S || flags & Script.flags.VERIFY_STRICTENC) {\n    if (!common.isDERSignatureEncoding(sig)) throw new ScriptError('SIG_DER');\n  }\n\n  if (flags & Script.flags.VERIFY_LOW_S) {\n    if (!common.isLowDER(sig)) throw new ScriptError('SIG_HIGH_S');\n  }\n\n  return true;\n}\n/**\n * Test whether the tx element is a valid signature based\n * on the encoding, S value, and sighash type. Requires\n * VERIFY_STRICTENC, VERIFY_SIGHASH_FORKID to be enabled respectively.\n * Note that this will allow zero-length signatures.\n * @param {Buffer} sig\n * @param {VerifyFlags?} flags\n * @returns {Boolean}\n * @throws {ScriptError}\n */\n\n\nfunction checkSighashEncoding(sig, flags) {\n  assert(Buffer.isBuffer(sig));\n  assert(typeof flags === 'number');\n\n  if (flags & Script.flags.VERIFY_STRICTENC) {\n    if (!common.isHashType(sig)) throw new ScriptError('SIG_HASHTYPE');\n    const usesFork = sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID;\n    const forkEnabled = flags & Script.flags.VERIFY_SIGHASH_FORKID;\n    if (!forkEnabled && usesFork) throw new ScriptError('ILLEGAL_FORKID');\n    if (forkEnabled && !usesFork) throw new ScriptError('MUST_USE_FORKID');\n  }\n\n  return true;\n}\n/**\n * Test whether the transaction tested against\n * the Sighash Encoding is a valid Schnorr Signature.\n * Requires Sighash\n * @param {Buffer} sig\n * @param {VeirfyFlags?} flags\n * @returns {Boolean}\n * @throws {ScriptError}\n */\n\n\nfunction checkTransactionSignature(sig, flags) {\n  assert(Buffer.isBuffer(sig));\n  assert(typeof flags === 'number'); // allow empty sigs\n\n  if (sig.length === 0) return true;\n  validateSchnorrSignature(sig.slice(0, -1), flags);\n  return checkSighashEncoding(sig, flags);\n}\n/**\n * Test whether the transaction is tested\n * against the sighash encoding w schnorr / ecdsa\n * for multisig opcodes.\n * @param {Buffer} sig\n * @param {VerifyFlags?} flags\n */\n\n\nfunction checkTransactionSchnorrSig(sig, flags) {\n  assert(Buffer.isBuffer(sig));\n  assert(typeof flags === 'number'); // Allow empty sigs.\n\n  if (sig.length === 0) return true;\n  if (!isSchnorrEncoded(sig.slice(0, -1), flags)) return validateECDSASignature(sig.slice(0, -1), flags);\n  return checkSighashEncoding(sig, flags);\n}\n/**\n * Test whether the transaction tested against\n * the Sighash Encoding is a valid ECDSA Signature.\n * @param {Buffer} sig\n * @param {VerifyFlags?} flags\n * @returns {Boolean}\n * @throws {ScriptError}\n */\n\n\nfunction checkTransactionECDSASignature(sig, flags) {\n  assert(Buffer.isBuffer(sig));\n  assert(typeof flags === 'number'); // Allow empty sigs\n\n  if (sig.length === 0) return true;\n  validateECDSASignature(sig.slice(0, -1), flags);\n  return checkSighashEncoding(sig, flags);\n}\n/**\n * Test whether the data element is a valid signature based\n * on the encoding, S value, and sighash type. Requires\n * VERIFY_DERSIG|VERIFY_LOW_S|VERIFY_STRICTENC, and VERIFY_LOW_S\n * to be enabled respectively. Note that this will allow zero-length\n * signatures.\n * @param {Buffer} sig\n * @param {VerifyFlags?} flags\n * @returns {Boolean}\n * @throws {ScriptError}\n */\n\n\nfunction validateDataSignature(sig, flags) {\n  assert(Buffer.isBuffer(sig));\n  assert(typeof flags === 'number'); // Allow empty sigs\n\n  if (sig.length === 0) return true;\n  return validateSchnorrSignature(sig.slice(0, sig.length), flags);\n}\n/**\n * Test whether the Signature is valid in context\n * 64-byte signatures are interpreted as schnorr signatures.\n * Always correctly encoded when Verify_SCHNORR flag is set.\n * @param {Buffer} sig\n * @param {Buffer} msg - Signature hash.\n * @param {VerifyFlags?} flags\n * @returns {Promise}\n * @throws {ScriptError}\n */\n\n\nfunction validateSchnorrSignature(sig, flags) {\n  assert(Buffer.isBuffer(sig));\n  assert(typeof flags === 'number');\n  if (common.isSchnorr(sig)) return true;\n  return validateECDSASignature(sig, flags);\n}\n/**\n * Test whether the current signature is schnorr encoded.\n * @param {Buffer} sig\n * @param {VerifyFlags?} flags\n * @returns {Boolean}\n * @throws {ScriptError}\n */\n\n\nfunction isSchnorrEncoded(sig, flags) {\n  assert(Buffer.isBuffer(sig));\n  assert(typeof flags === 'number');\n  if (common.isSchnorr(sig)) return true;\n  throw new ScriptError('SIG_NONSCHNORR');\n}\n/**\n * Test whether the signature from the stack\n * is valid in either Schnorr or DER Format.\n * Always encoded correctly when Schnorr flag is set.\n * @param {Buffer} hash\n * @param {Buffer} sig\n * @param {Buffer} key\n * @param {Number} flags\n */\n\n\nfunction verifySignature(hash, sig, key, flags) {\n  assert(Buffer.isBuffer(hash));\n  assert(Buffer.isBuffer(sig));\n  assert(Buffer.isBuffer(key));\n  assert(typeof flags === 'number');\n  let res = false;\n\n  if (sig.length === 64) {\n    res = secp256k1.schnorrVerify(hash, sig, key, flags);\n  } else {\n    res = secp256k1.verifyDER(hash, sig, key, flags);\n  }\n\n  return res;\n}\n/**\n * Verify a signature, taking into account sighash type.\n * @param {Buffer} msg - Signature hash.\n * @param {Buffer} sig\n * @param {Buffer} key\n * @returns {Boolean}\n */\n\n\nfunction checksig(msg, sig, key) {\n  return secp256k1.verifyDER(msg, sig.slice(0, -1), key);\n}\n/*\n * Expose\n */\n\n\nmodule.exports = Script;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/script/script.js"],"names":["assert","require","bio","ripemd160","sha1","sha256","hash160","hash256","secp256k1","consensus","policy","Opcode","Stack","ScriptError","ScriptNum","common","Address","Metrics","opcodes","scriptTypes","types","countBits","encoding","EMPTY_BUFFER","Buffer","alloc","metrics","Script","constructor","options","raw","code","fromOptions","length","value","isBuffer","fromRaw","Array","isArray","fromArray","values","entries","Symbol","iterator","toArray","slice","clear","op","push","compile","toItems","items","data","toPush","Error","fromItems","item","pushData","toStack","fromStack","stack","clone","inject","script","equals","isScript","compare","inspect","toString","out","toFormat","join","toASM","decode","isNulldata","size","getSize","bw","write","toWriter","render","writeVarBytes","toRaw","toJSON","fromJSON","json","from","getSubscript","index","i","removeSeparators","found","OP_CODESEPARATOR","bitcalculator","abkam","nKeysCount","checkBits","bitfield_size","execute","flags","tx","sigchecks","STANDARD_VERIFY_FLAGS","MAX_SCRIPT_SIZE","state","alt","lastSep","opCount","negate","nSigsRemaining","nKeysRemaining","minimal","VERIFY_MINIMALDATA","ip","MAX_SCRIPT_PUSH","OP_16","MAX_SCRIPT_OPS","isDisabled","isBranch","MAX_SCRIPT_STACK","OP_PUSHDATA4","isMinimal","OP_0","pushInt","OP_1NEGATE","OP_1","OP_2","OP_3","OP_4","OP_5","OP_6","OP_7","OP_8","OP_9","OP_10","OP_11","OP_12","OP_13","OP_14","OP_15","OP_NOP","OP_CHECKLOCKTIMEVERIFY","VERIFY_CHECKLOCKTIMEVERIFY","VERIFY_DISCOURAGE_UPGRADABLE_NOPS","num","getNum","isNeg","locktime","toDouble","verifyLocktime","OP_CHECKSEQUENCEVERIFY","VERIFY_CHECKSEQUENCEVERIFY","verifySequence","OP_NOP1","OP_NOP4","OP_NOP5","OP_NOP6","OP_NOP7","OP_NOP8","OP_NOP9","OP_NOP10","OP_IF","OP_NOTIF","val","VERIFY_MINIMALIF","get","getBool","pop","OP_ELSE","OP_ENDIF","OP_VERIFY","OP_RETURN","OP_TOALTSTACK","OP_FROMALTSTACK","OP_2DROP","OP_2DUP","v1","v2","OP_3DUP","v3","OP_2OVER","OP_2ROT","erase","OP_2SWAP","swap","OP_IFDUP","OP_DEPTH","OP_DROP","OP_DUP","OP_NIP","remove","OP_OVER","OP_PICK","OP_ROLL","getInt","OP_ROT","OP_SWAP","OP_TUCK","insert","OP_SIZE","OP_EQUAL","OP_EQUALVERIFY","res","pushBool","OP_1ADD","OP_1SUB","OP_NEGATE","OP_ABS","OP_NOT","OP_0NOTEQUAL","cmp","iaddn","isubn","ineg","iabs","isZero","fromBool","pushNum","OP_ADD","OP_SUB","OP_DIV","OP_MOD","OP_BOOLAND","OP_BOOLOR","OP_NUMEQUAL","OP_NUMEQUALVERIFY","OP_NUMNOTEQUAL","OP_LESSTHAN","OP_GREATERTHAN","OP_LESSTHANOREQUAL","OP_GREATERTHANOREQUAL","OP_MIN","OP_MAX","n1","n2","iadd","isub","div","mod","toBool","eq","lt","gt","lte","gte","min","max","OP_WITHIN","n3","OP_RIPEMD160","digest","OP_SHA1","OP_SHA256","OP_HASH160","OP_HASH256","OP_CHECKSIG","OP_CHECKSIGVERIFY","sig","key","subscript","VERIFY_SIGHASH_FORKID","hashType","SIGHASH_FORKID","findAndDelete","checkTransactionSignature","validateKey","type","hash","signatureHash","verifySignature","VERIFY_NULLFAIL","OP_CHECKDATASIG","OP_CHECKDATASIGVERIFY","msg","validateDataSignature","OP_CHECKMULTISIG","OP_CHECKMULTISIGVERIFY","keyCount","sigCount","keyTop","sigTop","okey","ikey","isig","MAX_MULTISIG_PUBKEYS","nSigsCount","dummy","VERIFY_SCHNORR_MULTISIG","Math","floor","mask","numBits","bKey","bSig","ik3y","is1g","checkTransactionSchnorrSig","j","checkTransactionECDSASignature","checksig","OP_CAT","concat","OP_SPLIT","pos","set","OP_REVERSEBYTES","reverse","OP_AND","OP_OR","OP_XOR","OP_NUM2BIN","n","v","toMinimal","copy","signbit","OP_BIN2NUM","target","fromPush","total","indexOf","isCode","OP_RESERVED","OP_VER","OP_VERIF","OP_VERNOTIF","OP_RESERVED1","OP_RESERVED2","fromPubkey","allocUnsafe","fromOp","fromPubkeyhash","fromMultisig","m","keys","pushSmall","sortKeys","pushOp","fromScripthash","fromNulldata","MAX_OP_RETURN","fromAddress","address","fromString","isPubkeyhash","isScripthash","getRedeem","getType","isPubkey","PUBKEY","PUBKEYHASH","SCRIPTHASH","isMultisig","MULTISIG","NULLDATA","NONSTANDARD","isUnknown","isStandard","getMultisig","MAX_OP_RETURN_BYTES","getVarSize","sizeVarBytes","getInputAddress","fromInputScript","getAddress","fromScript","enc","getLength","getOp","getPubkey","getData","getPubkeyhash","getSmall","toLength","getScripthash","getNulldata","isProgram","isUnspendable","getInputType","isPubkeyInput","isPubkeyhashInput","isScripthashInput","isMultisigInput","isUnknownInput","getPubkeyInput","getPubkeyhashInput","getMultisigInput","sigs","isDERSignatureEncoding","isKeyEncoding","redeem","isPushOnly","getScripthashInput","getCoinbaseHeight","toNum","fromNum","test","filter","getSigops","accurate","VERIFY_ZERO_SIGOPS","lastOp","OP_CHECKSDATAIG","VERIFY_CHECKDATASIG","getScripthashSigops","input","shift","splice","isOpcode","unshift","popOp","shiftOp","removeOp","setOp","unshiftOp","insertOp","popData","shiftData","removeData","setData","fromData","unshiftData","insertData","getPush","popPush","shiftPush","removePush","setPush","pushPush","unshiftPush","insertPush","getString","popString","shiftString","removeString","setString","str","pushString","unshiftString","insertString","toSmall","popSmall","shiftSmall","removeSmall","setSmall","fromSmall","unshiftSmall","insertSmall","limit","popNum","shiftNum","removeNum","setNum","unshiftNum","insertNum","toInt","popInt","shiftInt","removeInt","setInt","fromInt","unshiftInt","insertInt","popBool","shiftBool","removeBool","setBool","unshiftBool","insertBool","getSym","toSymbol","popSym","shiftSym","removeSym","setSym","symbol","fromSymbol","pushSym","unshiftSym","insertSym","trim","split","charCodeAt","toUpperCase","writeBytes","hex","substring","writeU8","verify","witness","output","VERIFY_SIGPUSHONLY","VERIFY_STRICTENC","VERIFY_P2SH","VERIFY_DISALLOW_SEGWIT_RECOVERY","REPORT_SIGCHECKS","VERIFY_CLEANSTACK","VERIFY_INPUT_SIGCHECKS","fromReader","br","readVarBytes","read","left","obj","opcodesByVal","hashTypeByVal","typesByVal","sort","a","b","VERIFY_COMPRESSED_PUBKEYTYPE","isCompressedEncoding","validateECDSASignature","isSchnorr","VERIFY_DERSIG","VERIFY_LOW_S","isLowDER","checkSighashEncoding","isHashType","usesFork","forkEnabled","validateSchnorrSignature","isSchnorrEncoded","schnorrVerify","verifyDER","module","exports"],"mappings":"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","sourcesContent":["/*!\n * script.js - script interpreter for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bio = require('bufio');\nconst ripemd160 = require('bcrypto/lib/ripemd160');\nconst sha1 = require('bcrypto/lib/sha1');\nconst sha256 = require('bcrypto/lib/sha256');\nconst hash160 = require('bcrypto/lib/hash160');\nconst hash256 = require('bcrypto/lib/hash256');\nconst secp256k1 = require('bcrypto/lib/secp256k1');\nconst consensus = require('../protocol/consensus');\nconst policy = require('../protocol/policy');\nconst Opcode = require('./opcode');\nconst Stack = require('./stack');\nconst ScriptError = require('./scripterror');\nconst ScriptNum = require('./scriptnum');\nconst common = require('./common');\nconst Address = require('../primitives/address');\nconst Metrics = require('./metrics');\nconst opcodes = common.opcodes;\nconst scriptTypes = common.types;\nconst countBits = common.countBits;\nconst {encoding} = bio;\n\n\n/*\n * Constants\n */\n\nconst EMPTY_BUFFER = Buffer.alloc(0);\nconst metrics = new Metrics();\n\n/**\n * Script\n * Represents a input or output script.\n * @alias module:script.Script\n * @property {Array} code - Parsed script code.\n * @property {Buffer?} raw - Serialized script.\n * @property {Number} length - Number of parsed opcodes.\n */\n\nclass Script {\n  /**\n   * Create a script.\n   * @constructor\n   * @param {Buffer|Array|Object} code\n   */\n\n  constructor(options) {\n    this.raw = EMPTY_BUFFER;\n    this.code = [];\n\n    if (options)\n      this.fromOptions(options);\n  }\n\n  /**\n   * Get length.\n   * @returns {Number}\n   */\n\n  get length() {\n    return this.code.length;\n  }\n\n  /**\n   * Set length.\n   * @param {Number} value\n   */\n\n  set length(value) {\n    this.code.length = value;\n  }\n\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n  fromOptions(options) {\n    assert(options, 'Script data is required.');\n\n    if (Buffer.isBuffer(options))\n      return this.fromRaw(options);\n\n    if (Array.isArray(options))\n      return this.fromArray(options);\n\n    if (options.raw) {\n      if (!options.code)\n        return this.fromRaw(options.raw);\n      assert(Buffer.isBuffer(options.raw), 'Raw must be a Buffer.');\n      this.raw = options.raw;\n    }\n\n    if (options.code) {\n      if (!options.raw)\n        return this.fromArray(options.code);\n      assert(Array.isArray(options.code), 'Code must be an array.');\n      this.code = options.code;\n    }\n\n    return this;\n  }\n\n  /**\n   * Insantiate script from options object.\n   * @param {Object} options\n   * @returns {Script}\n   */\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n\n  /**\n   * Instantiate a value-only iterator.\n   * @returns {ScriptIterator}\n   */\n\n  values() {\n    return this.code.values();\n  }\n\n  /**\n   * Instantiate a key and value iterator.\n   * @returns {ScriptIterator}\n   */\n\n  entries() {\n    return this.code.entries();\n  }\n\n  /**\n   * Instantiate a value-only iterator.\n   * @returns {ScriptIterator}\n   */\n\n  [Symbol.iterator]() {\n    return this.code[Symbol.iterator]();\n  }\n\n  /**\n   * Convert the script to an array of\n   * Buffers (pushdatas) and Numbers\n   * (opcodes).\n   * @returns {Array}\n   */\n\n  toArray() {\n    return this.code.slice();\n  }\n\n  /**\n   * Inject properties from an array of\n   * of buffers and numbers.\n   * @private\n   * @param {Array} code\n   * @returns {Script}\n   */\n\n  fromArray(code) {\n    assert(Array.isArray(code));\n\n    this.clear();\n\n    for (const op of code)\n      this.push(op);\n\n    return this.compile();\n  }\n\n  /**\n   * Instantiate script from an array\n   * of buffers and numbers.\n   * @param {Array} code\n   * @returns {Script}\n   */\n\n  static fromArray(code) {\n    return new this().fromArray(code);\n  }\n\n  /**\n   * Convert script to stack items.\n   * @returns {Buffer[]}\n   */\n\n  toItems() {\n    const items = [];\n\n    for (const op of this.code) {\n      const data = op.toPush();\n\n      if (!data)\n        throw new Error('Non-push opcode in script.');\n\n      items.push(data);\n    }\n\n    return items;\n  }\n\n  /**\n   * Inject data from stack items.\n   * @private\n   * @param {Buffer[]} items\n   * @returns {Script}\n   */\n\n  fromItems(items) {\n    assert(Array.isArray(items));\n\n    this.clear();\n\n    for (const item of items)\n      this.pushData(item);\n\n    return this.compile();\n  }\n\n  /**\n   * Instantiate script from stack items.\n   * @param {Buffer[]} items\n   * @returns {Script}\n   */\n\n  static fromItems(items) {\n    return new this().fromItems(items);\n  }\n\n  /**\n   * Convert script to stack.\n   * @returns {Stack}\n   */\n\n  toStack() {\n    return new Stack(this.toItems());\n  }\n\n  /**\n   * Inject data from stack.\n   * @private\n   * @param {Stack} stack\n   * @returns {Script}\n   */\n\n  fromStack(stack) {\n    return this.fromItems(stack.items);\n  }\n\n  /**\n   * Instantiate script from stack.\n   * @param {Stack} stack\n   * @returns {Script}\n   */\n\n  static fromStack(stack) {\n    return new this().fromStack(stack);\n  }\n\n  /**\n   * Clone the script.\n   * @returns {Script} Cloned script.\n   */\n\n  clone() {\n    return new this.constructor().inject(this);\n  }\n\n  /**\n   * Inject properties from script.\n   * Used for cloning.\n   * @private\n   * @param {Script} script\n   * @returns {Script}\n   */\n\n  inject(script) {\n    this.raw = script.raw;\n    this.code = script.code.slice();\n    return this;\n  }\n\n  /**\n   * Test equality against script.\n   * @param {Script} script\n   * @returns {Boolean}\n   */\n\n  equals(script) {\n    assert(Script.isScript(script));\n    return this.raw.equals(script.raw);\n  }\n\n  /**\n   * Compare against another script.\n   * @param {Script} script\n   * @returns {Number}\n   */\n\n  compare(script) {\n    assert(Script.isScript(script));\n    return this.raw.compare(script.raw);\n  }\n\n  /**\n   * Clear the script.\n   * @returns {Script}\n   */\n\n  clear() {\n    this.raw = EMPTY_BUFFER;\n    this.code.length = 0;\n    return this;\n  }\n\n  /**\n   * Inspect the script.\n   * @returns {String} Human-readable script code.\n   */\n\n  inspect() {\n    return `<Script: ${this.toString()}>`;\n  }\n\n  /**\n   * Convert the script to a bitcoind test string.\n   * @returns {String} Human-readable script code.\n   */\n\n  toString() {\n    const out = [];\n\n    for (const op of this.code)\n      out.push(op.toFormat());\n\n    return out.join(' ');\n  }\n\n  /**\n   * Format the script as bitcoind asm.\n   * @param {Boolean?} decode - Attempt to decode hash types.\n   * @returns {String} Human-readable script.\n   */\n\n  toASM(decode) {\n    if (this.isNulldata())\n      decode = false;\n\n    const out = [];\n\n    for (const op of this.code)\n      out.push(op.toASM(decode));\n\n    return out.join(' ');\n  }\n\n  /**\n   * Re-encode the script internally. Useful if you\n   * changed something manually in the `code` array.\n   * @returns {Script}\n   */\n\n  compile() {\n    if (this.code.length === 0)\n      return this.clear();\n\n    let size = 0;\n\n    for (const op of this.code)\n      size += op.getSize();\n\n    const bw = bio.write(size);\n\n    for (const op of this.code)\n      op.toWriter(bw);\n\n    this.raw = bw.render();\n\n    return this;\n  }\n\n  /**\n   * Write the script to a buffer writer.\n   * @param {BufferWriter} bw\n   */\n\n  toWriter(bw) {\n    bw.writeVarBytes(this.raw);\n    return bw;\n  }\n\n  /**\n   * Encode the script to a Buffer. See {@link Script#encode}.\n   * @param {String} enc - Encoding, either `'hex'` or `null`.\n   * @returns {Buffer|String} Serialized script.\n   */\n\n  toRaw() {\n    return this.raw;\n  }\n\n  /**\n   * Convert script to a hex string.\n   * @returns {String}\n   */\n\n  toJSON() {\n    return this.toRaw().toString('hex');\n  }\n\n  /**\n   * Inject properties from json object.\n   * @private\n   * @param {String} json\n   */\n\n  fromJSON(json) {\n    assert(typeof json === 'string', 'Code must be a string.');\n    return this.fromRaw(Buffer.from(json, 'hex'));\n  }\n\n  /**\n   * Instantiate script from a hex string.\n   * @params {String} json\n   * @returns {Script}\n   */\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n\n  /**\n   * Get the script's \"subscript\" starting at a separator.\n   * @param {Number} index - The last separator to sign/verify beyond.\n   * @returns {Script} Subscript.\n   */\n\n  getSubscript(index) {\n    if (index === 0)\n      return this.clone();\n\n    const script = new Script();\n\n    for (let i = index; i < this.code.length; i++) {\n      const op = this.code[i];\n\n      if (op.value === -1)\n        break;\n\n      script.code.push(op);\n    }\n\n    return script.compile();\n  }\n\n  /**\n   * Get the script's \"subscript\" starting at a separator.\n   * Remove all OP_CODESEPARATORs if present. This bizarre\n   * behavior is necessary for signing and verification when\n   * code separators are present.\n   * @returns {Script} Subscript.\n   */\n\n  removeSeparators() {\n    let found = false;\n\n    // Optimizing for the common case:\n    // Check for any separators first.\n    for (const op of this.code) {\n      if (op.value === -1)\n        break;\n\n      if (op.value === opcodes.OP_CODESEPARATOR) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found)\n      return this;\n\n    // Uncommon case: someone actually\n    // has a code separator. Go through\n    // and remove them all.\n    const script = new Script();\n\n    for (const op of this.code) {\n      if (op.value === -1)\n        break;\n\n      if (op.value !== opcodes.OP_CODESEPARATOR)\n        script.code.push(op);\n    }\n\n    return script.compile();\n  }\n\n  /**\n   * Get the value of the checkBits while calculated as little endian.\n   * @param {Buffer} abkam - Stack depth of the dummy element.\n   * @param {Number?} nKeysCount - Stack depth of the top pubkeys.\n   * @returns {Number}\n   */\n\n  bitcalculator(abkam, nKeysCount) {\n    let checkBits = 0;\n\n    const bitfield_size = ((nKeysCount + 7) / 8);\n\n    for (let i = 0; i < bitfield_size; i++) {\n      checkBits |= abkam[i] << (8 * i);\n    }\n\n    return checkBits;\n  }\n\n  /**\n   * Execute and interpret the script.\n   * @param {Stack} stack - Script execution stack.\n   * @param {Number?} flags - Script standard flags.\n   * @param {TX?} tx - Transaction being verified.\n   * @param {Number?} index - Index of input being verified.\n   * @param {Amount?} value - Previous output value.\n   * @param {Number?} sigchecks\n   * @throws {ScriptError} Will be thrown on VERIFY failures.\n   */\n\n  execute(stack, flags, tx, index, value, sigchecks) {\n    if (flags == null)\n      flags = Script.flags.STANDARD_VERIFY_FLAGS;\n\n    if (this.getSize() > consensus.MAX_SCRIPT_SIZE)\n      throw new ScriptError('SCRIPT_SIZE');\n\n    const state = [];\n    const alt = [];\n\n    let lastSep = 0;\n    let opCount = 0;\n    let negate = 0;\n    let nSigsRemaining = 0;\n    let nKeysRemaining = 0;\n    let checkBits;\n    let minimal = false;\n\n    if (flags & Script.flags.VERIFY_MINIMALDATA)\n      minimal = true;\n\n    for (let ip = 0; ip < this.code.length; ip++) {\n      const op = this.code[ip];\n\n      if (op.value === -1)\n        throw new ScriptError('BAD_OPCODE', op, ip);\n\n      if (op.data && op.data.length > consensus.MAX_SCRIPT_PUSH)\n        throw new ScriptError('PUSH_SIZE', op, ip);\n\n      if (op.value > opcodes.OP_16 && ++opCount > consensus.MAX_SCRIPT_OPS)\n        throw new ScriptError('OP_COUNT', op, ip);\n\n      if (op.isDisabled(flags))\n        throw new ScriptError('DISABLED_OPCODE', op, ip);\n\n      if (negate && !op.isBranch()) {\n        if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK)\n          throw new ScriptError('STACK_SIZE', op, ip);\n        continue;\n      }\n\n      if (op.data && 0 <= op.value <= opcodes.OP_PUSHDATA4) {\n        if (minimal && !op.isMinimal())\n          throw new ScriptError('MINIMALDATA', op, ip);\n\n        stack.push(op.data);\n\n        if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK)\n          throw new ScriptError('STACK_SIZE', op, ip);\n\n        continue;\n      }\n\n      switch (op.value) {\n        case opcodes.OP_0: {\n          stack.pushInt(0);\n          break;\n        }\n        case opcodes.OP_1NEGATE: {\n          stack.pushInt(-1);\n          break;\n        }\n        case opcodes.OP_1:\n        case opcodes.OP_2:\n        case opcodes.OP_3:\n        case opcodes.OP_4:\n        case opcodes.OP_5:\n        case opcodes.OP_6:\n        case opcodes.OP_7:\n        case opcodes.OP_8:\n        case opcodes.OP_9:\n        case opcodes.OP_10:\n        case opcodes.OP_11:\n        case opcodes.OP_12:\n        case opcodes.OP_13:\n        case opcodes.OP_14:\n        case opcodes.OP_15:\n        case opcodes.OP_16: {\n          stack.pushInt(op.value - 0x50);\n          break;\n        }\n        case opcodes.OP_NOP: {\n          break;\n        }\n        case opcodes.OP_CHECKLOCKTIMEVERIFY: {\n          // OP_CHECKLOCKTIMEVERIFY = OP_NOP2\n          if (!(flags & Script.flags.VERIFY_CHECKLOCKTIMEVERIFY)) {\n            if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n              throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);\n            break;\n          }\n\n          if (!tx)\n            throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const num = stack.getNum(-1, minimal, 5);\n\n          if (num.isNeg())\n            throw new ScriptError('NEGATIVE_LOCKTIME', op, ip);\n\n          const locktime = num.toDouble();\n\n          if (!tx.verifyLocktime(index, locktime))\n            throw new ScriptError('UNSATISFIED_LOCKTIME', op, ip);\n\n          break;\n        }\n        case opcodes.OP_CHECKSEQUENCEVERIFY: {\n          // OP_CHECKSEQUENCEVERIFY = OP_NOP3\n          if (!(flags & Script.flags.VERIFY_CHECKSEQUENCEVERIFY)) {\n            if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n              throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);\n            break;\n          }\n\n          if (!tx)\n            throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const num = stack.getNum(-1, minimal, 5);\n\n          if (num.isNeg())\n            throw new ScriptError('NEGATIVE_LOCKTIME', op, ip);\n\n          const locktime = num.toDouble();\n\n          if (!tx.verifySequence(index, locktime))\n            throw new ScriptError('UNSATISFIED_LOCKTIME', op, ip);\n\n          break;\n        }\n        case opcodes.OP_NOP1:\n        case opcodes.OP_NOP4:\n        case opcodes.OP_NOP5:\n        case opcodes.OP_NOP6:\n        case opcodes.OP_NOP7:\n        case opcodes.OP_NOP8:\n        case opcodes.OP_NOP9:\n        case opcodes.OP_NOP10: {\n          if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n            throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);\n          break;\n        }\n        case opcodes.OP_IF:\n        case opcodes.OP_NOTIF: {\n          let val = false;\n\n          if (!negate) {\n            if (stack.length < 1)\n              throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);\n\n            if (flags & Script.flags.VERIFY_MINIMALIF) {\n              const item = stack.get(-1);\n\n              if (item.length > 1)\n                throw new ScriptError('MINIMALIF');\n\n              if (item.length === 1 && item[0] !== 1)\n                throw new ScriptError('MINIMALIF');\n            }\n\n            val = stack.getBool(-1);\n\n            if (op.value === opcodes.OP_NOTIF)\n              val = !val;\n\n            stack.pop();\n          }\n\n          state.push(val);\n\n          if (!val)\n            negate += 1;\n\n          break;\n        }\n        case opcodes.OP_ELSE: {\n          if (state.length === 0)\n            throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);\n\n          state[state.length - 1] = !state[state.length - 1];\n\n          if (!state[state.length - 1])\n            negate += 1;\n          else\n            negate -= 1;\n\n          break;\n        }\n        case opcodes.OP_ENDIF: {\n          if (state.length === 0)\n            throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);\n\n          if (!state.pop())\n            negate -= 1;\n\n          break;\n        }\n        case opcodes.OP_VERIFY: {\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          if (!stack.getBool(-1))\n            throw new ScriptError('VERIFY', op, ip);\n\n          stack.pop();\n\n          break;\n        }\n        case opcodes.OP_RETURN: {\n          throw new ScriptError('OP_RETURN', op, ip);\n        }\n        case opcodes.OP_TOALTSTACK: {\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          alt.push(stack.pop());\n          break;\n        }\n        case opcodes.OP_FROMALTSTACK: {\n          if (alt.length === 0)\n            throw new ScriptError('INVALID_ALTSTACK_OPERATION', op, ip);\n\n          stack.push(alt.pop());\n          break;\n        }\n        case opcodes.OP_2DROP: {\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.pop();\n          stack.pop();\n          break;\n        }\n        case opcodes.OP_2DUP: {\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const v1 = stack.get(-2);\n          const v2 = stack.get(-1);\n\n          stack.push(v1);\n          stack.push(v2);\n          break;\n        }\n        case opcodes.OP_3DUP: {\n          if (stack.length < 3)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const v1 = stack.get(-3);\n          const v2 = stack.get(-2);\n          const v3 = stack.get(-1);\n\n          stack.push(v1);\n          stack.push(v2);\n          stack.push(v3);\n          break;\n        }\n        case opcodes.OP_2OVER: {\n          if (stack.length < 4)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const v1 = stack.get(-4);\n          const v2 = stack.get(-3);\n\n          stack.push(v1);\n          stack.push(v2);\n          break;\n        }\n        case opcodes.OP_2ROT: {\n          if (stack.length < 6)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const v1 = stack.get(-6);\n          const v2 = stack.get(-5);\n\n          stack.erase(-6, -4);\n          stack.push(v1);\n          stack.push(v2);\n          break;\n        }\n        case opcodes.OP_2SWAP: {\n          if (stack.length < 4)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.swap(-4, -2);\n          stack.swap(-3, -1);\n          break;\n        }\n        case opcodes.OP_IFDUP: {\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          if (stack.getBool(-1)) {\n            const val = stack.get(-1);\n            stack.push(val);\n          }\n\n          break;\n        }\n        case opcodes.OP_DEPTH: {\n          stack.pushInt(stack.length);\n          break;\n        }\n        case opcodes.OP_DROP: {\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.pop();\n          break;\n        }\n        case opcodes.OP_DUP: {\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.push(stack.get(-1));\n          break;\n        }\n        case opcodes.OP_NIP: {\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.remove(-2);\n          break;\n        }\n        case opcodes.OP_OVER: {\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.push(stack.get(-2));\n          break;\n        }\n        case opcodes.OP_PICK:\n        case opcodes.OP_ROLL: {\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const num = stack.getInt(-1, minimal, 4);\n          stack.pop();\n\n          if (num < 0 || num >= stack.length)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const val = stack.get(-num - 1);\n\n          if (op.value === opcodes.OP_ROLL)\n            stack.remove(-num - 1);\n\n          stack.push(val);\n          break;\n        }\n        case opcodes.OP_ROT: {\n          if (stack.length < 3)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.swap(-3, -2);\n          stack.swap(-2, -1);\n          break;\n        }\n        case opcodes.OP_SWAP: {\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.swap(-2, -1);\n          break;\n        }\n        case opcodes.OP_TUCK: {\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.insert(-2, stack.get(-1));\n          break;\n        }\n        case opcodes.OP_SIZE: {\n          if (stack.length < 1)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.pushInt(stack.get(-1).length);\n          break;\n        }\n        case opcodes.OP_EQUAL:\n        case opcodes.OP_EQUALVERIFY: {\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const v1 = stack.get(-2);\n          const v2 = stack.get(-1);\n\n          const res = v1.equals(v2);\n\n          stack.pop();\n          stack.pop();\n\n          stack.pushBool(res);\n\n          if (op.value === opcodes.OP_EQUALVERIFY) {\n            if (!res)\n              throw new ScriptError('EQUALVERIFY', op, ip);\n            stack.pop();\n          }\n\n          break;\n        }\n        case opcodes.OP_1ADD:\n        case opcodes.OP_1SUB:\n        case opcodes.OP_NEGATE:\n        case opcodes.OP_ABS:\n        case opcodes.OP_NOT:\n        case opcodes.OP_0NOTEQUAL: {\n          if (stack.length < 1)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          let num = stack.getNum(-1, minimal, 4);\n          let cmp;\n\n          switch (op.value) {\n            case opcodes.OP_1ADD:\n              num.iaddn(1);\n              break;\n            case opcodes.OP_1SUB:\n              num.isubn(1);\n              break;\n            case opcodes.OP_NEGATE:\n              num.ineg();\n              break;\n            case opcodes.OP_ABS:\n              num.iabs();\n              break;\n            case opcodes.OP_NOT:\n              cmp = num.isZero();\n              num = ScriptNum.fromBool(cmp);\n              break;\n            case opcodes.OP_0NOTEQUAL:\n              cmp = !num.isZero();\n              num = ScriptNum.fromBool(cmp);\n              break;\n            default:\n              assert(false, 'Fatal script error.');\n              break;\n          }\n\n          stack.pop();\n          stack.pushNum(num);\n\n          break;\n        }\n        case opcodes.OP_ADD:\n        case opcodes.OP_SUB:\n        case opcodes.OP_DIV:\n        case opcodes.OP_MOD:\n        case opcodes.OP_BOOLAND:\n        case opcodes.OP_BOOLOR:\n        case opcodes.OP_NUMEQUAL:\n        case opcodes.OP_NUMEQUALVERIFY:\n        case opcodes.OP_NUMNOTEQUAL:\n        case opcodes.OP_LESSTHAN:\n        case opcodes.OP_GREATERTHAN:\n        case opcodes.OP_LESSTHANOREQUAL:\n        case opcodes.OP_GREATERTHANOREQUAL:\n        case opcodes.OP_MIN:\n        case opcodes.OP_MAX: {\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const n1 = stack.getNum(-2, minimal, 4);\n          const n2 = stack.getNum(-1, minimal, 4);\n          let num, cmp;\n\n          switch (op.value) {\n            case opcodes.OP_ADD:\n              num = n1.iadd(n2);\n              break;\n            case opcodes.OP_SUB:\n              num = n1.isub(n2);\n              break;\n            case opcodes.OP_DIV:\n              if (n2.isZero())\n                throw new ScriptError('DIV_BY_ZERO', op, ip);\n              num = n1.div(n2);\n              break;\n            case opcodes.OP_MOD:\n              if (n2.isZero())\n                throw new ScriptError('MOD_BY_ZERO', op, ip);\n              num = n1.mod(n2);\n              break;\n            case opcodes.OP_BOOLAND:\n              cmp = n1.toBool() && n2.toBool();\n              num = ScriptNum.fromBool(cmp);\n              break;\n            case opcodes.OP_BOOLOR:\n              cmp = n1.toBool() || n2.toBool();\n              num = ScriptNum.fromBool(cmp);\n              break;\n            case opcodes.OP_NUMEQUAL:\n              cmp = n1.eq(n2);\n              num = ScriptNum.fromBool(cmp);\n              break;\n            case opcodes.OP_NUMEQUALVERIFY:\n              cmp = n1.eq(n2);\n              num = ScriptNum.fromBool(cmp);\n              break;\n            case opcodes.OP_NUMNOTEQUAL:\n              cmp = !n1.eq(n2);\n              num = ScriptNum.fromBool(cmp);\n              break;\n            case opcodes.OP_LESSTHAN:\n              cmp = n1.lt(n2);\n              num = ScriptNum.fromBool(cmp);\n              break;\n            case opcodes.OP_GREATERTHAN:\n              cmp = n1.gt(n2);\n              num = ScriptNum.fromBool(cmp);\n              break;\n            case opcodes.OP_LESSTHANOREQUAL:\n              cmp = n1.lte(n2);\n              num = ScriptNum.fromBool(cmp);\n              break;\n            case opcodes.OP_GREATERTHANOREQUAL:\n              cmp = n1.gte(n2);\n              num = ScriptNum.fromBool(cmp);\n              break;\n            case opcodes.OP_MIN:\n              num = ScriptNum.min(n1, n2);\n              break;\n            case opcodes.OP_MAX:\n              num = ScriptNum.max(n1, n2);\n              break;\n            default:\n              assert(false, 'Fatal script error.');\n              break;\n          }\n\n          stack.pop();\n          stack.pop();\n          stack.pushNum(num);\n\n          if (op.value === opcodes.OP_NUMEQUALVERIFY) {\n            if (!stack.getBool(-1))\n              throw new ScriptError('NUMEQUALVERIFY', op, ip);\n            stack.pop();\n          }\n\n          break;\n        }\n        case opcodes.OP_WITHIN: {\n          if (stack.length < 3)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const n1 = stack.getNum(-3, minimal, 4);\n          const n2 = stack.getNum(-2, minimal, 4);\n          const n3 = stack.getNum(-1, minimal, 4);\n\n          const val = n2.lte(n1) && n1.lt(n3);\n\n          stack.pop();\n          stack.pop();\n          stack.pop();\n\n          stack.pushBool(val);\n          break;\n        }\n        case opcodes.OP_RIPEMD160: {\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.push(ripemd160.digest(stack.pop()));\n          break;\n        }\n        case opcodes.OP_SHA1: {\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.push(sha1.digest(stack.pop()));\n          break;\n        }\n        case opcodes.OP_SHA256: {\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.push(sha256.digest(stack.pop()));\n          break;\n        }\n        case opcodes.OP_HASH160: {\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.push(hash160.digest(stack.pop()));\n          break;\n        }\n        case opcodes.OP_HASH256: {\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.push(hash256.digest(stack.pop()));\n          break;\n        }\n        case opcodes.OP_CODESEPARATOR: {\n          lastSep = ip + 1;\n          break;\n        }\n        case opcodes.OP_CHECKSIG:\n        case opcodes.OP_CHECKSIGVERIFY: {\n          if (!tx)\n            throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const sig = stack.get(-2);\n          const key = stack.get(-1);\n\n          const subscript = this.getSubscript(lastSep);\n\n          if (!(flags & Script.flags.VERIFY_SIGHASH_FORKID)\n            || !(sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID))\n            subscript.findAndDelete(sig);\n\n          checkTransactionSignature(sig, flags);\n          validateKey(key, flags);\n\n          let res = false;\n\n          if (sig.length > 0) {\n            const type = sig[sig.length - 1];\n            const hash = tx.signatureHash(\n              index,\n              subscript,\n              value,\n              type,\n              flags\n            );\n            res = verifySignature(hash, sig.slice(0, -1), key, flags);\n            metrics.sigchecks += 1;\n            sigchecks = metrics.sigchecks;\n          }\n\n          if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {\n            if (sig.length !== 0)\n              throw new ScriptError('NULLFAIL', op, ip);\n          }\n\n          stack.pop();\n          stack.pop();\n\n          stack.pushBool(res);\n\n          if (op.value === opcodes.OP_CHECKSIGVERIFY) {\n            if (!res)\n              throw new ScriptError('CHECKSIGVERIFY', op, ip);\n            stack.pop();\n          }\n\n          break;\n        }\n        case opcodes.OP_CHECKDATASIG:\n        case opcodes.OP_CHECKDATASIGVERIFY: {\n          // (sig message pubkey -- bool)\n          if (stack.length < 3)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const sig = stack.get(-3);\n          const msg = stack.get(-2);\n          const key = stack.get(-1);\n\n          validateDataSignature(sig, flags);\n          validateKey(key, flags);\n\n          let res = false;\n\n          if (sig.length > 0) {\n            const hash = sha256.digest(msg);\n            res = verifySignature(hash, sig, key, flags);\n            metrics.sigchecks += 1;\n\t    sigchecks = metrics.sigchecks;\n          }\n\n          if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {\n            if (sig.length !== 0)\n              throw new ScriptError('NULLFAIL', op, ip);\n          }\n\n          stack.pop();\n          stack.pop();\n          stack.pop();\n\n          stack.pushBool(res);\n\n          if (op.value === opcodes.OP_CHECKDATASIGVERIFY) {\n            if (!res)\n              throw new ScriptError('CHECKDATASIGVERIFY', op, ip);\n            stack.pop();\n          }\n\n          break;\n        }\n        case opcodes.OP_CHECKMULTISIG:\n        case opcodes.OP_CHECKMULTISIGVERIFY: {\n          if (!tx)\n            throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n\n          let keyCount = 1;\n          let sigCount = 0;\n          let keyTop, sigTop;\n\n          if (stack.length < keyCount)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          let nKeysCount = stack.getInt(-keyCount, minimal, 4);\n          let okey = nKeysCount + 2;\n          let ikey, isig;\n\n          if (nKeysCount < 0 || nKeysCount > consensus.MAX_MULTISIG_PUBKEYS)\n            throw new ScriptError('PUBKEY_COUNT', op, ip);\n\n          opCount += nKeysCount;\n\n          if (opCount > consensus.MAX_SCRIPT_OPS)\n            throw new ScriptError('OP_COUNT', op, ip);\n\n          keyCount += 1;\n          keyTop = keyCount;\n\n          // stack depth of nSigsCount\n          sigCount = keyTop + nKeysCount;\n\n          ikey = keyCount;\n          keyCount += nKeysCount;\n\n          if (stack.length < sigCount)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          let nSigsCount = stack.getInt(-sigCount, minimal, 4);\n\n          if (nSigsCount < 0 || nSigsCount > nKeysCount)\n            throw new ScriptError('SIG_COUNT', op, ip);\n\n          // stack depth of the top signature\n          sigTop = sigCount + 1;\n\n          // stack depth of the dummy element\n          const dummy = sigTop + nSigsCount;\n\n          if (stack.length < dummy)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          keyCount += 1;\n          isig = keyCount;\n          keyCount += nSigsCount;\n\n          const subscript = this.getSubscript(lastSep);\n          let res = true;\n\n          if ((flags & Script.flags.VERIFY_SCHNORR_MULTISIG)\n             && stack.get(-dummy).length !== 0) {\n              assert(consensus.MAX_MULTISIG_PUBKEYS < 32)\n\n            if (nKeysCount > 32)\n              throw new ScriptError('INVALID_BITFIELD_SIZE', op, ip);\n\n            const bitfield_size = Math.floor((nKeysCount + 7) / 8);\n            const abkam = stack.get(-dummy);\n\n            if (abkam.length !== bitfield_size)\n              throw new ScriptError('BITFIELD_SIZE', op, ip);\n\n            checkBits = this.bitcalculator(abkam, nKeysCount);\n\n            const mask = (1 << nKeysCount) - 1;\n            const numBits = countBits(checkBits);\n\n            if ((checkBits & mask) !== checkBits)\n              throw new ScriptError('BIT_RANGE', op, ip);\n\n            if (numBits !== nSigsCount)\n              throw new ScriptError('INVALID_BIT_COUNT', op, ip);\n\n            const bKey = keyTop + nKeysCount - 1;\n            const bSig = sigTop + nSigsCount - 1;\n\n            let ik3y = 0;\n\n            for (let is1g = 0; is1g < nSigsCount; is1g++, ik3y++) {\n              if ((checkBits >> ik3y) === 0) {\n                throw new ScriptError('INVALID_BIT_RANGE', op, ip);\n              }\n\n              while (((checkBits >> ik3y) & 0x01) === 0) {\n                ik3y++;\n              }\n\n              if (ik3y >= nKeysCount)\n                throw new ScriptError('PUBKEY_COUNT', op, ip);\n\n              const sig = stack.get(-bSig + is1g);\n              const key = stack.get(-bKey + ik3y);\n\n              // Handle checkbits left over\n              if (!sig)\n                continue;\n\n              checkTransactionSchnorrSig(sig, flags);\n              validateKey(key, flags);\n\n              if (sig.length > 0) {\n                const type = sig[sig.length - 1];\n                const hash = tx.signatureHash(\n                  index,\n                  subscript,\n                  value,\n                  type,\n                  flags\n                );\n\n                res = verifySignature(hash, sig.slice(0, -1), key, flags);\n                metrics.sigchecks += 1;\n\t\t            sigchecks = metrics.sigchecks;\n              }\n\n              while (keyCount > 1) {\n                if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {\n                  if (okey === 0 && stack.get(-1).length !== 0)\n                    throw new ScriptError('NULLFAIL', op, ip);\n                }\n    \n                if (okey > 0)\n                  okey -= 1;\n    \n                stack.pop();\n    \n                keyCount -= 1;\n              }\n\n            }\n\n\n            if ((checkBits >> ik3y) !== 0)\n              throw new ScriptError('INVALID_BIT_COUNT', op, ip);\n\n            stack.pop();\n            stack.pushBool(res);\n\n          } else {\n            // Legacy Multisig (ECDSA / NULL)\n            // A bug causes CHECKMULTISIG to consume one extra\n            // argument whose contents were not checked in any way.\n\n          for (let j = 0; j < nSigsCount; j++) {\n            const sig = stack.get(-sigTop - j);\n            if (!(flags & Script.flags.VERIFY_SIGHASH_FORKID)\n              || !(sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID))\n              subscript.findAndDelete(sig, flags);\n          }\n\n          nSigsRemaining = nSigsCount;\n          nKeysRemaining = nKeysCount;\n\n          while (res && nSigsCount > 0) {\n            const sig = stack.get(-isig);\n            const key = stack.get(-ikey);\n\n            checkTransactionECDSASignature(sig, flags);\n            validateKey(key, flags);\n\n            if (sig.length > 0) {\n              const type = sig[sig.length - 1];\n              const hash = tx.signatureHash(\n                index,\n                subscript,\n                value,\n                type,\n                flags\n              );\n\n              if (checksig(hash, sig, key)) {\n                isig += 1;\n                nSigsCount -= 1;\n              }\n            }\n\n            ikey += 1;\n            nKeysCount -= 1;\n\n            if (nSigsCount > nKeysCount)\n              res = false;\n          }\n\n          while (keyCount > 1) {\n            if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {\n              if (okey === 0 && stack.get(-1).length !== 0)\n                throw new ScriptError('NULLFAIL', op, ip);\n            }\n\n            if (okey > 0)\n              okey -= 1;\n\n            stack.pop();\n\n            keyCount -= 1;\n          }\n\n          if (stack.length < 1)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.pop();\n\n          stack.pushBool(res);\n\n          if (op.value === opcodes.OP_CHECKMULTISIGVERIFY) {\n            if (!res)\n              throw new ScriptError('CHECKMULTISIGVERIFY', op, ip);\n            stack.pop();\n           }\n          }\n\n          break;\n        }\n\n        //\n        // Byte string operations\n        //\n        case opcodes.OP_CAT: {\n          // (x1 x2 -- out)\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const v1 = stack.get(-2);\n          const v2 = stack.get(-1);\n          if (v1.length + v2.length > consensus.MAX_SCRIPT_PUSH) {\n            throw new ScriptError('PUSH_SIZE', op, ip);\n          }\n          stack.pop();\n          stack.pop();\n\n          stack.push(Buffer.concat([v1, v2]));\n\n          break;\n        }\n\n        case opcodes.OP_SPLIT: {\n          // (in position -- x1 x2)\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const data = stack.get(-2);\n\n          // Make sure the split point is appropriate.\n          const pos = stack.getInt(-1, minimal, 4);\n          if (pos < 0 || pos > data.length)\n            throw new ScriptError('INVALID_SPLIT_RANGE', op, ip);\n\n          // Prepare the results in their own buffer as `data`\n          // will be invalidated.\n          const n1 = data.slice(0, pos);\n          const n2 = data.slice(pos);\n\n          // Replace existing stack values by the new values.\n          stack.set(-2, n1);\n          stack.set(-1, n2);\n          break;\n        }\n        case opcodes.OP_REVERSEBYTES: {\n         if (stack.length < 1)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const data = stack.get(-1);\n\n          data.reverse();\n\n          break;\n        }\n\n        //\n        // Bitwise logic\n        //\n        case opcodes.OP_AND:\n        case opcodes.OP_OR:\n        case opcodes.OP_XOR: {\n          // (x1 x2 - out)\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const v1 = stack.get(-2);\n          const v2 = stack.get(-1);\n\n          // Inputs must be the same size\n          if (v1.length !== v2.length)\n            throw new ScriptError('INVALID_OPERAND_SIZE', op, ip);\n\n          const raw = Buffer.alloc(v1.length);\n\n          switch (op.value) {\n            case opcodes.OP_AND:\n              for (let i = 0; i < v1.length; i++) {\n                raw[i] = v1[i] & v2[i];\n              }\n              break;\n            case opcodes.OP_OR:\n              for (let i = 0; i < v1.length; i++) {\n                raw[i] = v1[i] | v2[i];\n              }\n              break;\n            case opcodes.OP_XOR:\n              for (let i = 0; i < v1.length; i++) {\n                raw[i] = v1[i] ^ v2[i];\n              }\n              break;\n            default:\n              break;\n          }\n\n          // And pop v1 and v2.\n          stack.pop();\n          stack.pop();\n\n          stack.push(raw);\n\n          break;\n        }\n\n        //\n        // Conversion operations\n        //\n        case opcodes.OP_NUM2BIN: {\n          // (in size -- out)\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const size = stack.getInt(-1, minimal, 4);\n          if (size < 0 || size > consensus.MAX_SCRIPT_PUSH)\n            throw new ScriptError('PUSH_SIZE', op, ip);\n\n          stack.pop();\n\n          const n = stack.get(-1);\n          const v = ScriptNum.toMinimal(Buffer.from(n));\n\n          // Try to see if we can fit that number in the number of\n          // byte requested.\n          if (v.length > size)\n            // We definitively cannot.\n            throw new ScriptError('IMPOSSIBLE_ENCODING', op, ip);\n\n          // We already have an element of the right size, we don't need to do\n          // anything.\n          if (v.length === size) {\n            stack.pop();\n            stack.push(v);\n            break;\n          }\n\n          const raw = Buffer.alloc(size);\n          v.copy(raw);\n\n          let signbit = 0x00;\n          if (v.length > 0) {\n            signbit = v[v.length - 1] & 0x80;\n            raw[v.length - 1] &= 0x7f;\n          }\n\n          raw[size-1] = signbit;\n\n          stack.pop();\n          stack.push(raw);\n\n          break;\n        }\n\n        case opcodes.OP_BIN2NUM: {\n          // (in -- out)\n          if (stack.length < 1) {\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n          }\n\n          const n = stack.get(-1);\n          const v = ScriptNum.toMinimal(Buffer.from(n));\n\n          stack.pop();\n          stack.push(v);\n\n          // The resulting number must be a valid number.\n          if (!ScriptNum.isMinimal(v) || v.length > 4)\n            throw new ScriptError('INVALID_NUMBER_RANGE', op, ip);\n\n          break;\n        }\n\n        default: {\n          throw new ScriptError('BAD_OPCODE', op, ip);\n        }\n      }\n    }\n\n    if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK)\n      throw new ScriptError('STACK_SIZE');\n\n    if (state.length !== 0)\n      throw new ScriptError('UNBALANCED_CONDITIONAL');\n  }\n\n  /**\n   * Remove all matched data elements from\n   * a script's code (used to remove signatures\n   * before verification). Note that this\n   * compares and removes data on the _byte level_.\n   * It also reserializes the data to a single\n   * script with minimaldata encoding beforehand.\n   * A signature will _not_ be removed if it is\n   * not minimaldata.\n   * @see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-November/006878.html\n   * @see https://test.webbtc.com/tx/19aa42fee0fa57c45d3b16488198b27caaacc4ff5794510d0c17f173f05587ff\n   * @param {Buffer} data - Data element to match against.\n   * @returns {Number} Total.\n   */\n\n  findAndDelete(data) {\n    const target = Opcode.fromPush(data);\n\n    if (this.raw.length < target.getSize())\n      return 0;\n\n    let found = false;\n\n    for (const op of this.code) {\n      if (op.value === -1)\n        break;\n\n      if (op.equals(target)) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found)\n      return 0;\n\n    const code = [];\n\n    let total = 0;\n\n    for (const op of this.code) {\n      if (op.value === -1)\n        break;\n\n      if (op.equals(target)) {\n        total += 1;\n        continue;\n      }\n\n      code.push(op);\n    }\n\n    this.code = code;\n    this.compile();\n\n    return total;\n  }\n\n  /**\n   * Find a data element in a script.\n   * @param {Buffer} data - Data element to match against.\n   * @returns {Number} Index (`-1` if not present).\n   */\n\n  indexOf(data) {\n    for (let i = 0; i < this.code.length; i++) {\n      const op = this.code[i];\n\n      if (op.value === -1)\n        break;\n\n      if (!op.data)\n        continue;\n\n      if (op.data.equals(data))\n        return i;\n    }\n\n    return -1;\n  }\n\n  /**\n   * Test a script to see if it is likely\n   * to be script code (no weird opcodes).\n   * @param {Number?} flags - Script standard flags.\n   * @returns {Boolean}\n   */\n\n  isCode(flags) {\n    if (flags == null)\n      flags = Script.flags.STANDARD_VERIFY_FLAGS;\n\n    for (const op of this.code) {\n      if (op.value === -1)\n        return false;\n\n      if (op.isDisabled(flags))\n        return false;\n\n      switch (op.value) {\n        case opcodes.OP_RESERVED:\n        case opcodes.OP_NOP:\n        case opcodes.OP_VER:\n        case opcodes.OP_VERIF:\n        case opcodes.OP_VERNOTIF:\n        case opcodes.OP_RESERVED1:\n        case opcodes.OP_RESERVED2:\n        case opcodes.OP_NOP1:\n          return false;\n      }\n\n      if (op.value > opcodes.OP_CHECKSEQUENCEVERIFY)\n        return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Inject properties from a pay-to-pubkey script.\n   * @private\n   * @param {Buffer} key\n   */\n\n  fromPubkey(key) {\n    assert(Buffer.isBuffer(key) && (key.length === 33 || key.length === 65));\n\n    this.raw = Buffer.allocUnsafe(1 + key.length + 1);\n    this.raw[0] = key.length;\n    key.copy(this.raw, 1);\n    this.raw[1 + key.length] = opcodes.OP_CHECKSIG;\n\n    key = this.raw.slice(1, 1 + key.length);\n\n    this.code.length = 0;\n    this.code.push(Opcode.fromPush(key));\n    this.code.push(Opcode.fromOp(opcodes.OP_CHECKSIG));\n\n    return this;\n  }\n\n  /**\n   * Create a pay-to-pubkey script.\n   * @param {Buffer} key\n   * @returns {Script}\n   */\n\n  static fromPubkey(key) {\n    return new this().fromPubkey(key);\n  }\n\n  /**\n   * Inject properties from a pay-to-pubkeyhash script.\n   * @private\n   * @param {Buffer} hash\n   */\n\n  fromPubkeyhash(hash) {\n    assert(Buffer.isBuffer(hash) && hash.length === 20);\n\n    this.raw = Buffer.allocUnsafe(25);\n    this.raw[0] = opcodes.OP_DUP;\n    this.raw[1] = opcodes.OP_HASH160;\n    this.raw[2] = 0x14;\n    hash.copy(this.raw, 3);\n    this.raw[23] = opcodes.OP_EQUALVERIFY;\n    this.raw[24] = opcodes.OP_CHECKSIG;\n\n    hash = this.raw.slice(3, 23);\n\n    this.code.length = 0;\n    this.code.push(Opcode.fromOp(opcodes.OP_DUP));\n    this.code.push(Opcode.fromOp(opcodes.OP_HASH160));\n    this.code.push(Opcode.fromPush(hash));\n    this.code.push(Opcode.fromOp(opcodes.OP_EQUALVERIFY));\n    this.code.push(Opcode.fromOp(opcodes.OP_CHECKSIG));\n\n    return this;\n  }\n\n  /**\n   * Create a pay-to-pubkeyhash script.\n   * @param {Buffer} hash\n   * @returns {Script}\n   */\n\n  static fromPubkeyhash(hash) {\n    return new this().fromPubkeyhash(hash);\n  }\n\n  /**\n   * Inject properties from pay-to-multisig script.\n   * @private\n   * @param {Number} m\n   * @param {Number} n\n   * @param {Buffer[]} keys\n   */\n\n  fromMultisig(m, n, keys) {\n    assert((m & 0xff) === m && (n & 0xff) === n);\n    assert(Array.isArray(keys));\n    assert(keys.length === n, '`n` keys are required for multisig.');\n    assert(m >= 1 && m <= n);\n    assert(n >= 1 && n <= 15);\n\n    this.clear();\n\n    this.pushSmall(m);\n\n    for (const key of sortKeys(keys))\n      this.pushData(key);\n\n    this.pushSmall(n);\n    this.pushOp(opcodes.OP_CHECKMULTISIG);\n\n    return this.compile();\n  }\n\n  /**\n   * Create a pay-to-multisig script.\n   * @param {Number} m\n   * @param {Number} n\n   * @param {Buffer[]} keys\n   * @returns {Script}\n   */\n\n  static fromMultisig(m, n, keys) {\n    return new this().fromMultisig(m, n, keys);\n  }\n\n  /**\n   * Inject properties from a pay-to-scripthash script.\n   * @private\n   * @param {Buffer} hash\n   */\n\n  fromScripthash(hash) {\n    assert(Buffer.isBuffer(hash) && hash.length === 20);\n\n    this.raw = Buffer.allocUnsafe(23);\n    this.raw[0] = opcodes.OP_HASH160;\n    this.raw[1] = 0x14;\n    hash.copy(this.raw, 2);\n    this.raw[22] = opcodes.OP_EQUAL;\n\n    hash = this.raw.slice(2, 22);\n\n    this.code.length = 0;\n    this.code.push(Opcode.fromOp(opcodes.OP_HASH160));\n    this.code.push(Opcode.fromPush(hash));\n    this.code.push(Opcode.fromOp(opcodes.OP_EQUAL));\n\n    return this;\n  }\n\n  /**\n   * Create a pay-to-scripthash script.\n   * @param {Buffer} hash\n   * @returns {Script}\n   */\n\n  static fromScripthash(hash) {\n    return new this().fromScripthash(hash);\n  }\n\n  /**\n   * Inject properties from a nulldata/opreturn script.\n   * @private\n   * @param {Buffer} flags\n   */\n\n  fromNulldata(flags) {\n    assert(Buffer.isBuffer(flags));\n    assert(flags.length <= policy.MAX_OP_RETURN, 'Nulldata too large.');\n\n    this.clear();\n    this.pushOp(opcodes.OP_RETURN);\n    this.pushData(flags);\n\n    return this.compile();\n  }\n\n  /**\n   * Create a nulldata/opreturn script.\n   * @param {Buffer} flags\n   * @returns {Script}\n   */\n\n  static fromNulldata(flags) {\n    return new this().fromNulldata(flags);\n  }\n\n  /**\n   * Inject properties from an address.\n   * @private\n   * @param {Address|AddressString} address\n   */\n\n  fromAddress(address) {\n    if (typeof address === 'string')\n      address = Address.fromString(address);\n\n    assert(address instanceof Address, 'Not an address.');\n\n    if (address.isPubkeyhash())\n      return this.fromPubkeyhash(address.hash);\n\n    if (address.isScripthash())\n      return this.fromScripthash(address.hash);\n\n    throw new Error('Unknown address type.');\n  }\n\n  /**\n   * Create an output script from an address.\n   * @param {Address|AddressString} address\n   * @returns {Script}\n   */\n\n  static fromAddress(address) {\n    return new this().fromAddress(address);\n  }\n\n  /**\n   * Grab and deserialize the redeem script.\n   * @returns {Script|null} Redeem script.\n   */\n\n  getRedeem() {\n    let data = null;\n\n    for (const op of this.code) {\n      if (op.value === -1)\n        return null;\n\n      if (op.value > opcodes.OP_16)\n        return null;\n\n      data = op.data;\n    }\n\n    if (!data)\n      return null;\n\n    return Script.fromRaw(data);\n  }\n\n  /**\n   * Get the standard script type.\n   * @returns {ScriptType}\n   */\n\n  getType() {\n    if (this.isPubkey())\n      return scriptTypes.PUBKEY;\n\n    if (this.isPubkeyhash())\n      return scriptTypes.PUBKEYHASH;\n\n    if (this.isScripthash())\n      return scriptTypes.SCRIPTHASH;\n\n    if (this.isMultisig())\n      return scriptTypes.MULTISIG;\n\n    if (this.isNulldata())\n      return scriptTypes.NULLDATA;\n\n    return scriptTypes.NONSTANDARD;\n  }\n\n  /**\n   * Test whether a script is of an unknown/non-standard type.\n   * @returns {Boolean}\n   */\n\n  isUnknown() {\n    return this.getType() === scriptTypes.NONSTANDARD;\n  }\n\n  /**\n   * Test whether the script is standard by policy standards.\n   * @returns {Boolean}\n   */\n\n  isStandard() {\n    const [m, n] = this.getMultisig();\n\n    if (m !== -1) {\n      if (n < 1 || n > 3)\n        return false;\n\n      if (m < 1 || m > n)\n        return false;\n\n      return true;\n    }\n\n    if (this.isNulldata())\n      return this.raw.length <= policy.MAX_OP_RETURN_BYTES;\n\n    return this.getType() !== scriptTypes.NONSTANDARD;\n  }\n\n  /**\n   * Calculate the size of the script\n   * excluding the varint size bytes.\n   * @returns {Number}\n   */\n\n  getSize() {\n    return this.raw.length;\n  }\n\n  /**\n   * Calculate the size of the script\n   * including the varint size bytes.\n   * @returns {Number}\n   */\n\n  getVarSize() {\n    return encoding.sizeVarBytes(this.raw);\n  }\n\n  /**\n   * \"Guess\" the address of the input script.\n   * This method is not 100% reliable.\n   * @returns {Address|null}\n   */\n\n  getInputAddress() {\n    return Address.fromInputScript(this);\n  }\n\n  /**\n   * Get the address of the script if present. Note that\n   * pubkey and multisig scripts will be treated as though\n   * they are pubkeyhash and scripthashes respectively.\n   * @returns {Address|null}\n   */\n\n  getAddress() {\n    return Address.fromScript(this);\n  }\n\n  /**\n   * Get the hash160 of the raw script.\n   * @param {String?} enc\n   * @returns {Hash}\n   */\n\n  hash160(enc) {\n    let hash = hash160.digest(this.toRaw());\n    if (enc === 'hex')\n      hash = hash.toString('hex');\n    return hash;\n  }\n\n  /**\n   * Get the sha256 of the raw script.\n   * @param {String?} enc\n   * @returns {Hash}\n   */\n\n  sha256(enc) {\n    let hash = sha256.digest(this.toRaw());\n    if (enc === 'hex')\n      hash = hash.toString('hex');\n    return hash;\n  }\n\n  /**\n   * Test whether the output script is pay-to-pubkey.\n   * @param {Boolean} [minimal=false] - Minimaldata only.\n   * @returns {Boolean}\n   */\n\n  isPubkey(minimal) {\n    if (minimal) {\n      return this.raw.length >= 35\n        && (this.raw[0] === 33 || this.raw[0] === 65)\n        && this.raw[0] + 2 === this.raw.length\n        && this.raw[this.raw.length - 1] === opcodes.OP_CHECKSIG;\n    }\n\n    if (this.code.length !== 2)\n      return false;\n\n    const size = this.getLength(0);\n\n    return (size === 33 || size === 65)\n      && this.getOp(1) === opcodes.OP_CHECKSIG;\n  }\n\n  /**\n   * Get P2PK key if present.\n   * @param {Boolean} [minimal=false] - Minimaldata only.\n   * @returns {Buffer|null}\n   */\n\n  getPubkey(minimal) {\n    if (!this.isPubkey(minimal))\n      return null;\n\n    if (minimal)\n      return this.raw.slice(1, 1 + this.raw[0]);\n\n    return this.getData(0);\n  }\n\n  /**\n   * Test whether the output script is pay-to-pubkeyhash.\n   * @param {Boolean} [minimal=false] - Minimaldata only.\n   * @returns {Boolean}\n   */\n\n  isPubkeyhash(minimal) {\n    if (minimal || this.raw.length === 25) {\n      return this.raw.length === 25\n        && this.raw[0] === opcodes.OP_DUP\n        && this.raw[1] === opcodes.OP_HASH160\n        && this.raw[2] === 0x14\n        && this.raw[23] === opcodes.OP_EQUALVERIFY\n        && this.raw[24] === opcodes.OP_CHECKSIG;\n    }\n\n    if (this.code.length !== 5)\n      return false;\n\n    return this.getOp(0) === opcodes.OP_DUP\n      && this.getOp(1) === opcodes.OP_HASH160\n      && this.getLength(2) === 20\n      && this.getOp(3) === opcodes.OP_EQUALVERIFY\n      && this.getOp(4) === opcodes.OP_CHECKSIG;\n  }\n\n  /**\n   * Get P2PKH hash if present.\n   * @param {Boolean} [minimal=false] - Minimaldata only.\n   * @returns {Buffer|null}\n   */\n\n  getPubkeyhash(minimal) {\n    if (!this.isPubkeyhash(minimal))\n      return null;\n\n    if (minimal)\n      return this.raw.slice(3, 23);\n\n    return this.getData(2);\n  }\n\n/**\n   * Test whether the output script is pay-to-multisig.\n   * @param {Boolean} [minimal=true] - Minimaldata only.\n   * @returns {Boolean}\n   */\n\n  isMultisig(minimal) {\n    if (this.code.length < 4 || this.code.length > 19)\n      return false;\n\n    if (this.getOp(-1) !== opcodes.OP_CHECKMULTISIG)\n      return false;\n\n    const m = this.getSmall(0);\n\n    if (m < 1)\n      return false;\n\n    const n = this.getSmall(-2);\n\n\n    if (n < 1 || m > n)\n      return false;\n\n    if (this.code.length !== n + 3)\n      return false;\n\n    for (let i = 1; i < n + 1; i++) {\n      const op = this.code[i];\n      const size = op.toLength();\n\n      if (size !== 33 && size !== 65)\n        return false;\n\n      if (minimal && !op.isMinimal())\n        return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Get multisig m and n values if present.\n   * @param {Boolean} [minimal=false] - Minimaldata only.\n   * @returns {Array} [m, n]\n   */\n\n  getMultisig(minimal) {\n    if (!this.isMultisig(minimal))\n      return [-1, -1];\n\n    return [this.getSmall(0), this.getSmall(-2)];\n  }\n\n  /**\n   * Test whether the output script is pay-to-scripthash. Note that\n   * bitcoin itself requires scripthashes to be in strict minimaldata\n   * encoding. Using `OP_HASH160 OP_PUSHDATA1 [hash] OP_EQUAL` will\n   * _not_ be recognized as a scripthash.\n   * @returns {Boolean}\n   */\n\n  isScripthash() {\n    return this.raw.length === 23\n      && this.raw[0] === opcodes.OP_HASH160\n      && this.raw[1] === 0x14\n      && this.raw[22] === opcodes.OP_EQUAL;\n  }\n\n  /**\n   * Get P2SH hash if present.\n   * @returns {Buffer|null}\n   */\n\n  getScripthash() {\n    if (!this.isScripthash())\n      return null;\n\n    return this.getData(1);\n  }\n\n  /**\n   * Test whether the output script is nulldata/opreturn.\n   * @param {Boolean} [minimal=false] - Minimaldata only.\n   * @returns {Boolean}\n   */\n\n  isNulldata(minimal) {\n    if (this.code.length === 0)\n      return false;\n\n    if (this.getOp(0) !== opcodes.OP_RETURN)\n      return false;\n\n    if (this.code.length === 1)\n      return true;\n\n    if (minimal) {\n      if (this.raw.length > policy.MAX_OP_RETURN_BYTES)\n        return false;\n    }\n\n    for (let i = 1; i < this.code.length; i++) {\n      const op = this.code[i];\n\n      if (op.value === -1)\n        return false;\n\n      if (op.value > opcodes.OP_16)\n        return false;\n\n      if (minimal && !op.isMinimal())\n        return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Get OP_RETURN data if present.\n   * @param {Boolean} [minimal=false] - Minimaldata only.\n   * @returns {Buffer|null}\n   */\n\n  getNulldata(minimal) {\n    if (!this.isNulldata(minimal))\n      return null;\n\n    for (let i = 1; i < this.code.length; i++) {\n      const op = this.code[i];\n      const data = op.toPush();\n      if (data)\n        return data;\n    }\n\n    return EMPTY_BUFFER;\n  }\n\n  /**\n   * Test whether the output script is a witness program.\n   * Note that this will return true even for malformed\n   * witness v0 programs.\n   * @returns {Boolean}\n   */\n\n  isProgram() {\n    if (this.raw.length < 4 || this.raw.length > 42)\n      return false;\n\n    if (this.raw[0] !== opcodes.OP_0\n      && (this.raw[0] < opcodes.OP_1 || this.raw[0] > opcodes.OP_16)) {\n      return false;\n    }\n\n    if (this.raw[1] + 2 !== this.raw.length)\n      return false;\n\n    return true;\n  }\n\n  /**\n   * Test whether the output script is unspendable.\n   * @returns {Boolean}\n   */\n\n  isUnspendable() {\n    if (this.raw.length > consensus.MAX_SCRIPT_SIZE)\n      return true;\n\n    return this.raw.length > 0 && this.raw[0] === opcodes.OP_RETURN;\n  }\n\n  /**\n   * \"Guess\" the type of the input script.\n   * This method is not 100% reliable.\n   * @returns {ScriptType}\n   */\n\n  getInputType() {\n    if (this.isPubkeyInput())\n      return scriptTypes.PUBKEY;\n\n    if (this.isPubkeyhashInput())\n      return scriptTypes.PUBKEYHASH;\n\n    if (this.isScripthashInput())\n      return scriptTypes.SCRIPTHASH;\n\n    if (this.isMultisigInput())\n      return scriptTypes.MULTISIG;\n\n    return scriptTypes.NONSTANDARD;\n  }\n\n  /**\n   * \"Guess\" whether the input script is an unknown/non-standard type.\n   * This method is not 100% reliable.\n   * @returns {Boolean}\n   */\n\n  isUnknownInput() {\n    return this.getInputType() === scriptTypes.NONSTANDARD;\n  }\n\n  /**\n   * \"Guess\" whether the input script is pay-to-pubkey.\n   * This method is not 100% reliable.\n   * @returns {Boolean}\n   */\n\n  isPubkeyInput() {\n    if (this.code.length !== 1)\n      return false;\n\n    const size = this.getLength(0);\n\n    return size >= 9 && size <= 73;\n  }\n\n  /**\n   * Get P2PK signature if present.\n   * @returns {Buffer|null}\n   */\n\n  getPubkeyInput() {\n    if (!this.isPubkeyInput())\n      return null;\n\n    return this.getData(0);\n  }\n\n  /**\n   * \"Guess\" whether the input script is pay-to-pubkeyhash.\n   * This method is not 100% reliable.\n   * @returns {Boolean}\n   */\n\n  isPubkeyhashInput() {\n    if (this.code.length !== 2)\n      return false;\n\n    const sig = this.getLength(0);\n    const key = this.getLength(1);\n\n    return sig >= 9 && sig <= 73\n      && (key === 33 || key === 65);\n  }\n\n  /**\n   * Get P2PKH signature and key if present.\n   * @returns {Array} [sig, key]\n   */\n\n  getPubkeyhashInput() {\n    if (!this.isPubkeyhashInput())\n      return [null, null];\n\n    return [this.getData(0), this.getData(1)];\n  }\n\n  /**\n   * \"Guess\" whether the input script is pay-to-multisig.\n   * This method is not 100% reliable.\n   * @returns {Boolean}\n   */\n\n  isMultisigInput() {\n    if (this.code.length < 2)\n      return false;\n\n    if (this.getOp(0) !== opcodes.OP_0)\n      return false;\n\n    if (this.getOp(1) > opcodes.OP_PUSHDATA4)\n      return false;\n\n    // We need to rule out scripthash\n    // because it may look like multisig.\n    if (this.isScripthashInput())\n      return false;\n\n    for (let i = 1; i < this.code.length; i++) {\n      const size = this.getLength(i);\n      if (size < 9 || size > 73)\n        return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Get multisig signatures if present.\n   * @returns {Buffer[]|null}\n   */\n\n  getMultisigInput() {\n    if (!this.isMultisigInput())\n      return null;\n\n    const sigs = [];\n\n    for (let i = 1; i < this.code.length; i++)\n      sigs.push(this.getData(i));\n\n    return sigs;\n  }\n\n  /**\n   * \"Guess\" whether the input script is pay-to-scripthash.\n   * This method is not 100% reliable.\n   * @returns {Boolean}\n   */\n\n  isScripthashInput() {\n    if (this.code.length < 1)\n      return false;\n\n    // Grab the raw redeem script.\n    const raw = this.getData(-1);\n\n    // Last data element should be an array\n    // for the redeem script.\n    if (!raw)\n      return false;\n\n    // Testing for scripthash inputs requires\n    // some evil magic to work. We do it by\n    // ruling things _out_. This test will not\n    // be correct 100% of the time. We rule\n    // out that the last data element is: a\n    // null dummy, a valid signature, a valid\n    // key, and we ensure that it is at least\n    // a script that does not use undefined\n    // opcodes.\n    if (raw.length === 0)\n      return false;\n\n    if (common.isDERSignatureEncoding(raw.slice(0, -1)))\n      return false;\n\n    if (common.isKeyEncoding(raw))\n      return false;\n\n    const redeem = Script.fromRaw(raw);\n\n    if (!redeem.isCode())\n      return false;\n\n    if (redeem.isUnspendable())\n      return false;\n\n    if (!this.isPushOnly())\n      return false;\n\n    return true;\n  }\n\n  /**\n   * Get P2SH redeem script if present.\n   * @returns {Buffer|null}\n   */\n\n  getScripthashInput() {\n    if (!this.isScripthashInput())\n      return null;\n\n    return this.getData(-1);\n  }\n\n  /**\n   * Get coinbase height.\n   * @returns {Number} `-1` if not present.\n   */\n\n  getCoinbaseHeight() {\n    return Script.getCoinbaseHeight(this.raw);\n  }\n\n  /**\n   * Get coinbase height.\n   * @param {Buffer} raw - Raw script.\n   * @returns {Number} `-1` if not present.\n   */\n\n  static getCoinbaseHeight(raw) {\n    if (raw.length === 0)\n      return -1;\n\n    if (raw[0] >= opcodes.OP_1 && raw[0] <= opcodes.OP_16)\n      return raw[0] - 0x50;\n\n    if (raw[0] > 0x06)\n      return -1;\n\n    const op = Opcode.fromRaw(raw);\n    const num = op.toNum();\n\n    if (!num)\n      return 1;\n\n    if (num.isNeg())\n      return -1;\n\n    if (!op.equals(Opcode.fromNum(num)))\n      return -1;\n\n    return num.toDouble();\n  }\n\n  /**\n   * Test the script against a bloom filter.\n   * @param {Bloom} filter\n   * @returns {Boolean}\n   */\n\n  test(filter) {\n    for (const op of this.code) {\n      if (op.value === -1)\n        break;\n\n      if (!op.data || op.data.length === 0)\n        continue;\n\n      if (filter.test(op.data))\n        return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Test the script to see if it contains only push ops.\n   * Push ops are: OP_1NEGATE, OP_0-OP_16 and all PUSHDATAs.\n   * @returns {Boolean}\n   */\n\n  isPushOnly() {\n    for (const op of this.code) {\n      if (op.value === -1)\n        return false;\n\n      if (op.value > opcodes.OP_16)\n        return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Count the sigops in the script.\n   * @param {Boolean} accurate - Whether to enable accurate counting. This will\n   * take into account the `n` value for OP_CHECKMULTISIG(VERIFY).\n   * @returns {Number} sigop count\n   */\n\n  getSigops(accurate, flags) {\n    if (flags & Script.flags.VERIFY_ZERO_SIGOPS)\n      return 0;\n\n    let total = 0;\n    let lastOp = -1;\n\n    for (const op of this.code) {\n      if (op.value === -1)\n        break;\n\n      switch (op.value) {\n        case opcodes.OP_CHECKSIG:\n        case opcodes.OP_CHECKSIGVERIFY:\n          total += 1;\n          break;\n        case opcodes.OP_CHECKSDATAIG:\n        case opcodes.OP_CHECKDATASIGVERIFY:\n          if (flags & Script.flags.VERIFY_CHECKDATASIG) {\n            total += 1;\n          }\n          break;\n        case opcodes.OP_CHECKMULTISIG:\n        case opcodes.OP_CHECKMULTISIGVERIFY:\n          if (accurate && lastOp >= opcodes.OP_1 && lastOp <= opcodes.OP_16)\n            total += lastOp - 0x50;\n          else\n            total += consensus.MAX_MULTISIG_PUBKEYS;\n          break;\n      }\n\n      lastOp = op.value;\n    }\n\n    return total;\n  }\n\n  /**\n   * Count the sigops in the script, taking into account redeem scripts.\n   * @param {Script} input - Input script, needed for access to redeem script.\n   * @param {VerifyFlags} flags\n   * @returns {Number} sigop count\n   */\n\n  getScripthashSigops(input, flags) {\n    if (!this.isScripthash())\n      return this.getSigops(true, flags);\n\n    const redeem = input.getRedeem();\n\n    if (!redeem)\n      return 0;\n\n    return redeem.getSigops(true, flags);\n  }\n\n  /*\n   * Mutation\n   */\n\n  get(index) {\n    if (index < 0)\n      index += this.code.length;\n\n    if (index < 0 || index >= this.code.length)\n      return null;\n\n    return this.code[index];\n  }\n\n  pop() {\n    const op = this.code.pop();\n    return op || null;\n  }\n\n  shift() {\n    const op = this.code.shift();\n    return op || null;\n  }\n\n  remove(index) {\n    if (index < 0)\n      index += this.code.length;\n\n    if (index < 0 || index >= this.code.length)\n      return null;\n\n    const items = this.code.splice(index, 1);\n\n    if (items.length === 0)\n      return null;\n\n    return items[0];\n  }\n\n  set(index, op) {\n    if (index < 0)\n      index += this.code.length;\n\n    assert(Opcode.isOpcode(op));\n    assert(index >= 0 && index <= this.code.length);\n\n    this.code[index] = op;\n\n    return this;\n  }\n\n  push(op) {\n    assert(Opcode.isOpcode(op));\n    this.code.push(op);\n    return this;\n  }\n\n  unshift(op) {\n    assert(Opcode.isOpcode(op));\n    this.code.unshift(op);\n    return this;\n  }\n\n  insert(index, op) {\n    if (index < 0)\n      index += this.code.length;\n\n    assert(Opcode.isOpcode(op));\n    assert(index >= 0 && index <= this.code.length);\n\n    this.code.splice(index, 0, op);\n\n    return this;\n  }\n\n  /*\n   * Op\n   */\n\n  getOp(index) {\n    const op = this.get(index);\n    return op ? op.value : -1;\n  }\n\n  popOp() {\n    const op = this.pop();\n    return op ? op.value : -1;\n  }\n\n  shiftOp() {\n    const op = this.shift();\n    return op ? op.value : -1;\n  }\n\n  removeOp(index) {\n    const op = this.remove(index);\n    return op ? op.value : -1;\n  }\n\n  setOp(index, value) {\n    return this.set(index, Opcode.fromOp(value));\n  }\n\n  pushOp(value) {\n    return this.push(Opcode.fromOp(value));\n  }\n\n  unshiftOp(value) {\n    return this.unshift(Opcode.fromOp(value));\n  }\n\n  insertOp(index, value) {\n    return this.insert(index, Opcode.fromOp(value));\n  }\n\n  /*\n   * Data\n   */\n\n  getData(index) {\n    const op = this.get(index);\n    return op ? op.data : null;\n  }\n\n  popData() {\n    const op = this.pop();\n    return op ? op.data : null;\n  }\n\n  shiftData() {\n    const op = this.shift();\n    return op ? op.data : null;\n  }\n\n  removeData(index) {\n    const op = this.remove(index);\n    return op ? op.data : null;\n  }\n\n  setData(index, data) {\n    return this.set(index, Opcode.fromData(data));\n  }\n\n  pushData(data) {\n    return this.push(Opcode.fromData(data));\n  }\n\n  unshiftData(data) {\n    return this.unshift(Opcode.fromData(data));\n  }\n\n  insertData(index, data) {\n    return this.insert(index, Opcode.fromData(data));\n  }\n\n  /*\n   * Length\n   */\n\n  getLength(index) {\n    const op = this.get(index);\n    return op ? op.toLength() : -1;\n  }\n\n  /*\n   * Push\n   */\n\n  getPush(index) {\n    const op = this.get(index);\n    return op ? op.toPush() : null;\n  }\n\n  popPush() {\n    const op = this.pop();\n    return op ? op.toPush() : null;\n  }\n\n  shiftPush() {\n    const op = this.shift();\n    return op ? op.toPush() : null;\n  }\n\n  removePush(index) {\n    const op = this.remove(index);\n    return op ? op.toPush() : null;\n  }\n\n  setPush(index, data) {\n    return this.set(index, Opcode.fromPush(data));\n  }\n\n  pushPush(data) {\n    return this.push(Opcode.fromPush(data));\n  }\n\n  unshiftPush(data) {\n    return this.unshift(Opcode.fromPush(data));\n  }\n\n  insertPush(index, data) {\n    return this.insert(index, Opcode.fromPush(data));\n  }\n\n  /*\n   * String\n   */\n\n  getString(index, enc) {\n    const op = this.get(index);\n    return op ? op.toString(enc) : null;\n  }\n\n  popString(enc) {\n    const op = this.pop();\n    return op ? op.toString(enc) : null;\n  }\n\n  shiftString(enc) {\n    const op = this.shift();\n    return op ? op.toString(enc) : null;\n  }\n\n  removeString(index, enc) {\n    const op = this.remove(index);\n    return op ? op.toString(enc) : null;\n  }\n\n  setString(index, str, enc) {\n    return this.set(index, Opcode.fromString(str, enc));\n  }\n\n  pushString(str, enc) {\n    return this.push(Opcode.fromString(str, enc));\n  }\n\n  unshiftString(str, enc) {\n    return this.unshift(Opcode.fromString(str, enc));\n  }\n\n  insertString(index, str, enc) {\n    return this.insert(index, Opcode.fromString(str, enc));\n  }\n\n  /*\n   * Small\n   */\n\n  getSmall(index) {\n    const op = this.get(index);\n    return op ? op.toSmall() : -1;\n  }\n\n  popSmall() {\n    const op = this.pop();\n    return op ? op.toSmall() : -1;\n  }\n\n  shiftSmall() {\n    const op = this.shift();\n    return op ? op.toSmall() : -1;\n  }\n\n  removeSmall(index) {\n    const op = this.remove(index);\n    return op ? op.toSmall() : -1;\n  }\n\n  setSmall(index, num) {\n    return this.set(index, Opcode.fromSmall(num));\n  }\n\n  pushSmall(num) {\n    return this.push(Opcode.fromSmall(num));\n  }\n\n  unshiftSmall(num) {\n    return this.unshift(Opcode.fromSmall(num));\n  }\n\n  insertSmall(index, num) {\n    return this.insert(index, Opcode.fromSmall(num));\n  }\n\n  /*\n   * Num\n   */\n\n  getNum(index, minimal, limit) {\n    const op = this.get(index);\n    return op ? op.toNum(minimal, limit) : null;\n  }\n\n  popNum(minimal, limit) {\n    const op = this.pop();\n    return op ? op.toNum(minimal, limit) : null;\n  }\n\n  shiftNum(minimal, limit) {\n    const op = this.shift();\n    return op ? op.toNum(minimal, limit) : null;\n  }\n\n  removeNum(index, minimal, limit) {\n    const op = this.remove(index);\n    return op ? op.toNum(minimal, limit) : null;\n  }\n\n  setNum(index, num) {\n    return this.set(index, Opcode.fromNum(num));\n  }\n\n  pushNum(num) {\n    return this.push(Opcode.fromNum(num));\n  }\n\n  unshiftNum(num) {\n    return this.unshift(Opcode.fromNum(num));\n  }\n\n  insertNum(index, num) {\n    return this.insert(index, Opcode.fromNum(num));\n  }\n\n  /*\n   * Int\n   */\n\n  getInt(index, minimal, limit) {\n    const op = this.get(index);\n    return op ? op.toInt(minimal, limit) : -1;\n  }\n\n  popInt(minimal, limit) {\n    const op = this.pop();\n    return op ? op.toInt(minimal, limit) : -1;\n  }\n\n  shiftInt(minimal, limit) {\n    const op = this.shift();\n    return op ? op.toInt(minimal, limit) : -1;\n  }\n\n  removeInt(index, minimal, limit) {\n    const op = this.remove(index);\n    return op ? op.toInt(minimal, limit) : -1;\n  }\n\n  setInt(index, num) {\n    return this.set(index, Opcode.fromInt(num));\n  }\n\n  pushInt(num) {\n    return this.push(Opcode.fromInt(num));\n  }\n\n  unshiftInt(num) {\n    return this.unshift(Opcode.fromInt(num));\n  }\n\n  insertInt(index, num) {\n    return this.insert(index, Opcode.fromInt(num));\n  }\n\n  /*\n   * Bool\n   */\n\n  getBool(index) {\n    const op = this.get(index);\n    return op ? op.toBool() : false;\n  }\n\n  popBool() {\n    const op = this.pop();\n    return op ? op.toBool() : false;\n  }\n\n  shiftBool() {\n    const op = this.shift();\n    return op ? op.toBool() : false;\n  }\n\n  removeBool(index) {\n    const op = this.remove(index);\n    return op ? op.toBool() : false;\n  }\n\n  setBool(index, value) {\n    return this.set(index, Opcode.fromBool(value));\n  }\n\n  pushBool(value) {\n    return this.push(Opcode.fromBool(value));\n  }\n\n  unshiftBool(value) {\n    return this.unshift(Opcode.fromBool(value));\n  }\n\n  insertBool(index, value) {\n    return this.insert(index, Opcode.fromBool(value));\n  }\n\n  /*\n   * Symbol\n   */\n\n  getSym(index) {\n    const op = this.get(index);\n    return op ? op.toSymbol() : null;\n  }\n\n  popSym() {\n    const op = this.pop();\n    return op ? op.toSymbol() : null;\n  }\n\n  shiftSym() {\n    const op = this.shift();\n    return op ? op.toSymbol() : null;\n  }\n\n  removeSym(index) {\n    const op = this.remove(index);\n    return op ? op.toSymbol() : null;\n  }\n\n  setSym(index, symbol) {\n    return this.set(index, Opcode.fromSymbol(symbol));\n  }\n\n  pushSym(symbol) {\n    return this.push(Opcode.fromSymbol(symbol));\n  }\n\n  unshiftSym(symbol) {\n    return this.unshift(Opcode.fromSymbol(symbol));\n  }\n\n  insertSym(index, symbol) {\n    return this.insert(index, Opcode.fromSymbol(symbol));\n  }\n\n  /**\n   * Inject properties from bitcoind test string.\n   * @private\n   * @param {String} items - Script string.\n   * @throws Parse error.\n   */\n\n  fromString(code) {\n    assert(typeof code === 'string');\n\n    code = code.trim();\n\n    if (code.length === 0)\n      return this;\n\n    const items = code.split(/\\s+/);\n    const bw = bio.write();\n\n    for (const item of items) {\n      let symbol = item;\n\n      if (symbol.charCodeAt(0) & 32)\n        symbol = symbol.toUpperCase();\n\n      if (!/^OP_/.test(symbol))\n        symbol = `OP_${symbol}`;\n\n      const value = opcodes[symbol];\n\n      if (value == null) {\n        if (item[0] === '\\'') {\n          assert(item[item.length - 1] === '\\'', 'Invalid string.');\n          const str = item.slice(1, -1);\n          const op = Opcode.fromString(str);\n          bw.writeBytes(op.toRaw());\n          continue;\n        }\n\n        if (/^-?\\d+$/.test(item)) {\n          const num = ScriptNum.fromString(item, 10);\n          const op = Opcode.fromNum(num);\n          bw.writeBytes(op.toRaw());\n          continue;\n        }\n\n        assert(item.indexOf('0x') === 0, 'Unknown opcode.');\n\n        const hex = item.substring(2);\n        const data = Buffer.from(hex, 'hex');\n\n        assert(data.length === hex.length / 2, 'Invalid hex string.');\n\n        bw.writeBytes(data);\n\n        continue;\n      }\n\n      bw.writeU8(value);\n    }\n\n    return this.fromRaw(bw.render());\n  }\n\n  /**\n   * Parse a bitcoind test script\n   * string into a script object.\n   * @param {String} items - Script string.\n   * @returns {Script}\n   * @throws Parse error.\n   */\n\n  static fromString(code) {\n    return new this().fromString(code);\n  }\n\n  /**\n   * Verify an input and output script, and a witness if present.\n   * @param {Script} input\n   * @param {Null} witness\n   * @param {Script} output\n   * @param {TX} tx\n   * @param {Number} index\n   * @param {Amount} value\n   * @param {VerifyFlags} flags\n   * @param {Number?} sigchecks\n   * @throws {ScriptError}\n   */\n\n  static verify(input, witness, output, tx, index, value, flags, sigchecks) {\n    if (flags == null)\n      flags = Script.flags.STANDARD_VERIFY_FLAGS;\n\n    if (flags & Script.flags.VERIFY_SIGPUSHONLY) {\n      if (!input.isPushOnly())\n        throw new ScriptError('SIG_PUSHONLY');\n    }\n\n    if (flags & Script.flags.VERIFY_SIGHASH_FORKID)\n      flags |= Script.flags.VERIFY_STRICTENC;\n\n    // Setup a stack.\n    let stack = new Stack();\n\n    // Execute the input script\n    input.execute(stack, flags, tx, index, value, metrics.sigchecks);\n\n    // Copy the stack for P2SH\n    let copy;\n    if (flags & Script.flags.VERIFY_P2SH)\n      copy = stack.clone();\n\n    // Execute the previous output script.\n    output.execute(stack, flags, tx, index, value, metrics.sigchecks);\n\n    // Verify the stack values.\n    if (stack.length === 0 || !stack.getBool(-1))\n      throw new ScriptError('EVAL_FALSE');\n\n    // If the script is P2SH, execute the real output script\n    if ((flags & Script.flags.VERIFY_P2SH) && output.isScripthash()) {\n      // P2SH can only have push ops in the scriptSig\n      if (!input.isPushOnly())\n        throw new ScriptError('SIG_PUSHONLY');\n\n      // Reset the stack\n      stack = copy;\n\n      // Stack should not be empty at this point\n      if (stack.length === 0)\n        throw new ScriptError('EVAL_FALSE');\n\n      // Grab the real redeem script\n      const raw = stack.pop();\n      const redeem = Script.fromRaw(raw);\n\n      if ((flags & Script.flags.VERIFY_DISALLOW_SEGWIT_RECOVERY) === 0\n         && stack.length === 0 && redeem.isProgram()) {\n\n        // Before activation all transaction count a value of 0\n        if (!(flags & Script.flags.REPORT_SIGCHECKS)) {\n          metrics.sigchecks = 0;\n        }\n        return;\n      }\n\n        // Execute the redeem script.\n      redeem.execute(stack, flags, tx, index, value, 0, metrics.sigchecks);\n\n      // Verify the the stack values.\n      if (stack.length === 0 || !stack.getBool(-1))\n        throw new ScriptError('EVAL_FALSE');\n    }\n\n    // Ensure there is nothing left on the stack.\n    if (flags & Script.flags.VERIFY_CLEANSTACK) {\n      assert((flags & Script.flags.VERIFY_P2SH) !== 0);\n      if (stack.length !== 1)\n        throw new ScriptError('CLEANSTACK');\n    }\n\n    if (flags & Script.flags.VERIFY_INPUT_SIGCHECKS) {\n      if (input.getSize() < metrics.sigchecks * 43 - 60)\n        throw new ScriptError('INPUT_SIGCHECKS');\n    }\n\n    if (!(flags & Script.flags.REPORT_SIGCHECKS)) {\n      metrics.sigchecks = 0;\n    }\n  }\n\n  /**\n   * Inject properties from buffer reader.\n   * @private\n   * @param {BufferReader} br\n   */\n\n  fromReader(br) {\n    return this.fromRaw(br.readVarBytes());\n  }\n\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer}\n   */\n\n  fromRaw(data) {\n    const br = bio.read(data);\n\n    this.raw = data;\n\n    while (br.left())\n      this.code.push(Opcode.fromReader(br));\n\n    return this;\n  }\n\n  /**\n   * Create a script from buffer reader.\n   * @param {BufferReader} br\n   * @param {String?} enc - Either `\"hex\"` or `null`.\n   * @returns {Script}\n   */\n\n  static fromReader(br) {\n    return new this().fromReader(br);\n  }\n\n  /**\n   * Create a script from a serialized buffer.\n   * @param {Buffer|String} data - Serialized script.\n   * @param {String?} enc - Either `\"hex\"` or `null`.\n   * @returns {Script}\n   */\n\n  static fromRaw(data, enc) {\n    if (typeof data === 'string')\n      data = Buffer.from(data, enc);\n    return new this().fromRaw(data);\n  }\n\n  /**\n   * Test whether an object a Script.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n  static isScript(obj) {\n    return obj instanceof Script;\n  }\n}\n\n/**\n * Script opcodes.\n * @enum {Number}\n * @default\n */\n\nScript.opcodes = common.opcodes;\n\n/**\n * Opcodes by value.\n * @const {RevMap}\n */\n\nScript.opcodesByVal = common.opcodesByVal;\n\n/**\n * Script and locktime flags. See {@link VerifyFlags}.\n * @enum {Number}\n */\n\nScript.flags = common.flags;\n\n/**\n * Sighash Types.\n * @enum {SighashType}\n * @default\n */\n\nScript.hashType = common.hashType;\n\n/**\n * Sighash types by value.\n * @const {RevMap}\n */\n\nScript.hashTypeByVal = common.hashTypeByVal;\n\n/**\n * Output script types.\n * @enum {Number}\n */\n\nScript.types = common.types;\n\n/**\n * Output script types by value.\n * @const {RevMap}\n */\n\nScript.typesByVal = common.typesByVal;\n\n/*\n * Helpers\n */\n\nfunction sortKeys(keys) {\n  return keys.slice().sort((a, b) => {\n    return a.compare(b);\n  });\n}\n\n/**\n * Test whether the data element is a valid key if VERIFY_STRICTENC is enabled.\n * @param {Buffer} key\n * @param {VerifyFlags?} flags\n * @returns {Boolean}\n * @throws {ScriptError}\n */\n\nfunction validateKey(key, flags) {\n  assert(Buffer.isBuffer(key));\n  assert(typeof flags === 'number');\n\n  if (flags & Script.flags.VERIFY_STRICTENC) {\n    if (!common.isKeyEncoding(key))\n      throw new ScriptError('PUBKEYTYPE');\n  }\n\n  if ((flags & Script.flags.VERIFY_COMPRESSED_PUBKEYTYPE)\n    && !common.isCompressedEncoding(key)) {\n    throw new ScriptError('NONCOMPRESSED_PUBKEY');\n  };\n\n  return true;\n}\n\n/**\n * Test whether the raw element is a valid signature based\n * on the encoding, S value, and sighash type.\n * In an ECDSA-only context, 64-byte signatures are bannned\n * when Schnorr Flag is set.\n * @param {Buffer} sig\n * @param {VerifyFlags?} flags\n * @returns {Boolean}\n * @throws {ScriptError}\n */\n\nfunction validateECDSASignature(sig, flags) {\n  assert(Buffer.isBuffer(sig));\n  assert(typeof flags === 'number');\n\n  if (common.isSchnorr(sig))\n    throw new ScriptError('SIG_BADLENGTH');\n\n  if ((flags & Script.flags.VERIFY_DERSIG)\n      || (flags & Script.flags.VERIFY_LOW_S)\n      || (flags & Script.flags.VERIFY_STRICTENC)) {\n    if (!common.isDERSignatureEncoding(sig))\n      throw new ScriptError('SIG_DER');\n  }\n\n  if (flags & Script.flags.VERIFY_LOW_S) {\n    if (!common.isLowDER(sig))\n      throw new ScriptError('SIG_HIGH_S');\n  }\n\n  return true;\n}\n\n/**\n * Test whether the tx element is a valid signature based\n * on the encoding, S value, and sighash type. Requires\n * VERIFY_STRICTENC, VERIFY_SIGHASH_FORKID to be enabled respectively.\n * Note that this will allow zero-length signatures.\n * @param {Buffer} sig\n * @param {VerifyFlags?} flags\n * @returns {Boolean}\n * @throws {ScriptError}\n */\n\nfunction checkSighashEncoding(sig, flags) {\n  assert(Buffer.isBuffer(sig));\n  assert(typeof flags === 'number');\n\n  if (flags & Script.flags.VERIFY_STRICTENC) {\n    if (!common.isHashType(sig))\n      throw new ScriptError('SIG_HASHTYPE');\n\n    const usesFork = sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID;\n    const forkEnabled = flags & Script.flags.VERIFY_SIGHASH_FORKID;\n\n    if (!forkEnabled && usesFork)\n      throw new ScriptError('ILLEGAL_FORKID');\n\n    if (forkEnabled && !usesFork)\n      throw new ScriptError('MUST_USE_FORKID');\n  }\n\n  return true;\n}\n\n/**\n * Test whether the transaction tested against\n * the Sighash Encoding is a valid Schnorr Signature.\n * Requires Sighash\n * @param {Buffer} sig\n * @param {VeirfyFlags?} flags\n * @returns {Boolean}\n * @throws {ScriptError}\n */\n\nfunction checkTransactionSignature(sig, flags) {\n  assert(Buffer.isBuffer(sig));\n  assert(typeof flags === 'number');\n\n  // allow empty sigs\n  if (sig.length === 0)\n    return true;\n\n  validateSchnorrSignature(sig.slice(0, -1), flags);\n\n  return checkSighashEncoding(sig, flags);\n}\n\n/**\n * Test whether the transaction is tested\n * against the sighash encoding w schnorr / ecdsa\n * for multisig opcodes.\n * @param {Buffer} sig\n * @param {VerifyFlags?} flags\n */\n\nfunction checkTransactionSchnorrSig(sig, flags) {\n  assert(Buffer.isBuffer(sig));\n  assert(typeof flags === 'number');\n\n  // Allow empty sigs.\n  if (sig.length === 0)\n    return true;\n\n  if (!isSchnorrEncoded(sig.slice(0, -1), flags))\n    return validateECDSASignature(sig.slice(0, -1), flags);\n\n  return checkSighashEncoding(sig, flags);\n}\n\n/**\n * Test whether the transaction tested against\n * the Sighash Encoding is a valid ECDSA Signature.\n * @param {Buffer} sig\n * @param {VerifyFlags?} flags\n * @returns {Boolean}\n * @throws {ScriptError}\n */\n\nfunction checkTransactionECDSASignature(sig, flags) {\n  assert(Buffer.isBuffer(sig));\n  assert(typeof flags === 'number');\n\n  // Allow empty sigs\n  if (sig.length === 0)\n    return true;\n\n  validateECDSASignature(sig.slice(0, -1), flags);\n\n  return checkSighashEncoding(sig, flags);\n}\n\n/**\n * Test whether the data element is a valid signature based\n * on the encoding, S value, and sighash type. Requires\n * VERIFY_DERSIG|VERIFY_LOW_S|VERIFY_STRICTENC, and VERIFY_LOW_S\n * to be enabled respectively. Note that this will allow zero-length\n * signatures.\n * @param {Buffer} sig\n * @param {VerifyFlags?} flags\n * @returns {Boolean}\n * @throws {ScriptError}\n */\n\nfunction validateDataSignature(sig, flags) {\n  assert(Buffer.isBuffer(sig));\n  assert(typeof flags === 'number');\n\n  // Allow empty sigs\n  if (sig.length === 0)\n    return true;\n\n  return validateSchnorrSignature(sig.slice(0, sig.length), flags);\n}\n\n/**\n * Test whether the Signature is valid in context\n * 64-byte signatures are interpreted as schnorr signatures.\n * Always correctly encoded when Verify_SCHNORR flag is set.\n * @param {Buffer} sig\n * @param {Buffer} msg - Signature hash.\n * @param {VerifyFlags?} flags\n * @returns {Promise}\n * @throws {ScriptError}\n */\n\nfunction validateSchnorrSignature(sig, flags) {\n  assert(Buffer.isBuffer(sig));\n  assert(typeof flags === 'number');\n\n  if (common.isSchnorr(sig))\n    return true;\n\n  return validateECDSASignature(sig, flags);\n}\n\n/**\n * Test whether the current signature is schnorr encoded.\n * @param {Buffer} sig\n * @param {VerifyFlags?} flags\n * @returns {Boolean}\n * @throws {ScriptError}\n */\n\nfunction isSchnorrEncoded(sig, flags) {\n  assert(Buffer.isBuffer(sig));\n  assert(typeof flags === 'number');\n\n  if (common.isSchnorr(sig))\n    return true;\n\n  throw new ScriptError('SIG_NONSCHNORR');\n}\n\n/**\n * Test whether the signature from the stack\n * is valid in either Schnorr or DER Format.\n * Always encoded correctly when Schnorr flag is set.\n * @param {Buffer} hash\n * @param {Buffer} sig\n * @param {Buffer} key\n * @param {Number} flags\n */\n\nfunction verifySignature(hash, sig, key, flags) {\n  assert(Buffer.isBuffer(hash));\n  assert(Buffer.isBuffer(sig));\n  assert(Buffer.isBuffer(key));\n  assert(typeof flags === 'number');\n\n  let res = false;\n\n  if (sig.length === 64) {\n    res = secp256k1.schnorrVerify(hash, sig, key, flags);\n  } else {\n    res = secp256k1.verifyDER(hash, sig, key, flags);\n  }\n\n  return res;\n}\n\n/**\n * Verify a signature, taking into account sighash type.\n * @param {Buffer} msg - Signature hash.\n * @param {Buffer} sig\n * @param {Buffer} key\n * @returns {Boolean}\n */\n\nfunction checksig(msg, sig, key) {\n  return secp256k1.verifyDER(msg, sig.slice(0, -1), key);\n}\n\n/*\n * Expose\n */\n\nmodule.exports = Script;\n"]},"metadata":{},"sourceType":"module"}