{"ast":null,"code":"/*!\n * cash32.js - cashaddr for bcrypto\n * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on Bitcoin-ABC/bitcoin-abc:\n *   Copyright (c) 2009-2019, The Bitcoin Developers (MIT License).\n *   Copyright (c) 2009-2017, The Bitcoin Core Developers (MIT License).\n *   https://github.com/Bitcoin-ABC/bitcoin-abc\n *\n * Parts of this software are based on sipa/bech32:\n *   Copyright (c) 2017, Pieter Wuille (MIT License).\n *   https://github.com/sipa/bech32\n *\n * Resources:\n *   https://github.com/bitcoincashorg/spec/blob/master/cashaddr.md\n *   https://github.com/Bitcoin-ABC/bitcoin-abc/blob/master/src/cashaddr.cpp\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n/**\n * Constants\n */\n\n\nconst POOL105 = Buffer.allocUnsafe(105);\nconst CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nconst TABLE = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, 10, 17, 21, 20, 26, 30, 7, 5, -1, -1, -1, -1, -1, -1, -1, 29, -1, 24, 13, 25, 9, 8, 23, -1, 18, 22, 31, 27, 19, -1, 1, 0, 3, 16, 11, 28, 12, 14, 6, 4, 2, -1, -1, -1, -1, -1, -1, 29, -1, 24, 13, 25, 9, 8, 23, -1, 18, 22, 31, 27, 19, -1, 1, 0, 3, 16, 11, 28, 12, 14, 6, 4, 2, -1, -1, -1, -1, -1];\nconst CHECKSUM_MASK = [0x00000007, 0xffffffff];\nconst GENERATOR = [0x00000098, 0xf2bc8e61, 0x00000079, 0xb76d99e2, 0x000000f3, 0x3e5fb3c4, 0x000000ae, 0x2eabe2a8, 0x0000001e, 0x4f43e470];\n/**\n * Update checksum\n * @ignore\n * @param {Number[]} chk\n * @param {Number} x\n * @returns {Number[]} -- new checksum\n */\n\nfunction polymod(pre, x) {\n  const c = pre; // b = c >> 35\n\n  const b = c[0] >>> 3; // c = (c & CHECKSUM_MASK) << 5\n\n  c[0] &= CHECKSUM_MASK[0];\n  c[1] &= CHECKSUM_MASK[1];\n  c[0] <<= 5;\n  c[0] |= c[1] >>> 27;\n  c[1] <<= 5;\n\n  for (let i = 0; i < 5; i++) {\n    if (b >>> i & 1) {\n      // c ^= GENERATOR[i]\n      c[0] ^= GENERATOR[i * 2 + 0];\n      c[1] ^= GENERATOR[i * 2 + 1];\n    }\n  } // c ^= x\n\n\n  c[1] ^= x;\n  return c;\n}\n/**\n * Serialize data to cash32.\n * @param {String} prefix\n * @param {Buffer} data - 5bit serialized\n * @returns {String}\n */\n\n\nfunction serialize(prefix, data) {\n  assert(typeof prefix === 'string');\n  assert(Buffer.isBuffer(data));\n  const chk = [0, 1];\n  let upper = false;\n  let lower = false;\n  let str = '';\n\n  for (let i = 0; i < prefix.length; i++) {\n    let ch = prefix.charCodeAt(i);\n    if (ch & 0xff00 || ch >>> 5 === 0) throw new Error('Invalid cash32 character.');\n\n    if (ch >= 0x61 && ch <= 0x7a) {\n      lower = true;\n    } else if (ch >= 0x41 && ch <= 0x5a) {\n      upper = true;\n      ch = ch - 0x41 + 0x61;\n    } else if (ch >= 0x30 && ch <= 0x39) {\n      throw new Error('Invalid cash32 prefix.');\n    }\n\n    polymod(chk, ch & 0x1f);\n    str += String.fromCharCode(ch);\n  }\n\n  if (lower && upper) throw new Error('Invalid cash32 prefix.');\n  polymod(chk, 0);\n  str += ':';\n\n  for (let i = 0; i < data.length; i++) {\n    const ch = data[i];\n    if (ch >>> 5 !== 0) throw new Error('Invalid cash32 value.');\n    polymod(chk, ch);\n    str += CHARSET[ch];\n  }\n\n  for (let i = 0; i < 8; i++) polymod(chk, 0);\n\n  chk[1] ^= 1; // i = 0, shift = 35\n\n  str += CHARSET[chk[0] >>> 3 & 0x1f];\n\n  for (let i = 1; i < 7; i++) {\n    const shift = (7 - i) * 5;\n    const v = chk[1] >>> shift | chk[0] << 32 - shift;\n    str += CHARSET[v & 0x1f];\n  } // i = 7, shift = 0\n\n\n  str += CHARSET[chk[1] & 0x1f];\n  return str;\n}\n/**\n * Decode cash32 string.\n * @param {String} str\n * @param {String} defaultPrefix (lowercase and w/o numbers)\n * @returns {Array} [prefix, data]\n */\n\n\nfunction deserialize(str, defaultPrefix) {\n  assert(typeof str === 'string');\n  assert(typeof defaultPrefix === 'string');\n  if (str.length < 8 || str.length > 196) // 83 + 1 + 112\n    throw new Error('Invalid cash32 data length.');\n  let lower = false;\n  let upper = false;\n  let number = false;\n  let plen = 0; // Process lower/upper, make sure we have prefix.\n\n  for (let i = 0; i < str.length; i++) {\n    const ch = str.charCodeAt(i);\n\n    if (ch >= 0x61 && ch <= 0x7a) {\n      lower = true;\n      continue;\n    }\n\n    if (ch >= 0x41 && ch <= 0x5a) {\n      upper = true;\n      continue;\n    }\n\n    if (ch >= 0x30 && ch <= 0x39) {\n      number = true;\n      continue;\n    }\n\n    if (ch === 0x3a) {\n      // :\n      if (number || i === 0 || i > 83) throw new Error('Invalid cash32 prefix.');\n      if (plen !== 0) throw new Error('Invalid cash32 separators.');\n      plen = i;\n      continue;\n    }\n\n    throw new Error('Invalid cash32 character.');\n  }\n\n  if (upper && lower) throw new Error('Invalid cash32 casing.'); // Process checksum.\n\n  const chk = [0, 1];\n  let prefix;\n\n  if (plen === 0) {\n    prefix = defaultPrefix.toLowerCase();\n  } else {\n    prefix = str.substring(0, plen).toLowerCase();\n    plen += 1;\n  } // Process prefix.\n\n\n  for (let i = 0; i < prefix.length; i++) {\n    const ch = prefix.charCodeAt(i);\n    polymod(chk, (ch | 0x20) & 0x1f);\n  }\n\n  polymod(chk, 0);\n  const dlen = str.length - plen;\n  if (dlen <= 8 || dlen > 112) throw new Error('Invalid cash32 data length.');\n  const data = Buffer.allocUnsafe(dlen);\n\n  for (let i = plen; i < str.length; i++) {\n    const ch = str.charCodeAt(i);\n    const v = ch & 0xff80 ? -1 : TABLE[ch];\n    if (v === -1) throw new Error('Invalid cash32 character.');\n    polymod(chk, v);\n    if (i + 8 < str.length) data[i - plen] = v;\n  }\n\n  const valid = chk[0] === 0 && chk[1] === 1 && prefix === defaultPrefix;\n  if (!valid) throw new Error('Invalid cash32 checksum.');\n  return [prefix, data.slice(0, -8)];\n}\n/**\n * Test whether a string is a cash32 string.\n * @param {String} str\n * @returns {Boolean}\n */\n\n\nfunction is(str, defaultPrefix) {\n  assert(typeof str === 'string');\n  assert(typeof defaultPrefix === 'string');\n\n  try {\n    deserialize(str, defaultPrefix);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Convert serialized data to another base.\n * @param {Buffer} input\n * @param {Number} i\n * @param {Buffer} output\n * @param {Number} j\n * @param {Number} frombits\n * @param {Number} tobits\n * @param {Boolean} pad\n * @returns {Buffer}\n */\n\n\nfunction convert(input, i, output, j, frombits, tobits, pad) {\n  assert(Buffer.isBuffer(input));\n  assert(i >>> 0 === i);\n  assert(Buffer.isBuffer(output));\n  assert(j >>> 0 === j);\n  assert((frombits & 0xff) === frombits);\n  assert((tobits & 0xff) === tobits);\n  assert(typeof pad === 'boolean');\n  assert(frombits !== 0);\n  assert(tobits !== 0);\n  const maxv = (1 << tobits) - 1;\n  let acc = 0;\n  let bits = 0;\n\n  for (; i < input.length; i++) {\n    const value = input[i];\n    if (value >>> frombits !== 0) throw new Error('Invalid bits.');\n    acc = acc << frombits | value;\n    bits += frombits;\n\n    while (bits >= tobits) {\n      bits -= tobits;\n      output[j++] = acc >>> bits & maxv;\n    }\n  }\n\n  if (pad) {\n    if (bits) output[j++] = acc << tobits - bits & maxv;\n  } else {\n    if (bits >= frombits || acc << tobits - bits & maxv) throw new Error('Invalid bits.');\n  }\n\n  assert(j <= output.length);\n  return output.slice(0, j);\n}\n/**\n * Calculate size required for bit conversion.\n * @param {Number} len\n * @param {Number} frombits\n * @param {Number} tobits\n * @param {Boolean} pad\n * @returns {Number}\n */\n\n\nfunction convertSize(len, frombits, tobits, pad) {\n  assert(len >>> 0 === len);\n  assert((frombits & 0xff) === frombits);\n  assert((tobits & 0xff) === tobits);\n  assert(typeof pad === 'boolean');\n  assert(frombits !== 0);\n  assert(tobits !== 0);\n  let size = (len * frombits + (tobits - 1)) / tobits;\n  size >>>= 0;\n  if (pad) size += 1;\n  return size;\n}\n/**\n * Convert serialized data to another base.\n * @param {Buffer} data\n * @param {Number} frombits\n * @param {Number} tobits\n * @param {Boolean} pad\n * @returns {Buffer}\n */\n\n\nfunction convertBits(data, frombits, tobits, pad) {\n  assert(Buffer.isBuffer(data));\n  const size = convertSize(data.length, frombits, tobits, pad);\n  const out = Buffer.allocUnsafe(size);\n  return convert(data, 0, out, 0, frombits, tobits, pad);\n}\n/**\n * Get cash32 encoded size.\n * @param {Number} size\n * @returns {Number}\n */\n\n\nfunction encodedSize(size) {\n  assert(size >>> 0 === size);\n\n  switch (size) {\n    case 20:\n      return 0;\n\n    case 24:\n      return 1;\n\n    case 28:\n      return 2;\n\n    case 32:\n      return 3;\n\n    case 40:\n      return 4;\n\n    case 48:\n      return 5;\n\n    case 56:\n      return 6;\n\n    case 64:\n      return 7;\n\n    default:\n      throw new Error('Non standard length.');\n  }\n}\n/**\n * Serialize data to cash32\n * @param {String} prefix\n * @param {Number} type - (0 = P2PKH, 1 = P2SH)\n * @param {Buffer} hash\n * @returns {String}\n */\n\n\nfunction encode(prefix, type, hash) {\n  assert(typeof prefix === 'string'); // There are 4 bits available for the version (2 ^ 4 = 16)\n\n  assert((type & 0x0f) === type, 'Invalid cash32 type.');\n  assert(Buffer.isBuffer(hash));\n  if (prefix.length === 0 || prefix.length > 83) throw new Error('Invalid cash32 prefix.');\n  const size = encodedSize(hash.length);\n  const data = Buffer.allocUnsafe(hash.length + 1);\n  data[0] = type << 3 | size;\n  hash.copy(data, 1);\n  const output = POOL105;\n  const converted = convert(data, 0, output, 0, 8, 5, true);\n  return serialize(prefix, converted);\n}\n/**\n * Deserialize data from cash32 address.\n * @param {String} str\n * @param {String} defaultPrefix (lowercase and w/o numbers)\n * @returns {Array}\n */\n\n\nfunction decode(str) {\n  let defaultPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bitcoincash';\n  const [prefix, data] = deserialize(str, defaultPrefix);\n  const extrabits = data.length * 5 & 7;\n  if (extrabits >= 5) throw new Error('Invalid padding in data.');\n  const last = data[data.length - 1];\n  const mask = (1 << extrabits) - 1;\n  if (last & mask) throw new Error('Non zero padding.');\n  const output = data;\n  const converted = convert(data, 0, output, 0, 5, 8, false);\n  const type = converted[0] >>> 3 & 0x1f;\n  const hash = converted.slice(1);\n  let size = 20 + 4 * (converted[0] & 0x03);\n  if (converted[0] & 0x04) size *= 2;\n  if (size !== hash.length) throw new Error('Invalid cash32 data length.');\n  return [prefix, type, hash];\n}\n/**\n * Test whether a string is a cash32 string.\n * @param {String} str\n * @param {String} defaultPrefix (lowercase and w/o numbers)\n * @returns {Boolean}\n */\n\n\nfunction test(str) {\n  let defaultPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bitcoincash';\n  assert(typeof str === 'string');\n  assert(typeof defaultPrefix === 'string');\n\n  try {\n    decode(str, defaultPrefix);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}\n/*\n * Expose\n */\n\n\nexports.native = 0;\nexports.serialize = serialize;\nexports.deserialize = deserialize;\nexports.is = is;\nexports.convertBits = convertBits;\nexports.encode = encode;\nexports.decode = decode;\nexports.test = test;","map":null,"metadata":{},"sourceType":"script"}