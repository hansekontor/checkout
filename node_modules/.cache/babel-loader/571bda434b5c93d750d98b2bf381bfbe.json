{"ast":null,"code":"/*!\n * secretbox.js - nacl secretbox for bcrypto\n * Copyright (c) 2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on golang/go:\n *   Copyright (c) 2009 The Go Authors. All rights reserved.\n *   https://github.com/golang/go\n *\n * Resources:\n *   https://nacl.cr.yp.to/secretbox.html\n *   https://github.com/golang/crypto/tree/master/nacl\n *   https://github.com/golang/crypto/blob/master/nacl/secretbox/secretbox.go\n *   https://github.com/golang/crypto/blob/master/nacl/secretbox/secretbox_test.go\n *   https://github.com/golang/crypto/blob/master/nacl/secretbox/example_test.go\n *   https://github.com/golang/crypto/blob/master/nacl/box/box.go\n *   https://github.com/golang/crypto/blob/master/nacl/box/box_test.go\n *   https://github.com/golang/crypto/blob/master/nacl/box/example_test.go\n */\n'use strict';\n\nconst assert = require('./internal/assert');\n\nconst Salsa20 = require('./salsa20');\n\nconst Poly1305 = require('./poly1305');\n/*\n * Constants\n */\n\n\nconst ZERO16 = Buffer.alloc(16, 0x00);\n/*\n * Secret Box\n */\n\nfunction seal(msg, key, nonce) {\n  assert(Buffer.isBuffer(msg));\n  assert(Buffer.isBuffer(key));\n  assert(Buffer.isBuffer(nonce));\n  assert(key.length === 32);\n  assert(nonce.length === 24);\n  const box = Buffer.alloc(16 + msg.length, 0x00);\n  const firstBlock = box.slice(16, 16 + 32);\n  const ciphertext = box.slice(16 + 32);\n  const salsa = new Salsa20();\n  const poly = new Poly1305();\n  const block = Buffer.alloc(64, 0x00);\n  const polyKey = block.slice(0, 32);\n  const rightSide = block.slice(32);\n  salsa.init(key, nonce);\n  salsa.encrypt(block); // box = tag || (first-block || msg[32:])\n\n  msg.copy(box, 16);\n\n  for (let i = 0; i < firstBlock.length; i++) firstBlock[i] ^= rightSide[i];\n\n  if (ciphertext.length > 0) {\n    salsa.init(key, nonce, 1);\n    salsa.encrypt(ciphertext);\n  }\n\n  poly.init(polyKey);\n  poly.update(firstBlock);\n  poly.update(ciphertext);\n  poly.final().copy(box, 0);\n  return box;\n}\n\nfunction open(sealed, key, nonce) {\n  assert(Buffer.isBuffer(sealed));\n  assert(Buffer.isBuffer(key));\n  assert(Buffer.isBuffer(nonce));\n  assert(key.length === 32);\n  assert(nonce.length === 24);\n  if (sealed.length < 16) throw new Error('Invalid secret box size.');\n  const input = Buffer.from(sealed);\n  const tag = input.slice(0, 16);\n  const firstBlock = input.slice(16, 16 + 32);\n  const ciphertext = input.slice(16 + 32);\n  const msg = input.slice(16);\n  const salsa = new Salsa20();\n  const poly = new Poly1305();\n  const block = Buffer.alloc(64, 0x00);\n  const polyKey = block.slice(0, 32);\n  const rightSide = block.slice(32, 64);\n  salsa.init(key, nonce);\n  salsa.encrypt(block);\n  poly.init(polyKey);\n  poly.update(firstBlock);\n  poly.update(ciphertext);\n  if (!poly.verify(tag)) throw new Error('Invalid secret box tag.');\n\n  for (let i = 0; i < firstBlock.length; i++) firstBlock[i] ^= rightSide[i];\n\n  if (ciphertext.length > 0) {\n    salsa.init(key, nonce, 1);\n    salsa.encrypt(ciphertext);\n  }\n\n  return msg;\n}\n\nfunction derive(secret, kdf) {\n  const key = deriveSecret(secret, kdf);\n  return Salsa20.derive(key, ZERO16);\n}\n/*\n * Helpers\n */\n\n\nfunction deriveSecret(secret, kdf) {\n  assert(Buffer.isBuffer(secret));\n\n  if (kdf == null) {\n    if (secret.length !== 32) throw new Error('Invalid secret size for secret box.');\n    return secret;\n  }\n\n  if (typeof kdf.digest === 'function') {\n    if (kdf.size < 32) throw new Error('Hash is too small for secret box.');\n    return kdf.digest(secret).slice(0, 32);\n  }\n\n  assert(typeof kdf === 'function');\n  const key = kdf(secret);\n  assert(Buffer.isBuffer(key));\n  if (key.length < 32) throw new Error('Key is too small for secret box.');\n  return key.slice(0, 32);\n}\n/*\n * Expose\n */\n\n\nexports.native = 0;\nexports.seal = seal;\nexports.open = open;\nexports.derive = derive;","map":null,"metadata":{},"sourceType":"script"}