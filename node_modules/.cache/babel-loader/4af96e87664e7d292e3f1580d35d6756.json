{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.tsCustomError = {});\n})(this, function (exports) {\n  /*! *****************************************************************************\r\n  Copyright (c) Microsoft Corporation. All rights reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n  this file except in compliance with the License. You may obtain a copy of the\r\n  License at http://www.apache.org/licenses/LICENSE-2.0\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n  MERCHANTABLITY OR NON-INFRINGEMENT.\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n  and limitations under the License.\r\n  ***************************************************************************** */\n\n  /* global Reflect, Promise */\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  function __extends(d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  }\n\n  function fixProto(target, prototype) {\n    var setPrototypeOf = Object.setPrototypeOf;\n    setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;\n  }\n\n  function fixStack(target, fn) {\n    if (fn === void 0) {\n      fn = target.constructor;\n    }\n\n    var captureStackTrace = Error.captureStackTrace;\n    captureStackTrace && captureStackTrace(target, fn);\n  }\n\n  var CustomError = function (_super) {\n    __extends(CustomError, _super);\n\n    function CustomError(message) {\n      var _newTarget = this.constructor;\n\n      var _this = _super.call(this, message) || this;\n\n      _this.name = _newTarget.name;\n      fixProto(_this, _newTarget.prototype);\n      fixStack(_this);\n      return _this;\n    }\n\n    return CustomError;\n  }(Error);\n\n  function customErrorFactory(fn, parent) {\n    if (parent === void 0) {\n      parent = Error;\n    }\n\n    function CustomError() {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      if (!(this instanceof CustomError)) return new (CustomError.bind.apply(CustomError, [void 0].concat(args)))();\n      parent.apply(this, args);\n      fn.apply(this, args);\n      this.name = fn.name || parent.name;\n      fixStack(this, CustomError);\n    }\n\n    return Object.defineProperties(CustomError, {\n      prototype: {\n        value: Object.create(parent.prototype, {\n          constructor: {\n            value: CustomError,\n            writable: true,\n            configurable: true\n          }\n        })\n      }\n    });\n  }\n\n  exports.CustomError = CustomError;\n  exports.customErrorFactory = customErrorFactory;\n}); //# sourceMappingURL=custom-error.umd.js.map","map":null,"metadata":{},"sourceType":"script"}