{"ast":null,"code":"/*!\n * writer.js - buffer writer for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst enforce = require('./enforce');\n\nconst encoding = require('./encoding');\n\nconst EncodingError = require('./error');\n/*\n * Constants\n */\n\n\nconst SEEK = 0;\nconst U8 = 1;\nconst U16 = 2;\nconst U16BE = 3;\nconst U24 = 4;\nconst U24BE = 5;\nconst U32 = 6;\nconst U32BE = 7;\nconst U40 = 8;\nconst U40BE = 9;\nconst U48 = 10;\nconst U48BE = 11;\nconst U56 = 12;\nconst U56BE = 13;\nconst U64 = 14;\nconst U64BE = 15;\nconst I8 = 16;\nconst I16 = 17;\nconst I16BE = 18;\nconst I24 = 19;\nconst I24BE = 20;\nconst I32 = 21;\nconst I32BE = 22;\nconst I40 = 23;\nconst I40BE = 24;\nconst I48 = 25;\nconst I48BE = 26;\nconst I56 = 27;\nconst I56BE = 28;\nconst I64 = 29;\nconst I64BE = 30;\nconst FL = 31;\nconst FLBE = 32;\nconst DBL = 33;\nconst DBLBE = 34;\nconst VARINT = 35;\nconst VARINT2 = 36;\nconst BYTES = 37;\nconst STR = 38;\nconst CHECKSUM = 39;\nconst FILL = 40;\n/**\n * Buffer Writer\n */\n\nclass BufferWriter {\n  /**\n   * Create a buffer writer.\n   * @constructor\n   */\n  constructor() {\n    this.ops = [];\n    this.offset = 0;\n  }\n  /**\n   * Allocate and render the final buffer.\n   * @returns {Buffer} Rendered buffer.\n   */\n\n\n  render() {\n    const data = Buffer.allocUnsafeSlow(this.offset);\n    let off = 0;\n\n    for (const op of this.ops) {\n      switch (op.type) {\n        case SEEK:\n          off += op.value;\n          break;\n\n        case U8:\n          off = encoding.writeU8(data, op.value, off);\n          break;\n\n        case U16:\n          off = encoding.writeU16(data, op.value, off);\n          break;\n\n        case U16BE:\n          off = encoding.writeU16BE(data, op.value, off);\n          break;\n\n        case U24:\n          off = encoding.writeU24(data, op.value, off);\n          break;\n\n        case U24BE:\n          off = encoding.writeU24BE(data, op.value, off);\n          break;\n\n        case U32:\n          off = encoding.writeU32(data, op.value, off);\n          break;\n\n        case U32BE:\n          off = encoding.writeU32BE(data, op.value, off);\n          break;\n\n        case U40:\n          off = encoding.writeU40(data, op.value, off);\n          break;\n\n        case U40BE:\n          off = encoding.writeU40BE(data, op.value, off);\n          break;\n\n        case U48:\n          off = encoding.writeU48(data, op.value, off);\n          break;\n\n        case U48BE:\n          off = encoding.writeU48BE(data, op.value, off);\n          break;\n\n        case U56:\n          off = encoding.writeU56(data, op.value, off);\n          break;\n\n        case U56BE:\n          off = encoding.writeU56BE(data, op.value, off);\n          break;\n\n        case U64:\n          off = encoding.writeU64(data, op.value, off);\n          break;\n\n        case U64BE:\n          off = encoding.writeU64BE(data, op.value, off);\n          break;\n\n        case I8:\n          off = encoding.writeI8(data, op.value, off);\n          break;\n\n        case I16:\n          off = encoding.writeI16(data, op.value, off);\n          break;\n\n        case I16BE:\n          off = encoding.writeI16BE(data, op.value, off);\n          break;\n\n        case I24:\n          off = encoding.writeI24(data, op.value, off);\n          break;\n\n        case I24BE:\n          off = encoding.writeI24BE(data, op.value, off);\n          break;\n\n        case I32:\n          off = encoding.writeI32(data, op.value, off);\n          break;\n\n        case I32BE:\n          off = encoding.writeI32BE(data, op.value, off);\n          break;\n\n        case I40:\n          off = encoding.writeI40(data, op.value, off);\n          break;\n\n        case I40BE:\n          off = encoding.writeI40BE(data, op.value, off);\n          break;\n\n        case I48:\n          off = encoding.writeI48(data, op.value, off);\n          break;\n\n        case I48BE:\n          off = encoding.writeI48BE(data, op.value, off);\n          break;\n\n        case I56:\n          off = encoding.writeI56(data, op.value, off);\n          break;\n\n        case I56BE:\n          off = encoding.writeI56BE(data, op.value, off);\n          break;\n\n        case I64:\n          off = encoding.writeI64(data, op.value, off);\n          break;\n\n        case I64BE:\n          off = encoding.writeI64BE(data, op.value, off);\n          break;\n\n        case FL:\n          off = encoding.writeFloat(data, op.value, off);\n          break;\n\n        case FLBE:\n          off = encoding.writeFloatBE(data, op.value, off);\n          break;\n\n        case DBL:\n          off = encoding.writeDouble(data, op.value, off);\n          break;\n\n        case DBLBE:\n          off = encoding.writeDoubleBE(data, op.value, off);\n          break;\n\n        case VARINT:\n          off = encoding.writeVarint(data, op.value, off);\n          break;\n\n        case VARINT2:\n          off = encoding.writeVarint2(data, op.value, off);\n          break;\n\n        case BYTES:\n          off += op.data.copy(data, off);\n          break;\n\n        case STR:\n          off += data.write(op.value, off, op.enc);\n          break;\n\n        case CHECKSUM:\n          off += op.func(data.slice(0, off)).copy(data, off, 0, 4);\n          break;\n\n        case FILL:\n          data.fill(op.value, off, off + op.size);\n          off += op.size;\n          break;\n\n        default:\n          throw new Error('Invalid type.');\n      }\n    }\n\n    if (off !== data.length) throw new EncodingError(off, 'Out of bounds write');\n    this.destroy();\n    return data;\n  }\n  /**\n   * Get size of data written so far.\n   * @returns {Number}\n   */\n\n\n  getSize() {\n    return this.offset;\n  }\n  /**\n   * Seek to relative offset.\n   * @param {Number} offset\n   */\n\n\n  seek(off) {\n    enforce(Number.isSafeInteger(off), 'off', 'integer');\n    if (this.offset + off < 0) throw new EncodingError(this.offset, 'Out of bounds write');\n    this.offset += off;\n    this.ops.push(new NumberOp(SEEK, off));\n    return this;\n  }\n  /**\n   * Destroy the buffer writer. Remove references to `ops`.\n   */\n\n\n  destroy() {\n    this.ops.length = 0;\n    this.offset = 0;\n    return this;\n  }\n  /**\n   * Write uint8.\n   * @param {Number} value\n   */\n\n\n  writeU8(value) {\n    this.offset += 1;\n    this.ops.push(new NumberOp(U8, value));\n    return this;\n  }\n  /**\n   * Write uint16le.\n   * @param {Number} value\n   */\n\n\n  writeU16(value) {\n    this.offset += 2;\n    this.ops.push(new NumberOp(U16, value));\n    return this;\n  }\n  /**\n   * Write uint16be.\n   * @param {Number} value\n   */\n\n\n  writeU16BE(value) {\n    this.offset += 2;\n    this.ops.push(new NumberOp(U16BE, value));\n    return this;\n  }\n  /**\n   * Write uint24le.\n   * @param {Number} value\n   */\n\n\n  writeU24(value) {\n    this.offset += 3;\n    this.ops.push(new NumberOp(U24, value));\n    return this;\n  }\n  /**\n   * Write uint24be.\n   * @param {Number} value\n   */\n\n\n  writeU24BE(value) {\n    this.offset += 3;\n    this.ops.push(new NumberOp(U24BE, value));\n    return this;\n  }\n  /**\n   * Write uint32le.\n   * @param {Number} value\n   */\n\n\n  writeU32(value) {\n    this.offset += 4;\n    this.ops.push(new NumberOp(U32, value));\n    return this;\n  }\n  /**\n   * Write uint32be.\n   * @param {Number} value\n   */\n\n\n  writeU32BE(value) {\n    this.offset += 4;\n    this.ops.push(new NumberOp(U32BE, value));\n    return this;\n  }\n  /**\n   * Write uint40le.\n   * @param {Number} value\n   */\n\n\n  writeU40(value) {\n    this.offset += 5;\n    this.ops.push(new NumberOp(U40, value));\n    return this;\n  }\n  /**\n   * Write uint40be.\n   * @param {Number} value\n   */\n\n\n  writeU40BE(value) {\n    this.offset += 5;\n    this.ops.push(new NumberOp(U40BE, value));\n    return this;\n  }\n  /**\n   * Write uint48le.\n   * @param {Number} value\n   */\n\n\n  writeU48(value) {\n    this.offset += 6;\n    this.ops.push(new NumberOp(U48, value));\n    return this;\n  }\n  /**\n   * Write uint48be.\n   * @param {Number} value\n   */\n\n\n  writeU48BE(value) {\n    this.offset += 6;\n    this.ops.push(new NumberOp(U48BE, value));\n    return this;\n  }\n  /**\n   * Write uint56le.\n   * @param {Number} value\n   */\n\n\n  writeU56(value) {\n    this.offset += 7;\n    this.ops.push(new NumberOp(U56, value));\n    return this;\n  }\n  /**\n   * Write uint56be.\n   * @param {Number} value\n   */\n\n\n  writeU56BE(value) {\n    this.offset += 7;\n    this.ops.push(new NumberOp(U56BE, value));\n    return this;\n  }\n  /**\n   * Write uint64le.\n   * @param {Number} value\n   */\n\n\n  writeU64(value) {\n    this.offset += 8;\n    this.ops.push(new NumberOp(U64, value));\n    return this;\n  }\n  /**\n   * Write uint64be.\n   * @param {Number} value\n   */\n\n\n  writeU64BE(value) {\n    this.offset += 8;\n    this.ops.push(new NumberOp(U64BE, value));\n    return this;\n  }\n  /**\n   * Write int8.\n   * @param {Number} value\n   */\n\n\n  writeI8(value) {\n    this.offset += 1;\n    this.ops.push(new NumberOp(I8, value));\n    return this;\n  }\n  /**\n   * Write int16le.\n   * @param {Number} value\n   */\n\n\n  writeI16(value) {\n    this.offset += 2;\n    this.ops.push(new NumberOp(I16, value));\n    return this;\n  }\n  /**\n   * Write int16be.\n   * @param {Number} value\n   */\n\n\n  writeI16BE(value) {\n    this.offset += 2;\n    this.ops.push(new NumberOp(I16BE, value));\n    return this;\n  }\n  /**\n   * Write int24le.\n   * @param {Number} value\n   */\n\n\n  writeI24(value) {\n    this.offset += 3;\n    this.ops.push(new NumberOp(I24, value));\n    return this;\n  }\n  /**\n   * Write int24be.\n   * @param {Number} value\n   */\n\n\n  writeI24BE(value) {\n    this.offset += 3;\n    this.ops.push(new NumberOp(I24BE, value));\n    return this;\n  }\n  /**\n   * Write int32le.\n   * @param {Number} value\n   */\n\n\n  writeI32(value) {\n    this.offset += 4;\n    this.ops.push(new NumberOp(I32, value));\n    return this;\n  }\n  /**\n   * Write int32be.\n   * @param {Number} value\n   */\n\n\n  writeI32BE(value) {\n    this.offset += 4;\n    this.ops.push(new NumberOp(I32BE, value));\n    return this;\n  }\n  /**\n   * Write int40le.\n   * @param {Number} value\n   */\n\n\n  writeI40(value) {\n    this.offset += 5;\n    this.ops.push(new NumberOp(I40, value));\n    return this;\n  }\n  /**\n   * Write int40be.\n   * @param {Number} value\n   */\n\n\n  writeI40BE(value) {\n    this.offset += 5;\n    this.ops.push(new NumberOp(I40BE, value));\n    return this;\n  }\n  /**\n   * Write int48le.\n   * @param {Number} value\n   */\n\n\n  writeI48(value) {\n    this.offset += 6;\n    this.ops.push(new NumberOp(I48, value));\n    return this;\n  }\n  /**\n   * Write int48be.\n   * @param {Number} value\n   */\n\n\n  writeI48BE(value) {\n    this.offset += 6;\n    this.ops.push(new NumberOp(I48BE, value));\n    return this;\n  }\n  /**\n   * Write int56le.\n   * @param {Number} value\n   */\n\n\n  writeI56(value) {\n    this.offset += 7;\n    this.ops.push(new NumberOp(I56, value));\n    return this;\n  }\n  /**\n   * Write int56be.\n   * @param {Number} value\n   */\n\n\n  writeI56BE(value) {\n    this.offset += 7;\n    this.ops.push(new NumberOp(I56BE, value));\n    return this;\n  }\n  /**\n   * Write int64le.\n   * @param {Number} value\n   */\n\n\n  writeI64(value) {\n    this.offset += 8;\n    this.ops.push(new NumberOp(I64, value));\n    return this;\n  }\n  /**\n   * Write int64be.\n   * @param {Number} value\n   */\n\n\n  writeI64BE(value) {\n    this.offset += 8;\n    this.ops.push(new NumberOp(I64BE, value));\n    return this;\n  }\n  /**\n   * Write float le.\n   * @param {Number} value\n   */\n\n\n  writeFloat(value) {\n    this.offset += 4;\n    this.ops.push(new NumberOp(FL, value));\n    return this;\n  }\n  /**\n   * Write float be.\n   * @param {Number} value\n   */\n\n\n  writeFloatBE(value) {\n    this.offset += 4;\n    this.ops.push(new NumberOp(FLBE, value));\n    return this;\n  }\n  /**\n   * Write double le.\n   * @param {Number} value\n   */\n\n\n  writeDouble(value) {\n    this.offset += 8;\n    this.ops.push(new NumberOp(DBL, value));\n    return this;\n  }\n  /**\n   * Write double be.\n   * @param {Number} value\n   */\n\n\n  writeDoubleBE(value) {\n    this.offset += 8;\n    this.ops.push(new NumberOp(DBLBE, value));\n    return this;\n  }\n  /**\n   * Write a varint.\n   * @param {Number} value\n   */\n\n\n  writeVarint(value) {\n    this.offset += encoding.sizeVarint(value);\n    this.ops.push(new NumberOp(VARINT, value));\n    return this;\n  }\n  /**\n   * Write a varint (type 2).\n   * @param {Number} value\n   */\n\n\n  writeVarint2(value) {\n    this.offset += encoding.sizeVarint2(value);\n    this.ops.push(new NumberOp(VARINT2, value));\n    return this;\n  }\n  /**\n   * Write bytes.\n   * @param {Buffer} value\n   */\n\n\n  writeBytes(value) {\n    enforce(Buffer.isBuffer(value), 'value', 'buffer');\n    if (value.length === 0) return this;\n    this.offset += value.length;\n    this.ops.push(new BufferOp(BYTES, value));\n    return this;\n  }\n  /**\n   * Write bytes with a varint length before them.\n   * @param {Buffer} value\n   */\n\n\n  writeVarBytes(value) {\n    enforce(Buffer.isBuffer(value), 'value', 'buffer');\n    this.offset += encoding.sizeVarint(value.length);\n    this.ops.push(new NumberOp(VARINT, value.length));\n    if (value.length === 0) return this;\n    this.offset += value.length;\n    this.ops.push(new BufferOp(BYTES, value));\n    return this;\n  }\n  /**\n   * Copy bytes.\n   * @param {Buffer} value\n   * @param {Number} start\n   * @param {Number} end\n   */\n\n\n  copy(value, start, end) {\n    enforce(Buffer.isBuffer(value), 'value', 'buffer');\n    enforce(start >>> 0 === start, 'start', 'integer');\n    enforce(end >>> 0 === end, 'end', 'integer');\n    enforce(end >= start, 'start', 'integer');\n    const buf = value.slice(start, end);\n    this.writeBytes(buf);\n    return this;\n  }\n  /**\n   * Write string to buffer.\n   * @param {String} value\n   * @param {String?} enc - Any buffer-supported encoding.\n   */\n\n\n  writeString(value, enc) {\n    if (enc == null) enc = 'binary';\n    enforce(typeof value === 'string', 'value', 'string');\n    enforce(typeof enc === 'string', 'enc', 'string');\n    if (value.length === 0) return this;\n    this.offset += Buffer.byteLength(value, enc);\n    this.ops.push(new StringOp(STR, value, enc));\n    return this;\n  }\n  /**\n   * Write a 32 byte hash.\n   * @param {Hash} value\n   */\n\n\n  writeHash(value) {\n    if (typeof value !== 'string') {\n      enforce(Buffer.isBuffer(value), 'value', 'buffer');\n      enforce(value.length === 32, 'value', '32-byte hash');\n      this.writeBytes(value);\n      return this;\n    }\n\n    enforce(value.length === 64, 'value', '32-byte hash');\n    this.writeString(value, 'hex');\n    return this;\n  }\n  /**\n   * Write a string with a varint length before it.\n   * @param {String}\n   * @param {String?} enc - Any buffer-supported encoding.\n   */\n\n\n  writeVarString(value, enc) {\n    if (enc == null) enc = 'binary';\n    enforce(typeof value === 'string', 'value', 'string');\n    enforce(typeof enc === 'string', 'enc', 'string');\n\n    if (value.length === 0) {\n      this.ops.push(new NumberOp(VARINT, 0));\n      return this;\n    }\n\n    const size = Buffer.byteLength(value, enc);\n    this.offset += encoding.sizeVarint(size);\n    this.offset += size;\n    this.ops.push(new NumberOp(VARINT, size));\n    this.ops.push(new StringOp(STR, value, enc));\n    return this;\n  }\n  /**\n   * Write a null-terminated string.\n   * @param {String|Buffer}\n   * @param {String?} enc - Any buffer-supported encoding.\n   */\n\n\n  writeNullString(value, enc) {\n    this.writeString(value, enc);\n    this.writeU8(0);\n    return this;\n  }\n  /**\n   * Calculate and write a checksum for the data written so far.\n   * @param {Function} hash\n   */\n\n\n  writeChecksum(hash) {\n    if (hash && typeof hash.digest === 'function') hash = hash.digest.bind(hash);\n    enforce(typeof hash === 'function', 'hash', 'function');\n    this.offset += 4;\n    this.ops.push(new FunctionOp(CHECKSUM, hash));\n    return this;\n  }\n  /**\n   * Fill N bytes with value.\n   * @param {Number} value\n   * @param {Number} size\n   */\n\n\n  fill(value, size) {\n    enforce((value & 0xff) === value, 'value', 'byte');\n    enforce(size >>> 0 === size, 'size', 'integer');\n    if (size === 0) return this;\n    this.offset += size;\n    this.ops.push(new FillOp(FILL, value, size));\n    return this;\n  }\n\n}\n/*\n * Helpers\n */\n\n\nclass WriteOp {\n  constructor(type) {\n    this.type = type;\n  }\n\n}\n\nclass NumberOp extends WriteOp {\n  constructor(type, value) {\n    super(type);\n    this.value = value;\n  }\n\n}\n\nclass BufferOp extends WriteOp {\n  constructor(type, data) {\n    super(type);\n    this.data = data;\n  }\n\n}\n\nclass StringOp extends WriteOp {\n  constructor(type, value, enc) {\n    super(type);\n    this.value = value;\n    this.enc = enc;\n  }\n\n}\n\nclass FunctionOp extends WriteOp {\n  constructor(type, func) {\n    super(type);\n    this.func = func;\n  }\n\n}\n\nclass FillOp extends WriteOp {\n  constructor(type, value, size) {\n    super(type);\n    this.value = value;\n    this.size = size;\n  }\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = BufferWriter;","map":null,"metadata":{},"sourceType":"script"}