{"ast":null,"code":"/*!\n * lru.js - LRU cache for bcoin\n * Copyright (c) 2014-2018, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n/**\n * LRU Cache\n */\n\n\nclass LRU {\n  /**\n   * Create an LRU cache.\n   * @constructor\n   * @param {Number} capacity\n   * @param {Function?} getSize\n   * @param {Function?} CustomMap\n   */\n  constructor(capacity, getSize, CustomMap) {\n    assert(typeof capacity === 'number', 'Capacity must be a number.');\n    assert(capacity >= 0, 'Capacity cannot be negative.');\n    assert(!getSize || typeof getSize === 'function', 'Bad size callback.');\n    assert(!CustomMap || typeof CustomMap === 'function');\n    this.map = CustomMap ? new CustomMap() : new Map();\n    this.size = 0;\n    this.items = 0;\n    this.head = null;\n    this.tail = null;\n    this.pending = null;\n    this.capacity = capacity;\n    this.getSize = getSize;\n  }\n  /**\n   * Calculate size of an item.\n   * @private\n   * @param {LRUItem} item\n   * @returns {Number} Size.\n   */\n\n\n  _getSize(item) {\n    if (this.getSize) return 120 + this.getSize(item.value, item.key);\n    return 1;\n  }\n  /**\n   * Compact the LRU linked list.\n   * @private\n   */\n\n\n  _compact() {\n    if (this.size <= this.capacity) return;\n    let item = null;\n    let next = null;\n\n    for (item = this.head; item; item = next) {\n      if (this.size <= this.capacity) break;\n      this.size -= this._getSize(item);\n      this.items -= 1;\n      this.map.delete(item.key);\n      next = item.next;\n      item.prev = null;\n      item.next = null;\n    }\n\n    if (!item) {\n      this.head = null;\n      this.tail = null;\n      return;\n    }\n\n    this.head = item;\n    item.prev = null;\n  }\n  /**\n   * Reset the cache. Clear all items.\n   */\n\n\n  reset() {\n    let item, next;\n\n    for (item = this.head; item; item = next) {\n      this.map.delete(item.key);\n      this.items -= 1;\n      next = item.next;\n      item.prev = null;\n      item.next = null;\n    }\n\n    assert(!item);\n    this.size = 0;\n    this.head = null;\n    this.tail = null;\n  }\n  /**\n   * Add an item to the cache.\n   * @param {String|Number} key\n   * @param {Object} value\n   */\n\n\n  set(key, value) {\n    if (this.capacity === 0) return;\n    let item = this.map.get(key);\n\n    if (item) {\n      this.size -= this._getSize(item);\n      item.value = value;\n      this.size += this._getSize(item);\n\n      this._removeList(item);\n\n      this._appendList(item);\n\n      this._compact();\n\n      return;\n    }\n\n    item = new LRUItem(key, value);\n    this.map.set(key, item);\n\n    this._appendList(item);\n\n    this.size += this._getSize(item);\n    this.items += 1;\n\n    this._compact();\n  }\n  /**\n   * Retrieve an item from the cache.\n   * @param {String|Number} key\n   * @returns {Object} Item.\n   */\n\n\n  get(key) {\n    if (this.capacity === 0) return null;\n    const item = this.map.get(key);\n    if (!item) return null;\n\n    this._removeList(item);\n\n    this._appendList(item);\n\n    return item.value;\n  }\n  /**\n   * Test whether the cache contains a key.\n   * @param {String|Number} key\n   * @returns {Boolean}\n   */\n\n\n  has(key) {\n    if (this.capacity === 0) return false;\n    return this.map.has(key);\n  }\n  /**\n   * Remove an item from the cache.\n   * @param {String|Number} key\n   * @returns {Boolean} Whether an item was removed.\n   */\n\n\n  remove(key) {\n    if (this.capacity === 0) return false;\n    const item = this.map.get(key);\n    if (!item) return false;\n    this.size -= this._getSize(item);\n    this.items -= 1;\n    this.map.delete(key);\n\n    this._removeList(item);\n\n    return true;\n  }\n  /**\n   * Prepend an item to the linked list (sets new head).\n   * @private\n   * @param {LRUItem}\n   */\n\n\n  _prependList(item) {\n    this._insertList(null, item);\n  }\n  /**\n   * Append an item to the linked list (sets new tail).\n   * @private\n   * @param {LRUItem}\n   */\n\n\n  _appendList(item) {\n    this._insertList(this.tail, item);\n  }\n  /**\n   * Insert item into the linked list.\n   * @private\n   * @param {LRUItem|null} ref\n   * @param {LRUItem} item\n   */\n\n\n  _insertList(ref, item) {\n    assert(!item.next);\n    assert(!item.prev);\n\n    if (ref == null) {\n      if (!this.head) {\n        this.head = item;\n        this.tail = item;\n      } else {\n        this.head.prev = item;\n        item.next = this.head;\n        this.head = item;\n      }\n\n      return;\n    }\n\n    item.next = ref.next;\n    item.prev = ref;\n    ref.next = item;\n    if (item.next) item.next.prev = item;\n    if (ref === this.tail) this.tail = item;\n  }\n  /**\n   * Remove item from the linked list.\n   * @private\n   * @param {LRUItem}\n   */\n\n\n  _removeList(item) {\n    if (item.prev) item.prev.next = item.next;\n    if (item.next) item.next.prev = item.prev;\n    if (item === this.head) this.head = item.next;\n    if (item === this.tail) this.tail = item.prev || this.head;\n    if (!this.head) assert(!this.tail);\n    if (!this.tail) assert(!this.head);\n    item.prev = null;\n    item.next = null;\n  }\n  /**\n   * Collect all keys in the cache, sorted by LRU.\n   * @returns {String[]}\n   */\n\n\n  keys() {\n    const items = [];\n\n    for (let item = this.head; item; item = item.next) {\n      if (item === this.head) assert(!item.prev);\n      if (!item.prev) assert(item === this.head);\n      if (!item.next) assert(item === this.tail);\n      items.push(item.key);\n    }\n\n    return items;\n  }\n  /**\n   * Collect all values in the cache, sorted by LRU.\n   * @returns {String[]}\n   */\n\n\n  values() {\n    const items = [];\n\n    for (let item = this.head; item; item = item.next) items.push(item.value);\n\n    return items;\n  }\n  /**\n   * Convert the LRU cache to an array of items.\n   * @returns {Object[]}\n   */\n\n\n  toArray() {\n    const items = [];\n\n    for (let item = this.head; item; item = item.next) items.push(item);\n\n    return items;\n  }\n  /**\n   * Create an atomic batch for the lru\n   * (used for caching database writes).\n   * @returns {LRUBatch}\n   */\n\n\n  batch() {\n    return new LRUBatch(this);\n  }\n  /**\n   * Start the pending batch.\n   */\n\n\n  start() {\n    assert(!this.pending);\n    this.pending = this.batch();\n  }\n  /**\n   * Clear the pending batch.\n   */\n\n\n  clear() {\n    assert(this.pending);\n    this.pending.clear();\n  }\n  /**\n   * Drop the pending batch.\n   */\n\n\n  drop() {\n    assert(this.pending);\n    this.pending = null;\n  }\n  /**\n   * Commit the pending batch.\n   */\n\n\n  commit() {\n    assert(this.pending);\n    this.pending.commit();\n    this.pending = null;\n  }\n  /**\n   * Push an item onto the pending batch.\n   * @param {String} key\n   * @param {Object} value\n   */\n\n\n  push(key, value) {\n    assert(this.pending);\n    if (this.capacity === 0) return;\n    this.pending.set(key, value);\n  }\n  /**\n   * Push a removal onto the pending batch.\n   * @param {String} key\n   */\n\n\n  unpush(key) {\n    assert(this.pending);\n    if (this.capacity === 0) return;\n    this.pending.remove(key);\n  }\n\n}\n/**\n * LRU Item\n * @alias module:utils.LRUItem\n */\n\n\nclass LRUItem {\n  /**\n   * Create an LRU item.\n   * @constructor\n   * @private\n   * @param {String} key\n   * @param {Object} value\n   */\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n    this.next = null;\n    this.prev = null;\n  }\n\n}\n/**\n * LRU Batch\n * @alias module:utils.LRUBatch\n */\n\n\nclass LRUBatch {\n  /**\n   * Create an LRU batch.\n   * @constructor\n   * @param {LRU} lru\n   */\n  constructor(lru) {\n    this.lru = lru;\n    this.ops = [];\n  }\n  /**\n   * Push an item onto the batch.\n   * @param {String} key\n   * @param {Object} value\n   */\n\n\n  set(key, value) {\n    this.ops.push(new LRUOp(false, key, value));\n  }\n  /**\n   * Push a removal onto the batch.\n   * @param {String} key\n   */\n\n\n  remove(key) {\n    this.ops.push(new LRUOp(true, key, null));\n  }\n  /**\n   * Clear the batch.\n   */\n\n\n  clear() {\n    this.ops.length = 0;\n  }\n  /**\n   * Commit the batch.\n   */\n\n\n  commit() {\n    for (const op of this.ops) {\n      if (op.remove) {\n        this.lru.remove(op.key);\n        continue;\n      }\n\n      this.lru.set(op.key, op.value);\n    }\n\n    this.ops.length = 0;\n  }\n\n}\n/**\n * LRU Op\n * @alias module:utils.LRUOp\n * @private\n */\n\n\nclass LRUOp {\n  /**\n   * Create an LRU op.\n   * @constructor\n   * @param {Boolean} remove\n   * @param {String} key\n   * @param {Object} value\n   */\n  constructor(remove, key, value) {\n    this.remove = remove;\n    this.key = key;\n    this.value = value;\n  }\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = LRU;","map":null,"metadata":{},"sourceType":"script"}