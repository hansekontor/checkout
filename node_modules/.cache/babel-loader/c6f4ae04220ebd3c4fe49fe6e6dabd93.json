{"ast":null,"code":"/*!\n * siphash.js - siphash for bcrypto\n * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on bitcoin/bitcoin:\n *   Copyright (c) 2009-2019, The Bitcoin Core Developers (MIT License).\n *   Copyright (c) 2009-2019, The Bitcoin Developers (MIT License).\n *   https://github.com/bitcoin/bitcoin\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/SipHash\n *   https://131002.net/siphash/\n *   https://131002.net/siphash/siphash.pdf\n *   https://github.com/bitcoin/bitcoin/blob/master/src/crypto/siphash.cpp\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n/*\n * Constants\n */\n\n\nconst HI = 1 / 0x100000000;\n/**\n * Javascript siphash 2-4 implementation.\n * @private\n * @param {Buffer} data\n * @param {Buffer} key - 128 bit key.\n * @returns {Array} [hi, lo]\n */\n\nfunction _siphash(data, key) {\n  assert(Buffer.isBuffer(data));\n  assert(Buffer.isBuffer(key) && key.length >= 16);\n  const blocks = data.length >>> 3;\n  const c0 = new U64(0x736f6d65, 0x70736575);\n  const c1 = new U64(0x646f7261, 0x6e646f6d);\n  const c2 = new U64(0x6c796765, 0x6e657261);\n  const c3 = new U64(0x74656462, 0x79746573);\n  const f0 = new U64(data.length << 24, 0);\n  const f1 = new U64(0, 0xff);\n  const k0 = U64.decode(key, 0);\n  const k1 = U64.decode(key, 8); // Init.\n\n  const v0 = c0.ixor(k0);\n  const v1 = c1.ixor(k1);\n  const v2 = c2.ixor(k0);\n  const v3 = c3.ixor(k1); // Blocks.\n\n  let p = 0;\n\n  for (let i = 0; i < blocks; i++) {\n    const d = U64.decode(data, p);\n    v3.ixor(d);\n    sipround(v0, v1, v2, v3);\n    sipround(v0, v1, v2, v3);\n    v0.ixor(d);\n    p += 8;\n  } // Trailing.\n\n\n  switch (data.length & 7) {\n    case 7:\n      f0.hi |= data[p + 6] << 16;\n\n    case 6:\n      f0.hi |= data[p + 5] << 8;\n\n    case 5:\n      f0.hi |= data[p + 4];\n\n    case 4:\n      f0.lo |= data[p + 3] << 24;\n\n    case 3:\n      f0.lo |= data[p + 2] << 16;\n\n    case 2:\n      f0.lo |= data[p + 1] << 8;\n\n    case 1:\n      f0.lo |= data[p];\n  } // Finalization.\n\n\n  v3.ixor(f0);\n  sipround(v0, v1, v2, v3);\n  sipround(v0, v1, v2, v3);\n  v0.ixor(f0);\n  v2.ixor(f1);\n  sipround(v0, v1, v2, v3);\n  sipround(v0, v1, v2, v3);\n  sipround(v0, v1, v2, v3);\n  sipround(v0, v1, v2, v3);\n  v0.ixor(v1);\n  v0.ixor(v2);\n  v0.ixor(v3);\n  return [v0.hi, v0.lo];\n}\n/**\n * Javascript siphash 2-4 implementation (64 bit ints).\n * @private\n * @param {Number} hi\n * @param {Number} lo\n * @param {Buffer} key - 128 bit key.\n * @returns {Array} [hi, lo]\n */\n\n\nfunction _siphash64(hi, lo, key) {\n  assert(typeof hi === 'number');\n  assert(typeof lo === 'number');\n  assert(Buffer.isBuffer(key) && key.length >= 16);\n  const c0 = new U64(0x736f6d65, 0x70736575);\n  const c1 = new U64(0x646f7261, 0x6e646f6d);\n  const c2 = new U64(0x6c796765, 0x6e657261);\n  const c3 = new U64(0x74656462, 0x79746573);\n  const f0 = new U64(hi, lo);\n  const f1 = new U64(0, 0xff);\n  const k0 = U64.decode(key, 0);\n  const k1 = U64.decode(key, 8); // Init.\n\n  const v0 = c0.ixor(k0);\n  const v1 = c1.ixor(k1);\n  const v2 = c2.ixor(k0);\n  const v3 = c3.ixor(k1); // Finalization.\n\n  v3.ixor(f0);\n  sipround(v0, v1, v2, v3);\n  sipround(v0, v1, v2, v3);\n  v0.ixor(f0);\n  v2.ixor(f1);\n  sipround(v0, v1, v2, v3);\n  sipround(v0, v1, v2, v3);\n  sipround(v0, v1, v2, v3);\n  sipround(v0, v1, v2, v3);\n  v0.ixor(v1);\n  v0.ixor(v2);\n  v0.ixor(v3);\n  return [v0.hi, v0.lo];\n}\n/**\n * Javascript siphash 2-4 implementation\n * (64 bit ints with a 256 bit key).\n * @private\n * @param {Number} hi\n * @param {Number} lo\n * @param {Buffer} key - 128 bit key.\n * @returns {Array} [hi, lo]\n */\n\n\nfunction _siphash64k256(hi, lo, key) {\n  assert(typeof hi === 'number');\n  assert(typeof lo === 'number');\n  assert(Buffer.isBuffer(key) && key.length >= 32);\n  const f0 = new U64(hi, lo);\n  const f1 = new U64(0, 0xff);\n  const k0 = U64.decode(key, 0);\n  const k1 = U64.decode(key, 8);\n  const k2 = U64.decode(key, 16);\n  const k3 = U64.decode(key, 24); // Init.\n\n  const v0 = k0;\n  const v1 = k1;\n  const v2 = k2;\n  const v3 = k3; // Finalization.\n\n  v3.ixor(f0);\n  sipround(v0, v1, v2, v3);\n  sipround(v0, v1, v2, v3);\n  v0.ixor(f0);\n  v2.ixor(f1);\n  sipround(v0, v1, v2, v3);\n  sipround(v0, v1, v2, v3);\n  sipround(v0, v1, v2, v3);\n  sipround(v0, v1, v2, v3);\n  v0.ixor(v1);\n  v0.ixor(v2);\n  v0.ixor(v3);\n  return [v0.hi, v0.lo];\n}\n/**\n * Javascript siphash 2-4 implementation.\n * Used by bitcoin for compact block relay.\n * @param {Buffer} data\n * @param {Buffer} key - 128 bit key.\n * @returns {Array} [hi, lo]\n */\n\n\nfunction siphash(data, key) {\n  return _siphash(data, key);\n}\n/**\n * Javascript siphash 2-4 implementation (32 bit ints).\n * Used by legacy cuckoo cycle.\n * @param {Number} num\n * @param {Buffer} key - 128 bit key.\n * @returns {Number}\n */\n\n\nfunction siphash32(num, key) {\n  return _siphash64(0, num, key)[1];\n}\n/**\n * Javascript siphash 2-4 implementation (64 bit ints).\n * Used by legacy cuckoo cycle.\n * @param {Number} hi\n * @param {Number} lo\n * @param {Buffer} key - 128 bit key.\n * @returns {Array} [hi, lo]\n */\n\n\nfunction siphash64(hi, lo, key) {\n  return _siphash64(hi, lo, key);\n}\n/**\n * Javascript siphash 2-4 implementation\n * (32 bit ints with a 256 bit key).\n * Used by cuckoo cycle.\n * @param {Number} num\n * @param {Buffer} key - 256 bit key.\n * @returns {Number}\n */\n\n\nfunction siphash32k256(num, key) {\n  return _siphash64k256(0, num, key)[1];\n}\n/**\n * Javascript siphash 2-4 implementation\n * (64 bit ints with a 256 bit key).\n * Used by cuckoo cycle.\n * @param {Number} hi\n * @param {Number} lo\n * @param {Buffer} key - 256 bit key.\n * @returns {Array} [hi, lo]\n */\n\n\nfunction siphash64k256(hi, lo, key) {\n  return _siphash64k256(hi, lo, key);\n}\n/**\n * Javascript siphash 2-4 implementation\n * plus 128 bit reduction by a modulus.\n * Used by the neutrino protocol.\n * @param {Buffer} data\n * @param {Buffer} key - 128 bit key.\n * @param {Number} mhi - Modulus hi bits.\n * @param {Number} mlo - Modulus lo bits.\n * @returns {Array} [hi, lo]\n */\n\n\nfunction sipmod(data, key, mhi, mlo) {\n  const [hi, lo] = _siphash(data, key);\n\n  return reduce64(hi, lo, mhi, mlo);\n}\n/**\n * U64\n * @ignore\n */\n\n\nclass U64 {\n  constructor(hi, lo) {\n    this.hi = hi | 0;\n    this.lo = lo | 0;\n  }\n\n  isum(bhi, blo) {\n    // Credit to @indutny for this method.\n    const a = this;\n    const lo = a.lo + blo | 0;\n    const s = lo >> 31;\n    const as = a.lo >> 31;\n    const bs = blo >> 31;\n    const c = (as & bs | ~s & (as ^ bs)) & 1;\n    const hi = (a.hi + bhi | 0) + c;\n    a.hi = hi | 0;\n    a.lo = lo;\n    return a;\n  }\n\n  iadd(b) {\n    return this.isum(b.hi, b.lo);\n  }\n\n  ixor(b) {\n    this.hi ^= b.hi;\n    this.lo ^= b.lo;\n    return this;\n  }\n\n  irotl(bits) {\n    let ahi = this.hi;\n    let alo = this.lo;\n    let bhi = this.hi;\n    let blo = this.lo; // a = x << b\n\n    if (bits < 32) {\n      ahi <<= bits;\n      ahi |= alo >>> 32 - bits;\n      alo <<= bits;\n    } else {\n      ahi = alo << bits - 32;\n      alo = 0;\n    }\n\n    bits = 64 - bits; // b = x >> (64 - b)\n\n    if (bits < 32) {\n      blo >>>= bits;\n      blo |= bhi << 32 - bits;\n      bhi >>>= bits;\n    } else {\n      blo = bhi >>> bits - 32;\n      bhi = 0;\n    } // a | b\n\n\n    this.hi = ahi | bhi;\n    this.lo = alo | blo;\n    return this;\n  }\n\n  static mul(alo, blo) {\n    // u32 * u32 = u64\n    const a16 = alo >>> 16;\n    const a00 = alo & 0xffff;\n    const b16 = blo >>> 16;\n    const b00 = blo & 0xffff;\n    let c48 = 0;\n    let c32 = 0;\n    let c16 = 0;\n    let c00 = 0;\n    c00 += a00 * b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xffff;\n    c16 += a16 * b00;\n    c32 += c16 >>> 16;\n    c16 &= 0xffff;\n    c16 += a00 * b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xffff;\n    c48 += c32 >>> 16;\n    c32 &= 0xffff;\n    c32 += a16 * b16;\n    c48 += c32 >>> 16;\n    c32 &= 0xffff;\n    c48 += c32 >>> 16;\n    c48 &= 0xffff;\n    const hi = c48 << 16 | c32;\n    const lo = c16 << 16 | c00;\n    return new U64(hi, lo);\n  }\n\n  static decode(data, off) {\n    const lo = readU32(data, off);\n    const hi = readU32(data, off + 4);\n    return new U64(hi, lo);\n  }\n\n}\n/*\n * Helpers\n */\n\n\nfunction sipround(v0, v1, v2, v3) {\n  v0.iadd(v1);\n  v1.irotl(13);\n  v1.ixor(v0);\n  v0.irotl(32);\n  v2.iadd(v3);\n  v3.irotl(16);\n  v3.ixor(v2);\n  v0.iadd(v3);\n  v3.irotl(21);\n  v3.ixor(v0);\n  v2.iadd(v1);\n  v1.irotl(17);\n  v1.ixor(v2);\n  v2.irotl(32);\n}\n\nfunction reduce64(ahi, alo, bhi, blo) {\n  // Compute `((uint128_t)a * b) >> 64`.\n  // Start with 4 32->64 bit multiplications.\n  const axbhi = U64.mul(ahi, bhi);\n  const axbmid = U64.mul(ahi, blo);\n  const bxamid = U64.mul(bhi, alo);\n  const axblo = U64.mul(alo, blo); // We can safely overflow in these next steps.\n  // c = (axbmid & 0xffffffff) + (bxamid & 0xffffffff) + (axblo >> 32)\n\n  const c = (axbmid.lo >>> 0) + (bxamid.lo >>> 0) + (axblo.hi >>> 0); // m = (axbmid >> 32) + (bxamid >> 32) + (c >> 32)\n\n  const m = (axbmid.hi >>> 0) + (bxamid.hi >>> 0) + (c * HI >>> 0); // axbhi + m\n\n  const {\n    hi,\n    lo\n  } = axbhi.isum(m * HI | 0, m | 0);\n  return [hi, lo];\n}\n\nfunction readU32(data, off) {\n  return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;\n}\n/*\n * Expose\n */\n\n\nexports.native = 0;\nexports.siphash = siphash;\nexports.siphash32 = siphash32;\nexports.siphash64 = siphash64;\nexports.siphash32k256 = siphash32k256;\nexports.siphash64k256 = siphash64k256;\nexports.sipmod = sipmod;","map":null,"metadata":{},"sourceType":"script"}