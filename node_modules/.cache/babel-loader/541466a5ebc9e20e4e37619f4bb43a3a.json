{"ast":null,"code":"/*!\n * keccak.js - Keccak/SHA3 implementation for bcrypto\n * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on emn178/js-sha3:\n *   Copyright (c) 2015-2017, Chen, Yi-Cyuan (MIT License).\n *   https://github.com/emn178/js-sha3\n *\n * Parts of this software are based on rhash/RHash:\n *   Copyright (c) 2005-2014, Aleksey Kravchenko\n *   https://github.com/rhash/RHash\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/SHA-3\n *   https://keccak.team/specifications.html\n *   https://csrc.nist.gov/projects/hash-functions/sha-3-project/sha-3-standardization\n *   http://dx.doi.org/10.6028/NIST.FIPS.202\n *   https://github.com/rhash/RHash/blob/master/librhash/sha3.c\n *   https://github.com/emn178/js-sha3/blob/master/src/sha3.js\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst HMAC = require('../internal/hmac');\n/*\n * Constants\n */\n\n\nconst FINALIZED = 0x80000000;\nconst ROUND_CONST = new Uint32Array([0x00000001, 0x00000000, 0x00008082, 0x00000000, 0x0000808a, 0x80000000, 0x80008000, 0x80000000, 0x0000808b, 0x00000000, 0x80000001, 0x00000000, 0x80008081, 0x80000000, 0x00008009, 0x80000000, 0x0000008a, 0x00000000, 0x00000088, 0x00000000, 0x80008009, 0x00000000, 0x8000000a, 0x00000000, 0x8000808b, 0x00000000, 0x0000008b, 0x80000000, 0x00008089, 0x80000000, 0x00008003, 0x80000000, 0x00008002, 0x80000000, 0x00000080, 0x80000000, 0x0000800a, 0x00000000, 0x8000000a, 0x80000000, 0x80008081, 0x80000000, 0x00008080, 0x80000000, 0x80000001, 0x00000000, 0x80008008, 0x80000000]);\n/**\n * Keccak\n */\n\nclass Keccak {\n  constructor() {\n    this.state = new Uint32Array(50);\n    this.block = Buffer.allocUnsafe(168);\n    this.bs = 136;\n    this.pos = FINALIZED;\n  }\n\n  init(bits) {\n    if (bits == null) bits = 256;\n    assert((bits & 0xffff) === bits);\n    assert(bits >= 128);\n    assert(bits <= 512);\n    const rate = 1600 - bits * 2;\n    assert(rate >= 0 && (rate & 63) === 0);\n    this.bs = rate / 8;\n    this.pos = 0;\n    return this;\n  }\n\n  update(data) {\n    assert(Buffer.isBuffer(data));\n    assert(!(this.pos & FINALIZED), 'Context is not initialized.');\n    let len = data.length;\n    let pos = this.pos;\n    let off = 0;\n    this.pos = (this.pos + len) % this.bs;\n\n    if (pos > 0) {\n      let want = this.bs - pos;\n      if (want > len) want = len;\n      data.copy(this.block, pos, off, off + want);\n      pos += want;\n      len -= want;\n      off += want;\n      if (pos < this.bs) return this;\n\n      this._transform(this.block, 0);\n    }\n\n    while (len >= this.bs) {\n      this._transform(data, off);\n\n      off += this.bs;\n      len -= this.bs;\n    }\n\n    if (len > 0) data.copy(this.block, 0, off, off + len);\n    return this;\n  }\n\n  final(pad, len) {\n    if (pad == null) pad = 0x01;\n    if (len == null || len === 0) len = 100 - this.bs / 2;\n    assert((pad & 0xff) === pad);\n    assert(len >>> 0 === len);\n    assert(!(this.pos & FINALIZED), 'Context is not initialized.');\n    this.block.fill(0, this.pos, this.bs);\n    this.block[this.pos] |= pad;\n    this.block[this.bs - 1] |= 0x80;\n\n    this._transform(this.block, 0);\n\n    this.pos = FINALIZED;\n    assert(len < this.bs);\n    const out = Buffer.allocUnsafe(len);\n\n    for (let i = 0; i < len; i++) out[i] = this.state[i >>> 2] >>> 8 * (i & 3);\n\n    for (let i = 0; i < 50; i++) this.state[i] = 0;\n\n    for (let i = 0; i < this.bs; i++) this.block[i] = 0;\n\n    return out;\n  }\n\n  _transform(block, off) {\n    const count = this.bs / 4;\n    const s = this.state;\n\n    for (let i = 0; i < count; i++) s[i] ^= readU32(block, off + i * 4);\n\n    for (let n = 0; n < 48; n += 2) {\n      const c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];\n      const c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];\n      const c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];\n      const c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];\n      const c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];\n      const c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];\n      const c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];\n      const c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];\n      const c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];\n      const c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];\n      const h0 = c8 ^ (c2 << 1 | c3 >>> 31);\n      const l0 = c9 ^ (c3 << 1 | c2 >>> 31);\n      const h1 = c0 ^ (c4 << 1 | c5 >>> 31);\n      const l1 = c1 ^ (c5 << 1 | c4 >>> 31);\n      const h2 = c2 ^ (c6 << 1 | c7 >>> 31);\n      const l2 = c3 ^ (c7 << 1 | c6 >>> 31);\n      const h3 = c4 ^ (c8 << 1 | c9 >>> 31);\n      const l3 = c5 ^ (c9 << 1 | c8 >>> 31);\n      const h4 = c6 ^ (c0 << 1 | c1 >>> 31);\n      const l4 = c7 ^ (c1 << 1 | c0 >>> 31);\n      s[0] ^= h0;\n      s[1] ^= l0;\n      s[10] ^= h0;\n      s[11] ^= l0;\n      s[20] ^= h0;\n      s[21] ^= l0;\n      s[30] ^= h0;\n      s[31] ^= l0;\n      s[40] ^= h0;\n      s[41] ^= l0;\n      s[2] ^= h1;\n      s[3] ^= l1;\n      s[12] ^= h1;\n      s[13] ^= l1;\n      s[22] ^= h1;\n      s[23] ^= l1;\n      s[32] ^= h1;\n      s[33] ^= l1;\n      s[42] ^= h1;\n      s[43] ^= l1;\n      s[4] ^= h2;\n      s[5] ^= l2;\n      s[14] ^= h2;\n      s[15] ^= l2;\n      s[24] ^= h2;\n      s[25] ^= l2;\n      s[34] ^= h2;\n      s[35] ^= l2;\n      s[44] ^= h2;\n      s[45] ^= l2;\n      s[6] ^= h3;\n      s[7] ^= l3;\n      s[16] ^= h3;\n      s[17] ^= l3;\n      s[26] ^= h3;\n      s[27] ^= l3;\n      s[36] ^= h3;\n      s[37] ^= l3;\n      s[46] ^= h3;\n      s[47] ^= l3;\n      s[8] ^= h4;\n      s[9] ^= l4;\n      s[18] ^= h4;\n      s[19] ^= l4;\n      s[28] ^= h4;\n      s[29] ^= l4;\n      s[38] ^= h4;\n      s[39] ^= l4;\n      s[48] ^= h4;\n      s[49] ^= l4;\n      const b0 = s[0];\n      const b1 = s[1];\n      const b32 = s[11] << 4 | s[10] >>> 28;\n      const b33 = s[10] << 4 | s[11] >>> 28;\n      const b14 = s[20] << 3 | s[21] >>> 29;\n      const b15 = s[21] << 3 | s[20] >>> 29;\n      const b46 = s[31] << 9 | s[30] >>> 23;\n      const b47 = s[30] << 9 | s[31] >>> 23;\n      const b28 = s[40] << 18 | s[41] >>> 14;\n      const b29 = s[41] << 18 | s[40] >>> 14;\n      const b20 = s[2] << 1 | s[3] >>> 31;\n      const b21 = s[3] << 1 | s[2] >>> 31;\n      const b2 = s[13] << 12 | s[12] >>> 20;\n      const b3 = s[12] << 12 | s[13] >>> 20;\n      const b34 = s[22] << 10 | s[23] >>> 22;\n      const b35 = s[23] << 10 | s[22] >>> 22;\n      const b16 = s[33] << 13 | s[32] >>> 19;\n      const b17 = s[32] << 13 | s[33] >>> 19;\n      const b48 = s[42] << 2 | s[43] >>> 30;\n      const b49 = s[43] << 2 | s[42] >>> 30;\n      const b40 = s[5] << 30 | s[4] >>> 2;\n      const b41 = s[4] << 30 | s[5] >>> 2;\n      const b22 = s[14] << 6 | s[15] >>> 26;\n      const b23 = s[15] << 6 | s[14] >>> 26;\n      const b4 = s[25] << 11 | s[24] >>> 21;\n      const b5 = s[24] << 11 | s[25] >>> 21;\n      const b36 = s[34] << 15 | s[35] >>> 17;\n      const b37 = s[35] << 15 | s[34] >>> 17;\n      const b18 = s[45] << 29 | s[44] >>> 3;\n      const b19 = s[44] << 29 | s[45] >>> 3;\n      const b10 = s[6] << 28 | s[7] >>> 4;\n      const b11 = s[7] << 28 | s[6] >>> 4;\n      const b42 = s[17] << 23 | s[16] >>> 9;\n      const b43 = s[16] << 23 | s[17] >>> 9;\n      const b24 = s[26] << 25 | s[27] >>> 7;\n      const b25 = s[27] << 25 | s[26] >>> 7;\n      const b6 = s[36] << 21 | s[37] >>> 11;\n      const b7 = s[37] << 21 | s[36] >>> 11;\n      const b38 = s[47] << 24 | s[46] >>> 8;\n      const b39 = s[46] << 24 | s[47] >>> 8;\n      const b30 = s[8] << 27 | s[9] >>> 5;\n      const b31 = s[9] << 27 | s[8] >>> 5;\n      const b12 = s[18] << 20 | s[19] >>> 12;\n      const b13 = s[19] << 20 | s[18] >>> 12;\n      const b44 = s[29] << 7 | s[28] >>> 25;\n      const b45 = s[28] << 7 | s[29] >>> 25;\n      const b26 = s[38] << 8 | s[39] >>> 24;\n      const b27 = s[39] << 8 | s[38] >>> 24;\n      const b8 = s[48] << 14 | s[49] >>> 18;\n      const b9 = s[49] << 14 | s[48] >>> 18;\n      s[0] = b0 ^ ~b2 & b4;\n      s[1] = b1 ^ ~b3 & b5;\n      s[10] = b10 ^ ~b12 & b14;\n      s[11] = b11 ^ ~b13 & b15;\n      s[20] = b20 ^ ~b22 & b24;\n      s[21] = b21 ^ ~b23 & b25;\n      s[30] = b30 ^ ~b32 & b34;\n      s[31] = b31 ^ ~b33 & b35;\n      s[40] = b40 ^ ~b42 & b44;\n      s[41] = b41 ^ ~b43 & b45;\n      s[2] = b2 ^ ~b4 & b6;\n      s[3] = b3 ^ ~b5 & b7;\n      s[12] = b12 ^ ~b14 & b16;\n      s[13] = b13 ^ ~b15 & b17;\n      s[22] = b22 ^ ~b24 & b26;\n      s[23] = b23 ^ ~b25 & b27;\n      s[32] = b32 ^ ~b34 & b36;\n      s[33] = b33 ^ ~b35 & b37;\n      s[42] = b42 ^ ~b44 & b46;\n      s[43] = b43 ^ ~b45 & b47;\n      s[4] = b4 ^ ~b6 & b8;\n      s[5] = b5 ^ ~b7 & b9;\n      s[14] = b14 ^ ~b16 & b18;\n      s[15] = b15 ^ ~b17 & b19;\n      s[24] = b24 ^ ~b26 & b28;\n      s[25] = b25 ^ ~b27 & b29;\n      s[34] = b34 ^ ~b36 & b38;\n      s[35] = b35 ^ ~b37 & b39;\n      s[44] = b44 ^ ~b46 & b48;\n      s[45] = b45 ^ ~b47 & b49;\n      s[6] = b6 ^ ~b8 & b0;\n      s[7] = b7 ^ ~b9 & b1;\n      s[16] = b16 ^ ~b18 & b10;\n      s[17] = b17 ^ ~b19 & b11;\n      s[26] = b26 ^ ~b28 & b20;\n      s[27] = b27 ^ ~b29 & b21;\n      s[36] = b36 ^ ~b38 & b30;\n      s[37] = b37 ^ ~b39 & b31;\n      s[46] = b46 ^ ~b48 & b40;\n      s[47] = b47 ^ ~b49 & b41;\n      s[8] = b8 ^ ~b0 & b2;\n      s[9] = b9 ^ ~b1 & b3;\n      s[18] = b18 ^ ~b10 & b12;\n      s[19] = b19 ^ ~b11 & b13;\n      s[28] = b28 ^ ~b20 & b22;\n      s[29] = b29 ^ ~b21 & b23;\n      s[38] = b38 ^ ~b30 & b32;\n      s[39] = b39 ^ ~b31 & b33;\n      s[48] = b48 ^ ~b40 & b42;\n      s[49] = b49 ^ ~b41 & b43;\n      s[0] ^= ROUND_CONST[n + 0];\n      s[1] ^= ROUND_CONST[n + 1];\n    }\n  }\n\n  static hash() {\n    return new Keccak();\n  }\n\n  static hmac(bits, pad, len) {\n    if (bits == null) bits = 256;\n    assert(bits >>> 0 === bits);\n    const rate = 1600 - bits * 2;\n    return new HMAC(Keccak, rate / 8, [bits], [pad, len]);\n  }\n\n  static digest(data, bits, pad, len) {\n    return Keccak.ctx.init(bits).update(data).final(pad, len);\n  }\n\n  static root(left, right, bits, pad, len) {\n    if (bits == null) bits = 256;\n    if (len == null) len = 0;\n\n    if (len === 0) {\n      assert(bits >>> 0 === bits);\n      len = bits >>> 3;\n    }\n\n    assert(len >>> 0 === len);\n    assert(Buffer.isBuffer(left) && left.length === len);\n    assert(Buffer.isBuffer(right) && right.length === len);\n    return Keccak.ctx.init(bits).update(left).update(right).final(pad, len);\n  }\n\n  static multi(x, y, z, bits, pad, len) {\n    const {\n      ctx\n    } = Keccak;\n    ctx.init(bits);\n    ctx.update(x);\n    ctx.update(y);\n    if (z) ctx.update(z);\n    return ctx.final(pad, len);\n  }\n\n  static mac(data, key, bits, pad, len) {\n    return Keccak.hmac(bits, pad, len).init(key).update(data).final();\n  }\n\n}\n/*\n * Static\n */\n\n\nKeccak.native = 0;\nKeccak.id = 'KECCAK256';\nKeccak.size = 32;\nKeccak.bits = 256;\nKeccak.blockSize = 136;\nKeccak.zero = Buffer.alloc(32, 0x00);\nKeccak.ctx = new Keccak();\n/*\n * Helpers\n */\n\nfunction readU32(data, off) {\n  return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;\n}\n/*\n * Expose\n */\n\n\nmodule.exports = Keccak;","map":null,"metadata":{},"sourceType":"script"}