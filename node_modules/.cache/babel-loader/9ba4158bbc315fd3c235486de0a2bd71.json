{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.common.reedsolomon {*/\n\nvar GenericGFPoly_1 = require(\"./GenericGFPoly\");\n\nvar Integer_1 = require(\"../../util/Integer\");\n\nvar IllegalArgumentException_1 = require(\"../../IllegalArgumentException\");\n\nvar ArithmeticException_1 = require(\"../../ArithmeticException\");\n/**\r\n * <p>This class contains utility methods for performing mathematical operations over\r\n * the Galois Fields. Operations use a given primitive polynomial in calculations.</p>\r\n *\r\n * <p>Throughout this package, elements of the GF are represented as an {@code int}\r\n * for convenience and speed (but at the cost of memory).\r\n * </p>\r\n *\r\n * @author Sean Owen\r\n * @author David Olivier\r\n */\n\n\nvar GenericGF =\n/** @class */\nfunction () {\n  /**\r\n   * Create a representation of GF(size) using the given primitive polynomial.\r\n   *\r\n   * @param primitive irreducible polynomial whose coefficients are represented by\r\n   *  the bits of an int, where the least-significant bit represents the constant\r\n   *  coefficient\r\n   * @param size the size of the field\r\n   * @param b the factor b in the generator polynomial can be 0- or 1-based\r\n   *  (g(x) = (x+a^b)(x+a^(b+1))...(x+a^(b+2t-1))).\r\n   *  In most cases it should be 1, but for QR code it is 0.\r\n   */\n  function GenericGF(primitive\n  /*int*/\n  , size\n  /*int*/\n  , generatorBase\n  /*int*/\n  ) {\n    this.primitive = primitive;\n    this.size = size;\n    this.generatorBase = generatorBase;\n    var expTable = new Int32Array(size);\n    var x = 1;\n\n    for (var i = 0; i < size; i++) {\n      expTable[i] = x;\n      x *= 2; // we're assuming the generator alpha is 2\n\n      if (x >= size) {\n        x ^= primitive;\n        x &= size - 1;\n      }\n    }\n\n    this.expTable = expTable;\n    var logTable = new Int32Array(size);\n\n    for (var i = 0; i < size - 1; i++) {\n      logTable[expTable[i]] = i;\n    }\n\n    this.logTable = logTable; // logTable[0] == 0 but this should never be used\n\n    this.zero = new GenericGFPoly_1.default(this, Int32Array.from([0]));\n    this.one = new GenericGFPoly_1.default(this, Int32Array.from([1]));\n  }\n\n  GenericGF.prototype.getZero = function () {\n    return this.zero;\n  };\n\n  GenericGF.prototype.getOne = function () {\n    return this.one;\n  };\n  /**\r\n   * @return the monomial representing coefficient * x^degree\r\n   */\n\n\n  GenericGF.prototype.buildMonomial = function (degree\n  /*int*/\n  , coefficient\n  /*int*/\n  ) {\n    if (degree < 0) {\n      throw new IllegalArgumentException_1.default();\n    }\n\n    if (coefficient === 0) {\n      return this.zero;\n    }\n\n    var coefficients = new Int32Array(degree + 1);\n    coefficients[0] = coefficient;\n    return new GenericGFPoly_1.default(this, coefficients);\n  };\n  /**\r\n   * Implements both addition and subtraction -- they are the same in GF(size).\r\n   *\r\n   * @return sum/difference of a and b\r\n   */\n\n\n  GenericGF.addOrSubtract = function (a\n  /*int*/\n  , b\n  /*int*/\n  ) {\n    return a ^ b;\n  };\n  /**\r\n   * @return 2 to the power of a in GF(size)\r\n   */\n\n\n  GenericGF.prototype.exp = function (a\n  /*int*/\n  ) {\n    return this.expTable[a];\n  };\n  /**\r\n   * @return base 2 log of a in GF(size)\r\n   */\n\n\n  GenericGF.prototype.log = function (a\n  /*int*/\n  ) {\n    if (a === 0) {\n      throw new IllegalArgumentException_1.default();\n    }\n\n    return this.logTable[a];\n  };\n  /**\r\n   * @return multiplicative inverse of a\r\n   */\n\n\n  GenericGF.prototype.inverse = function (a\n  /*int*/\n  ) {\n    if (a === 0) {\n      throw new ArithmeticException_1.default();\n    }\n\n    return this.expTable[this.size - this.logTable[a] - 1];\n  };\n  /**\r\n   * @return product of a and b in GF(size)\r\n   */\n\n\n  GenericGF.prototype.multiply = function (a\n  /*int*/\n  , b\n  /*int*/\n  ) {\n    if (a === 0 || b === 0) {\n      return 0;\n    }\n\n    return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.size - 1)];\n  };\n\n  GenericGF.prototype.getSize = function () {\n    return this.size;\n  };\n\n  GenericGF.prototype.getGeneratorBase = function () {\n    return this.generatorBase;\n  };\n  /*@Override*/\n\n\n  GenericGF.prototype.toString = function () {\n    return 'GF(0x' + Integer_1.default.toHexString(this.primitive) + ',' + this.size + ')';\n  };\n\n  GenericGF.prototype.equals = function (o) {\n    return o === this;\n  };\n\n  GenericGF.AZTEC_DATA_12 = new GenericGF(0x1069, 4096, 1); // x^12 + x^6 + x^5 + x^3 + 1\n\n  GenericGF.AZTEC_DATA_10 = new GenericGF(0x409, 1024, 1); // x^10 + x^3 + 1\n\n  GenericGF.AZTEC_DATA_6 = new GenericGF(0x43, 64, 1); // x^6 + x + 1\n\n  GenericGF.AZTEC_PARAM = new GenericGF(0x13, 16, 1); // x^4 + x + 1\n\n  GenericGF.QR_CODE_FIELD_256 = new GenericGF(0x011D, 256, 0); // x^8 + x^4 + x^3 + x^2 + 1\n\n  GenericGF.DATA_MATRIX_FIELD_256 = new GenericGF(0x012D, 256, 1); // x^8 + x^5 + x^3 + x^2 + 1\n\n  GenericGF.AZTEC_DATA_8 = GenericGF.DATA_MATRIX_FIELD_256;\n  GenericGF.MAXICODE_FIELD_64 = GenericGF.AZTEC_DATA_6;\n  return GenericGF;\n}();\n\nexports.default = GenericGF;","map":null,"metadata":{},"sourceType":"script"}