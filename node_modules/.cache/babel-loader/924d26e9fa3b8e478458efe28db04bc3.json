{"ast":null,"code":"/*!\n * stack.js - stack object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst common = require('./common');\n\nconst ScriptNum = require('./scriptnum');\n/**\n * Stack\n * Represents the stack of a Script during execution.\n * @alias module:script.Stack\n * @property {Buffer[]} items - Stack items.\n * @property {Number} length - Size of stack.\n */\n\n\nclass Stack {\n  /**\n   * Create a stack.\n   * @constructor\n   * @param {Buffer[]?} items - Stack items.\n   */\n  constructor(items) {\n    this.items = items || [];\n  } //   /**\n  //    * Get length.\n  //    * @returns {Number}\n  //    */\n  //   get length() {\n  //     return this.items.length;\n  //   }\n  //   /**\n  //    * Set length.\n  //    * @param {Number} value\n  //    */\n  //   set length(value) {\n  //     this.items.length = value;\n  //   }\n  //   /**\n  //    * Instantiate a value-only iterator.\n  //    * @returns {StackIterator}\n  //    */\n  //   [Symbol.iterator]() {\n  //     return this.items[Symbol.iterator]();\n  //   }\n  //   /**\n  //    * Instantiate a value-only iterator.\n  //    * @returns {StackIterator}\n  //    */\n  //   values() {\n  //     return this.items.values();\n  //   }\n  //   /**\n  //    * Instantiate a key and value iterator.\n  //    * @returns {StackIterator}\n  //    */\n  //   entries() {\n  //     return this.items.entries();\n  //   }\n  //   /**\n  //    * Inspect the stack.\n  //    * @returns {String} Human-readable stack.\n  //    */\n  //   inspect() {\n  //     return `<Stack: ${this.toString()}>`;\n  //   }\n  //   /**\n  //    * Convert the stack to a string.\n  //    * @returns {String} Human-readable stack.\n  //    */\n  //   toString() {\n  //     const out = [];\n  //     for (const item of this.items)\n  //       out.push(item.toString('hex'));\n  //     return out.join(' ');\n  //   }\n  //   /**\n  //    * Format the stack as bitcoind asm.\n  //    * @param {Boolean?} decode - Attempt to decode hash types.\n  //    * @returns {String} Human-readable script.\n  //    */\n  //   toASM(decode) {\n  //     const out = [];\n  //     for (const item of this.items)\n  //       out.push(common.toASM(item, decode));\n  //     return out.join(' ');\n  //   }\n  //   /**\n  //    * Clone the stack.\n  //    * @returns {Stack} Cloned stack.\n  //    */\n  //   clone() {\n  //     return new this.constructor(this.items.slice());\n  //   }\n  //   /**\n  //    * Clear the stack.\n  //    * @returns {Stack}\n  //    */\n  //   clear() {\n  //     this.items.length = 0;\n  //     return this;\n  //   }\n  //   /**\n  //    * Get a stack item by index.\n  //    * @param {Number} index\n  //    * @returns {Buffer|null}\n  //    */\n  //   get(index) {\n  //     if (index < 0)\n  //       index += this.items.length;\n  //     if (index < 0 || index >= this.items.length)\n  //       return null;\n  //     return this.items[index];\n  //   }\n  //   /**\n  //    * Pop a stack item.\n  //    * @see Array#pop\n  //    * @returns {Buffer|null}\n  //    */\n  //   pop() {\n  //     const item = this.items.pop();\n  //     return item || null;\n  //   }\n  //   /**\n  //    * Shift a stack item.\n  //    * @see Array#shift\n  //    * @returns {Buffer|null}\n  //    */\n  //   shift() {\n  //     const item = this.items.shift();\n  //     return item || null;\n  //   }\n  //   /**\n  //    * Remove an item.\n  //    * @param {Number} index\n  //    * @returns {Buffer}\n  //    */\n  //   remove(index) {\n  //     if (index < 0)\n  //       index += this.items.length;\n  //     if (index < 0 || index >= this.items.length)\n  //       return null;\n  //     const items = this.items.splice(index, 1);\n  //     if (items.length === 0)\n  //       return null;\n  //     return items[0];\n  //   }\n  //   /**\n  //    * Set stack item at index.\n  //    * @param {Number} index\n  //    * @param {Buffer} value\n  //    * @returns {Buffer}\n  //    */\n  //   set(index, item) {\n  //     if (index < 0)\n  //       index += this.items.length;\n  //     assert(Buffer.isBuffer(item));\n  //     assert(index >= 0 && index <= this.items.length);\n  //     this.items[index] = item;\n  //     return this;\n  //   }\n  //   /**\n  //    * Push item onto stack.\n  //    * @see Array#push\n  //    * @param {Buffer} item\n  //    * @returns {Number} Stack size.\n  //    */\n  //   push(item) {\n  //     assert(Buffer.isBuffer(item));\n  //     this.items.push(item);\n  //     return this;\n  //   }\n  //   /**\n  //    * Unshift item from stack.\n  //    * @see Array#unshift\n  //    * @param {Buffer} item\n  //    * @returns {Number}\n  //    */\n  //   unshift(item) {\n  //     assert(Buffer.isBuffer(item));\n  //     this.items.unshift(item);\n  //     return this;\n  //   }\n  //   /**\n  //    * Insert an item.\n  //    * @param {Number} index\n  //    * @param {Buffer} item\n  //    * @returns {Buffer}\n  //    */\n  //   insert(index, item) {\n  //     if (index < 0)\n  //       index += this.items.length;\n  //     assert(Buffer.isBuffer(item));\n  //     assert(index >= 0 && index <= this.items.length);\n  //     this.items.splice(index, 0, item);\n  //     return this;\n  //   }\n  //   /**\n  //    * Erase stack items.\n  //    * @param {Number} start\n  //    * @param {Number} end\n  //    * @returns {Buffer[]}\n  //    */\n  //   erase(start, end) {\n  //     if (start < 0)\n  //       start = this.items.length + start;\n  //     if (end < 0)\n  //       end = this.items.length + end;\n  //     this.items.splice(start, end - start);\n  //   }\n  //   /**\n  //    * Swap stack values.\n  //    * @param {Number} i1 - Index 1.\n  //    * @param {Number} i2 - Index 2.\n  //    */\n  //   swap(i1, i2) {\n  //     if (i1 < 0)\n  //       i1 = this.items.length + i1;\n  //     if (i2 < 0)\n  //       i2 = this.items.length + i2;\n  //     const v1 = this.items[i1];\n  //     const v2 = this.items[i2];\n  //     this.items[i1] = v2;\n  //     this.items[i2] = v1;\n  //   }\n  //   /*\n  //    * Data\n  //    */\n  //   getData(index) {\n  //     return this.get(index);\n  //   }\n  //   popData() {\n  //     return this.pop();\n  //   }\n  //   shiftData() {\n  //     return this.shift();\n  //   }\n  //   removeData(index) {\n  //     return this.remove(index);\n  //   }\n  //   setData(index, data) {\n  //     return this.set(index, data);\n  //   }\n  //   pushData(data) {\n  //     return this.push(data);\n  //   }\n  //   unshiftData(data) {\n  //     return this.unshift(data);\n  //   }\n  //   insertData(index, data) {\n  //     return this.insert(index, data);\n  //   }\n  //   /*\n  //    * Length\n  //    */\n  //   getLength(index) {\n  //     const item = this.get(index);\n  //     return item ? item.length : -1;\n  //   }\n  //   /*\n  //    * String\n  //    */\n  //   getString(index, enc) {\n  //     const item = this.get(index);\n  //     return item ? Stack.toString(item, enc) : null;\n  //   }\n  //   popString(enc) {\n  //     const item = this.pop();\n  //     return item ? Stack.toString(item, enc) : null;\n  //   }\n  //   shiftString(enc) {\n  //     const item = this.shift();\n  //     return item ? Stack.toString(item, enc) : null;\n  //   }\n  //   removeString(index, enc) {\n  //     const item = this.remove(index);\n  //     return item ? Stack.toString(item, enc) : null;\n  //   }\n  //   setString(index, str, enc) {\n  //     return this.set(index, Stack.fromString(str, enc));\n  //   }\n  //   pushString(str, enc) {\n  //     return this.push(Stack.fromString(str, enc));\n  //   }\n  //   unshiftString(str, enc) {\n  //     return this.unshift(Stack.fromString(str, enc));\n  //   }\n  //   insertString(index, str, enc) {\n  //     return this.insert(index, Stack.fromString(str, enc));\n  //   }\n  //   /*\n  //    * Num\n  //    */\n  //   getNum(index, minimal, limit) {\n  //     const item = this.get(index);\n  //     return item ? Stack.toNum(item, minimal, limit) : null;\n  //   }\n  //   popNum(minimal, limit) {\n  //     const item = this.pop();\n  //     return item ? Stack.toNum(item, minimal, limit) : null;\n  //   }\n  //   shiftNum(minimal, limit) {\n  //     const item = this.shift();\n  //     return item ? Stack.toNum(item, minimal, limit) : null;\n  //   }\n  //   removeNum(index, minimal, limit) {\n  //     const item = this.remove(index);\n  //     return item ? Stack.toNum(item, minimal, limit) : null;\n  //   }\n  //   setNum(index, num) {\n  //     return this.set(index, Stack.fromNum(num));\n  //   }\n  //   pushNum(num) {\n  //     return this.push(Stack.fromNum(num));\n  //   }\n  //   unshiftNum(num) {\n  //     return this.unshift(Stack.fromNum(num));\n  //   }\n  //   insertNum(index, num) {\n  //     return this.insert(index, Stack.fromNum(num));\n  //   }\n  //   /*\n  //    * Int\n  //    */\n  //   getInt(index, minimal, limit) {\n  //     const item = this.get(index);\n  //     return item ? Stack.toInt(item, minimal, limit) : -1;\n  //   }\n  //   popInt(minimal, limit) {\n  //     const item = this.pop();\n  //     return item ? Stack.toInt(item, minimal, limit) : -1;\n  //   }\n  //   shiftInt(minimal, limit) {\n  //     const item = this.shift();\n  //     return item ? Stack.toInt(item, minimal, limit) : -1;\n  //   }\n  //   removeInt(index, minimal, limit) {\n  //     const item = this.remove(index);\n  //     return item ? Stack.toInt(item, minimal, limit) : -1;\n  //   }\n  //   setInt(index, num) {\n  //     return this.set(index, Stack.fromInt(num));\n  //   }\n  //   pushInt(num) {\n  //     return this.push(Stack.fromInt(num));\n  //   }\n  //   unshiftInt(num) {\n  //     return this.unshift(Stack.fromInt(num));\n  //   }\n  //   insertInt(index, num) {\n  //     return this.insert(index, Stack.fromInt(num));\n  //   }\n  //   /*\n  //    * Bool\n  //    */\n  //   getBool(index) {\n  //     const item = this.get(index);\n  //     return item ? Stack.toBool(item) : false;\n  //   }\n  //   popBool() {\n  //     const item = this.pop();\n  //     return item ? Stack.toBool(item) : false;\n  //   }\n  //   shiftBool() {\n  //     const item = this.shift();\n  //     return item ? Stack.toBool(item) : false;\n  //   }\n  //   removeBool(index) {\n  //     const item = this.remove(index);\n  //     return item ? Stack.toBool(item) : false;\n  //   }\n  //   setBool(index, value) {\n  //     return this.set(index, Stack.fromBool(value));\n  //   }\n  //   pushBool(value) {\n  //     return this.push(Stack.fromBool(value));\n  //   }\n  //   unshiftBool(value) {\n  //     return this.unshift(Stack.fromBool(value));\n  //   }\n  //   insertBool(index, value) {\n  //     return this.insert(index, Stack.fromBool(value));\n  //   }\n  //   /**\n  //    * Test an object to see if it is a Stack.\n  //    * @param {Object} obj\n  //    * @returns {Boolean}\n  //    */\n  //   static isStack(obj) {\n  //     return obj instanceof Stack;\n  //   }\n  //   /*\n  //    * Encoding\n  //    */\n  //   static toString(item, enc) {\n  //     assert(Buffer.isBuffer(item));\n  //     return item.toString(enc || 'utf8');\n  //   }\n  //   static fromString(str, enc) {\n  //     assert(typeof str === 'string');\n  //     return Buffer.from(str, enc || 'utf8');\n  //   }\n  //   static toNum(item, minimal, limit) {\n  //     return ScriptNum.decode(item, minimal, limit);\n  //   }\n  //   static fromNum(num) {\n  //     assert(ScriptNum.isScriptNum(num));\n  //     return num.encode();\n  //   }\n  //   static toInt(item, minimal, limit) {\n  //     const num = Stack.toNum(item, minimal, limit);\n  //     return num.getInt();\n  //   }\n  //   static fromInt(int) {\n  //     assert(typeof int === 'number');\n  //     if (int >= -1 && int <= 16)\n  //       return common.small[int + 1];\n  //     const num = ScriptNum.fromNumber(int);\n  //     return Stack.fromNum(num);\n  //   }\n  //   static toBool(item) {\n  //     assert(Buffer.isBuffer(item));\n  //     for (let i = 0; i < item.length; i++) {\n  //       if (item[i] !== 0) {\n  //         // Cannot be negative zero\n  //         if (i === item.length - 1 && item[i] === 0x80)\n  //           return false;\n  //         return true;\n  //       }\n  //     }\n  //     return false;\n  //   }\n  //   static fromBool(value) {\n  //     assert(typeof value === 'boolean');\n  //     return Stack.fromInt(value ? 1 : 0);\n  //   }\n\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = Stack;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/script/stack.js"],"names":["assert","require","common","ScriptNum","Stack","constructor","items","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,OAAD,CAAtB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAME,SAAS,GAAGF,OAAO,CAAC,aAAD,CAAzB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMG,KAAN,CAAY;AACV;AACF;AACA;AACA;AACA;AAEEC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACjB,SAAKA,KAAL,GAAaA,KAAK,IAAI,EAAtB;AACD,GATS,CAWZ;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;;AAjiBY;AAoiBZ;AACA;AACA;;;AAEAC,MAAM,CAACC,OAAP,GAAiBJ,KAAjB","sourcesContent":["/*!\n * stack.js - stack object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst common = require('./common');\nconst ScriptNum = require('./scriptnum');\n\n/**\n * Stack\n * Represents the stack of a Script during execution.\n * @alias module:script.Stack\n * @property {Buffer[]} items - Stack items.\n * @property {Number} length - Size of stack.\n */\n\nclass Stack {\n  /**\n   * Create a stack.\n   * @constructor\n   * @param {Buffer[]?} items - Stack items.\n   */\n\n  constructor(items) {\n    this.items = items || [];\n  }\n\n//   /**\n//    * Get length.\n//    * @returns {Number}\n//    */\n\n//   get length() {\n//     return this.items.length;\n//   }\n\n//   /**\n//    * Set length.\n//    * @param {Number} value\n//    */\n\n//   set length(value) {\n//     this.items.length = value;\n//   }\n\n//   /**\n//    * Instantiate a value-only iterator.\n//    * @returns {StackIterator}\n//    */\n\n//   [Symbol.iterator]() {\n//     return this.items[Symbol.iterator]();\n//   }\n\n//   /**\n//    * Instantiate a value-only iterator.\n//    * @returns {StackIterator}\n//    */\n\n//   values() {\n//     return this.items.values();\n//   }\n\n//   /**\n//    * Instantiate a key and value iterator.\n//    * @returns {StackIterator}\n//    */\n\n//   entries() {\n//     return this.items.entries();\n//   }\n\n//   /**\n//    * Inspect the stack.\n//    * @returns {String} Human-readable stack.\n//    */\n\n//   inspect() {\n//     return `<Stack: ${this.toString()}>`;\n//   }\n\n//   /**\n//    * Convert the stack to a string.\n//    * @returns {String} Human-readable stack.\n//    */\n\n//   toString() {\n//     const out = [];\n\n//     for (const item of this.items)\n//       out.push(item.toString('hex'));\n\n//     return out.join(' ');\n//   }\n\n//   /**\n//    * Format the stack as bitcoind asm.\n//    * @param {Boolean?} decode - Attempt to decode hash types.\n//    * @returns {String} Human-readable script.\n//    */\n\n//   toASM(decode) {\n//     const out = [];\n\n//     for (const item of this.items)\n//       out.push(common.toASM(item, decode));\n\n//     return out.join(' ');\n//   }\n\n//   /**\n//    * Clone the stack.\n//    * @returns {Stack} Cloned stack.\n//    */\n\n//   clone() {\n//     return new this.constructor(this.items.slice());\n//   }\n\n//   /**\n//    * Clear the stack.\n//    * @returns {Stack}\n//    */\n\n//   clear() {\n//     this.items.length = 0;\n//     return this;\n//   }\n\n//   /**\n//    * Get a stack item by index.\n//    * @param {Number} index\n//    * @returns {Buffer|null}\n//    */\n\n//   get(index) {\n//     if (index < 0)\n//       index += this.items.length;\n\n//     if (index < 0 || index >= this.items.length)\n//       return null;\n\n//     return this.items[index];\n//   }\n\n//   /**\n//    * Pop a stack item.\n//    * @see Array#pop\n//    * @returns {Buffer|null}\n//    */\n\n//   pop() {\n//     const item = this.items.pop();\n//     return item || null;\n//   }\n\n//   /**\n//    * Shift a stack item.\n//    * @see Array#shift\n//    * @returns {Buffer|null}\n//    */\n\n//   shift() {\n//     const item = this.items.shift();\n//     return item || null;\n//   }\n\n//   /**\n//    * Remove an item.\n//    * @param {Number} index\n//    * @returns {Buffer}\n//    */\n\n//   remove(index) {\n//     if (index < 0)\n//       index += this.items.length;\n\n//     if (index < 0 || index >= this.items.length)\n//       return null;\n\n//     const items = this.items.splice(index, 1);\n\n//     if (items.length === 0)\n//       return null;\n\n//     return items[0];\n//   }\n\n//   /**\n//    * Set stack item at index.\n//    * @param {Number} index\n//    * @param {Buffer} value\n//    * @returns {Buffer}\n//    */\n\n//   set(index, item) {\n//     if (index < 0)\n//       index += this.items.length;\n\n//     assert(Buffer.isBuffer(item));\n//     assert(index >= 0 && index <= this.items.length);\n\n//     this.items[index] = item;\n\n//     return this;\n//   }\n\n//   /**\n//    * Push item onto stack.\n//    * @see Array#push\n//    * @param {Buffer} item\n//    * @returns {Number} Stack size.\n//    */\n\n//   push(item) {\n//     assert(Buffer.isBuffer(item));\n//     this.items.push(item);\n//     return this;\n//   }\n\n//   /**\n//    * Unshift item from stack.\n//    * @see Array#unshift\n//    * @param {Buffer} item\n//    * @returns {Number}\n//    */\n\n//   unshift(item) {\n//     assert(Buffer.isBuffer(item));\n//     this.items.unshift(item);\n//     return this;\n//   }\n\n//   /**\n//    * Insert an item.\n//    * @param {Number} index\n//    * @param {Buffer} item\n//    * @returns {Buffer}\n//    */\n\n//   insert(index, item) {\n//     if (index < 0)\n//       index += this.items.length;\n\n//     assert(Buffer.isBuffer(item));\n//     assert(index >= 0 && index <= this.items.length);\n\n//     this.items.splice(index, 0, item);\n\n//     return this;\n//   }\n\n//   /**\n//    * Erase stack items.\n//    * @param {Number} start\n//    * @param {Number} end\n//    * @returns {Buffer[]}\n//    */\n\n//   erase(start, end) {\n//     if (start < 0)\n//       start = this.items.length + start;\n\n//     if (end < 0)\n//       end = this.items.length + end;\n\n//     this.items.splice(start, end - start);\n//   }\n\n//   /**\n//    * Swap stack values.\n//    * @param {Number} i1 - Index 1.\n//    * @param {Number} i2 - Index 2.\n//    */\n\n//   swap(i1, i2) {\n//     if (i1 < 0)\n//       i1 = this.items.length + i1;\n\n//     if (i2 < 0)\n//       i2 = this.items.length + i2;\n\n//     const v1 = this.items[i1];\n//     const v2 = this.items[i2];\n\n//     this.items[i1] = v2;\n//     this.items[i2] = v1;\n//   }\n\n//   /*\n//    * Data\n//    */\n\n//   getData(index) {\n//     return this.get(index);\n//   }\n\n//   popData() {\n//     return this.pop();\n//   }\n\n//   shiftData() {\n//     return this.shift();\n//   }\n\n//   removeData(index) {\n//     return this.remove(index);\n//   }\n\n//   setData(index, data) {\n//     return this.set(index, data);\n//   }\n\n//   pushData(data) {\n//     return this.push(data);\n//   }\n\n//   unshiftData(data) {\n//     return this.unshift(data);\n//   }\n\n//   insertData(index, data) {\n//     return this.insert(index, data);\n//   }\n\n//   /*\n//    * Length\n//    */\n\n//   getLength(index) {\n//     const item = this.get(index);\n//     return item ? item.length : -1;\n//   }\n\n//   /*\n//    * String\n//    */\n\n//   getString(index, enc) {\n//     const item = this.get(index);\n//     return item ? Stack.toString(item, enc) : null;\n//   }\n\n//   popString(enc) {\n//     const item = this.pop();\n//     return item ? Stack.toString(item, enc) : null;\n//   }\n\n//   shiftString(enc) {\n//     const item = this.shift();\n//     return item ? Stack.toString(item, enc) : null;\n//   }\n\n//   removeString(index, enc) {\n//     const item = this.remove(index);\n//     return item ? Stack.toString(item, enc) : null;\n//   }\n\n//   setString(index, str, enc) {\n//     return this.set(index, Stack.fromString(str, enc));\n//   }\n\n//   pushString(str, enc) {\n//     return this.push(Stack.fromString(str, enc));\n//   }\n\n//   unshiftString(str, enc) {\n//     return this.unshift(Stack.fromString(str, enc));\n//   }\n\n//   insertString(index, str, enc) {\n//     return this.insert(index, Stack.fromString(str, enc));\n//   }\n\n//   /*\n//    * Num\n//    */\n\n//   getNum(index, minimal, limit) {\n//     const item = this.get(index);\n//     return item ? Stack.toNum(item, minimal, limit) : null;\n//   }\n\n//   popNum(minimal, limit) {\n//     const item = this.pop();\n//     return item ? Stack.toNum(item, minimal, limit) : null;\n//   }\n\n//   shiftNum(minimal, limit) {\n//     const item = this.shift();\n//     return item ? Stack.toNum(item, minimal, limit) : null;\n//   }\n\n//   removeNum(index, minimal, limit) {\n//     const item = this.remove(index);\n//     return item ? Stack.toNum(item, minimal, limit) : null;\n//   }\n\n//   setNum(index, num) {\n//     return this.set(index, Stack.fromNum(num));\n//   }\n\n//   pushNum(num) {\n//     return this.push(Stack.fromNum(num));\n//   }\n\n//   unshiftNum(num) {\n//     return this.unshift(Stack.fromNum(num));\n//   }\n\n//   insertNum(index, num) {\n//     return this.insert(index, Stack.fromNum(num));\n//   }\n\n//   /*\n//    * Int\n//    */\n\n//   getInt(index, minimal, limit) {\n//     const item = this.get(index);\n//     return item ? Stack.toInt(item, minimal, limit) : -1;\n//   }\n\n//   popInt(minimal, limit) {\n//     const item = this.pop();\n//     return item ? Stack.toInt(item, minimal, limit) : -1;\n//   }\n\n//   shiftInt(minimal, limit) {\n//     const item = this.shift();\n//     return item ? Stack.toInt(item, minimal, limit) : -1;\n//   }\n\n//   removeInt(index, minimal, limit) {\n//     const item = this.remove(index);\n//     return item ? Stack.toInt(item, minimal, limit) : -1;\n//   }\n\n//   setInt(index, num) {\n//     return this.set(index, Stack.fromInt(num));\n//   }\n\n//   pushInt(num) {\n//     return this.push(Stack.fromInt(num));\n//   }\n\n//   unshiftInt(num) {\n//     return this.unshift(Stack.fromInt(num));\n//   }\n\n//   insertInt(index, num) {\n//     return this.insert(index, Stack.fromInt(num));\n//   }\n\n//   /*\n//    * Bool\n//    */\n\n//   getBool(index) {\n//     const item = this.get(index);\n//     return item ? Stack.toBool(item) : false;\n//   }\n\n//   popBool() {\n//     const item = this.pop();\n//     return item ? Stack.toBool(item) : false;\n//   }\n\n//   shiftBool() {\n//     const item = this.shift();\n//     return item ? Stack.toBool(item) : false;\n//   }\n\n//   removeBool(index) {\n//     const item = this.remove(index);\n//     return item ? Stack.toBool(item) : false;\n//   }\n\n//   setBool(index, value) {\n//     return this.set(index, Stack.fromBool(value));\n//   }\n\n//   pushBool(value) {\n//     return this.push(Stack.fromBool(value));\n//   }\n\n//   unshiftBool(value) {\n//     return this.unshift(Stack.fromBool(value));\n//   }\n\n//   insertBool(index, value) {\n//     return this.insert(index, Stack.fromBool(value));\n//   }\n\n//   /**\n//    * Test an object to see if it is a Stack.\n//    * @param {Object} obj\n//    * @returns {Boolean}\n//    */\n\n//   static isStack(obj) {\n//     return obj instanceof Stack;\n//   }\n\n//   /*\n//    * Encoding\n//    */\n\n//   static toString(item, enc) {\n//     assert(Buffer.isBuffer(item));\n//     return item.toString(enc || 'utf8');\n//   }\n\n//   static fromString(str, enc) {\n//     assert(typeof str === 'string');\n//     return Buffer.from(str, enc || 'utf8');\n//   }\n\n//   static toNum(item, minimal, limit) {\n//     return ScriptNum.decode(item, minimal, limit);\n//   }\n\n//   static fromNum(num) {\n//     assert(ScriptNum.isScriptNum(num));\n//     return num.encode();\n//   }\n\n//   static toInt(item, minimal, limit) {\n//     const num = Stack.toNum(item, minimal, limit);\n//     return num.getInt();\n//   }\n\n//   static fromInt(int) {\n//     assert(typeof int === 'number');\n\n//     if (int >= -1 && int <= 16)\n//       return common.small[int + 1];\n\n//     const num = ScriptNum.fromNumber(int);\n\n//     return Stack.fromNum(num);\n//   }\n\n//   static toBool(item) {\n//     assert(Buffer.isBuffer(item));\n\n//     for (let i = 0; i < item.length; i++) {\n//       if (item[i] !== 0) {\n//         // Cannot be negative zero\n//         if (i === item.length - 1 && item[i] === 0x80)\n//           return false;\n//         return true;\n//       }\n//     }\n\n//     return false;\n//   }\n\n//   static fromBool(value) {\n//     assert(typeof value === 'boolean');\n//     return Stack.fromInt(value ? 1 : 0);\n//   }\n}\n\n/*\n * Expose\n */\n\nmodule.exports = Stack;\n"]},"metadata":{},"sourceType":"module"}