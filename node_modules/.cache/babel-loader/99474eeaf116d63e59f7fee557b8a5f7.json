{"ast":null,"code":"/*!\n * blake2s.js - BLAKE2s implementation for bcrypto\n * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on dcposch/blakejs:\n *   Daniel Clemens Posch (CC0)\n *   https://github.com/dcposch/blakejs/blob/master/blake2s.js\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/BLAKE_(hash_function)\n *   https://tools.ietf.org/html/rfc7693\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst HMAC = require('../internal/hmac');\n/*\n * Constants\n */\n\n\nconst FINALIZED = 0x80000000;\nconst IV = new Uint32Array([0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]);\nconst SIGMA = new Uint8Array([0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x0e, 0x0a, 0x04, 0x08, 0x09, 0x0f, 0x0d, 0x06, 0x01, 0x0c, 0x00, 0x02, 0x0b, 0x07, 0x05, 0x03, 0x0b, 0x08, 0x0c, 0x00, 0x05, 0x02, 0x0f, 0x0d, 0x0a, 0x0e, 0x03, 0x06, 0x07, 0x01, 0x09, 0x04, 0x07, 0x09, 0x03, 0x01, 0x0d, 0x0c, 0x0b, 0x0e, 0x02, 0x06, 0x05, 0x0a, 0x04, 0x00, 0x0f, 0x08, 0x09, 0x00, 0x05, 0x07, 0x02, 0x04, 0x0a, 0x0f, 0x0e, 0x01, 0x0b, 0x0c, 0x06, 0x08, 0x03, 0x0d, 0x02, 0x0c, 0x06, 0x0a, 0x00, 0x0b, 0x08, 0x03, 0x04, 0x0d, 0x07, 0x05, 0x0f, 0x0e, 0x01, 0x09, 0x0c, 0x05, 0x01, 0x0f, 0x0e, 0x0d, 0x04, 0x0a, 0x00, 0x07, 0x06, 0x03, 0x09, 0x02, 0x08, 0x0b, 0x0d, 0x0b, 0x07, 0x0e, 0x0c, 0x01, 0x03, 0x09, 0x05, 0x00, 0x0f, 0x04, 0x08, 0x06, 0x02, 0x0a, 0x06, 0x0f, 0x0e, 0x09, 0x0b, 0x03, 0x00, 0x08, 0x0c, 0x02, 0x0d, 0x07, 0x01, 0x04, 0x0a, 0x05, 0x0a, 0x02, 0x08, 0x04, 0x07, 0x06, 0x01, 0x05, 0x0f, 0x0b, 0x09, 0x0e, 0x03, 0x0c, 0x0d, 0x00]);\n/**\n * BLAKE2s\n */\n\nclass BLAKE2s {\n  constructor() {\n    this.state = new Uint32Array(8);\n    this.V = new Uint32Array(16);\n    this.M = new Uint32Array(16);\n    this.block = Buffer.allocUnsafe(64);\n    this.size = 32;\n    this.count = 0;\n    this.pos = FINALIZED;\n  }\n\n  init(size, key) {\n    if (size == null) size = 32;\n    assert(size >>> 0 === size);\n    assert(key == null || Buffer.isBuffer(key));\n    if (size === 0 || size > 32) throw new Error('Bad output length.');\n    if (key && key.length > 32) throw new Error('Bad key length.');\n    const klen = key ? key.length : 0;\n\n    for (let i = 0; i < 8; i++) this.state[i] = IV[i];\n\n    this.size = size;\n    this.count = 0;\n    this.pos = 0;\n    this.state[0] ^= 0x01010000 ^ klen << 8 ^ this.size;\n\n    if (klen > 0) {\n      const block = Buffer.alloc(64, 0x00);\n      key.copy(block, 0);\n      this.update(block);\n    }\n\n    return this;\n  }\n\n  update(data) {\n    assert(Buffer.isBuffer(data));\n    assert(!(this.pos & FINALIZED), 'Context is not initialized.');\n    let off = 0;\n    let len = data.length;\n\n    if (len > 0) {\n      const left = this.pos;\n      const fill = 64 - left;\n\n      if (len > fill) {\n        this.pos = 0;\n        data.copy(this.block, left, off, off + fill);\n        this.count += 64;\n\n        this._compress(this.block, 0, false);\n\n        off += fill;\n        len -= fill;\n\n        while (len > 64) {\n          this.count += 64;\n\n          this._compress(data, off, false);\n\n          off += 64;\n          len -= 64;\n        }\n      }\n\n      data.copy(this.block, this.pos, off, off + len);\n      this.pos += len;\n    }\n\n    return this;\n  }\n\n  final() {\n    assert(!(this.pos & FINALIZED), 'Context is not initialized.');\n    this.count += this.pos;\n    this.block.fill(0, this.pos, 64);\n\n    this._compress(this.block, 0, true);\n\n    this.pos = FINALIZED;\n    const out = Buffer.allocUnsafe(this.size);\n\n    for (let i = 0; i < this.size; i++) out[i] = this.state[i >>> 2] >>> 8 * (i & 3);\n\n    for (let i = 0; i < 8; i++) this.state[i] = 0;\n\n    for (let i = 0; i < 16; i++) {\n      this.V[i] = 0;\n      this.M[i] = 0;\n    }\n\n    for (let i = 0; i < 64; i++) this.block[i] = 0;\n\n    return out;\n  }\n\n  _compress(block, off, last) {\n    const {\n      V,\n      M\n    } = this;\n\n    for (let i = 0; i < 8; i++) {\n      V[i] = this.state[i];\n      V[i + 8] = IV[i];\n    } // uint64\n\n\n    V[12] ^= this.count;\n    V[13] ^= this.count * (1 / 0x100000000);\n\n    if (last) {\n      // last block\n      V[14] ^= -1; // last node\n\n      V[15] ^= 0;\n    }\n\n    for (let i = 0; i < 16; i++) {\n      M[i] = readU32(block, off);\n      off += 4;\n    }\n\n    for (let i = 0; i < 10; i++) {\n      G(V, M, 0, 4, 8, 12, SIGMA[i * 16 + 0], SIGMA[i * 16 + 1]);\n      G(V, M, 1, 5, 9, 13, SIGMA[i * 16 + 2], SIGMA[i * 16 + 3]);\n      G(V, M, 2, 6, 10, 14, SIGMA[i * 16 + 4], SIGMA[i * 16 + 5]);\n      G(V, M, 3, 7, 11, 15, SIGMA[i * 16 + 6], SIGMA[i * 16 + 7]);\n      G(V, M, 0, 5, 10, 15, SIGMA[i * 16 + 8], SIGMA[i * 16 + 9]);\n      G(V, M, 1, 6, 11, 12, SIGMA[i * 16 + 10], SIGMA[i * 16 + 11]);\n      G(V, M, 2, 7, 8, 13, SIGMA[i * 16 + 12], SIGMA[i * 16 + 13]);\n      G(V, M, 3, 4, 9, 14, SIGMA[i * 16 + 14], SIGMA[i * 16 + 15]);\n    }\n\n    for (let i = 0; i < 8; i++) this.state[i] ^= V[i] ^ V[i + 8];\n  }\n\n  static hash() {\n    return new BLAKE2s();\n  }\n\n  static hmac(size) {\n    return new HMAC(BLAKE2s, 64, [size]);\n  }\n\n  static digest(data, size, key) {\n    const {\n      ctx\n    } = BLAKE2s;\n    ctx.init(size, key);\n    ctx.update(data);\n    return ctx.final();\n  }\n\n  static root(left, right, size, key) {\n    if (size == null) size = 32;\n    assert(Buffer.isBuffer(left) && left.length === size);\n    assert(Buffer.isBuffer(right) && right.length === size);\n    const {\n      ctx\n    } = BLAKE2s;\n    ctx.init(size, key);\n    ctx.update(left);\n    ctx.update(right);\n    return ctx.final();\n  }\n\n  static multi(x, y, z, size, key) {\n    const {\n      ctx\n    } = BLAKE2s;\n    ctx.init(size, key);\n    ctx.update(x);\n    ctx.update(y);\n    if (z) ctx.update(z);\n    return ctx.final();\n  }\n\n  static mac(data, key, size) {\n    return BLAKE2s.hmac(size).init(key).update(data).final();\n  }\n\n}\n/*\n * Static\n */\n\n\nBLAKE2s.native = 0;\nBLAKE2s.id = 'BLAKE2S256';\nBLAKE2s.size = 32;\nBLAKE2s.bits = 256;\nBLAKE2s.blockSize = 64;\nBLAKE2s.zero = Buffer.alloc(32, 0x00);\nBLAKE2s.ctx = new BLAKE2s();\n/*\n * Helpers\n */\n\nfunction rotr32(x, y) {\n  return x >>> y ^ x << 32 - y;\n}\n\nfunction G(v, m, a, b, c, d, ix, iy) {\n  const x = m[ix];\n  const y = m[iy];\n  v[a] = v[a] + v[b] + x;\n  v[d] = rotr32(v[d] ^ v[a], 16);\n  v[c] = v[c] + v[d];\n  v[b] = rotr32(v[b] ^ v[c], 12);\n  v[a] = v[a] + v[b] + y;\n  v[d] = rotr32(v[d] ^ v[a], 8);\n  v[c] = v[c] + v[d];\n  v[b] = rotr32(v[b] ^ v[c], 7);\n}\n\nfunction readU32(data, off) {\n  return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;\n}\n/*\n * Expose\n */\n\n\nmodule.exports = BLAKE2s;","map":null,"metadata":{},"sourceType":"script"}