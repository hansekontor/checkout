{"ast":null,"code":"/*!\n * base16.js - base16 for javascript\n * Copyright (c) 2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://tools.ietf.org/html/rfc4648\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst isBrowser = Buffer.alloc(0)._isBuffer === true;\n/*\n * Base16\n */\n\nfunction encode(data, size) {\n  assert(Buffer.isBuffer(data));\n  assert(size == null || size >>> 0 === size);\n  let str = data.toString('hex');\n\n  if (size != null) {\n    size *= 2;\n    if (str.length > size) throw new RangeError('Data length exceeds requested size.');\n\n    while (str.length < size) str = '00' + str;\n  }\n\n  return str;\n}\n\nfunction encodeLE(data, size) {\n  const str = encode(data, size);\n  let out = '';\n\n  for (let i = str.length - 2; i >= 0; i -= 2) out += str[i] + str[i + 1];\n\n  return out;\n}\n\nfunction decode(str, size) {\n  assert(typeof str === 'string');\n  assert(size == null || size >>> 0 === size);\n  if (str.length & 1) throw new Error('Invalid hex string.');\n  if (size != null && str.length !== size * 2) throw new RangeError('String length differs from expected size.');\n  const data = Buffer.from(str, 'hex');\n  if (str.length !== data.length * 2) throw new Error('Invalid hex string.');\n\n  if (isBrowser && data.length > 0) {\n    // Browserify may parse hex as:\n    //\n    //   parseInt(str.substring(i, i + 2), 16)\n    //\n    // This causes problems with error cases.\n    //\n    // For example:\n    //\n    //   parseInt('6x', 16) === 6\n    //\n    // This means our final byte with an\n    // invalid character will be `06` and\n    // it does not affect the length of\n    // the buffer. We can check for this\n    // below.\n    //\n    // This differs from node. Node will\n    // discard the entire byte regardless\n    // of which character is invalid.\n    //\n    // https://github.com/nodejs/node/blob/524dd46/src/string_bytes.cc#L247\n    // https://github.com/feross/buffer/blob/b651e3a/index.js#L806\n    if (data[data.length - 1] >>> 4 === 0) {\n      if (!/[0-9a-f]$/i.test(str)) throw new Error('Invalid hex string.');\n    }\n  }\n\n  return data;\n}\n\nfunction decodeLE(str, size) {\n  const data = decode(str, size);\n\n  for (let i = data.length - 1, j = 0; i > j; i--, j++) [data[i], data[j]] = [data[j], data[i]];\n\n  return data;\n}\n\nfunction test(str, size) {\n  assert(typeof str === 'string');\n  assert(size == null || size >>> 0 === size); // Note: We cannot use byteLength to validate since the\n  // calculation is a simple division by 2 without parsing.\n  //\n  // https://github.com/nodejs/node/blob/524dd46/lib/buffer.js#L540\n  // https://github.com/feross/buffer/blob/b651e3a/index.js#L415\n\n  if (str.length & 1) return false;\n  if (size != null && str.length !== size * 2) return false;\n  return /^[0-9a-f]*$/i.test(str);\n}\n/*\n * Expose\n */\n\n\nexports.encode = encode;\nexports.encodeLE = encodeLE;\nexports.decode = decode;\nexports.decodeLE = decodeLE;\nexports.test = test;","map":null,"metadata":{},"sourceType":"script"}