{"ast":null,"code":"/*!\n * ssh.js - SSH keys for javascript\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://github.com/openssh/openssh-portable/blob/master/cipher.c\n *   https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.key\n */\n\n/* eslint no-prototype-builtins: \"off\" */\n'use strict';\n\nconst assert = require('./internal/assert');\n\nconst bio = require('bufio');\n\nconst base64 = require('./encoding/base64');\n\nconst {\n  padLeft,\n  padRight\n} = require('./encoding/util');\n\nconst bcrypt = require('./bcrypt');\n\nconst cipher = require('./cipher');\n\nconst random = require('./random');\n\nconst openssl = require('./encoding/openssl');\n\nconst {\n  PEMBlock\n} = require('./encoding/pem');\n\nconst pemcrypt = require('./encoding/pemcrypt');\n\nconst pkcs1 = require('./encoding/pkcs1');\n\nconst sec1 = require('./encoding/sec1');\n\nconst p256 = require('./p256');\n\nconst p384 = require('./p384');\n\nconst p521 = require('./p521');\n\nconst ed25519 = require('./ed25519');\n\nconst BN = require('./bn');\n/*\n * Constants\n */\n\n\nconst keyTypes = {\n  DSA: 'ssh-dss',\n  RSA: 'ssh-rsa',\n  P256: 'ecdsa-sha2-nistp256',\n  P384: 'ecdsa-sha2-nistp384',\n  P521: 'ecdsa-sha2-nistp521',\n  ED25519: 'ssh-ed25519'\n};\nconst keyTypesByVal = {\n  [keyTypes.DSA]: 'DSA',\n  [keyTypes.RSA]: 'RSA',\n  [keyTypes.P256]: 'P256',\n  [keyTypes.P384]: 'P384',\n  [keyTypes.P521]: 'P521',\n  [keyTypes.ED25519]: 'ED25519'\n};\nconst typeToCurve = {\n  [keyTypes.P256]: 'nistp256',\n  [keyTypes.P384]: 'nistp384',\n  [keyTypes.P521]: 'nistp521'\n};\nconst cipherToName = {\n  '3des-cbc': 'DES-EDE3-CBC',\n  'aes128-cbc': 'AES-128-CBC',\n  'aes192-cbc': 'AES-192-CBC',\n  'aes256-cbc': 'AES-256-CBC',\n  'rijndael-cbc@lysator.liu.se': 'AES-256-CBC',\n  'aes128-ctr': 'AES-128-CTR',\n  'aes192-ctr': 'AES-192-CTR',\n  'aes256-ctr': 'AES-256-CTR'\n};\nconst AUTH_MAGIC = 'openssh-key-v1';\nconst EMPTY = Buffer.alloc(0);\nconst ZERO32 = Buffer.alloc(32, 0x00);\n/**\n * SSHPublicKey\n */\n\nclass SSHPublicKey extends bio.Struct {\n  constructor() {\n    super();\n    this.type = keyTypes.ED25519; // DSA\n\n    this.p = EMPTY;\n    this.q = EMPTY;\n    this.g = EMPTY;\n    this.y = EMPTY; // RSA\n\n    this.n = EMPTY;\n    this.e = EMPTY; // ECDSA / EDDSA\n\n    this.point = ZERO32; // Comment\n\n    this.comment = '';\n  }\n\n  getCurve() {\n    if (!typeToCurve.hasOwnProperty(this.type)) throw new Error('No curve available.');\n    return typeToCurve[this.type];\n  }\n\n  getSize() {\n    let size = 0;\n    size += sizeString(this.type);\n\n    switch (this.type) {\n      case keyTypes.DSA:\n        {\n          size += sizeBytes(this.p);\n          size += sizeBytes(this.q);\n          size += sizeBytes(this.g);\n          size += sizeBytes(this.y);\n          break;\n        }\n\n      case keyTypes.RSA:\n        {\n          size += sizeBytes(this.e);\n          size += sizeBytes(this.n);\n          break;\n        }\n\n      case keyTypes.P256:\n      case keyTypes.P384:\n      case keyTypes.P521:\n        {\n          size += sizeBytes(this.getCurve());\n          size += sizeBytes(this.point);\n          break;\n        }\n\n      case keyTypes.ED25519:\n        {\n          size += sizeBytes(this.point);\n          break;\n        }\n\n      default:\n        {\n          throw new assert.AssertionError('Invalid key.');\n        }\n    }\n\n    return size;\n  }\n\n  write(bw) {\n    writeString(bw, this.type);\n\n    switch (this.type) {\n      case keyTypes.DSA:\n        {\n          writeBytes(bw, this.p);\n          writeBytes(bw, this.q);\n          writeBytes(bw, this.g);\n          writeBytes(bw, this.y);\n          break;\n        }\n\n      case keyTypes.RSA:\n        {\n          writeBytes(bw, this.e);\n          writeBytes(bw, this.n);\n          break;\n        }\n\n      case keyTypes.P256:\n      case keyTypes.P384:\n      case keyTypes.P521:\n        {\n          writeString(bw, this.getCurve());\n          writeBytes(bw, this.point);\n          break;\n        }\n\n      case keyTypes.ED25519:\n        {\n          writeBytes(bw, this.point);\n          break;\n        }\n\n      default:\n        {\n          throw new assert.AssertionError('Invalid key.');\n        }\n    }\n\n    return bw;\n  }\n\n  read(br) {\n    this.type = readString(br);\n\n    switch (this.type) {\n      case keyTypes.DSA:\n        {\n          this.p = readBytes(br);\n          this.q = readBytes(br);\n          this.g = readBytes(br);\n          this.y = readBytes(br);\n          break;\n        }\n\n      case keyTypes.RSA:\n        {\n          this.e = readBytes(br);\n          this.n = readBytes(br);\n          break;\n        }\n\n      case keyTypes.P256:\n      case keyTypes.P384:\n      case keyTypes.P521:\n        {\n          if (readString(br) !== this.getCurve()) throw new Error('Invalid curve prefix.');\n          this.point = readBytes(br);\n          break;\n        }\n\n      case keyTypes.ED25519:\n        {\n          this.point = readBytes(br);\n          break;\n        }\n\n      default:\n        {\n          throw new Error('Invalid key type.');\n        }\n    }\n\n    return this;\n  }\n\n  toString() {\n    const raw = this.encode();\n    let comment = this.comment;\n    if (comment.length > 0) comment = ' ' + comment;\n    return `${this.type} ${base64.encode(raw)}${comment}`;\n  }\n\n  fromString(str) {\n    assert(typeof str === 'string');\n    const parts = str.split(' ', 3);\n    if (parts.length < 2) throw new Error('Invalid SSH key text.');\n    const [type, rest] = parts;\n    if (!keyTypesByVal.hasOwnProperty(type)) throw new Error(`Unknown SSH public key type: ${type}.`);\n    const data = base64.decode(rest);\n    this.decode(data);\n    if (this.type !== type) throw new Error('Key type mismatch.');\n    if (parts.length > 2) this.comment = parts[2].trim();\n    return this;\n  }\n\n  format() {\n    switch (this.type) {\n      case keyTypes.DSA:\n        {\n          return {\n            type: this.type,\n            p: this.p.toString('hex'),\n            q: this.q.toString('hex'),\n            g: this.g.toString('hex'),\n            y: this.y.toString('hex'),\n            comment: this.comment\n          };\n        }\n\n      case keyTypes.RSA:\n        {\n          return {\n            type: this.type,\n            n: this.n.toString('hex'),\n            e: this.e.toString('hex'),\n            comment: this.comment\n          };\n        }\n\n      case keyTypes.P256:\n      case keyTypes.P384:\n      case keyTypes.P521:\n      case keyTypes.ED25519:\n        {\n          return {\n            type: this.type,\n            point: this.point.toString('hex'),\n            comment: this.comment\n          };\n        }\n\n      default:\n        {\n          return this;\n        }\n    }\n  }\n\n}\n/**\n * SSHPrivateKey\n */\n\n\nclass SSHPrivateKey extends bio.Struct {\n  constructor() {\n    super();\n    this.type = keyTypes.ED25519; // DSA\n\n    this.p = EMPTY;\n    this.q = EMPTY;\n    this.g = EMPTY;\n    this.y = EMPTY;\n    this.x = EMPTY; // RSA\n\n    this.n = EMPTY;\n    this.e = EMPTY;\n    this.d = EMPTY;\n    this.p = EMPTY;\n    this.q = EMPTY;\n    this.dp = EMPTY;\n    this.dq = EMPTY;\n    this.qi = EMPTY; // ECDSA / EDDSA\n\n    this.key = ZERO32; // Comment\n\n    this.comment = '';\n    this.modern = false;\n  }\n\n  getCurve() {\n    if (!typeToCurve.hasOwnProperty(this.type)) throw new Error('No curve available.');\n    return typeToCurve[this.type];\n  }\n\n  encodeSSH(passwd) {\n    assert(passwd == null || typeof passwd === 'string');\n    const kdf = new KDFOptions();\n    const pub = new SSHPublicKey();\n    const priv = new RawPrivateKey();\n    const bw = bio.write(8192);\n    bw.writeString(AUTH_MAGIC);\n    bw.writeU8(0);\n\n    if (passwd != null) {\n      kdf.name = 'bcrypt';\n      kdf.salt = random.randomBytes(16);\n      kdf.rounds = 16;\n      writeString(bw, 'aes256-ctr');\n    } else {\n      writeString(bw, 'none');\n    }\n\n    kdf.write(bw);\n    writeInt(bw, 1);\n    pub.type = this.type;\n    writeBytes(bw, pub.encode());\n    priv.type = this.type;\n\n    switch (this.type) {\n      case keyTypes.DSA:\n        {\n          priv.p = this.p;\n          priv.q = this.q;\n          priv.g = this.g;\n          priv.y = this.y;\n          priv.x = this.x;\n          break;\n        }\n\n      case keyTypes.RSA:\n        {\n          priv.n = this.n;\n          priv.e = this.e;\n          priv.d = this.d;\n          priv.p = this.p;\n          priv.q = this.q;\n          priv.qi = this.qi;\n          break;\n        }\n\n      case keyTypes.P256:\n        {\n          priv.point = p256.publicKeyCreate(this.key, false);\n          priv.key = this.key;\n          break;\n        }\n\n      case keyTypes.P384:\n        {\n          priv.point = p384.publicKeyCreate(this.key, false);\n          priv.key = this.key;\n          break;\n        }\n\n      case keyTypes.P521:\n        {\n          priv.point = p521.publicKeyCreate(this.key, false);\n          priv.key = this.key;\n          break;\n        }\n\n      case keyTypes.ED25519:\n        {\n          priv.point = ed25519.publicKeyCreate(this.key);\n          priv.key = this.key;\n          break;\n        }\n\n      default:\n        {\n          throw new assert.AssertionError('Invalid key.');\n        }\n    }\n\n    priv.comment = this.comment;\n    let raw = priv.encode(passwd != null);\n    if (passwd != null) raw = encrypt(raw, 'aes256-ctr', passwd, kdf.salt, kdf.rounds);\n    writeBytes(bw, raw);\n    return bw.slice();\n  }\n\n  decodeSSH(data, passwd) {\n    const br = bio.read(data);\n    const magic = br.readString(14, 'binary');\n    if (magic !== AUTH_MAGIC || br.readU8() !== 0) throw new Error('Invalid magic prefix for SSH key.');\n    const cipher = readString(br);\n    const kdf = KDFOptions.read(br);\n    if (readInt(br) !== 1) throw new Error('Too many SSH keys.');\n    const pubRaw = readBytes(br);\n    const publicKey = SSHPublicKey.decode(pubRaw);\n    let privRaw = readBytes(br);\n\n    if (cipher !== 'none') {\n      if (passwd == null) throw new Error('Cannot decrypt without passphrase.');\n      if (kdf.name !== 'bcrypt') throw new Error('Invalid KDF.');\n      privRaw = decrypt(privRaw, cipher, passwd, kdf.salt, kdf.rounds);\n    }\n\n    const priv = RawPrivateKey.decode(privRaw);\n    if (priv.type !== publicKey.type) throw new Error('Public/private mismatch.');\n    this.type = publicKey.type;\n\n    switch (this.type) {\n      case keyTypes.DSA:\n        {\n          this.p = priv.p;\n          this.q = priv.q;\n          this.g = priv.g;\n          this.y = priv.y;\n          this.x = priv.x;\n          break;\n        }\n\n      case keyTypes.RSA:\n        {\n          this.n = priv.n;\n          this.e = priv.e;\n          this.d = priv.d;\n          this.p = priv.p;\n          this.q = priv.q;\n          this.qi = priv.qi;\n          break;\n        }\n\n      case keyTypes.P256:\n      case keyTypes.P384:\n      case keyTypes.P521:\n      case keyTypes.ED25519:\n        {\n          this.key = priv.key;\n          break;\n        }\n\n      default:\n        {\n          throw new assert.AssertionError('Invalid key.');\n        }\n    } // Recompute dp and dq.\n\n\n    if (this.type === keyTypes.RSA) {\n      const p = BN.decode(this.p);\n      const q = BN.decode(this.q);\n      const d = BN.decode(this.d);\n      const dp = d.mod(p.subn(1));\n      const dq = d.mod(q.subn(1));\n      this.dp = dp.encode();\n      this.dq = dq.encode();\n    }\n\n    this.comment = priv.comment;\n    this.modern = true;\n    return this;\n  }\n\n  encode(passwd) {\n    // Ed25519 can _only_ use the new school encoding.\n    if (this.modern || this.type === keyTypes.ED25519) return this.encodeSSH(passwd);\n\n    switch (this.type) {\n      case keyTypes.DSA:\n        {\n          const key = new openssl.DSAPrivateKey(0, this.p, this.q, this.g, this.y, this.x);\n          return key.encode();\n        }\n\n      case keyTypes.RSA:\n        {\n          const key = new pkcs1.RSAPrivateKey(0, this.n, this.e, this.d, this.p, this.q, this.dp, this.dq, this.qi);\n          return key.encode();\n        }\n\n      case keyTypes.P256:\n      case keyTypes.P384:\n      case keyTypes.P521:\n        {\n          let curve = null;\n          let pub = null;\n\n          switch (this.type) {\n            case keyTypes.P256:\n              curve = 'P256';\n              pub = p256.publicKeyCreate(this.key, false);\n              break;\n\n            case keyTypes.P384:\n              curve = 'P384';\n              pub = p384.publicKeyCreate(this.key, false);\n              break;\n\n            case keyTypes.P521:\n              curve = 'P521';\n              pub = p521.publicKeyCreate(this.key, false);\n              break;\n          }\n\n          const key = new sec1.ECPrivateKey(1, this.key, curve, pub);\n          return key.encode();\n        }\n\n      default:\n        {\n          throw new assert.AssertionError('Invalid key.');\n        }\n    }\n  }\n\n  toString(passwd) {\n    const block = new PEMBlock(); // Ed25519 can _only_ use the new school encoding.\n\n    if (this.modern || this.type === keyTypes.ED25519) {\n      block.type = 'OPENSSH PRIVATE KEY';\n      block.data = this.encode(passwd);\n      return block.toString();\n    }\n\n    switch (this.type) {\n      case keyTypes.DSA:\n        {\n          block.type = 'DSA PRIVATE KEY';\n          break;\n        }\n\n      case keyTypes.RSA:\n        {\n          block.type = 'RSA PRIVATE KEY';\n          break;\n        }\n\n      case keyTypes.P256:\n      case keyTypes.P384:\n      case keyTypes.P521:\n        {\n          block.type = 'EC PRIVATE KEY';\n          break;\n        }\n\n      default:\n        {\n          throw new assert.AssertionError('Invalid key.');\n        }\n    }\n\n    block.data = this.encode(null);\n    if (passwd != null) pemcrypt.encrypt(block, 'AES-128-CBC', passwd);\n    return block.toString();\n  }\n\n  fromString(str, passwd) {\n    const block = PEMBlock.fromString(str);\n\n    if (block.isEncrypted()) {\n      if (passwd == null) throw new Error('Private key requires a passphrase.');\n      pemcrypt.decrypt(block, passwd);\n    }\n\n    switch (block.type) {\n      case 'DSA PRIVATE KEY':\n        {\n          // OpenSSL PKCS1-like format\n          const key = openssl.DSAPrivateKey.decode(block.data);\n          this.type = keyTypes.DSA;\n          this.p = key.p.value;\n          this.q = key.q.value;\n          this.g = key.g.value;\n          this.y = key.y.value;\n          this.x = key.x.value;\n          return this;\n        }\n\n      case 'RSA PRIVATE KEY':\n        {\n          // PKCS1\n          const key = pkcs1.RSAPrivateKey.decode(block.data);\n          this.type = keyTypes.RSA;\n          this.n = key.n.value;\n          this.e = key.e.value;\n          this.d = key.d.value;\n          this.p = key.p.value;\n          this.q = key.q.value;\n          this.dp = key.dp.value;\n          this.dq = key.dq.value;\n          this.qi = key.qi.value;\n          return this;\n        }\n\n      case 'EC PRIVATE KEY':\n        {\n          // SEC1\n          const key = sec1.ECPrivateKey.decode(block.data);\n          const curve = key.namedCurveOID.getCurveName();\n          if (!curve) throw new Error(`Unknown curve: ${key.namedCurveOID.toString()}.`);\n          let type = null;\n          let size = 0;\n\n          switch (curve) {\n            case 'P256':\n              type = keyTypes.P256;\n              size = 32;\n              break;\n\n            case 'P384':\n              type = keyTypes.P384;\n              size = 48;\n              break;\n\n            case 'P521':\n              type = keyTypes.P521;\n              size = 66;\n              break;\n\n            case 'ED25519':\n              type = keyTypes.ED25519;\n              size = 32;\n              break;\n\n            default:\n              throw new Error(`Unsupported curve: ${curve}.`);\n          }\n\n          this.type = type;\n          this.key = curve === 'ED25519' ? padRight(key.privateKey.value, size) : padLeft(key.privateKey.value, size);\n          return this;\n        }\n\n      case 'OPENSSH PRIVATE KEY':\n        {\n          // OpenSSH format\n          return this.decodeSSH(block.data, passwd);\n        }\n\n      default:\n        {\n          throw new Error(`Unknown private key type: ${block.type}.`);\n        }\n    }\n  }\n\n  format() {\n    switch (this.type) {\n      case keyTypes.DSA:\n        {\n          return {\n            type: this.type,\n            p: this.p.toString('hex'),\n            q: this.q.toString('hex'),\n            g: this.g.toString('hex'),\n            y: this.y.toString('hex'),\n            x: this.x.toString('hex'),\n            comment: this.comment,\n            modern: this.modern\n          };\n        }\n\n      case keyTypes.RSA:\n        {\n          return {\n            type: this.type,\n            n: this.n.toString('hex'),\n            e: this.q.toString('hex'),\n            d: this.d.toString('hex'),\n            p: this.p.toString('hex'),\n            q: this.q.toString('hex'),\n            dp: this.dp.toString('hex'),\n            dq: this.dq.toString('hex'),\n            qi: this.qi.toString('hex'),\n            comment: this.comment,\n            modern: this.modern\n          };\n        }\n\n      case keyTypes.P256:\n      case keyTypes.P384:\n      case keyTypes.P521:\n      case keyTypes.ED25519:\n        {\n          return {\n            type: this.type,\n            key: this.key.toString('hex'),\n            comment: this.comment,\n            modern: this.modern\n          };\n        }\n\n      default:\n        {\n          return this;\n        }\n    }\n  }\n\n}\n/**\n * KDFOptions\n */\n\n\nclass KDFOptions extends bio.Struct {\n  constructor() {\n    super();\n    this.name = 'none';\n    this.salt = EMPTY;\n    this.rounds = 0;\n  }\n\n  getBodySize() {\n    let size = 0;\n\n    switch (this.name) {\n      case 'none':\n        break;\n\n      case 'bcrypt':\n        size += sizeBytes(this.salt);\n        size += sizeInt(this.rounds);\n        break;\n\n      default:\n        throw new Error(`Unknown KDF: ${this.name}.`);\n    }\n\n    return size;\n  }\n\n  getSize() {\n    let size = 0;\n    size += sizeString(this.name);\n    size += sizeInt(0);\n    size += this.getBodySize();\n    return size;\n  }\n\n  write(bw) {\n    writeString(bw, this.name);\n    writeInt(bw, this.getBodySize());\n\n    switch (this.name) {\n      case 'none':\n        break;\n\n      case 'bcrypt':\n        writeBytes(bw, this.salt);\n        writeInt(bw, this.rounds);\n        break;\n\n      default:\n        throw new Error(`Unknown KDF: ${this.name}.`);\n    }\n\n    return bw;\n  }\n\n  read(br) {\n    this.name = readString(br);\n    const child = readChild(br);\n\n    switch (this.name) {\n      case 'none':\n        break;\n\n      case 'bcrypt':\n        this.salt = readBytes(child);\n        this.rounds = readInt(child);\n        break;\n\n      default:\n        throw new Error(`Unknown KDF: ${this.name}.`);\n    }\n\n    return this;\n  }\n\n}\n/**\n * RawPrivateKey\n */\n\n\nclass RawPrivateKey extends bio.Struct {\n  constructor() {\n    super();\n    this.type = keyTypes.ED25519; // DSA\n\n    this.p = EMPTY;\n    this.q = EMPTY;\n    this.g = EMPTY;\n    this.y = EMPTY;\n    this.x = EMPTY; // RSA\n\n    this.n = EMPTY;\n    this.e = EMPTY;\n    this.d = EMPTY;\n    this.p = EMPTY;\n    this.q = EMPTY;\n    this.qi = EMPTY; // ECDSA / EDDSA\n\n    this.point = ZERO32;\n    this.key = ZERO32;\n    this.comment = '';\n  }\n\n  getSize(useNonce) {\n    let size = 0;\n    size += sizeInt(0);\n    size += sizeInt(0);\n    size += sizeString(this.type);\n\n    switch (this.type) {\n      case keyTypes.DSA:\n        {\n          size += sizeBytes(this.p);\n          size += sizeBytes(this.q);\n          size += sizeBytes(this.g);\n          size += sizeBytes(this.y);\n          size += sizeBytes(this.x);\n          break;\n        }\n\n      case keyTypes.RSA:\n        {\n          size += sizeBytes(this.n);\n          size += sizeBytes(this.e);\n          size += sizeBytes(this.d);\n          size += sizeBytes(this.qi);\n          size += sizeBytes(this.p);\n          size += sizeBytes(this.q);\n          break;\n        }\n\n      case keyTypes.P256:\n      case keyTypes.P384:\n      case keyTypes.P521:\n        {\n          size += sizeString(typeToCurve[this.type]);\n          size += sizeBytes(this.point);\n          size += sizeBytes(this.key);\n          break;\n        }\n\n      case keyTypes.ED25519:\n        {\n          size += sizeBytes(this.point);\n          size += sizeInt(0);\n          size += this.key.length;\n          size += this.point.length;\n          break;\n        }\n\n      default:\n        {\n          throw new Error('Invalid key.');\n        }\n    }\n\n    size += sizeString(this.comment);\n    size += 8 - (size & 7);\n    return size;\n  }\n\n  write(bw, useNonce) {\n    const offset = bw.offset;\n    let n = 0;\n    if (useNonce) n = Math.random() * 0x100000000 >>> 0;\n    writeInt(bw, n);\n    writeInt(bw, n);\n    writeString(bw, this.type);\n\n    switch (this.type) {\n      case keyTypes.DSA:\n        {\n          writeBytes(bw, this.p);\n          writeBytes(bw, this.q);\n          writeBytes(bw, this.g);\n          writeBytes(bw, this.y);\n          writeBytes(bw, this.x);\n          break;\n        }\n\n      case keyTypes.RSA:\n        {\n          writeBytes(bw, this.n);\n          writeBytes(bw, this.e);\n          writeBytes(bw, this.d);\n          writeBytes(bw, this.qi);\n          writeBytes(bw, this.p);\n          writeBytes(bw, this.q);\n          break;\n        }\n\n      case keyTypes.P256:\n      case keyTypes.P384:\n      case keyTypes.P521:\n        {\n          writeString(bw, typeToCurve[this.type]);\n          writeBytes(bw, this.point);\n          writeBytes(bw, this.key);\n          break;\n        }\n\n      case keyTypes.ED25519:\n        {\n          writeBytes(bw, this.point);\n          writeBytes(bw, bio.concat(this.key, this.point));\n          break;\n        }\n\n      default:\n        {\n          throw new Error('Invalid key.');\n        }\n    }\n\n    writeString(bw, this.comment);\n    let size = bw.offset - offset;\n    let i = 1;\n\n    while (size & 7) {\n      bw.writeU8(i);\n      size += 1;\n      i += 1;\n    }\n\n    return bw;\n  }\n\n  read(br) {\n    if ((br.left() & 7) !== 0) throw new Error('Invalid padding.');\n    if (readInt(br) !== readInt(br)) throw new Error('Decryption failed.');\n    this.type = readString(br);\n\n    switch (this.type) {\n      case keyTypes.DSA:\n        {\n          this.p = readBytes(br);\n          this.q = readBytes(br);\n          this.g = readBytes(br);\n          this.y = readBytes(br);\n          this.x = readBytes(br);\n          break;\n        }\n\n      case keyTypes.RSA:\n        {\n          this.n = readBytes(br);\n          this.e = readBytes(br);\n          this.d = readBytes(br);\n          this.qi = readBytes(br);\n          this.p = readBytes(br);\n          this.q = readBytes(br);\n          break;\n        }\n\n      case keyTypes.P256:\n      case keyTypes.P384:\n      case keyTypes.P521:\n        {\n          const curve = readString(br);\n          if (curve !== typeToCurve[this.type]) throw new Error('Invalid curve.');\n          this.point = readBytes(br);\n          this.key = readBytes(br);\n          if (this.type === keyTypes.P256) this.key = padLeft(this.key, 32);else if (this.type === keyTypes.P384) this.key = padLeft(this.key, 48);else this.key = padLeft(this.key, 66);\n          break;\n        }\n\n      case keyTypes.ED25519:\n        {\n          const point = readBytes(br);\n          const blob = readBytes(br);\n          if (blob.length !== 64) throw new Error('Invalid key pair.');\n          const key = blob.slice(0, 32);\n          const pub = blob.slice(32, 64);\n          if (!point.equals(pub)) throw new Error('Public key mismatch.');\n          this.point = point;\n          this.key = key;\n          break;\n        }\n\n      default:\n        {\n          throw new Error('Invalid key.');\n        }\n    }\n\n    this.comment = readString(br);\n    const padding = br.readBytes(br.left(), true);\n\n    for (let i = 0; i < padding.length; i++) {\n      if (padding[i] !== i + 1) throw new Error('Invalid padding.');\n    }\n\n    return this;\n  }\n\n}\n/*\n * Encryption\n */\n\n\nfunction derive(sname, passwd, salt, rounds) {\n  assert(typeof sname === 'string');\n  assert(typeof passwd === 'string');\n  assert(Buffer.isBuffer(salt));\n  assert(rounds >>> 0 === rounds);\n  if (!cipherToName.hasOwnProperty(sname)) throw new Error(`Unknown cipher: ${sname}.`);\n  const name = cipherToName[sname];\n  const {\n    keySize,\n    ivSize\n  } = cipher.get(name);\n  const size = keySize + ivSize;\n  const secret = bcrypt.pbkdf(passwd, salt, rounds, size);\n  const key = secret.slice(0, keySize);\n  const iv = secret.slice(keySize, keySize + ivSize);\n  return [name, key, iv];\n}\n\nfunction encrypt(data, sname, passwd, salt, rounds) {\n  const [name, key, iv] = derive(sname, passwd, salt, rounds);\n  return cipher.encrypt(name, key, iv, data);\n}\n\nfunction decrypt(data, sname, passwd, salt, rounds) {\n  const [name, key, iv] = derive(sname, passwd, salt, rounds);\n  return cipher.decrypt(name, key, iv, data);\n}\n/*\n * Encoding\n */\n\n\nfunction readString(br) {\n  return br.readString(br.readU32BE(), 'binary');\n}\n\nfunction readBytes(br) {\n  return br.readBytes(br.readU32BE());\n}\n\nfunction readChild(br) {\n  return br.readChild(br.readU32BE());\n}\n\nfunction readInt(br) {\n  return br.readU32BE();\n}\n\nfunction sizeString(str) {\n  return 4 + str.length;\n}\n\nfunction writeString(bw, str) {\n  bw.writeU32BE(str.length);\n  bw.writeString(str, 'binary');\n  return bw;\n}\n\nfunction sizeBytes(data) {\n  return 4 + data.length;\n}\n\nfunction writeBytes(bw, data) {\n  bw.writeU32BE(data.length);\n  bw.writeBytes(data);\n  return bw;\n}\n\nfunction sizeInt(num) {\n  return 4;\n}\n\nfunction writeInt(bw, num) {\n  bw.writeU32BE(num);\n  return bw;\n}\n/*\n * Expose\n */\n\n\nexports.keyTypes = keyTypes;\nexports.keyTypesByVal = keyTypesByVal;\nexports.SSHPublicKey = SSHPublicKey;\nexports.SSHPrivateKey = SSHPrivateKey;\nexports.KDFOptions = KDFOptions;\nexports.RawPrivateKey = RawPrivateKey;","map":null,"metadata":{},"sourceType":"script"}