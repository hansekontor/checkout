{"ast":null,"code":"/*!\n * idea.js - IDEA for javascript\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on dgryski/go-idea:\n *   Copyright (c) 2013-2017, Damian Gryski. All rights reserved.\n *   https://github.com/dgryski/go-idea\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/International_Data_Encryption_Algorithm\n *   https://github.com/dgryski/go-idea/blob/master/idea.go\n */\n'use strict';\n\nconst assert = require('../../internal/assert');\n/*\n * Constants\n */\n\n\nconst ROUNDS = 8;\nconst KEYLEN = 6 * ROUNDS + 4;\nconst ZERO16 = Buffer.alloc(16, 0x00);\n/**\n * IDEA\n */\n\nclass IDEA {\n  constructor() {\n    this.key = ZERO16;\n    this.encryptKey = null;\n    this.decryptKey = null;\n  }\n\n  get blockSize() {\n    return 8;\n  }\n\n  init(key) {\n    assert(Buffer.isBuffer(key));\n    assert(key.length === 16);\n    this.destroy();\n    this.key = Buffer.from(key);\n    return this;\n  }\n\n  getEncryptKey() {\n    if (!this.encryptKey) this.encryptKey = this.expandKey(this.key);\n    return this.encryptKey;\n  }\n\n  getDecryptKey() {\n    if (!this.decryptKey) this.decryptKey = this.invertKey(this.getEncryptKey());\n    return this.decryptKey;\n  }\n\n  encrypt(input, ipos, output, opos) {\n    const key = this.getEncryptKey();\n    return this.crypt(input, ipos, output, opos, key);\n  }\n\n  decrypt(input, ipos, output, opos) {\n    const key = this.getDecryptKey();\n    return this.crypt(input, ipos, output, opos, key);\n  }\n\n  destroy() {\n    for (let i = 0; i < 16; i++) this.key[i] = 0;\n\n    if (this.encryptKey) {\n      for (let i = 0; i < KEYLEN; i++) this.encryptKey[i] = 0;\n    }\n\n    if (this.decryptKey) {\n      for (let i = 0; i < KEYLEN; i++) this.decryptKey[i] = 0;\n    }\n\n    this.key = ZERO16;\n    this.encryptKey = null;\n    this.decryptKey = null;\n    return this;\n  }\n\n  expandKey(key) {\n    const ek = new Uint16Array(KEYLEN);\n    let p = 0;\n    let j = 0;\n    let i = 0;\n\n    for (; j < 8; j++) {\n      ek[j] = readU16(key, p);\n      p += 2;\n    }\n\n    p = 0;\n\n    for (; j < KEYLEN; j++) {\n      i += 1;\n      ek[p + (i + 7)] = ek[p + (i & 7)] << 9 | ek[p + (i + 1 & 7)] >>> 7;\n      p += i & 8;\n      i &= 7;\n    }\n\n    return ek;\n  }\n\n  invertKey(ek) {\n    const dk = new Uint16Array(KEYLEN);\n    let t1, t2, t3;\n    let dki = KEYLEN;\n    let eki = 0;\n    t1 = invm(ek[eki]);\n    eki += 1;\n    t2 = -ek[eki];\n    eki += 1;\n    t3 = -ek[eki];\n    eki += 1;\n    dki -= 1;\n    dk[dki] = invm(ek[eki]);\n    eki += 1;\n    dki -= 1;\n    dk[dki] = t3;\n    dki -= 1;\n    dk[dki] = t2;\n    dki -= 1;\n    dk[dki] = t1;\n\n    for (let i = 0; i < ROUNDS - 1; i++) {\n      t1 = ek[eki];\n      eki += 1;\n      dki -= 1;\n      dk[dki] = ek[eki];\n      eki += 1;\n      dki -= 1;\n      dk[dki] = t1;\n      t1 = invm(ek[eki]);\n      eki += 1;\n      t2 = -ek[eki];\n      eki += 1;\n      t3 = -ek[eki];\n      eki += 1;\n      dki -= 1;\n      dk[dki] = invm(ek[eki]);\n      eki += 1;\n      dki -= 1;\n      dk[dki] = t2;\n      dki -= 1;\n      dk[dki] = t3;\n      dki -= 1;\n      dk[dki] = t1;\n    }\n\n    t1 = ek[eki];\n    eki += 1;\n    dki -= 1;\n    dk[dki] = ek[eki];\n    eki += 1;\n    dki -= 1;\n    dk[dki] = t1;\n    t1 = invm(ek[eki]);\n    eki += 1;\n    t2 = -ek[eki];\n    eki += 1;\n    t3 = -ek[eki];\n    eki += 1;\n    dki -= 1;\n    dk[dki] = invm(ek[eki]);\n    dki -= 1;\n    dk[dki] = t3;\n    dki -= 1;\n    dk[dki] = t2;\n    dki -= 1;\n    dk[dki] = t1;\n    return dk;\n  }\n\n  crypt(input, ipos, output, opos, key) {\n    let x1 = readU16(input, ipos + 0);\n    let x2 = readU16(input, ipos + 2);\n    let x3 = readU16(input, ipos + 4);\n    let x4 = readU16(input, ipos + 6);\n    let s2 = 0;\n    let s3 = 0;\n    let p = 0;\n\n    for (let r = ROUNDS; r > 0; r--) {\n      x1 = mul(x1, key[p]);\n      p += 1;\n      x2 += key[p];\n      p += 1;\n      x3 += key[p];\n      p += 1;\n      x4 = mul(x4, key[p]);\n      p += 1;\n      s3 = x3;\n      x3 ^= x1;\n      x3 = mul(x3, key[p]);\n      p += 1;\n      s2 = x2;\n      x2 ^= x4;\n      x2 += x3;\n      x2 = mul(x2, key[p]);\n      p += 1;\n      x3 += x2;\n      x1 ^= x2;\n      x4 ^= x3;\n      x2 ^= s3;\n      x3 ^= s2;\n    }\n\n    x1 = mul(x1, key[p]);\n    p += 1;\n    x3 += key[p];\n    p += 1;\n    x2 += key[p];\n    p += 1;\n    x4 = mul(x4, key[p]);\n    writeU16(output, x1, opos + 0);\n    writeU16(output, x3, opos + 2);\n    writeU16(output, x2, opos + 4);\n    writeU16(output, x4, opos + 6);\n  }\n\n}\n/*\n * Helpers\n */\n\n\nfunction invm(x) {\n  x &= 0xffff;\n  if (x <= 1) return x;\n  let t1 = 0x10001 / x & 0xffff;\n  let y = 0x10001 % x;\n  if (y === 1) return 1 - t1 & 0xffff;\n  let t0 = 1;\n  let q = 0;\n\n  while (y !== 1) {\n    q = x / y & 0xffff;\n    x %= y;\n    t0 += q * t1;\n    t0 &= 0xffff;\n    if (x === 1) return t0;\n    q = y / x & 0xffff;\n    y %= x;\n    t1 += q * t0;\n    t1 &= 0xffff;\n  }\n\n  return 1 - t1 & 0xffff;\n}\n\nfunction mul(x, y) {\n  x &= 0xffff;\n  y &= 0xffff;\n  if (y === 0) return 1 - x & 0xffff;\n  if (x === 0) return 1 - y & 0xffff;\n  const t32 = x * y >>> 0;\n  x = t32 & 0xffff;\n  y = t32 >>> 16;\n  if (x < y) return x - y + 1 & 0xffff;\n  return x - y & 0xffff;\n}\n\nfunction readU16(data, pos) {\n  return data[pos++] * 0x100 + data[pos];\n}\n\nfunction writeU16(data, value, pos) {\n  data[pos++] = value >>> 8;\n  data[pos++] = value;\n  return pos;\n}\n/*\n * Expose\n */\n\n\nmodule.exports = IDEA;","map":null,"metadata":{},"sourceType":"script"}