{"ast":null,"code":"/*!\n * outpoint.js - outpoint object for bcoin\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bio = require('bufio');\n\nconst util = require('../utils/util');\n\nconst consensus = require('../protocol/consensus');\n\nconst {\n  inspectSymbol\n} = require('../utils');\n/**\n * Outpoint\n * Represents a COutPoint.\n * @alias module:primitives.Outpoint\n * @property {Hash} hash\n * @property {Number} index\n */\n\n\nclass Outpoint {\n  /**\n   * Create an outpoint.\n   * @constructor\n   * @param {Hash?} hash\n   * @param {Number?} index\n   */\n  constructor(hash, index) {\n    this.hash = consensus.ZERO_HASH;\n    this.index = 0xffffffff;\n\n    if (hash != null) {\n      assert(Buffer.isBuffer(hash));\n      assert(index >>> 0 === index, 'Index must be a uint32.');\n      this.hash = hash;\n      this.index = index;\n    }\n  }\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n\n  fromOptions(options) {\n    assert(options, 'Outpoint data is required.');\n    assert(Buffer.isBuffer(options.hash));\n    assert(options.index >>> 0 === options.index, 'Index must be a uint32.');\n    this.hash = options.hash;\n    this.index = options.index;\n    return this;\n  }\n  /**\n   * Instantate outpoint from options object.\n   * @param {Object} options\n   * @returns {Outpoint}\n   */\n\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  } //   /**\n  //    * Clone the outpoint.\n  //    * @returns {Outpoint}\n  //    */\n  //   clone() {\n  //     const outpoint = new this.constructor();\n  //     outpoint.hash = this.hash;\n  //     outpoint.index = this.index;\n  //     return outpoint;\n  //   }\n  //   /**\n  //    * Test equality against another outpoint.\n  //    * @param {Outpoint} prevout\n  //    * @returns {Boolean}\n  //    */\n  //   equals(prevout) {\n  //     assert(Outpoint.isOutpoint(prevout));\n  //     return this.hash.equals(prevout.hash)\n  //       && this.index === prevout.index;\n  //   }\n  //   /**\n  //    * Compare against another outpoint (BIP69).\n  //    * @param {Outpoint} prevout\n  //    * @returns {Number}\n  //    */\n  //   compare(prevout) {\n  //     assert(Outpoint.isOutpoint(prevout));\n  //     const cmp = strcmp(this.txid(), prevout.txid());\n  //     if (cmp !== 0)\n  //       return cmp;\n  //     return this.index - prevout.index;\n  //   }\n  //   /**\n  //    * Test whether the outpoint is null (hash of zeroes\n  //    * with max-u32 index). Used to detect coinbases.\n  //    * @returns {Boolean}\n  //    */\n  //   isNull() {\n  //     return this.index === 0xffffffff && this.hash.equals(consensus.ZERO_HASH);\n  //   }\n  //   /**\n  //    * Get little-endian hash.\n  //    * @returns {Hash}\n  //    */\n  //   rhash() {\n  //     return util.revHex(this.hash);\n  //   }\n  //   /**\n  //    * Get little-endian hash.\n  //    * @returns {Hash}\n  //    */\n  //   txid() {\n  //     return this.rhash();\n  //   }\n  //   /**\n  //    * Serialize outpoint to a key\n  //    * suitable for a hash table.\n  //    * @returns {String}\n  //    */\n  //   toKey() {\n  //     return this.toRaw();\n  //   }\n  //   /**\n  //    * Inject properties from hash table key.\n  //    * @private\n  //    * @param {String} key\n  //    * @returns {Outpoint}\n  //    */\n  //   fromKey(key) {\n  //     this.hash = key.slice(0, 32);\n  //     this.index = bio.readU32(key, 32);\n  //     return this;\n  //   }\n  //   /**\n  //    * Instantiate outpoint from hash table key.\n  //    * @param {String} key\n  //    * @returns {Outpoint}\n  //    */\n  //   static fromKey(key) {\n  //     return new this().fromKey(key);\n  //   }\n  //   /**\n  //    * Write outpoint to a buffer writer.\n  //    * @param {BufferWriter} bw\n  //    */\n  //   toWriter(bw) {\n  //     bw.writeHash(this.hash);\n  //     bw.writeU32(this.index);\n  //     return bw;\n  //   }\n  //   /**\n  //    * Calculate size of outpoint.\n  //    * @returns {Number}\n  //    */\n  //   getSize() {\n  //     return 36;\n  //   }\n  //   /**\n  //    * Serialize outpoint.\n  //    * @returns {Buffer}\n  //    */\n  //   toRaw() {\n  //     return this.toWriter(bio.write(36)).render();\n  //   }\n  //   /**\n  //    * Inject properties from buffer reader.\n  //    * @private\n  //    * @param {BufferReader} br\n  //    */\n  //   fromReader(br) {\n  //     this.hash = br.readHash();\n  //     this.index = br.readU32();\n  //     return this;\n  //   }\n  //   /**\n  //    * Inject properties from serialized data.\n  //    * @private\n  //    * @param {Buffer} data\n  //    */\n  //   fromRaw(data) {\n  //     return this.fromReader(bio.read(data));\n  //   }\n  //   /**\n  //    * Instantiate outpoint from a buffer reader.\n  //    * @param {BufferReader} br\n  //    * @returns {Outpoint}\n  //    */\n  //   static fromReader(br) {\n  //     return new this().fromReader(br);\n  //   }\n  //   /**\n  //    * Instantiate outpoint from serialized data.\n  //    * @param {Buffer} data\n  //    * @returns {Outpoint}\n  //    */\n  //   static fromRaw(data) {\n  //     return new this().fromRaw(data);\n  //   }\n  //   /**\n  //    * Inject properties from json object.\n  //    * @private\n  //    * @params {Object} json\n  //    */\n  //   fromJSON(json) {\n  //     assert(json, 'Outpoint data is required.');\n  //     assert(typeof json.hash === 'string', 'Hash must be a string.');\n  //     assert((json.index >>> 0) === json.index, 'Index must be a uint32.');\n  //     this.hash = util.fromRev(json.hash);\n  //     this.index = json.index;\n  //     return this;\n  //   }\n  //   /**\n  //    * Convert the outpoint to an object suitable\n  //    * for JSON serialization. Note that the hash\n  //    * will be reversed to abide by bitcoind's legacy\n  //    * of little-endian uint256s.\n  //    * @returns {Object}\n  //    */\n  //   toJSON() {\n  //     return {\n  //       hash: util.revHex(this.hash),\n  //       index: this.index\n  //     };\n  //   }\n  //   /**\n  //    * Instantiate outpoint from json object.\n  //    * @param {Object} json\n  //    * @returns {Outpoint}\n  //    */\n  //   static fromJSON(json) {\n  //     return new this().fromJSON(json);\n  //   }\n  //   /**\n  //    * Inject properties from tx.\n  //    * @private\n  //    * @param {TX} tx\n  //    * @param {Number} index\n  //    */\n  //   fromTX(tx, index) {\n  //     assert(tx);\n  //     assert(typeof index === 'number');\n  //     assert(index >= 0);\n  //     this.hash = tx.hash();\n  //     this.index = index;\n  //     return this;\n  //   }\n  //   /**\n  //    * Instantiate outpoint from tx.\n  //    * @param {TX} tx\n  //    * @param {Number} index\n  //    * @returns {Outpoint}\n  //    */\n  //   static fromTX(tx, index) {\n  //     return new this().fromTX(tx, index);\n  //   }\n  //   /**\n  //    * Serialize outpoint to a key\n  //    * suitable for a hash table.\n  //    * @param {Hash} hash\n  //    * @param {Number} index\n  //    * @returns {String}\n  //    */\n  //   static toKey(hash, index) {\n  //     return new Outpoint(hash, index).toKey();\n  //   }\n  //   /**\n  //    * Convert the outpoint to a user-friendly string.\n  //    * @returns {String}\n  //    */\n  //   [inspectSymbol]() {\n  //     return `<Outpoint: ${this.rhash()}/${this.index}>`;\n  //   }\n  //   /**\n  //    * Test an object to see if it is an outpoint.\n  //    * @param {Object} obj\n  //    * @returns {Boolean}\n  //    */\n  //   static isOutpoint(obj) {\n  //     return obj instanceof Outpoint;\n  //   }\n\n\n} // /*\n//  * Helpers\n//  */\n// function strcmp(a, b) {\n//   const len = Math.min(a.length, b.length);\n//   for (let i = 0; i < len; i++) {\n//     if (a[i] < b[i])\n//       return -1;\n//     if (a[i] > b[i])\n//       return 1;\n//   }\n//   if (a.length < b.length)\n//     return -1;\n//   if (a.length > b.length)\n//     return 1;\n//   return 0;\n// }\n\n/*\n * Expose\n */\n\n\nmodule.exports = Outpoint;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/primitives/outpoint.js"],"names":["assert","require","bio","util","consensus","inspectSymbol","Outpoint","constructor","hash","index","ZERO_HASH","Buffer","isBuffer","fromOptions","options","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,OAAD,CAAtB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAME,IAAI,GAAGF,OAAO,CAAC,eAAD,CAApB;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,uBAAD,CAAzB;;AACA,MAAM;AAACI,EAAAA;AAAD,IAAkBJ,OAAO,CAAC,UAAD,CAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMK,QAAN,CAAe;AACb;AACF;AACA;AACA;AACA;AACA;AAEEC,EAAAA,WAAW,CAACC,IAAD,EAAOC,KAAP,EAAc;AACvB,SAAKD,IAAL,GAAYJ,SAAS,CAACM,SAAtB;AACA,SAAKD,KAAL,GAAa,UAAb;;AAEA,QAAID,IAAI,IAAI,IAAZ,EAAkB;AAChBR,MAAAA,MAAM,CAACW,MAAM,CAACC,QAAP,CAAgBJ,IAAhB,CAAD,CAAN;AACAR,MAAAA,MAAM,CAAES,KAAK,KAAK,CAAX,KAAkBA,KAAnB,EAA0B,yBAA1B,CAAN;AACA,WAAKD,IAAL,GAAYA,IAAZ;AACA,WAAKC,KAAL,GAAaA,KAAb;AACD;AACF;AAED;AACF;AACA;AACA;AACA;;;AAEEI,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnBd,IAAAA,MAAM,CAACc,OAAD,EAAU,4BAAV,CAAN;AACAd,IAAAA,MAAM,CAACW,MAAM,CAACC,QAAP,CAAgBE,OAAO,CAACN,IAAxB,CAAD,CAAN;AACAR,IAAAA,MAAM,CAAEc,OAAO,CAACL,KAAR,KAAkB,CAAnB,KAA0BK,OAAO,CAACL,KAAnC,EAA0C,yBAA1C,CAAN;AACA,SAAKD,IAAL,GAAYM,OAAO,CAACN,IAApB;AACA,SAAKC,KAAL,GAAaK,OAAO,CAACL,KAArB;AACA,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEoB,SAAXI,WAAW,CAACC,OAAD,EAAU;AAC1B,WAAO,IAAI,IAAJ,GAAWD,WAAX,CAAuBC,OAAvB,CAAP;AACD,GA3CY,CA6Cf;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AA1Te,C,CA6Tf;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;;AAEAC,MAAM,CAACC,OAAP,GAAiBV,QAAjB","sourcesContent":["/*!\n * outpoint.js - outpoint object for bcoin\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bio = require('bufio');\nconst util = require('../utils/util');\nconst consensus = require('../protocol/consensus');\nconst {inspectSymbol} = require('../utils');\n\n/**\n * Outpoint\n * Represents a COutPoint.\n * @alias module:primitives.Outpoint\n * @property {Hash} hash\n * @property {Number} index\n */\n\nclass Outpoint {\n  /**\n   * Create an outpoint.\n   * @constructor\n   * @param {Hash?} hash\n   * @param {Number?} index\n   */\n\n  constructor(hash, index) {\n    this.hash = consensus.ZERO_HASH;\n    this.index = 0xffffffff;\n\n    if (hash != null) {\n      assert(Buffer.isBuffer(hash));\n      assert((index >>> 0) === index, 'Index must be a uint32.');\n      this.hash = hash;\n      this.index = index;\n    }\n  }\n\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n  fromOptions(options) {\n    assert(options, 'Outpoint data is required.');\n    assert(Buffer.isBuffer(options.hash));\n    assert((options.index >>> 0) === options.index, 'Index must be a uint32.');\n    this.hash = options.hash;\n    this.index = options.index;\n    return this;\n  }\n\n  /**\n   * Instantate outpoint from options object.\n   * @param {Object} options\n   * @returns {Outpoint}\n   */\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n\n//   /**\n//    * Clone the outpoint.\n//    * @returns {Outpoint}\n//    */\n\n//   clone() {\n//     const outpoint = new this.constructor();\n//     outpoint.hash = this.hash;\n//     outpoint.index = this.index;\n//     return outpoint;\n//   }\n\n//   /**\n//    * Test equality against another outpoint.\n//    * @param {Outpoint} prevout\n//    * @returns {Boolean}\n//    */\n\n//   equals(prevout) {\n//     assert(Outpoint.isOutpoint(prevout));\n//     return this.hash.equals(prevout.hash)\n//       && this.index === prevout.index;\n//   }\n\n//   /**\n//    * Compare against another outpoint (BIP69).\n//    * @param {Outpoint} prevout\n//    * @returns {Number}\n//    */\n\n//   compare(prevout) {\n//     assert(Outpoint.isOutpoint(prevout));\n\n//     const cmp = strcmp(this.txid(), prevout.txid());\n\n//     if (cmp !== 0)\n//       return cmp;\n\n//     return this.index - prevout.index;\n//   }\n\n//   /**\n//    * Test whether the outpoint is null (hash of zeroes\n//    * with max-u32 index). Used to detect coinbases.\n//    * @returns {Boolean}\n//    */\n\n//   isNull() {\n//     return this.index === 0xffffffff && this.hash.equals(consensus.ZERO_HASH);\n//   }\n\n//   /**\n//    * Get little-endian hash.\n//    * @returns {Hash}\n//    */\n\n//   rhash() {\n//     return util.revHex(this.hash);\n//   }\n\n//   /**\n//    * Get little-endian hash.\n//    * @returns {Hash}\n//    */\n\n//   txid() {\n//     return this.rhash();\n//   }\n\n//   /**\n//    * Serialize outpoint to a key\n//    * suitable for a hash table.\n//    * @returns {String}\n//    */\n\n//   toKey() {\n//     return this.toRaw();\n//   }\n\n//   /**\n//    * Inject properties from hash table key.\n//    * @private\n//    * @param {String} key\n//    * @returns {Outpoint}\n//    */\n\n//   fromKey(key) {\n//     this.hash = key.slice(0, 32);\n//     this.index = bio.readU32(key, 32);\n//     return this;\n//   }\n\n//   /**\n//    * Instantiate outpoint from hash table key.\n//    * @param {String} key\n//    * @returns {Outpoint}\n//    */\n\n//   static fromKey(key) {\n//     return new this().fromKey(key);\n//   }\n\n//   /**\n//    * Write outpoint to a buffer writer.\n//    * @param {BufferWriter} bw\n//    */\n\n//   toWriter(bw) {\n//     bw.writeHash(this.hash);\n//     bw.writeU32(this.index);\n//     return bw;\n//   }\n\n//   /**\n//    * Calculate size of outpoint.\n//    * @returns {Number}\n//    */\n\n//   getSize() {\n//     return 36;\n//   }\n\n//   /**\n//    * Serialize outpoint.\n//    * @returns {Buffer}\n//    */\n\n//   toRaw() {\n//     return this.toWriter(bio.write(36)).render();\n//   }\n\n//   /**\n//    * Inject properties from buffer reader.\n//    * @private\n//    * @param {BufferReader} br\n//    */\n\n//   fromReader(br) {\n//     this.hash = br.readHash();\n//     this.index = br.readU32();\n//     return this;\n//   }\n\n//   /**\n//    * Inject properties from serialized data.\n//    * @private\n//    * @param {Buffer} data\n//    */\n\n//   fromRaw(data) {\n//     return this.fromReader(bio.read(data));\n//   }\n\n//   /**\n//    * Instantiate outpoint from a buffer reader.\n//    * @param {BufferReader} br\n//    * @returns {Outpoint}\n//    */\n\n//   static fromReader(br) {\n//     return new this().fromReader(br);\n//   }\n\n//   /**\n//    * Instantiate outpoint from serialized data.\n//    * @param {Buffer} data\n//    * @returns {Outpoint}\n//    */\n\n//   static fromRaw(data) {\n//     return new this().fromRaw(data);\n//   }\n\n//   /**\n//    * Inject properties from json object.\n//    * @private\n//    * @params {Object} json\n//    */\n\n//   fromJSON(json) {\n//     assert(json, 'Outpoint data is required.');\n//     assert(typeof json.hash === 'string', 'Hash must be a string.');\n//     assert((json.index >>> 0) === json.index, 'Index must be a uint32.');\n//     this.hash = util.fromRev(json.hash);\n//     this.index = json.index;\n//     return this;\n//   }\n\n//   /**\n//    * Convert the outpoint to an object suitable\n//    * for JSON serialization. Note that the hash\n//    * will be reversed to abide by bitcoind's legacy\n//    * of little-endian uint256s.\n//    * @returns {Object}\n//    */\n\n//   toJSON() {\n//     return {\n//       hash: util.revHex(this.hash),\n//       index: this.index\n//     };\n//   }\n\n//   /**\n//    * Instantiate outpoint from json object.\n//    * @param {Object} json\n//    * @returns {Outpoint}\n//    */\n\n//   static fromJSON(json) {\n//     return new this().fromJSON(json);\n//   }\n\n//   /**\n//    * Inject properties from tx.\n//    * @private\n//    * @param {TX} tx\n//    * @param {Number} index\n//    */\n\n//   fromTX(tx, index) {\n//     assert(tx);\n//     assert(typeof index === 'number');\n//     assert(index >= 0);\n//     this.hash = tx.hash();\n//     this.index = index;\n//     return this;\n//   }\n\n//   /**\n//    * Instantiate outpoint from tx.\n//    * @param {TX} tx\n//    * @param {Number} index\n//    * @returns {Outpoint}\n//    */\n\n//   static fromTX(tx, index) {\n//     return new this().fromTX(tx, index);\n//   }\n\n//   /**\n//    * Serialize outpoint to a key\n//    * suitable for a hash table.\n//    * @param {Hash} hash\n//    * @param {Number} index\n//    * @returns {String}\n//    */\n\n//   static toKey(hash, index) {\n//     return new Outpoint(hash, index).toKey();\n//   }\n\n//   /**\n//    * Convert the outpoint to a user-friendly string.\n//    * @returns {String}\n//    */\n\n//   [inspectSymbol]() {\n//     return `<Outpoint: ${this.rhash()}/${this.index}>`;\n//   }\n\n//   /**\n//    * Test an object to see if it is an outpoint.\n//    * @param {Object} obj\n//    * @returns {Boolean}\n//    */\n\n//   static isOutpoint(obj) {\n//     return obj instanceof Outpoint;\n//   }\n}\n\n// /*\n//  * Helpers\n//  */\n\n// function strcmp(a, b) {\n//   const len = Math.min(a.length, b.length);\n\n//   for (let i = 0; i < len; i++) {\n//     if (a[i] < b[i])\n//       return -1;\n//     if (a[i] > b[i])\n//       return 1;\n//   }\n\n//   if (a.length < b.length)\n//     return -1;\n\n//   if (a.length > b.length)\n//     return 1;\n\n//   return 0;\n// }\n\n/*\n * Expose\n */\n\nmodule.exports = Outpoint;\n"]},"metadata":{},"sourceType":"module"}