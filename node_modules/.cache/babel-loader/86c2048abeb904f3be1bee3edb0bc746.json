{"ast":null,"code":"/*!\n * reader.js - buffer reader for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst enforce = require('./enforce');\n\nconst encoding = require('./encoding');\n\nconst EncodingError = require('./error');\n/*\n * Constants\n */\n\n\nconst EMPTY = Buffer.alloc(0);\n/**\n * Buffer Reader\n */\n\nclass BufferReader {\n  /**\n   * Create a buffer reader.\n   * @constructor\n   * @param {Buffer} data\n   * @param {Boolean?} zeroCopy - Do not reallocate buffers when\n   * slicing. Note that this can lead to memory leaks if not used\n   * carefully.\n   */\n  constructor(data) {\n    let zeroCopy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    enforce(Buffer.isBuffer(data), 'data', 'buffer');\n    enforce(typeof zeroCopy === 'boolean', 'zeroCopy', 'boolean');\n    this.data = data;\n    this.offset = 0;\n    this.zeroCopy = zeroCopy;\n    this.stack = [];\n  }\n  /**\n   * Assertion.\n   * @param {Number} size\n   */\n\n\n  check(size) {\n    if (this.offset + size > this.data.length) throw new EncodingError(this.offset, 'Out of bounds read', this.check);\n  }\n  /**\n   * Get total size of passed-in Buffer.\n   * @returns {Buffer}\n   */\n\n\n  getSize() {\n    return this.data.length;\n  }\n  /**\n   * Calculate number of bytes left to read.\n   * @returns {Number}\n   */\n\n\n  left() {\n    this.check(0);\n    return this.data.length - this.offset;\n  }\n  /**\n   * Seek to a position to read from by offset.\n   * @param {Number} off - Offset (positive or negative).\n   */\n\n\n  seek(off) {\n    enforce(Number.isSafeInteger(off), 'off', 'integer');\n    if (this.offset + off < 0) throw new EncodingError(this.offset, 'Out of bounds read');\n    this.check(off);\n    this.offset += off;\n    return this;\n  }\n  /**\n   * Mark the current starting position.\n   */\n\n\n  start() {\n    this.stack.push(this.offset);\n    return this.offset;\n  }\n  /**\n   * Stop reading. Pop the start position off the stack\n   * and calculate the size of the data read.\n   * @returns {Number} Size.\n   * @throws on empty stack.\n   */\n\n\n  end() {\n    if (this.stack.length === 0) throw new Error('Cannot end without a stack item.');\n    const start = this.stack.pop();\n    return this.offset - start;\n  }\n  /**\n   * Stop reading. Pop the start position off the stack\n   * and return the data read.\n   * @param {Bolean?} zeroCopy - Do a fast buffer\n   * slice instead of allocating a new buffer (warning:\n   * may cause memory leaks if not used with care).\n   * @returns {Buffer} Data read.\n   * @throws on empty stack.\n   */\n\n\n  endData() {\n    let zeroCopy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    enforce(typeof zeroCopy === 'boolean', 'zeroCopy', 'boolean');\n    if (this.stack.length === 0) throw new Error('Cannot end without a stack item.');\n    const start = this.stack.pop();\n    const end = this.offset;\n    const size = end - start;\n    const data = this.data;\n    if (size === data.length) return data;\n    if (this.zeroCopy || zeroCopy) return data.slice(start, end);\n    const ret = Buffer.allocUnsafeSlow(size);\n    data.copy(ret, 0, start, end);\n    return ret;\n  }\n  /**\n   * Destroy the reader. Remove references to the data.\n   */\n\n\n  destroy() {\n    this.data = EMPTY;\n    this.offset = 0;\n    this.stack.length = 0;\n    return this;\n  }\n  /**\n   * Read uint8.\n   * @returns {Number}\n   */\n\n\n  readU8() {\n    this.check(1);\n    const ret = this.data[this.offset];\n    this.offset += 1;\n    return ret;\n  }\n  /**\n   * Read uint16le.\n   * @returns {Number}\n   */\n\n\n  readU16() {\n    this.check(2);\n    const ret = encoding.readU16(this.data, this.offset);\n    this.offset += 2;\n    return ret;\n  }\n  /**\n   * Read uint16be.\n   * @returns {Number}\n   */\n\n\n  readU16BE() {\n    this.check(2);\n    const ret = encoding.readU16BE(this.data, this.offset);\n    this.offset += 2;\n    return ret;\n  }\n  /**\n   * Read uint24le.\n   * @returns {Number}\n   */\n\n\n  readU24() {\n    this.check(3);\n    const ret = encoding.readU24(this.data, this.offset);\n    this.offset += 3;\n    return ret;\n  }\n  /**\n   * Read uint24be.\n   * @returns {Number}\n   */\n\n\n  readU24BE() {\n    this.check(3);\n    const ret = encoding.readU24BE(this.data, this.offset);\n    this.offset += 3;\n    return ret;\n  }\n  /**\n   * Read uint32le.\n   * @returns {Number}\n   */\n\n\n  readU32() {\n    this.check(4);\n    const ret = encoding.readU32(this.data, this.offset);\n    this.offset += 4;\n    return ret;\n  }\n  /**\n   * Read uint32be.\n   * @returns {Number}\n   */\n\n\n  readU32BE() {\n    this.check(4);\n    const ret = encoding.readU32BE(this.data, this.offset);\n    this.offset += 4;\n    return ret;\n  }\n  /**\n   * Read uint40le.\n   * @returns {Number}\n   */\n\n\n  readU40() {\n    this.check(5);\n    const ret = encoding.readU40(this.data, this.offset);\n    this.offset += 5;\n    return ret;\n  }\n  /**\n   * Read uint40be.\n   * @returns {Number}\n   */\n\n\n  readU40BE() {\n    this.check(5);\n    const ret = encoding.readU40BE(this.data, this.offset);\n    this.offset += 5;\n    return ret;\n  }\n  /**\n   * Read uint48le.\n   * @returns {Number}\n   */\n\n\n  readU48() {\n    this.check(6);\n    const ret = encoding.readU48(this.data, this.offset);\n    this.offset += 6;\n    return ret;\n  }\n  /**\n   * Read uint48be.\n   * @returns {Number}\n   */\n\n\n  readU48BE() {\n    this.check(6);\n    const ret = encoding.readU48BE(this.data, this.offset);\n    this.offset += 6;\n    return ret;\n  }\n  /**\n   * Read uint56le.\n   * @returns {Number}\n   */\n\n\n  readU56() {\n    this.check(7);\n    const ret = encoding.readU56(this.data, this.offset);\n    this.offset += 7;\n    return ret;\n  }\n  /**\n   * Read uint56be.\n   * @returns {Number}\n   */\n\n\n  readU56BE() {\n    this.check(7);\n    const ret = encoding.readU56BE(this.data, this.offset);\n    this.offset += 7;\n    return ret;\n  }\n  /**\n   * Read uint64le as a js number.\n   * @returns {Number}\n   * @throws on num > MAX_SAFE_INTEGER\n   */\n\n\n  readU64() {\n    this.check(8);\n    const ret = encoding.readU64(this.data, this.offset);\n    this.offset += 8;\n    return ret;\n  }\n  /**\n   * Read uint64be as a js number.\n   * @returns {Number}\n   * @throws on num > MAX_SAFE_INTEGER\n   */\n\n\n  readU64BE() {\n    this.check(8);\n    const ret = encoding.readU64BE(this.data, this.offset);\n    this.offset += 8;\n    return ret;\n  }\n  /**\n   * Read int8.\n   * @returns {Number}\n   */\n\n\n  readI8() {\n    this.check(1);\n    const ret = encoding.readI8(this.data, this.offset);\n    this.offset += 1;\n    return ret;\n  }\n  /**\n   * Read int16le.\n   * @returns {Number}\n   */\n\n\n  readI16() {\n    this.check(2);\n    const ret = encoding.readI16(this.data, this.offset);\n    this.offset += 2;\n    return ret;\n  }\n  /**\n   * Read int16be.\n   * @returns {Number}\n   */\n\n\n  readI16BE() {\n    this.check(2);\n    const ret = encoding.readI16BE(this.data, this.offset);\n    this.offset += 2;\n    return ret;\n  }\n  /**\n   * Read int24le.\n   * @returns {Number}\n   */\n\n\n  readI24() {\n    this.check(3);\n    const ret = encoding.readI24(this.data, this.offset);\n    this.offset += 3;\n    return ret;\n  }\n  /**\n   * Read int24be.\n   * @returns {Number}\n   */\n\n\n  readI24BE() {\n    this.check(3);\n    const ret = encoding.readI24BE(this.data, this.offset);\n    this.offset += 3;\n    return ret;\n  }\n  /**\n   * Read int32le.\n   * @returns {Number}\n   */\n\n\n  readI32() {\n    this.check(4);\n    const ret = encoding.readI32(this.data, this.offset);\n    this.offset += 4;\n    return ret;\n  }\n  /**\n   * Read int32be.\n   * @returns {Number}\n   */\n\n\n  readI32BE() {\n    this.check(4);\n    const ret = encoding.readI32BE(this.data, this.offset);\n    this.offset += 4;\n    return ret;\n  }\n  /**\n   * Read int40le.\n   * @returns {Number}\n   */\n\n\n  readI40() {\n    this.check(5);\n    const ret = encoding.readI40(this.data, this.offset);\n    this.offset += 5;\n    return ret;\n  }\n  /**\n   * Read int40be.\n   * @returns {Number}\n   */\n\n\n  readI40BE() {\n    this.check(5);\n    const ret = encoding.readI40BE(this.data, this.offset);\n    this.offset += 5;\n    return ret;\n  }\n  /**\n   * Read int48le.\n   * @returns {Number}\n   */\n\n\n  readI48() {\n    this.check(6);\n    const ret = encoding.readI48(this.data, this.offset);\n    this.offset += 6;\n    return ret;\n  }\n  /**\n   * Read int48be.\n   * @returns {Number}\n   */\n\n\n  readI48BE() {\n    this.check(6);\n    const ret = encoding.readI48BE(this.data, this.offset);\n    this.offset += 6;\n    return ret;\n  }\n  /**\n   * Read int56le.\n   * @returns {Number}\n   */\n\n\n  readI56() {\n    this.check(7);\n    const ret = encoding.readI56(this.data, this.offset);\n    this.offset += 7;\n    return ret;\n  }\n  /**\n   * Read int56be.\n   * @returns {Number}\n   */\n\n\n  readI56BE() {\n    this.check(7);\n    const ret = encoding.readI56BE(this.data, this.offset);\n    this.offset += 7;\n    return ret;\n  }\n  /**\n   * Read int64le as a js number.\n   * @returns {Number}\n   * @throws on num > MAX_SAFE_INTEGER\n   */\n\n\n  readI64() {\n    this.check(8);\n    const ret = encoding.readI64(this.data, this.offset);\n    this.offset += 8;\n    return ret;\n  }\n  /**\n   * Read int64be as a js number.\n   * @returns {Number}\n   * @throws on num > MAX_SAFE_INTEGER\n   */\n\n\n  readI64BE() {\n    this.check(8);\n    const ret = encoding.readI64BE(this.data, this.offset);\n    this.offset += 8;\n    return ret;\n  }\n  /**\n   * Read float le.\n   * @returns {Number}\n   */\n\n\n  readFloat() {\n    this.check(4);\n    const ret = encoding.readFloat(this.data, this.offset);\n    this.offset += 4;\n    return ret;\n  }\n  /**\n   * Read float be.\n   * @returns {Number}\n   */\n\n\n  readFloatBE() {\n    this.check(4);\n    const ret = encoding.readFloatBE(this.data, this.offset);\n    this.offset += 4;\n    return ret;\n  }\n  /**\n   * Read double float le.\n   * @returns {Number}\n   */\n\n\n  readDouble() {\n    this.check(8);\n    const ret = encoding.readDouble(this.data, this.offset);\n    this.offset += 8;\n    return ret;\n  }\n  /**\n   * Read double float be.\n   * @returns {Number}\n   */\n\n\n  readDoubleBE() {\n    this.check(8);\n    const ret = encoding.readDoubleBE(this.data, this.offset);\n    this.offset += 8;\n    return ret;\n  }\n  /**\n   * Read a varint.\n   * @returns {Number}\n   */\n\n\n  readVarint() {\n    const {\n      size,\n      value\n    } = encoding.readVarint(this.data, this.offset);\n    this.offset += size;\n    return value;\n  }\n  /**\n   * Read a varint (type 2).\n   * @returns {Number}\n   */\n\n\n  readVarint2() {\n    const {\n      size,\n      value\n    } = encoding.readVarint2(this.data, this.offset);\n    this.offset += size;\n    return value;\n  }\n  /**\n   * Read N bytes (will do a fast slice if zero copy).\n   * @param {Number} size\n   * @param {Bolean?} zeroCopy - Do a fast buffer\n   * slice instead of allocating a new buffer (warning:\n   * may cause memory leaks if not used with care).\n   * @returns {Buffer}\n   */\n\n\n  readBytes(size) {\n    let zeroCopy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    enforce(size >>> 0 === size, 'size', 'integer');\n    enforce(typeof zeroCopy === 'boolean', 'zeroCopy', 'boolean');\n    this.check(size);\n    let ret;\n\n    if (this.zeroCopy || zeroCopy) {\n      ret = this.data.slice(this.offset, this.offset + size);\n    } else {\n      ret = Buffer.allocUnsafeSlow(size);\n      this.data.copy(ret, 0, this.offset, this.offset + size);\n    }\n\n    this.offset += size;\n    return ret;\n  }\n  /**\n   * Read a varint number of bytes (will do a fast slice if zero copy).\n   * @param {Bolean?} zeroCopy - Do a fast buffer\n   * slice instead of allocating a new buffer (warning:\n   * may cause memory leaks if not used with care).\n   * @returns {Buffer}\n   */\n\n\n  readVarBytes() {\n    let zeroCopy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return this.readBytes(this.readVarint(), zeroCopy);\n  }\n  /**\n   * Slice N bytes and create a child reader.\n   * @param {Number} size\n   * @returns {BufferReader}\n   */\n\n\n  readChild(size) {\n    enforce(size >>> 0 === size, 'size', 'integer');\n    this.check(size);\n    const data = this.data.slice(0, this.offset + size);\n    const br = new this.constructor(data);\n    br.offset = this.offset;\n    this.offset += size;\n    return br;\n  }\n  /**\n   * Read a string.\n   * @param {Number} size\n   * @param {String} enc - Any buffer-supported encoding.\n   * @returns {String}\n   */\n\n\n  readString(size, enc) {\n    if (enc == null) enc = 'binary';\n    enforce(size >>> 0 === size, 'size', 'integer');\n    enforce(typeof enc === 'string', 'enc', 'string');\n    this.check(size);\n    const ret = this.data.toString(enc, this.offset, this.offset + size);\n    this.offset += size;\n    return ret;\n  }\n  /**\n   * Read a 32-byte hash.\n   * @param {String} enc - `\"hex\"` or `null`.\n   * @returns {Hash|Buffer}\n   */\n\n\n  readHash(enc) {\n    if (enc) return this.readString(32, enc);\n    return this.readBytes(32);\n  }\n  /**\n   * Read string of a varint length.\n   * @param {String} enc - Any buffer-supported encoding.\n   * @param {Number?} limit - Size limit.\n   * @returns {String}\n   */\n\n\n  readVarString(enc) {\n    let limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (enc == null) enc = 'binary';\n    enforce(typeof enc === 'string', 'enc', 'string');\n    enforce(limit >>> 0 === limit, 'limit', 'integer');\n    const size = this.readVarint();\n    if (limit !== 0 && size > limit) throw new EncodingError(this.offset, 'String exceeds limit');\n    return this.readString(size, enc);\n  }\n  /**\n   * Read a null-terminated string.\n   * @param {String} enc - Any buffer-supported encoding.\n   * @returns {String}\n   */\n\n\n  readNullString(enc) {\n    if (enc == null) enc = 'binary';\n    enforce(typeof enc === 'string', 'enc', 'string');\n    let i = this.offset;\n\n    for (; i < this.data.length; i++) {\n      if (this.data[i] === 0) break;\n    }\n\n    if (i === this.data.length) throw new EncodingError(this.offset, 'No NUL terminator');\n    const ret = this.readString(i - this.offset, enc);\n    this.offset = i + 1;\n    return ret;\n  }\n  /**\n   * Create a checksum from the last start position.\n   * @param {Function} hash\n   * @returns {Number} Checksum.\n   */\n\n\n  createChecksum(hash) {\n    if (!hash || typeof hash.digest !== 'function') enforce(typeof hash === 'function', 'hash', 'function');\n    let start = 0;\n    if (this.stack.length > 0) start = this.stack[this.stack.length - 1];\n    const data = this.data.slice(start, this.offset);\n    const raw = hash.digest ? hash.digest(data) : hash(data);\n    return encoding.readU32(raw, 0);\n  }\n  /**\n   * Verify a 4-byte checksum against a calculated checksum.\n   * @param {Function} hash\n   * @returns {Number} checksum\n   * @throws on bad checksum\n   */\n\n\n  verifyChecksum(hash) {\n    const checksum = this.createChecksum(hash);\n    const expect = this.readU32();\n    if (checksum !== expect) throw new EncodingError(this.offset, 'Checksum mismatch');\n    return checksum;\n  }\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = BufferReader;","map":null,"metadata":{},"sourceType":"script"}