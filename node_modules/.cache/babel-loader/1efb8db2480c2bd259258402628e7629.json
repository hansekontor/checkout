{"ast":null,"code":"/*!\n * payment.js - bip70 payment for bcoin\n * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst ProtoReader = require('./utils/protoreader');\n\nconst ProtoWriter = require('./utils/protowriter');\n\nconst {\n  setData,\n  getData\n} = require('./paymentdetails').prototype;\n/**\n * BIP70 Payment\n */\n\n\nclass Payment {\n  /**\n   * Create a payment.\n   * @constructor\n   * @param {Object?} options\n   * @property {Buffer} merchantData\n   * @property {Buffer[]} transactions\n   * @property {Buffer[]} refundTo\n   * @property {String|null} memo\n   */\n  constructor(options) {\n    this.merchantData = null;\n    this.transactions = [];\n    this.refundTo = [];\n    this.memo = null;\n    if (options) this.fromOptions(options);\n  }\n  /**\n   * Inject properties from options.\n   * @private\n   * @param {Object} options\n   * @returns {Payment}\n   */\n\n\n  fromOptions(options) {\n    if (options.merchantData) this.setData(options.merchantData);\n\n    if (options.transactions) {\n      assert(Array.isArray(options.transactions));\n\n      for (const tx of options.transactions) {\n        assert(Buffer.isBuffer(tx));\n        this.transactions.push(tx);\n      }\n    }\n\n    if (options.refundTo) {\n      assert(Array.isArray(options.refundTo));\n\n      for (const output of options.refundTo) {\n        assert(output && typeof output === 'object');\n        assert(Number.isSafeInteger(output.value) && output.value >= 0);\n        assert(Buffer.isBuffer(output.script));\n        this.refundTo.push(output);\n      }\n    }\n\n    if (options.memo != null) {\n      assert(typeof options.memo === 'string');\n      this.memo = options.memo;\n    }\n\n    return this;\n  }\n  /**\n   * Instantiate payment from options.\n   * @param {Object} options\n   * @returns {Payment}\n   */\n\n\n  static fromOptions(options) {\n    return new Payment().fromOptions(options);\n  }\n  /**\n   * Set payment details.\n   * @param {Object} data\n   * @param {String?} enc\n   */\n\n\n  setData(data, enc) {\n    return setData.call(this, data, enc);\n  }\n  /**\n   * Get payment details.\n   * @param {String?} enc\n   * @returns {String|Object|null}\n   */\n\n\n  getData(enc) {\n    return getData.call(this, enc);\n  }\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   * @returns {Payment}\n   */\n\n\n  fromRaw(data) {\n    const br = new ProtoReader(data);\n    this.merchantData = br.readFieldBytes(1, true);\n\n    while (br.nextTag() === 2) {\n      const tx = br.readFieldBytes(2);\n      this.transactions.push(tx);\n    }\n\n    while (br.nextTag() === 3) {\n      const op = new ProtoReader(br.readFieldBytes(3));\n      const output = {\n        value: op.readFieldU64(1, true),\n        script: op.readFieldBytes(2, true)\n      };\n      this.refundTo.push(output);\n    }\n\n    this.memo = br.readFieldString(4, true);\n    return this;\n  }\n  /**\n   * Instantiate payment from serialized data.\n   * @param {Buffer} data\n   * @returns {Payment}\n   */\n\n\n  static fromRaw(data, enc) {\n    if (typeof data === 'string') data = Buffer.from(data, enc);\n    return new Payment().fromRaw(data);\n  }\n  /**\n   * Serialize the payment (protobuf).\n   * @returns {Buffer}\n   */\n\n\n  toRaw() {\n    const bw = new ProtoWriter();\n    if (this.merchantData) bw.writeFieldBytes(1, this.merchantData);\n\n    for (const tx of this.transactions) bw.writeFieldBytes(2, tx);\n\n    for (const output of this.refundTo) {\n      const op = new ProtoWriter();\n      op.writeFieldU64(1, output.value);\n      op.writeFieldBytes(2, output.script);\n      bw.writeFieldBytes(3, op.render());\n    }\n\n    if (this.memo != null) bw.writeFieldString(4, this.memo);\n    return bw.render();\n  }\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = Payment;","map":null,"metadata":{},"sourceType":"script"}