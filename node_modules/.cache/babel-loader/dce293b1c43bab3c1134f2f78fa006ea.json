{"ast":null,"code":"/*!\n * tx.js - transaction object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bio = require('bufio');\n\nconst hash256 = require('bcrypto/lib/hash256');\n\nconst secp256k1 = require('bcrypto/lib/secp256k1');\n\nconst {\n  BufferSet\n} = require('buffer-map');\n\nconst util = require('../utils/util');\n\nconst Amount = require('../btc/amount');\n\nconst Network = require('../protocol/network');\n\nconst Script = require('../script/script');\n\nconst SLP = require('../script/slp');\n\nconst Input = require('./input');\n\nconst Output = require('./output');\n\nconst Outpoint = require('./outpoint');\n\nconst InvItem = require('./invitem');\n\nconst consensus = require('../protocol/consensus');\n\nconst policy = require('../protocol/policy');\n\nconst ScriptError = require('../script/scripterror');\n\nconst {\n  encoding\n} = bio;\nconst {\n  hashType\n} = Script;\n\nconst common = require('../script/common');\n\nconst {\n  inspectSymbol\n} = require('../utils');\n/**\n * TX\n * A static transaction object.\n * @alias module:primitives.TX\n * @property {Number} version\n * @property {Input[]} inputs\n * @property {Output[]} outputs\n * @property {Number} locktime\n * @property {SlpTokenRecord?} slpToken\n */\n\n\nclass TX {\n  /**\n   * Create a transaction.\n   * @constructor\n   * @param {Object?} options\n   */\n  constructor(options) {\n    this.version = 1;\n    this.inputs = [];\n    this.outputs = [];\n    this.locktime = 0;\n    this.mutable = false;\n    this._hash = null;\n    this._hhash = null;\n    this._raw = null;\n    this._offset = -1;\n    this._block = false;\n    this._size = -1;\n    this._sigops = -1;\n    this._hashPrevouts = null;\n    this._hashSequence = null;\n    this._hashOutputs = null;\n    if (options) this.fromOptions(options);\n  }\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n\n  fromOptions(options) {\n    assert(options, 'TX data is required.');\n\n    if (options.version != null) {\n      assert(options.version >>> 0 === options.version, 'Version must be a uint32.');\n      this.version = options.version;\n    }\n\n    if (options.inputs) {\n      assert(Array.isArray(options.inputs), 'Inputs must be an array.');\n\n      for (const input of options.inputs) this.inputs.push(new Input(input));\n    }\n\n    if (options.outputs) {\n      assert(Array.isArray(options.outputs), 'Outputs must be an array.');\n\n      for (const output of options.outputs) this.outputs.push(new Output(output));\n    }\n\n    if (options.locktime != null) {\n      assert(options.locktime >>> 0 === options.locktime, 'Locktime must be a uint32.');\n      this.locktime = options.locktime;\n    }\n\n    if (options.slpToken.constructor === SLP.TokenRecord().constructor) {\n      this.slpToken = options.slpToken;\n    }\n\n    return this;\n  }\n  /**\n   * Instantiate TX from options object.\n   * @param {Object} options\n   * @returns {TX}\n   */\n\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n  /**\n   * Clone the transaction.\n   * @returns {TX}\n   */\n\n\n  clone() {\n    return new this.constructor().inject(this);\n  }\n  /**\n   * Inject properties from tx.\n   * Used for cloning.\n   * @private\n   * @param {TX} tx\n   * @returns {TX}\n   */\n\n\n  inject(tx) {\n    this.version = tx.version;\n\n    for (const input of tx.inputs) this.inputs.push(input.clone());\n\n    for (const output of tx.outputs) this.outputs.push(output.clone());\n\n    this.locktime = tx.locktime;\n    return this;\n  }\n  /**\n   * Clear any cached values.\n   */\n\n\n  refresh() {\n    this._hash = null;\n    this._hhash = null;\n    this._raw = null;\n    this._size = -1;\n    this._offset = -1;\n    this._block = false;\n    this._sigops = -1;\n    this._hashPrevouts = null;\n    this._hashSequence = null;\n    this._hashOutputs = null;\n  }\n  /**\n   * Hash the transaction with the non-witness serialization.\n   * @param {String?} enc - Can be `'hex'` or `null`.\n   * @returns {Hash|Buffer} hash\n   */\n\n\n  hash(enc) {\n    let h = this._hash;\n\n    if (!h) {\n      h = hash256.digest(this.toRaw());\n      if (!this.mutable) this._hash = h;\n    }\n\n    if (enc === 'hex') {\n      let hex = this._hhash;\n\n      if (!hex) {\n        hex = h.toString('hex');\n        if (!this.mutable) this._hhash = hex;\n      }\n\n      h = hex;\n    }\n\n    return h;\n  }\n  /**\n   * Serialize the transaction. Note\n   * that this is cached.\n   * @returns {Buffer} Serialized transaction.\n   */\n\n\n  toRaw() {\n    return this.frame().data;\n  }\n  /**\n   * Write the transaction to a buffer writer.\n   * @param {BufferWriter} bw\n   * @param {Boolean} block\n   */\n\n\n  toWriter(bw, block) {\n    if (this.mutable) return this.writeNormal(bw);\n\n    if (block) {\n      this._offset = bw.offset;\n      this._block = true;\n    }\n\n    bw.writeBytes(this.toRaw());\n    return bw;\n  }\n  /**\n   * Serialize the transaction. Note\n   * that this is cached.\n   * @private\n   * @returns {RawTX}\n   */\n\n\n  frame() {\n    if (this.mutable) {\n      assert(!this._raw);\n      return this.frameNormal();\n    }\n\n    if (this._raw) {\n      assert(this._size >= 0);\n      const raw = new RawTX(this._size);\n      raw.data = this._raw;\n      return raw;\n    }\n\n    const raw = this.frameNormal();\n    this._raw = raw.data;\n    this._size = raw.size;\n    return raw;\n  }\n  /**\n   * Return the offset and size of the transaction. Useful\n   * when the transaction is deserialized within a block.\n   * @returns {Object} contains `size` and `offset`.\n   */\n\n\n  getPosition() {\n    if (!(this._block && this._offset > 80)) console.log(this);\n    assert(this._block && this._offset > 80, 'Position not available.');\n    return {\n      offset: this._offset,\n      size: this._size\n    };\n  }\n  /**\n   * Calculate the real size of the transaction.\n   * @returns {Number} size\n   */\n\n\n  getSize() {\n    if (this.mutable) return this.getNormalSizes().size;\n    return this.frame().size;\n  }\n  /**\n   * Get the signature hash of the transaction for signing verifying.\n   * @param {Number} index - Index of input being signed/verified.\n   * @param {Script} prev - Previous output script or redeem script.\n   * @param {Amount} value - Previous output value.\n   * @param {SighashType} type - Sighash type.\n   * @param {Number} flags - Script flags.\n   * @returns {Buffer} Signature hash.\n   */\n\n\n  signatureHash(index, prev, value, type, flags) {\n    assert(index >= 0 && index < this.inputs.length);\n    assert(prev instanceof Script);\n    assert(typeof value === 'number');\n    assert(typeof type === 'number');\n    if (flags == null) flags = Script.flags.STANDARD_VERIFY_FLAGS;\n\n    if (flags & Script.flags.VERIFY_REPLAY_PROTECTION) {\n      const newForkValue = common.getHashTypeForkValue(type) ^ 0xdead;\n      type = common.hashTypeWithForkValue(type, newForkValue | 0xff0000);\n    }\n\n    if (type & Script.hashType.SIGHASH_FORKID && flags & Script.flags.VERIFY_SIGHASH_FORKID) {\n      return this.signatureHashV1(index, prev, value, type);\n    }\n\n    return this.signatureHashV0(index, prev, type);\n  }\n  /**\n   * Legacy sighashing -- O(n^2).\n   * @private\n   * @param {Number} index\n   * @param {Script} prev\n   * @param {SighashType} type\n   * @returns {Buffer}\n   */\n\n\n  signatureHashV0(index, prev, type) {\n    if ((type & 0x1f) === hashType.SINGLE) {\n      // Bitcoind used to return 1 as an error code:\n      // it ended up being treated like a hash.\n      if (index >= this.outputs.length) {\n        const hash = Buffer.alloc(32, 0x00);\n        hash[0] = 0x01;\n        return hash;\n      }\n    } // Remove all code separators.\n\n\n    prev = prev.removeSeparators(); // Calculate buffer size.\n\n    const size = this.hashSize(index, prev, type);\n    const bw = bio.pool(size);\n    bw.writeU32(this.version); // Serialize inputs.\n\n    if (type & hashType.ANYONECANPAY) {\n      // Serialize only the current\n      // input if ANYONECANPAY.\n      const input = this.inputs[index]; // Count.\n\n      bw.writeVarint(1); // Outpoint.\n\n      input.prevout.toWriter(bw); // Replace script with previous\n      // output script if current index.\n\n      bw.writeVarBytes(prev.toRaw());\n      bw.writeU32(input.sequence);\n    } else {\n      bw.writeVarint(this.inputs.length);\n\n      for (let i = 0; i < this.inputs.length; i++) {\n        const input = this.inputs[i]; // Outpoint.\n\n        input.prevout.toWriter(bw); // Replace script with previous\n        // output script if current index.\n\n        if (i === index) {\n          bw.writeVarBytes(prev.toRaw());\n          bw.writeU32(input.sequence);\n          continue;\n        } // Script is null.\n\n\n        bw.writeVarint(0); // Sequences are 0 if NONE or SINGLE.\n\n        switch (type & 0x1f) {\n          case hashType.NONE:\n          case hashType.SINGLE:\n            bw.writeU32(0);\n            break;\n\n          default:\n            bw.writeU32(input.sequence);\n            break;\n        }\n      }\n    } // Serialize outputs.\n\n\n    switch (type & 0x1f) {\n      case hashType.NONE:\n        {\n          // No outputs if NONE.\n          bw.writeVarint(0);\n          break;\n        }\n\n      case hashType.SINGLE:\n        {\n          const output = this.outputs[index]; // Drop all outputs after the\n          // current input index if SINGLE.\n\n          bw.writeVarint(index + 1);\n\n          for (let i = 0; i < index; i++) {\n            // Null all outputs not at\n            // current input index.\n            bw.writeI64(-1);\n            bw.writeVarint(0);\n          } // Regular serialization\n          // at current input index.\n\n\n          output.toWriter(bw);\n          break;\n        }\n\n      default:\n        {\n          // Regular output serialization if ALL.\n          bw.writeVarint(this.outputs.length);\n\n          for (const output of this.outputs) output.toWriter(bw);\n\n          break;\n        }\n    }\n\n    bw.writeU32(this.locktime); // Append the hash type.\n\n    bw.writeU32(type);\n    return hash256.digest(bw.render());\n  }\n  /**\n   * Calculate sighash size.\n   * @private\n   * @param {Number} index\n   * @param {Script} prev\n   * @param {Number} type\n   * @returns {Number}\n   */\n\n\n  hashSize(index, prev, type) {\n    let size = 0;\n    size += 4;\n\n    if (type & hashType.ANYONECANPAY) {\n      size += 1;\n      size += 36;\n      size += prev.getVarSize();\n      size += 4;\n    } else {\n      size += encoding.sizeVarint(this.inputs.length);\n      size += 41 * (this.inputs.length - 1);\n      size += 36;\n      size += prev.getVarSize();\n      size += 4;\n    }\n\n    switch (type & 0x1f) {\n      case hashType.NONE:\n        size += 1;\n        break;\n\n      case hashType.SINGLE:\n        size += encoding.sizeVarint(index + 1);\n        size += 9 * index;\n        size += this.outputs[index].getSize();\n        break;\n\n      default:\n        size += encoding.sizeVarint(this.outputs.length);\n\n        for (const output of this.outputs) size += output.getSize();\n\n        break;\n    }\n\n    size += 8;\n    return size;\n  }\n  /**\n   * Witness sighashing -- O(n).\n   * @private\n   * @param {Number} index\n   * @param {Script} prev\n   * @param {Amount} value\n   * @param {SighashType} type\n   * @returns {Buffer}\n   */\n\n\n  signatureHashV1(index, prev, value, type) {\n    const input = this.inputs[index];\n    let prevouts = consensus.ZERO_HASH;\n    let sequences = consensus.ZERO_HASH;\n    let outputs = consensus.ZERO_HASH;\n\n    if (!(type & hashType.ANYONECANPAY)) {\n      if (this._hashPrevouts) {\n        prevouts = this._hashPrevouts;\n      } else {\n        const bw = bio.pool(this.inputs.length * 36);\n\n        for (const input of this.inputs) input.prevout.toWriter(bw);\n\n        prevouts = hash256.digest(bw.render());\n        if (!this.mutable) this._hashPrevouts = prevouts;\n      }\n    }\n\n    if (!(type & hashType.ANYONECANPAY) && (type & 0x1f) !== hashType.SINGLE && (type & 0x1f) !== hashType.NONE) {\n      if (this._hashSequence) {\n        sequences = this._hashSequence;\n      } else {\n        const bw = bio.pool(this.inputs.length * 4);\n\n        for (const input of this.inputs) bw.writeU32(input.sequence);\n\n        sequences = hash256.digest(bw.render());\n        if (!this.mutable) this._hashSequence = sequences;\n      }\n    }\n\n    if ((type & 0x1f) !== hashType.SINGLE && (type & 0x1f) !== hashType.NONE) {\n      if (this._hashOutputs) {\n        outputs = this._hashOutputs;\n      } else {\n        let size = 0;\n\n        for (const output of this.outputs) size += output.getSize();\n\n        const bw = bio.pool(size);\n\n        for (const output of this.outputs) output.toWriter(bw);\n\n        outputs = hash256.digest(bw.render());\n        if (!this.mutable) this._hashOutputs = outputs;\n      }\n    } else if ((type & 0x1f) === hashType.SINGLE) {\n      if (index < this.outputs.length) {\n        const output = this.outputs[index];\n        outputs = hash256.digest(output.toRaw());\n      }\n    }\n\n    const size = 156 + prev.getVarSize();\n    const bw = bio.pool(size);\n    bw.writeU32(this.version);\n    bw.writeBytes(prevouts);\n    bw.writeBytes(sequences);\n    bw.writeHash(input.prevout.hash);\n    bw.writeU32(input.prevout.index);\n    bw.writeVarBytes(prev.toRaw());\n    bw.writeI64(value);\n    bw.writeU32(input.sequence);\n    bw.writeBytes(outputs);\n    bw.writeU32(this.locktime);\n    bw.writeU32(type);\n    return hash256.digest(bw.render());\n  }\n  /**\n   * Verify signature.\n   * @param {Number} index\n   * @param {Script} prev\n   * @param {Amount} value\n   * @param {Buffer} sig\n   * @param {Buffer} key\n   * @param {Number} flags\n   * @returns {Boolean}\n   */\n\n\n  checksig(index, prev, value, sig, key, flags) {\n    if (sig.length === 0) return false;\n    const type = sig[sig.length - 1];\n    const hash = this.signatureHash(index, prev, value, type, flags);\n    let res;\n\n    if (common.isSchnorr(sig)) {\n      res = secp256k1.schnorrVerify(hash, sig.slice(0, -1), key);\n    } else {\n      res = secp256k1.verifyDER(hash, sig.slice(0, -1), key);\n    }\n\n    return res;\n  }\n  /**\n   * Create a signature suitable for inserting into scriptSigs.\n   * @param {Number} index - Index of input being signed.\n   * @param {Script} prev - Previous output script or redeem script.\n   * @param {Amount} value - Previous output value.\n   * @param {Buffer} key\n   * @param {SighashType} type\n   * @param {Number} flags - Script flags.\n   * @returns {Buffer} Signature in SCHNORR / DER format.\n   */\n\n\n  signature(index, prev, value, key, type, flags) {\n    let sig;\n    if (type == null) type = hashType.ALL;\n    if (flags == null) flags = Script.flags.VERIFY_SIGHASH_FORKID;\n    const hash = this.signatureHash(index, prev, value, type, flags);\n    const DER = secp256k1.signDER(hash, key);\n    const SCHNORR = secp256k1.schnorrSign(hash, key);\n\n    if (common.isSchnorr(SCHNORR)) {\n      sig = SCHNORR;\n    } else {\n      sig = DER;\n    }\n\n    const bw = bio.write(sig.length + 1);\n    bw.writeBytes(sig);\n    bw.writeU8(type);\n    return bw.render();\n  }\n  /**\n   * Create a signature suitable for inserting into scriptSigs.\n   * @param {Number} index - Index of input being signed.\n   * @param {Script} prev - Previous output script or redeem script.\n   * @param {Amount} value - Previous output value.\n   * @param {Buffer} key\n   * @param {SighashType} type\n   * @param {Number} flags - Script flags.\n   * @returns {Buffer} Signature in Schnorr format.\n   */\n\n\n  schnorrSignature(index, prev, value, key, type, flags) {\n    if (type == null) type = hashType.ALL;\n    if (flags == null) flags = Script.flags.VERIFY_SIGHASH_FORKID;\n    const hash = this.signatureHash(index, prev, value, type, flags);\n    const sig = secp256k1.schnorrSign(hash, key);\n    const bw = bio.write(sig.length + 1);\n    bw.writeBytes(sig);\n    bw.writeU8(type);\n    return bw.render();\n  }\n  /**\n   * Verify all transaction inputs.\n   * @param {CoinView} view\n   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n   * @throws {ScriptError} on invalid inputs\n   */\n\n\n  check(view, flags) {\n    if (this.inputs.length === 0) throw new ScriptError('UNKNOWN_ERROR', 'No inputs.');\n    if (this.isCoinbase()) return;\n\n    for (let i = 0; i < this.inputs.length; i++) {\n      const {\n        prevout\n      } = this.inputs[i];\n      const coin = view.getOutput(prevout);\n      if (!coin) throw new ScriptError('UNKNOWN_ERROR', 'No coin available.');\n      this.checkInput(i, coin, flags);\n    }\n  }\n  /**\n   * Verify a transaction input.\n   * @param {Number} index - Index of output being\n   * verified.\n   * @param {Coin|Output} coin - Previous output.\n   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n   * @throws {ScriptError} on invalid input\n   */\n\n\n  checkInput(index, coin, flags) {\n    const input = this.inputs[index];\n    assert(input, 'Input does not exist.');\n    assert(coin, 'No coin passed.');\n    Script.verify(input.script, null, coin.script, this, index, coin.value, flags);\n  }\n  /**\n   * Verify the transaction inputs on the worker pool\n   * (if workers are enabled).\n   * @param {CoinView} view\n   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n   * @param {WorkerPool?} pool\n   * @returns {Promise}\n   */\n\n\n  async checkAsync(view, flags, pool) {\n    if (this.inputs.length === 0) throw new ScriptError('UNKNOWN_ERROR', 'No inputs.');\n    if (this.isCoinbase()) return;\n\n    if (!pool) {\n      this.check(view, flags);\n      return;\n    }\n\n    await pool.check(this, view, flags);\n  }\n  /**\n   * Verify a transaction input asynchronously.\n   * @param {Number} index - Index of output being\n   * verified.\n   * @param {Coin|Output} coin - Previous output.\n   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n   * @param {WorkerPool?} pool\n   * @returns {Promise}\n   */\n\n\n  async checkInputAsync(index, coin, flags, pool) {\n    const input = this.inputs[index];\n    assert(input, 'Input does not exist.');\n    assert(coin, 'No coin passed.');\n\n    if (!pool) {\n      this.checkInput(index, coin, flags);\n      return;\n    }\n\n    await pool.checkInput(this, index, coin, flags);\n  }\n  /**\n   * Verify all transaction inputs.\n   * @param {CoinView} view\n   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n   * @returns {Boolean} Whether the inputs are valid.\n   */\n\n\n  verify(view, flags) {\n    try {\n      this.check(view, flags);\n    } catch (e) {\n      if (e.type === 'ScriptError') return false;\n      throw e;\n    }\n\n    return true;\n  }\n  /**\n   * Verify a transaction input.\n   * @param {Number} index - Index of output being\n   * verified.\n   * @param {Coin|Output} coin - Previous output.\n   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n   * @returns {Boolean} Whether the input is valid.\n   */\n\n\n  verifyInput(index, coin, flags) {\n    try {\n      this.checkInput(index, coin, flags);\n    } catch (e) {\n      if (e.type === 'ScriptError') return false;\n      throw e;\n    }\n\n    return true;\n  }\n  /**\n   * Verify the transaction inputs on the worker pool\n   * (if workers are enabled).\n   * @param {CoinView} view\n   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n   * @param {WorkerPool?} pool\n   * @returns {Promise}\n   */\n\n\n  async verifyAsync(view, flags, pool) {\n    try {\n      await this.checkAsync(view, flags, pool);\n    } catch (e) {\n      if (e.type === 'ScriptError') return false;\n      throw e;\n    }\n\n    return true;\n  }\n  /**\n   * Verify a transaction input asynchronously.\n   * @param {Number} index - Index of output being\n   * verified.\n   * @param {Coin|Output} coin - Previous output.\n   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n   * @param {WorkerPool?} pool\n   * @returns {Promise}\n   */\n\n\n  async verifyInputAsync(index, coin, flags, pool) {\n    try {\n      await this.checkInput(index, coin, flags, pool);\n    } catch (e) {\n      if (e.type === 'ScriptError') return false;\n      throw e;\n    }\n\n    return true;\n  }\n  /**\n   * Test whether the transaction is a coinbase\n   * by examining the inputs.\n   * @returns {Boolean}\n   */\n\n\n  isCoinbase() {\n    return this.inputs.length === 1 && this.inputs[0].prevout.isNull();\n  }\n  /**\n   * Test whether the transaction is replaceable.\n   * @returns {Boolean}\n   */\n\n\n  isRBF() {\n    // Core doesn't do this, but it should:\n    if (this.version === 2) return false;\n\n    for (const input of this.inputs) {\n      if (input.isRBF()) return true;\n    }\n\n    return false;\n  }\n  /**\n   * Calculate the fee for the transaction.\n   * @param {CoinView} view\n   * @returns {Amount} fee (zero if not all coins are available).\n   */\n\n\n  getFee(view) {\n    if (!this.hasCoins(view)) return 0;\n    return this.getInputValue(view) - this.getOutputValue();\n  }\n  /**\n   * Calculate the total input value.\n   * @param {CoinView} view\n   * @returns {Amount} value\n   */\n\n\n  getInputValue(view) {\n    let total = 0;\n\n    for (const {\n      prevout\n    } of this.inputs) {\n      const coin = view.getOutput(prevout);\n      if (!coin) return 0;\n      total += coin.value;\n    }\n\n    return total;\n  }\n  /**\n   * Calculate the total output value.\n   * @returns {Amount} value\n   */\n\n\n  getOutputValue() {\n    let total = 0;\n\n    for (const output of this.outputs) total += output.value;\n\n    return total;\n  }\n  /**\n   * Get all input addresses.\n   * @private\n   * @param {CoinView} view\n   * @returns {Array} [addrs, table]\n   */\n\n\n  _getInputAddresses(view) {\n    const table = new BufferSet();\n    const addrs = [];\n    if (this.isCoinbase()) return [addrs, table];\n\n    for (const input of this.inputs) {\n      const coin = view ? view.getOutputFor(input) : null;\n      const addr = input.getAddress(coin);\n      if (!addr) continue;\n      const hash = addr.getHash();\n\n      if (!table.has(hash)) {\n        table.add(hash);\n        addrs.push(addr);\n      }\n    }\n\n    return [addrs, table];\n  }\n  /**\n   * Get all output addresses.\n   * @private\n   * @returns {Array} [addrs, table]\n   */\n\n\n  _getOutputAddresses() {\n    const table = new BufferSet();\n    const addrs = [];\n\n    for (const output of this.outputs) {\n      const addr = output.getAddress();\n      if (!addr) continue;\n      const hash = addr.getHash();\n\n      if (!table.has(hash)) {\n        table.add(hash);\n        addrs.push(addr);\n      }\n    }\n\n    return [addrs, table];\n  }\n  /**\n   * Get all addresses.\n   * @private\n   * @param {CoinView} view\n   * @returns {Array} [addrs, table]\n   */\n\n\n  _getAddresses(view) {\n    const [addrs, table] = this._getInputAddresses(view);\n\n    const output = this.getOutputAddresses();\n\n    for (const addr of output) {\n      const hash = addr.getHash();\n\n      if (!table.has(hash)) {\n        table.add(hash);\n        addrs.push(addr);\n      }\n    }\n\n    return [addrs, table];\n  }\n  /**\n   * Get all input addresses.\n   * @param {CoinView|null} view\n   * @returns {Address[]} addresses\n   */\n\n\n  getInputAddresses(view) {\n    const [addrs] = this._getInputAddresses(view);\n\n    return addrs;\n  }\n  /**\n   * Get all output addresses.\n   * @returns {Address[]} addresses\n   */\n\n\n  getOutputAddresses() {\n    const [addrs] = this._getOutputAddresses();\n\n    return addrs;\n  }\n  /**\n   * Get all addresses.\n   * @param {CoinView|null} view\n   * @returns {Address[]} addresses\n   */\n\n\n  getAddresses(view) {\n    const [addrs] = this._getAddresses(view);\n\n    return addrs;\n  }\n  /**\n   * Get all input address hashes.\n   * @param {CoinView|null} view\n   * @returns {Hash[]} hashes\n   */\n\n\n  getInputHashes(view, enc) {\n    const [, table] = this._getInputAddresses(view);\n\n    if (enc !== 'hex') return table.toArray();\n    return table.toArray().map(h => h.toString('hex'));\n  }\n  /**\n   * Get all output address hashes.\n   * @returns {Hash[]} hashes\n   */\n\n\n  getOutputHashes(enc) {\n    const [, table] = this._getOutputAddresses();\n\n    if (enc !== 'hex') return table.toArray();\n    return table.toArray().map(h => h.toString('hex'));\n  }\n  /**\n   * Get all address hashes.\n   * @param {CoinView|null} view\n   * @returns {Hash[]} hashes\n   */\n\n\n  getHashes(view, enc) {\n    const [, table] = this._getAddresses(view);\n\n    if (enc !== 'hex') return table.toArray();\n    return table.toArray().map(h => h.toString('hex'));\n  }\n  /**\n   * Test whether the transaction has\n   * all coins available.\n   * @param {CoinView} view\n   * @returns {Boolean}\n   */\n\n\n  hasCoins(view) {\n    if (this.inputs.length === 0) return false;\n\n    for (const {\n      prevout\n    } of this.inputs) {\n      if (!view.hasEntry(prevout)) return false;\n    }\n\n    return true;\n  }\n  /**\n   * Check finality of transaction by examining\n   * nLocktime and nSequence values.\n   * @example\n   * tx.isFinal(chain.height + 1, network.now());\n   * @param {Number} height - Height at which to test. This\n   * is usually the chain height, or the chain height + 1\n   * when the transaction entered the mempool.\n   * @param {Number} time - Time at which to test. This is\n   * usually the chain tip's parent's median time, or the\n   * time at which the transaction entered the mempool. If\n   * MEDIAN_TIME_PAST is enabled this will be the median\n   * time of the chain tip's previous entry's median time.\n   * @returns {Boolean}\n   */\n\n\n  isFinal(height, time) {\n    const THRESHOLD = consensus.LOCKTIME_THRESHOLD;\n    if (this.locktime === 0) return true;\n    if (this.locktime < (this.locktime < THRESHOLD ? height : time)) return true;\n\n    for (const input of this.inputs) {\n      if (input.sequence !== 0xffffffff) return false;\n    }\n\n    return true;\n  }\n  /**\n   * Verify the absolute locktime of a transaction.\n   * Called by OP_CHECKLOCKTIMEVERIFY.\n   * @param {Number} index - Index of input being verified.\n   * @param {Number} predicate - Locktime to verify against.\n   * @returns {Boolean}\n   */\n\n\n  verifyLocktime(index, predicate) {\n    const THRESHOLD = consensus.LOCKTIME_THRESHOLD;\n    const input = this.inputs[index];\n    assert(input, 'Input does not exist.');\n    assert(predicate >= 0, 'Locktime must be non-negative.'); // Locktimes must be of the same type (blocks or seconds).\n\n    if (this.locktime < THRESHOLD !== predicate < THRESHOLD) return false;\n    if (predicate > this.locktime) return false;\n    if (input.sequence === 0xffffffff) return false;\n    return true;\n  }\n  /**\n   * Verify the relative locktime of an input.\n   * Called by OP_CHECKSEQUENCEVERIFY.\n   * @param {Number} index - Index of input being verified.\n   * @param {Number} predicate - Relative locktime to verify against.\n   * @returns {Boolean}\n   */\n\n\n  verifySequence(index, predicate) {\n    const DISABLE_FLAG = consensus.SEQUENCE_DISABLE_FLAG;\n    const TYPE_FLAG = consensus.SEQUENCE_TYPE_FLAG;\n    const MASK = consensus.SEQUENCE_MASK;\n    const input = this.inputs[index];\n    assert(input, 'Input does not exist.');\n    assert(predicate >= 0, 'Locktime must be non-negative.'); // For future softfork capability.\n\n    if (predicate & DISABLE_FLAG) return true; // Version must be >=2.\n\n    if (this.version < 2) return false; // Cannot use the disable flag without\n    // the predicate also having the disable\n    // flag (for future softfork capability).\n\n    if (input.sequence & DISABLE_FLAG) return false; // Locktimes must be of the same type (blocks or seconds).\n\n    if ((input.sequence & TYPE_FLAG) !== (predicate & TYPE_FLAG)) return false;\n    if ((predicate & MASK) > (input.sequence & MASK)) return false;\n    return true;\n  }\n  /**\n   * Calculate legacy (inaccurate) sigop count.\n   * @returns {Number} sigop count\n   */\n\n\n  getLegacySigops() {\n    if (this._sigops !== -1) return this._sigops;\n    let total = 0;\n\n    for (const input of this.inputs) total += input.script.getSigops(false);\n\n    for (const output of this.outputs) total += output.script.getSigops(false);\n\n    if (!this.mutable) this._sigops = total;\n    return total;\n  }\n  /**\n   * Calculate accurate sigop count, taking into account redeem scripts.\n   * @param {CoinView} view\n   * @param {VerifyFlags} flags\n   * @returns {Number} sigop count\n   */\n\n\n  getScripthashSigops(view, flags) {\n    if (this.isCoinbase()) return 0;\n    let total = 0;\n\n    for (const input of this.inputs) {\n      const coin = view.getOutputFor(input);\n      if (!coin) continue;\n      if (!coin.script.isScripthash()) continue;\n      total += coin.script.getScripthashSigops(input.script, flags);\n    }\n\n    return total;\n  }\n  /**\n   * Calculate sigops count.\n   * @param {CoinView} view\n   * @param {VerifyFlags?} flags\n   * @returns {Number} sigop count\n   */\n\n\n  getSigopsCount(view, flags) {\n    if (flags === null) flags = Script.flags.STANDARD_VERIFY_FLAGS;\n    let cost = this.getLegacySigops();\n    if (flags & Script.flags.VERIFY_P2SH) cost += this.getScripthashSigops(view, flags);\n    return cost;\n  }\n  /**\n   * Calculate sigop count.\n   * @param {CoinView} view\n   * @param {VerifyFlags?} flags\n   * @returns {Number} sigop count\n   */\n\n\n  getSigops(view, flags) {\n    return this.getSigopsCount(view, flags);\n  }\n  /**\n   * Non-contextual sanity checks for the transaction.\n   * Will mostly verify coin and output values.\n   * @see CheckTransaction()\n   * @returns {Array} [result, reason, score]\n   */\n\n\n  isSane() {\n    const [valid] = this.checkSanity();\n    return valid;\n  }\n  /**\n   * Non-contextual sanity checks for the transaction.\n   * Will mostly verify coin and output values.\n   * @see CheckTransaction()\n   * @returns {Array} [valid, reason, score]\n   */\n\n\n  checkSanity() {\n    if (this.inputs.length === 0) return [false, 'bad-txns-vin-empty', 100];\n    if (this.outputs.length === 0) return [false, 'bad-txns-vout-empty', 100];\n    if (this.getSize() > consensus.MAX_TX_SIZE) return [false, 'bad-txns-oversize', 100];\n    let total = 0;\n\n    for (const output of this.outputs) {\n      if (output.value < 0) return [false, 'bad-txns-vout-negative', 100];\n      if (output.value > consensus.MAX_MONEY) return [false, 'bad-txns-vout-toolarge', 100];\n      total += output.value;\n      if (total < 0 || total > consensus.MAX_MONEY) return [false, 'bad-txns-txouttotal-toolarge', 100];\n    }\n\n    const prevout = new BufferSet();\n\n    for (const input of this.inputs) {\n      const key = input.prevout.toKey();\n      if (prevout.has(key)) return [false, 'bad-txns-inputs-duplicate', 100];\n      prevout.add(key);\n    }\n\n    if (this.isCoinbase()) {\n      const size = this.inputs[0].script.getSize();\n      if (size < 2 || size > consensus.MAX_COINBASE_SCRIPTSIG_SIZE) return [false, 'bad-cb-length', 100];\n    } else {\n      for (const input of this.inputs) {\n        if (input.prevout.isNull()) return [false, 'bad-txns-prevout-null', 10];\n      }\n    }\n\n    return [true, 'valid', 0];\n  }\n  /**\n   * Non-contextual checks to determine whether the\n   * transaction has all standard output script\n   * types and standard input script size with only\n   * pushdatas in the code.\n   * Will mostly verify coin and output values.\n   * @see IsStandardTx()\n   * @returns {Array} [valid, reason, score]\n   */\n\n\n  isStandard() {\n    const [valid] = this.checkStandard();\n    return valid;\n  }\n  /**\n   * Non-contextual checks to determine whether the\n   * transaction has all standard output script\n   * types and standard input script size with only\n   * pushdatas in the code.\n   * Will mostly verify coin and output values.\n   * @see IsStandardTx()\n   * @returns {Array} [valid, reason, score]\n   */\n\n\n  checkStandard() {\n    if (this.version < 1 || this.version > policy.MAX_TX_VERSION) return [false, 'version', 0]; // MAX_STANDARD_TX_SIZE\n\n    if (this.getSize() >= policy.MAX_TX_SIZE) return [false, 'tx-size', 0];\n\n    for (const input of this.inputs) {\n      if (input.script.getSize() > 1650) return [false, 'scriptsig-size', 0];\n      if (!input.script.isPushOnly()) return [false, 'scriptsig-not-pushonly', 0];\n    }\n\n    let nulldata = 0;\n\n    for (const output of this.outputs) {\n      if (!output.script.isStandard()) return [false, 'scriptpubkey', 0];\n\n      if (output.script.isNulldata()) {\n        nulldata++;\n        continue;\n      }\n\n      if (output.script.isMultisig() && !policy.BARE_MULTISIG) return [false, 'bare-multisig', 0];\n      if (output.isDust(policy.MIN_RELAY)) return [false, 'dust', 0];\n    }\n\n    if (nulldata > 1) return [false, 'multi-op-return', 0];\n    return [true, 'valid', 0];\n  }\n  /**\n   * Perform contextual checks to verify coin and input\n   * script standardness (including the redeem script).\n   * @see AreInputsStandard()\n   * @param {CoinView} view\n   * @param {VerifyFlags?} flags\n   * @returns {Boolean}\n   */\n\n\n  hasStandardInputs(view) {\n    if (this.isCoinbase()) return true;\n\n    for (const input of this.inputs) {\n      const coin = view.getOutputFor(input);\n      if (!coin) return false;\n      if (coin.script.isPubkeyhash()) continue;\n\n      if (coin.script.isScripthash()) {\n        const redeem = input.script.getRedeem();\n        if (!redeem) return false;\n        if (redeem.getSigops(true) > policy.MAX_P2SH_SIGOPS) return false;\n        continue;\n      }\n\n      if (coin.script.isUnknown()) return false;\n    }\n\n    return true;\n  }\n  /**\n   * Perform contextual checks to verify input, output,\n   * and fee values, as well as coinbase spend maturity\n   * (coinbases can only be spent 100 blocks or more\n   * after they're created). Note that this function is\n   * consensus critical.\n   * @param {CoinView} view\n   * @param {Number} height - Height at which the\n   * transaction is being spent. In the mempool this is\n   * the chain height plus one at the time it entered the pool.\n   * @returns {Boolean}\n   */\n\n\n  verifyInputs(view, height) {\n    const [fee] = this.checkInputs(view, height);\n    return fee !== -1;\n  }\n  /**\n   * Perform contextual checks to verify input, output,\n   * and fee values, as well as coinbase spend maturity\n   * (coinbases can only be spent 100 blocks or more\n   * after they're created). Note that this function is\n   * consensus critical.\n   * @param {CoinView} view\n   * @param {Number} height - Height at which the\n   * transaction is being spent. In the mempool this is\n   * the chain height plus one at the time it entered the pool.\n   * @returns {Array} [fee, reason, score]\n   */\n\n\n  checkInputs(view, height) {\n    assert(typeof height === 'number');\n    let total = 0;\n\n    for (const {\n      prevout\n    } of this.inputs) {\n      const entry = view.getEntry(prevout);\n      if (!entry) return [-1, 'bad-txns-inputs-missingorspent', 0];\n\n      if (entry.coinbase) {\n        if (height - entry.height < consensus.COINBASE_MATURITY) return [-1, 'bad-txns-premature-spend-of-coinbase', 0];\n      }\n\n      const coin = view.getOutput(prevout);\n      assert(coin);\n      if (coin.value < 0 || coin.value > consensus.MAX_MONEY) return [-1, 'bad-txns-inputvalues-outofrange', 100];\n      total += coin.value;\n      if (total < 0 || total > consensus.MAX_MONEY) return [-1, 'bad-txns-inputvalues-outofrange', 100];\n    } // Overflows already checked in `isSane()`.\n\n\n    const value = this.getOutputValue();\n    if (total < value) return [-1, 'bad-txns-in-belowout', 100];\n    const fee = total - value;\n    if (fee < 0) return [-1, 'bad-txns-fee-negative', 100];\n    if (fee > consensus.MAX_MONEY) return [-1, 'bad-txns-fee-outofrange', 100];\n    return [fee, 'valid', 0];\n  }\n  /**\n   * Calculate the modified size of the transaction. This\n   * is used in the mempool for calculating priority.\n   * @param {Number?} size - The size to modify. If not present,\n   * virtual size will be used.\n   * @returns {Number} Modified size.\n   */\n\n\n  getModifiedSize(size) {\n    if (size == null) size = this.getSize();\n\n    for (const input of this.inputs) {\n      const offset = 41 + Math.min(110, input.script.getSize());\n      if (size > offset) size -= offset;\n    }\n\n    return size;\n  }\n  /**\n   * Calculate the transaction priority.\n   * @param {CoinView} view\n   * @param {Number} height\n   * @param {Number?} size - Size to calculate priority\n   * based on. If not present, virtual size will be used.\n   * @returns {Number}\n   */\n\n\n  getPriority(view, height, size) {\n    assert(typeof height === 'number', 'Must pass in height.');\n    if (this.isCoinbase()) return 0;\n    if (size == null) size = this.getSize();\n    let sum = 0;\n\n    for (const {\n      prevout\n    } of this.inputs) {\n      const coin = view.getOutput(prevout);\n      if (!coin) continue;\n      const coinHeight = view.getHeight(prevout);\n      if (coinHeight === -1) continue;\n\n      if (coinHeight <= height) {\n        const age = height - coinHeight;\n        sum += coin.value * age;\n      }\n    }\n\n    return Math.floor(sum / size);\n  }\n  /**\n   * Calculate the transaction's on-chain value.\n   * @param {CoinView} view\n   * @returns {Number}\n   */\n\n\n  getChainValue(view) {\n    if (this.isCoinbase()) return 0;\n    let value = 0;\n\n    for (const {\n      prevout\n    } of this.inputs) {\n      const coin = view.getOutput(prevout);\n      if (!coin) continue;\n      const height = view.getHeight(prevout);\n      if (height === -1) continue;\n      value += coin.value;\n    }\n\n    return value;\n  }\n  /**\n   * Determine whether the transaction is above the\n   * free threshold in priority. A transaction which\n   * passed this test is most likely relayable\n   * without a fee.\n   * @param {CoinView} view\n   * @param {Number?} height - If not present, tx\n   * height or network height will be used.\n   * @param {Number?} size - If not present, modified\n   * size will be calculated and used.\n   * @returns {Boolean}\n   */\n\n\n  isFree(view, height, size) {\n    const priority = this.getPriority(view, height, size);\n    return priority > policy.FREE_THRESHOLD;\n  }\n  /**\n   * Calculate minimum fee in order for the transaction\n   * to be relayable (not the constant min relay fee).\n   * @param {Number?} size - If not present, max size\n   * estimation will be calculated and used.\n   * @param {Rate?} rate - Rate of satoshi per kB.\n   * @returns {Amount} fee\n   */\n\n\n  getMinFee(size, rate) {\n    if (size == null) size = this.getSize();\n    return policy.getMinFee(size, rate);\n  }\n  /**\n   * Calculate the minimum fee in order for the transaction\n   * to be relayable, but _round to the nearest kilobyte\n   * when taking into account size.\n   * @param {Number?} size - If not present, max size\n   * estimation will be calculated and used.\n   * @param {Rate?} rate - Rate of satoshi per kB.\n   * @returns {Amount} fee\n   */\n\n\n  getRoundFee(size, rate) {\n    if (size == null) size = this.getSize();\n    return policy.getRoundFee(size, rate);\n  }\n  /**\n   * Calculate the transaction's rate based on size\n   * and fees. Size will be calculated if not present.\n   * @param {CoinView} view\n   * @param {Number?} size\n   * @returns {Rate}\n   */\n\n\n  getRate(view, size) {\n    const fee = this.getFee(view);\n    if (fee < 0) return 0;\n    if (size == null) size = this.getSize();\n    return policy.getRate(size, fee);\n  }\n  /**\n   * Get all unique outpoint hashes.\n   * @returns {Hash[]} Outpoint hashes.\n   */\n\n\n  getPrevout() {\n    if (this.isCoinbase()) return [];\n    const prevout = new BufferSet();\n\n    for (const input of this.inputs) prevout.add(input.prevout.hash);\n\n    return prevout.toArray();\n  }\n  /**\n   * Test a transaction against a bloom filter using\n   * the BIP37 matching algorithm. Note that this may\n   * update the filter depending on what the `update`\n   * value is.\n   * @see \"Filter matching algorithm\":\n   * @see https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki\n   * @param {BloomFilter} filter\n   * @returns {Boolean} True if the transaction matched.\n   */\n\n\n  isWatched(filter) {\n    let found = false; // 1. Test the tx hash\n\n    if (filter.test(this.hash())) found = true; // 2. Test data elements in output scripts\n    //    (may need to update filter on match)\n\n    for (let i = 0; i < this.outputs.length; i++) {\n      const output = this.outputs[i]; // Test the output script\n\n      if (output.script.test(filter)) {\n        if (filter.update === 1\n        /* ALL */\n        ) {\n          const prevout = Outpoint.fromTX(this, i);\n          filter.add(prevout.toRaw());\n        } else if (filter.update === 2\n        /* PUBKEY_ONLY */\n        ) {\n          if (output.script.isPubkey() || output.script.isMultisig()) {\n            const prevout = Outpoint.fromTX(this, i);\n            filter.add(prevout.toRaw());\n          }\n        }\n\n        found = true;\n      }\n    }\n\n    if (found) return found; // 3. Test prev_out structure\n    // 4. Test data elements in input scripts\n\n    for (const input of this.inputs) {\n      const prevout = input.prevout; // Test the COutPoint structure\n\n      if (filter.test(prevout.toRaw())) return true; // Test the input script\n\n      if (input.script.test(filter)) return true;\n    } // 5. No match\n\n\n    return false;\n  }\n  /**\n   * Get little-endian tx hash.\n   * @returns {Hash}\n   */\n\n\n  rhash() {\n    return util.revHex(this.hash());\n  }\n  /**\n   * Get little-endian tx hash.\n   * @returns {Hash}\n   */\n\n\n  txid() {\n    return this.rhash();\n  }\n  /**\n   * Convert the tx to an inv item.\n   * @returns {InvItem}\n   */\n\n\n  toInv() {\n    return new InvItem(InvItem.types.TX, this.hash());\n  }\n  /**\n   * Inspect the transaction and return a more\n   * user-friendly representation of the data.\n   * @returns {Object}\n   */\n\n\n  [inspectSymbol]() {\n    return this.format();\n  }\n  /**\n   * Inspect the transaction and return a more\n   * user-friendly representation of the data.\n   * @param {CoinView} view\n   * @param {ChainEntry} entry\n   * @param {Number} index\n   * @returns {Object}\n   */\n\n\n  format(view, entry, index) {\n    let rate = 0;\n    let fee = 0;\n    let height = -1;\n    let block = null;\n    let time = 0;\n    let date = null;\n\n    if (view) {\n      fee = this.getFee(view);\n      rate = this.getRate(view); // Rate can exceed 53 bits in testing.\n\n      if (!Number.isSafeInteger(rate)) rate = 0;\n    }\n\n    if (entry) {\n      height = entry.height;\n      block = util.revHex(entry.hash);\n      time = entry.time;\n      date = util.date(time);\n    }\n\n    if (index == null) index = -1;\n    const hr = {\n      hash: this.txid(),\n      size: this.getSize(),\n      value: Amount.btc(this.getOutputValue()),\n      fee: Amount.btc(fee),\n      rate: Amount.btc(rate),\n      minFee: Amount.btc(this.getMinFee()),\n      height: height,\n      block: block,\n      time: time,\n      date: date,\n      index: index,\n      version: this.version,\n      inputs: this.inputs.map(input => {\n        const coin = view ? view.getOutputFor(input) : null;\n        return input.format(coin);\n      }),\n      outputs: this.outputs,\n      locktime: this.locktime\n    };\n\n    if (this.slpToken) {\n      return { ...hr,\n        slpToken: this.slpToken\n      };\n    }\n\n    return hr;\n  }\n  /**\n   * Convert the transaction to an object suitable\n   * for JSON serialization.\n   * @returns {Object}\n   */\n\n\n  toJSON() {\n    return this.getJSON();\n  }\n  /**\n   * Convert the transaction to an object suitable\n   * for JSON serialization. Note that the hashes\n   * will be reversed to abide by bitcoind's legacy\n   * of little-endian uint256s.\n   * @param {Network} network\n   * @param {CoinView} view\n   * @param {ChainEntry} entry\n   * @param {Number} index\n   * @returns {Object}\n   */\n\n\n  getJSON(network, view, entry, index) {\n    let rate, fee, height, block, time, date;\n\n    if (view) {\n      fee = this.getFee(view);\n      rate = this.getRate(view); // Rate can exceed 53 bits in testing.\n\n      if (!Number.isSafeInteger(rate)) rate = 0;\n    }\n\n    if (entry) {\n      height = entry.height;\n      block = util.revHex(entry.hash);\n      time = entry.time;\n      date = util.date(time);\n    }\n\n    network = Network.get(network);\n    const json = {\n      hash: this.txid(),\n      fee: fee,\n      rate: rate,\n      mtime: util.now(),\n      height: height,\n      block: block,\n      time: time,\n      date: date,\n      index: index,\n      version: this.version,\n      inputs: this.inputs.map(input => {\n        const coin = view ? view.getCoinFor(input) : null;\n        return input.getJSON(network, coin);\n      }),\n      outputs: this.outputs.map(output => {\n        return output.getJSON(network);\n      }),\n      locktime: this.locktime,\n      hex: this.toRaw().toString('hex')\n    };\n\n    if (this.slpToken) {\n      return { ...json,\n        slpToken: this.slpToken.getJSON()\n      };\n    }\n\n    return json;\n  }\n  /**\n   * Inject properties from a json object.\n   * @private\n   * @param {Object} json\n   */\n\n\n  fromJSON(json) {\n    assert(json, 'TX data is required.');\n    assert(json.version >>> 0 === json.version, 'Version must be a uint32.');\n    assert(Array.isArray(json.inputs), 'Inputs must be an array.');\n    assert(Array.isArray(json.outputs), 'Outputs must be an array.');\n    assert(json.locktime >>> 0 === json.locktime, 'Locktime must be a uint32.');\n    this.version = json.version;\n\n    for (const input of json.inputs) this.inputs.push(Input.fromJSON(input));\n\n    for (const output of json.outputs) this.outputs.push(Output.fromJSON(output));\n\n    this.locktime = json.locktime;\n    if (json.slpToken) this.slpToken = SLP.TokenRecord().fromJSON(json.slpToken);\n    return this;\n  }\n  /**\n   * Instantiate a transaction from a\n   * jsonified transaction object.\n   * @param {Object} json - The jsonified transaction object.\n   * @returns {TX}\n   */\n\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n  /**\n   * Instantiate a transaction from a serialized Buffer.\n   * @param {Buffer} data\n   * @param {String?} enc - Encoding, can be `'hex'` or null.\n   * @returns {TX}\n   */\n\n\n  static fromRaw(data, enc) {\n    if (typeof data === 'string') data = Buffer.from(data, enc);\n    return new this().fromRaw(data);\n  }\n  /**\n   * Instantiate a transaction from a buffer reader.\n   * @param {BufferReader} br\n   * @param {Boolean} block\n   * @returns {TX}\n   */\n\n\n  static fromReader(br, block) {\n    return new this().fromReader(br, block);\n  }\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   */\n\n\n  fromRaw(data) {\n    return this.fromReader(bio.read(data));\n  }\n  /**\n   * Inject properties from buffer reader.\n   * @private\n   * @param {BufferReader} br\n   * @param {Boolean} block\n   */\n\n\n  fromReader(br, block) {\n    const start = br.start();\n    this.version = br.readU32();\n    const inCount = br.readVarint();\n\n    for (let i = 0; i < inCount; i++) this.inputs.push(Input.fromReader(br));\n\n    const outCount = br.readVarint();\n\n    for (let i = 0; i < outCount; i++) this.outputs.push(Output.fromReader(br));\n\n    this.locktime = br.readU32();\n\n    if (block) {\n      this._offset = start;\n      this._block = true;\n    }\n\n    if (!this.mutable) {\n      this._raw = br.endData();\n      this._size = this._raw.length;\n    } else {\n      br.end();\n    }\n\n    return this;\n  }\n  /**\n   * Serialize transaction without witness.\n   * @private\n   * @returns {RawTX}\n   */\n\n\n  frameNormal() {\n    const raw = this.getNormalSizes();\n    const bw = bio.write(raw.size);\n    this.writeNormal(bw);\n    raw.data = bw.render();\n    return raw;\n  }\n  /**\n   * Serialize transaction without witness.\n   * @private\n   * @param {BufferWriter} bw\n   * @returns {RawTX}\n   */\n\n\n  writeNormal(bw) {\n    if (this.inputs.length === 0 && this.outputs.length !== 0) throw new Error('Cannot serialize zero-input tx.');\n    bw.writeU32(this.version);\n    bw.writeVarint(this.inputs.length);\n\n    for (const input of this.inputs) input.toWriter(bw);\n\n    bw.writeVarint(this.outputs.length);\n\n    for (const output of this.outputs) output.toWriter(bw);\n\n    bw.writeU32(this.locktime);\n    return bw;\n  }\n  /**\n   * Calculate the real size of the transaction\n   * without the witness vector.\n   * @returns {RawTX}\n   */\n\n\n  getNormalSizes() {\n    let base = 0;\n    base += 4;\n    base += encoding.sizeVarint(this.inputs.length);\n\n    for (const input of this.inputs) base += input.getSize();\n\n    base += encoding.sizeVarint(this.outputs.length);\n\n    for (const output of this.outputs) base += output.getSize();\n\n    base += 4;\n    return new RawTX(base, 0);\n  }\n  /**\n   * Test whether an object is a TX.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n\n  static isTX(obj) {\n    return obj instanceof TX;\n  }\n\n}\n/*\n * Helpers\n */\n\n\nclass RawTX {\n  constructor(size) {\n    this.data = null;\n    this.size = size;\n  }\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = TX;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/primitives/tx.js"],"names":["assert","require","bio","hash256","secp256k1","BufferSet","util","Amount","Network","Script","SLP","Input","Output","Outpoint","InvItem","consensus","policy","ScriptError","encoding","hashType","common","inspectSymbol","TX","constructor","options","version","inputs","outputs","locktime","mutable","_hash","_hhash","_raw","_offset","_block","_size","_sigops","_hashPrevouts","_hashSequence","_hashOutputs","fromOptions","Array","isArray","input","push","output","slpToken","TokenRecord","clone","inject","tx","refresh","hash","enc","h","digest","toRaw","hex","toString","frame","data","toWriter","bw","block","writeNormal","offset","writeBytes","frameNormal","raw","RawTX","size","getPosition","console","log","getSize","getNormalSizes","signatureHash","index","prev","value","type","flags","length","STANDARD_VERIFY_FLAGS","VERIFY_REPLAY_PROTECTION","newForkValue","getHashTypeForkValue","hashTypeWithForkValue","SIGHASH_FORKID","VERIFY_SIGHASH_FORKID","signatureHashV1","signatureHashV0","SINGLE","Buffer","alloc","removeSeparators","hashSize","pool","writeU32","ANYONECANPAY","writeVarint","prevout","writeVarBytes","sequence","i","NONE","writeI64","render","getVarSize","sizeVarint","prevouts","ZERO_HASH","sequences","writeHash","checksig","sig","key","res","isSchnorr","schnorrVerify","slice","verifyDER","signature","ALL","DER","signDER","SCHNORR","schnorrSign","write","writeU8","schnorrSignature","check","view","isCoinbase","coin","getOutput","checkInput","verify","script","checkAsync","checkInputAsync","e","verifyInput","verifyAsync","verifyInputAsync","isNull","isRBF","getFee","hasCoins","getInputValue","getOutputValue","total","_getInputAddresses","table","addrs","getOutputFor","addr","getAddress","getHash","has","add","_getOutputAddresses","_getAddresses","getOutputAddresses","getInputAddresses","getAddresses","getInputHashes","toArray","map","getOutputHashes","getHashes","hasEntry","isFinal","height","time","THRESHOLD","LOCKTIME_THRESHOLD","verifyLocktime","predicate","verifySequence","DISABLE_FLAG","SEQUENCE_DISABLE_FLAG","TYPE_FLAG","SEQUENCE_TYPE_FLAG","MASK","SEQUENCE_MASK","getLegacySigops","getSigops","getScripthashSigops","isScripthash","getSigopsCount","cost","VERIFY_P2SH","isSane","valid","checkSanity","MAX_TX_SIZE","MAX_MONEY","toKey","MAX_COINBASE_SCRIPTSIG_SIZE","isStandard","checkStandard","MAX_TX_VERSION","isPushOnly","nulldata","isNulldata","isMultisig","BARE_MULTISIG","isDust","MIN_RELAY","hasStandardInputs","isPubkeyhash","redeem","getRedeem","MAX_P2SH_SIGOPS","isUnknown","verifyInputs","fee","checkInputs","entry","getEntry","coinbase","COINBASE_MATURITY","getModifiedSize","Math","min","getPriority","sum","coinHeight","getHeight","age","floor","getChainValue","isFree","priority","FREE_THRESHOLD","getMinFee","rate","getRoundFee","getRate","getPrevout","isWatched","filter","found","test","update","fromTX","isPubkey","rhash","revHex","txid","toInv","types","format","date","Number","isSafeInteger","hr","btc","minFee","toJSON","getJSON","network","get","json","mtime","now","getCoinFor","fromJSON","fromRaw","from","fromReader","br","read","start","readU32","inCount","readVarint","outCount","endData","end","Error","base","isTX","obj","module","exports"],"mappings":"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","sourcesContent":["/*!\n * tx.js - transaction object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bio = require('bufio');\nconst hash256 = require('bcrypto/lib/hash256');\nconst secp256k1 = require('bcrypto/lib/secp256k1');\nconst {BufferSet} = require('buffer-map');\nconst util = require('../utils/util');\nconst Amount = require('../btc/amount');\nconst Network = require('../protocol/network');\nconst Script = require('../script/script');\nconst SLP = require('../script/slp');\nconst Input = require('./input');\nconst Output = require('./output');\nconst Outpoint = require('./outpoint');\nconst InvItem = require('./invitem');\nconst consensus = require('../protocol/consensus');\nconst policy = require('../protocol/policy');\nconst ScriptError = require('../script/scripterror');\nconst {encoding} = bio;\nconst {hashType} = Script;\nconst common = require('../script/common');\nconst {inspectSymbol} = require('../utils');\n\n/**\n * TX\n * A static transaction object.\n * @alias module:primitives.TX\n * @property {Number} version\n * @property {Input[]} inputs\n * @property {Output[]} outputs\n * @property {Number} locktime\n * @property {SlpTokenRecord?} slpToken\n */\n\nclass TX {\n  /**\n   * Create a transaction.\n   * @constructor\n   * @param {Object?} options\n   */\n\n  constructor(options) {\n    this.version = 1;\n    this.inputs = [];\n    this.outputs = [];\n    this.locktime = 0;\n\n    this.mutable = false;\n\n    this._hash = null;\n    this._hhash = null;\n\n    this._raw = null;\n    this._offset = -1;\n    this._block = false;\n    this._size = -1;\n    this._sigops = -1;\n\n    this._hashPrevouts = null;\n    this._hashSequence = null;\n    this._hashOutputs = null;\n\n    if (options)\n      this.fromOptions(options);\n  }\n\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n  fromOptions(options) {\n    assert(options, 'TX data is required.');\n\n    if (options.version != null) {\n      assert((options.version >>> 0) === options.version,\n        'Version must be a uint32.');\n      this.version = options.version;\n    }\n\n    if (options.inputs) {\n      assert(Array.isArray(options.inputs), 'Inputs must be an array.');\n      for (const input of options.inputs)\n        this.inputs.push(new Input(input));\n    }\n\n    if (options.outputs) {\n      assert(Array.isArray(options.outputs), 'Outputs must be an array.');\n      for (const output of options.outputs)\n        this.outputs.push(new Output(output));\n    }\n\n    if (options.locktime != null) {\n      assert((options.locktime >>> 0) === options.locktime,\n        'Locktime must be a uint32.');\n      this.locktime = options.locktime;\n    }\n\n    if (options.slpToken.constructor === SLP.TokenRecord().constructor) {\n      this.slpToken = options.slpToken;\n    }\n\n    return this;\n  }\n\n  /**\n   * Instantiate TX from options object.\n   * @param {Object} options\n   * @returns {TX}\n   */\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n\n  /**\n   * Clone the transaction.\n   * @returns {TX}\n   */\n\n  clone() {\n    return new this.constructor().inject(this);\n  }\n\n  /**\n   * Inject properties from tx.\n   * Used for cloning.\n   * @private\n   * @param {TX} tx\n   * @returns {TX}\n   */\n\n  inject(tx) {\n    this.version = tx.version;\n\n    for (const input of tx.inputs)\n      this.inputs.push(input.clone());\n\n    for (const output of tx.outputs)\n      this.outputs.push(output.clone());\n\n    this.locktime = tx.locktime;\n\n    return this;\n  }\n\n  /**\n   * Clear any cached values.\n   */\n\n  refresh() {\n    this._hash = null;\n    this._hhash = null;\n\n    this._raw = null;\n    this._size = -1;\n    this._offset = -1;\n    this._block = false;\n    this._sigops = -1;\n\n    this._hashPrevouts = null;\n    this._hashSequence = null;\n    this._hashOutputs = null;\n  }\n\n  /**\n   * Hash the transaction with the non-witness serialization.\n   * @param {String?} enc - Can be `'hex'` or `null`.\n   * @returns {Hash|Buffer} hash\n   */\n\n  hash(enc) {\n    let h = this._hash;\n\n    if (!h) {\n      h = hash256.digest(this.toRaw());\n      if (!this.mutable)\n        this._hash = h;\n    }\n\n    if (enc === 'hex') {\n      let hex = this._hhash;\n      if (!hex) {\n        hex = h.toString('hex');\n        if (!this.mutable)\n          this._hhash = hex;\n      }\n      h = hex;\n    }\n\n    return h;\n  }\n\n  /**\n   * Serialize the transaction. Note\n   * that this is cached.\n   * @returns {Buffer} Serialized transaction.\n   */\n\n  toRaw() {\n    return this.frame().data;\n  }\n\n  /**\n   * Write the transaction to a buffer writer.\n   * @param {BufferWriter} bw\n   * @param {Boolean} block\n   */\n\n  toWriter(bw, block) {\n    if (this.mutable)\n      return this.writeNormal(bw);\n\n    if (block) {\n      this._offset = bw.offset;\n      this._block = true;\n    }\n\n    bw.writeBytes(this.toRaw());\n\n    return bw;\n  }\n\n  /**\n   * Serialize the transaction. Note\n   * that this is cached.\n   * @private\n   * @returns {RawTX}\n   */\n\n  frame() {\n    if (this.mutable) {\n      assert(!this._raw);\n      return this.frameNormal();\n    }\n\n    if (this._raw) {\n      assert(this._size >= 0);\n      const raw = new RawTX(this._size);\n      raw.data = this._raw;\n      return raw;\n    }\n\n    const raw = this.frameNormal();\n\n    this._raw = raw.data;\n    this._size = raw.size;\n\n    return raw;\n  }\n\n  /**\n   * Return the offset and size of the transaction. Useful\n   * when the transaction is deserialized within a block.\n   * @returns {Object} contains `size` and `offset`.\n   */\n\n  getPosition() {\n    if (!(this._block && this._offset > 80))\n      console.log(this);\n    assert(this._block && this._offset > 80, 'Position not available.');\n\n    return {\n      offset: this._offset,\n      size: this._size\n    };\n  }\n\n  /**\n   * Calculate the real size of the transaction.\n   * @returns {Number} size\n   */\n\n  getSize() {\n    if (this.mutable)\n      return this.getNormalSizes().size;\n    return this.frame().size;\n  }\n\n  /**\n   * Get the signature hash of the transaction for signing verifying.\n   * @param {Number} index - Index of input being signed/verified.\n   * @param {Script} prev - Previous output script or redeem script.\n   * @param {Amount} value - Previous output value.\n   * @param {SighashType} type - Sighash type.\n   * @param {Number} flags - Script flags.\n   * @returns {Buffer} Signature hash.\n   */\n\n  signatureHash(index, prev, value, type, flags) {\n    assert(index >= 0 && index < this.inputs.length);\n    assert(prev instanceof Script);\n    assert(typeof value === 'number');\n    assert(typeof type === 'number');\n\n    if (flags == null)\n      flags = Script.flags.STANDARD_VERIFY_FLAGS;\n\n    if (flags & Script.flags.VERIFY_REPLAY_PROTECTION) {\n      const newForkValue = (common.getHashTypeForkValue(type) ^ 0xdead);\n      type = common.hashTypeWithForkValue(type, newForkValue | 0xff0000);\n    }\n\n    if ((type & Script.hashType.SIGHASH_FORKID)\n        && (flags & Script.flags.VERIFY_SIGHASH_FORKID)) {\n      return this.signatureHashV1(index, prev, value, type);\n    }\n\n    return this.signatureHashV0(index, prev, type);\n  }\n\n  /**\n   * Legacy sighashing -- O(n^2).\n   * @private\n   * @param {Number} index\n   * @param {Script} prev\n   * @param {SighashType} type\n   * @returns {Buffer}\n   */\n\n  signatureHashV0(index, prev, type) {\n    if ((type & 0x1f) === hashType.SINGLE) {\n      // Bitcoind used to return 1 as an error code:\n      // it ended up being treated like a hash.\n      if (index >= this.outputs.length) {\n        const hash = Buffer.alloc(32, 0x00);\n        hash[0] = 0x01;\n        return hash;\n      }\n    }\n\n    // Remove all code separators.\n    prev = prev.removeSeparators();\n\n    // Calculate buffer size.\n    const size = this.hashSize(index, prev, type);\n    const bw = bio.pool(size);\n\n    bw.writeU32(this.version);\n\n    // Serialize inputs.\n    if (type & hashType.ANYONECANPAY) {\n      // Serialize only the current\n      // input if ANYONECANPAY.\n      const input = this.inputs[index];\n\n      // Count.\n      bw.writeVarint(1);\n\n      // Outpoint.\n      input.prevout.toWriter(bw);\n\n      // Replace script with previous\n      // output script if current index.\n      bw.writeVarBytes(prev.toRaw());\n      bw.writeU32(input.sequence);\n    } else {\n      bw.writeVarint(this.inputs.length);\n      for (let i = 0; i < this.inputs.length; i++) {\n        const input = this.inputs[i];\n\n        // Outpoint.\n        input.prevout.toWriter(bw);\n\n        // Replace script with previous\n        // output script if current index.\n        if (i === index) {\n          bw.writeVarBytes(prev.toRaw());\n          bw.writeU32(input.sequence);\n          continue;\n        }\n\n        // Script is null.\n        bw.writeVarint(0);\n\n        // Sequences are 0 if NONE or SINGLE.\n        switch (type & 0x1f) {\n          case hashType.NONE:\n          case hashType.SINGLE:\n            bw.writeU32(0);\n            break;\n          default:\n            bw.writeU32(input.sequence);\n            break;\n        }\n      }\n    }\n\n    // Serialize outputs.\n    switch (type & 0x1f) {\n      case hashType.NONE: {\n        // No outputs if NONE.\n        bw.writeVarint(0);\n        break;\n      }\n      case hashType.SINGLE: {\n        const output = this.outputs[index];\n\n        // Drop all outputs after the\n        // current input index if SINGLE.\n        bw.writeVarint(index + 1);\n\n        for (let i = 0; i < index; i++) {\n          // Null all outputs not at\n          // current input index.\n          bw.writeI64(-1);\n          bw.writeVarint(0);\n        }\n\n        // Regular serialization\n        // at current input index.\n        output.toWriter(bw);\n\n        break;\n      }\n      default: {\n        // Regular output serialization if ALL.\n        bw.writeVarint(this.outputs.length);\n        for (const output of this.outputs)\n          output.toWriter(bw);\n        break;\n      }\n    }\n\n    bw.writeU32(this.locktime);\n\n    // Append the hash type.\n    bw.writeU32(type);\n\n    return hash256.digest(bw.render());\n  }\n\n  /**\n   * Calculate sighash size.\n   * @private\n   * @param {Number} index\n   * @param {Script} prev\n   * @param {Number} type\n   * @returns {Number}\n   */\n\n  hashSize(index, prev, type) {\n    let size = 0;\n\n    size += 4;\n\n    if (type & hashType.ANYONECANPAY) {\n      size += 1;\n      size += 36;\n      size += prev.getVarSize();\n      size += 4;\n    } else {\n      size += encoding.sizeVarint(this.inputs.length);\n      size += 41 * (this.inputs.length - 1);\n      size += 36;\n      size += prev.getVarSize();\n      size += 4;\n    }\n\n    switch (type & 0x1f) {\n      case hashType.NONE:\n        size += 1;\n        break;\n      case hashType.SINGLE:\n        size += encoding.sizeVarint(index + 1);\n        size += 9 * index;\n        size += this.outputs[index].getSize();\n        break;\n      default:\n        size += encoding.sizeVarint(this.outputs.length);\n        for (const output of this.outputs)\n          size += output.getSize();\n        break;\n    }\n\n    size += 8;\n\n    return size;\n  }\n\n  /**\n   * Witness sighashing -- O(n).\n   * @private\n   * @param {Number} index\n   * @param {Script} prev\n   * @param {Amount} value\n   * @param {SighashType} type\n   * @returns {Buffer}\n   */\n\n  signatureHashV1(index, prev, value, type) {\n    const input = this.inputs[index];\n    let prevouts = consensus.ZERO_HASH;\n    let sequences = consensus.ZERO_HASH;\n    let outputs = consensus.ZERO_HASH;\n\n    if (!(type & hashType.ANYONECANPAY)) {\n      if (this._hashPrevouts) {\n        prevouts = this._hashPrevouts;\n      } else {\n        const bw = bio.pool(this.inputs.length * 36);\n\n        for (const input of this.inputs)\n          input.prevout.toWriter(bw);\n\n        prevouts = hash256.digest(bw.render());\n\n        if (!this.mutable)\n          this._hashPrevouts = prevouts;\n      }\n    }\n\n    if (!(type & hashType.ANYONECANPAY)\n        && (type & 0x1f) !== hashType.SINGLE\n        && (type & 0x1f) !== hashType.NONE) {\n      if (this._hashSequence) {\n        sequences = this._hashSequence;\n      } else {\n        const bw = bio.pool(this.inputs.length * 4);\n\n        for (const input of this.inputs)\n          bw.writeU32(input.sequence);\n\n        sequences = hash256.digest(bw.render());\n\n        if (!this.mutable)\n          this._hashSequence = sequences;\n      }\n    }\n\n    if ((type & 0x1f) !== hashType.SINGLE\n        && (type & 0x1f) !== hashType.NONE) {\n      if (this._hashOutputs) {\n        outputs = this._hashOutputs;\n      } else {\n        let size = 0;\n\n        for (const output of this.outputs)\n          size += output.getSize();\n\n        const bw = bio.pool(size);\n\n        for (const output of this.outputs)\n          output.toWriter(bw);\n\n        outputs = hash256.digest(bw.render());\n\n        if (!this.mutable)\n          this._hashOutputs = outputs;\n      }\n    } else if ((type & 0x1f) === hashType.SINGLE) {\n      if (index < this.outputs.length) {\n        const output = this.outputs[index];\n        outputs = hash256.digest(output.toRaw());\n      }\n    }\n\n    const size = 156 + prev.getVarSize();\n    const bw = bio.pool(size);\n\n    bw.writeU32(this.version);\n    bw.writeBytes(prevouts);\n    bw.writeBytes(sequences);\n    bw.writeHash(input.prevout.hash);\n    bw.writeU32(input.prevout.index);\n    bw.writeVarBytes(prev.toRaw());\n    bw.writeI64(value);\n    bw.writeU32(input.sequence);\n    bw.writeBytes(outputs);\n    bw.writeU32(this.locktime);\n    bw.writeU32(type);\n\n    return hash256.digest(bw.render());\n  }\n\n  /**\n   * Verify signature.\n   * @param {Number} index\n   * @param {Script} prev\n   * @param {Amount} value\n   * @param {Buffer} sig\n   * @param {Buffer} key\n   * @param {Number} flags\n   * @returns {Boolean}\n   */\n\n  checksig(index, prev, value, sig, key, flags) {\n    if (sig.length === 0)\n      return false;\n\n    const type = sig[sig.length - 1];\n    const hash = this.signatureHash(index, prev, value, type, flags);\n\n    let res;\n\n    if (common.isSchnorr(sig)) {\n      res = secp256k1.schnorrVerify(hash, sig.slice(0, -1), key)\n    } else {\n      res = secp256k1.verifyDER(hash, sig.slice(0, -1), key);\n    }\n\n    return res;\n  }\n\n  /**\n   * Create a signature suitable for inserting into scriptSigs.\n   * @param {Number} index - Index of input being signed.\n   * @param {Script} prev - Previous output script or redeem script.\n   * @param {Amount} value - Previous output value.\n   * @param {Buffer} key\n   * @param {SighashType} type\n   * @param {Number} flags - Script flags.\n   * @returns {Buffer} Signature in SCHNORR / DER format.\n   */\n\n  signature(index, prev, value, key, type, flags) {\n    let sig;\n\n    if (type == null)\n      type = hashType.ALL;\n\n    if (flags == null)\n      flags = Script.flags.VERIFY_SIGHASH_FORKID;\n\n    const hash = this.signatureHash(index, prev, value, type, flags);\n\n    const DER = secp256k1.signDER(hash, key);\n    const SCHNORR = secp256k1.schnorrSign(hash, key);\n\n    if (common.isSchnorr(SCHNORR)) {\n      sig = SCHNORR;\n    } else {\n      sig = DER;\n    }\n    const bw = bio.write(sig.length + 1);\n\n    bw.writeBytes(sig);\n    bw.writeU8(type);\n\n    return bw.render();\n  }\n\n  /**\n   * Create a signature suitable for inserting into scriptSigs.\n   * @param {Number} index - Index of input being signed.\n   * @param {Script} prev - Previous output script or redeem script.\n   * @param {Amount} value - Previous output value.\n   * @param {Buffer} key\n   * @param {SighashType} type\n   * @param {Number} flags - Script flags.\n   * @returns {Buffer} Signature in Schnorr format.\n   */\n\n  schnorrSignature(index, prev, value, key, type, flags) {\n    if (type == null)\n      type = hashType.ALL;\n\n    if (flags == null)\n      flags = Script.flags.VERIFY_SIGHASH_FORKID;\n\n    const hash = this.signatureHash(index, prev, value, type, flags);\n    const sig = secp256k1.schnorrSign(hash, key);\n    const bw = bio.write(sig.length + 1);\n\n    bw.writeBytes(sig);\n    bw.writeU8(type);\n\n    return bw.render();\n  }\n\n  /**\n   * Verify all transaction inputs.\n   * @param {CoinView} view\n   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n   * @throws {ScriptError} on invalid inputs\n   */\n\n  check(view, flags) {\n    if (this.inputs.length === 0)\n      throw new ScriptError('UNKNOWN_ERROR', 'No inputs.');\n\n    if (this.isCoinbase())\n      return;\n\n    for (let i = 0; i < this.inputs.length; i++) {\n      const {prevout} = this.inputs[i];\n      const coin = view.getOutput(prevout);\n\n      if (!coin)\n        throw new ScriptError('UNKNOWN_ERROR', 'No coin available.');\n\n      this.checkInput(i, coin, flags);\n    }\n  }\n\n  /**\n   * Verify a transaction input.\n   * @param {Number} index - Index of output being\n   * verified.\n   * @param {Coin|Output} coin - Previous output.\n   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n   * @throws {ScriptError} on invalid input\n   */\n\n  checkInput(index, coin, flags) {\n    const input = this.inputs[index];\n\n    assert(input, 'Input does not exist.');\n    assert(coin, 'No coin passed.');\n\n    Script.verify(\n      input.script,\n      null,\n      coin.script,\n      this,\n      index,\n      coin.value,\n      flags\n    );\n  }\n\n  /**\n   * Verify the transaction inputs on the worker pool\n   * (if workers are enabled).\n   * @param {CoinView} view\n   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n   * @param {WorkerPool?} pool\n   * @returns {Promise}\n   */\n\n  async checkAsync(view, flags, pool) {\n    if (this.inputs.length === 0)\n      throw new ScriptError('UNKNOWN_ERROR', 'No inputs.');\n\n    if (this.isCoinbase())\n      return;\n\n    if (!pool) {\n      this.check(view, flags);\n      return;\n    }\n\n    await pool.check(this, view, flags);\n  }\n\n  /**\n   * Verify a transaction input asynchronously.\n   * @param {Number} index - Index of output being\n   * verified.\n   * @param {Coin|Output} coin - Previous output.\n   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n   * @param {WorkerPool?} pool\n   * @returns {Promise}\n   */\n\n  async checkInputAsync(index, coin, flags, pool) {\n    const input = this.inputs[index];\n\n    assert(input, 'Input does not exist.');\n    assert(coin, 'No coin passed.');\n\n    if (!pool) {\n      this.checkInput(index, coin, flags);\n      return;\n    }\n\n    await pool.checkInput(this, index, coin, flags);\n  }\n\n  /**\n   * Verify all transaction inputs.\n   * @param {CoinView} view\n   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n   * @returns {Boolean} Whether the inputs are valid.\n   */\n\n  verify(view, flags) {\n    try {\n      this.check(view, flags);\n    } catch (e) {\n      if (e.type === 'ScriptError')\n        return false;\n      throw e;\n    }\n    return true;\n  }\n\n  /**\n   * Verify a transaction input.\n   * @param {Number} index - Index of output being\n   * verified.\n   * @param {Coin|Output} coin - Previous output.\n   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n   * @returns {Boolean} Whether the input is valid.\n   */\n\n  verifyInput(index, coin, flags) {\n    try {\n      this.checkInput(index, coin, flags);\n    } catch (e) {\n      if (e.type === 'ScriptError')\n        return false;\n      throw e;\n    }\n    return true;\n  }\n\n  /**\n   * Verify the transaction inputs on the worker pool\n   * (if workers are enabled).\n   * @param {CoinView} view\n   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n   * @param {WorkerPool?} pool\n   * @returns {Promise}\n   */\n\n  async verifyAsync(view, flags, pool) {\n    try {\n      await this.checkAsync(view, flags, pool);\n    } catch (e) {\n      if (e.type === 'ScriptError')\n        return false;\n      throw e;\n    }\n    return true;\n  }\n\n  /**\n   * Verify a transaction input asynchronously.\n   * @param {Number} index - Index of output being\n   * verified.\n   * @param {Coin|Output} coin - Previous output.\n   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n   * @param {WorkerPool?} pool\n   * @returns {Promise}\n   */\n\n  async verifyInputAsync(index, coin, flags, pool) {\n    try {\n      await this.checkInput(index, coin, flags, pool);\n    } catch (e) {\n      if (e.type === 'ScriptError')\n        return false;\n      throw e;\n    }\n    return true;\n  }\n\n  /**\n   * Test whether the transaction is a coinbase\n   * by examining the inputs.\n   * @returns {Boolean}\n   */\n\n  isCoinbase() {\n    return this.inputs.length === 1 && this.inputs[0].prevout.isNull();\n  }\n\n  /**\n   * Test whether the transaction is replaceable.\n   * @returns {Boolean}\n   */\n\n  isRBF() {\n    // Core doesn't do this, but it should:\n    if (this.version === 2)\n      return false;\n\n    for (const input of this.inputs) {\n      if (input.isRBF())\n        return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Calculate the fee for the transaction.\n   * @param {CoinView} view\n   * @returns {Amount} fee (zero if not all coins are available).\n   */\n\n  getFee(view) {\n    if (!this.hasCoins(view))\n      return 0;\n\n    return this.getInputValue(view) - this.getOutputValue();\n  }\n\n  /**\n   * Calculate the total input value.\n   * @param {CoinView} view\n   * @returns {Amount} value\n   */\n\n  getInputValue(view) {\n    let total = 0;\n\n    for (const {prevout} of this.inputs) {\n      const coin = view.getOutput(prevout);\n\n      if (!coin)\n        return 0;\n\n      total += coin.value;\n    }\n\n    return total;\n  }\n\n  /**\n   * Calculate the total output value.\n   * @returns {Amount} value\n   */\n\n  getOutputValue() {\n    let total = 0;\n\n    for (const output of this.outputs)\n      total += output.value;\n\n    return total;\n  }\n\n  /**\n   * Get all input addresses.\n   * @private\n   * @param {CoinView} view\n   * @returns {Array} [addrs, table]\n   */\n\n  _getInputAddresses(view) {\n    const table = new BufferSet();\n    const addrs = [];\n\n    if (this.isCoinbase())\n      return [addrs, table];\n\n    for (const input of this.inputs) {\n      const coin = view ? view.getOutputFor(input) : null;\n      const addr = input.getAddress(coin);\n\n      if (!addr)\n        continue;\n\n      const hash = addr.getHash();\n\n      if (!table.has(hash)) {\n        table.add(hash);\n        addrs.push(addr);\n      }\n    }\n\n    return [addrs, table];\n  }\n\n  /**\n   * Get all output addresses.\n   * @private\n   * @returns {Array} [addrs, table]\n   */\n\n  _getOutputAddresses() {\n    const table = new BufferSet();\n    const addrs = [];\n\n    for (const output of this.outputs) {\n      const addr = output.getAddress();\n\n      if (!addr)\n        continue;\n\n      const hash = addr.getHash();\n\n      if (!table.has(hash)) {\n        table.add(hash);\n        addrs.push(addr);\n      }\n    }\n\n    return [addrs, table];\n  }\n\n  /**\n   * Get all addresses.\n   * @private\n   * @param {CoinView} view\n   * @returns {Array} [addrs, table]\n   */\n\n  _getAddresses(view) {\n    const [addrs, table] = this._getInputAddresses(view);\n    const output = this.getOutputAddresses();\n\n    for (const addr of output) {\n      const hash = addr.getHash();\n\n      if (!table.has(hash)) {\n        table.add(hash);\n        addrs.push(addr);\n      }\n    }\n\n    return [addrs, table];\n  }\n\n  /**\n   * Get all input addresses.\n   * @param {CoinView|null} view\n   * @returns {Address[]} addresses\n   */\n\n  getInputAddresses(view) {\n    const [addrs] = this._getInputAddresses(view);\n    return addrs;\n  }\n\n  /**\n   * Get all output addresses.\n   * @returns {Address[]} addresses\n   */\n\n  getOutputAddresses() {\n    const [addrs] = this._getOutputAddresses();\n    return addrs;\n  }\n\n  /**\n   * Get all addresses.\n   * @param {CoinView|null} view\n   * @returns {Address[]} addresses\n   */\n\n  getAddresses(view) {\n    const [addrs] = this._getAddresses(view);\n    return addrs;\n  }\n\n  /**\n   * Get all input address hashes.\n   * @param {CoinView|null} view\n   * @returns {Hash[]} hashes\n   */\n\n  getInputHashes(view, enc) {\n    const [, table] = this._getInputAddresses(view);\n\n    if (enc !== 'hex')\n      return table.toArray();\n\n    return table.toArray().map(h => h.toString('hex'));\n  }\n\n  /**\n   * Get all output address hashes.\n   * @returns {Hash[]} hashes\n   */\n\n  getOutputHashes(enc) {\n    const [, table] = this._getOutputAddresses();\n\n    if (enc !== 'hex')\n      return table.toArray();\n\n    return table.toArray().map(h => h.toString('hex'));\n  }\n\n  /**\n   * Get all address hashes.\n   * @param {CoinView|null} view\n   * @returns {Hash[]} hashes\n   */\n\n  getHashes(view, enc) {\n    const [, table] = this._getAddresses(view);\n\n    if (enc !== 'hex')\n      return table.toArray();\n\n    return table.toArray().map(h => h.toString('hex'));\n  }\n\n  /**\n   * Test whether the transaction has\n   * all coins available.\n   * @param {CoinView} view\n   * @returns {Boolean}\n   */\n\n  hasCoins(view) {\n    if (this.inputs.length === 0)\n      return false;\n\n    for (const {prevout} of this.inputs) {\n      if (!view.hasEntry(prevout))\n        return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Check finality of transaction by examining\n   * nLocktime and nSequence values.\n   * @example\n   * tx.isFinal(chain.height + 1, network.now());\n   * @param {Number} height - Height at which to test. This\n   * is usually the chain height, or the chain height + 1\n   * when the transaction entered the mempool.\n   * @param {Number} time - Time at which to test. This is\n   * usually the chain tip's parent's median time, or the\n   * time at which the transaction entered the mempool. If\n   * MEDIAN_TIME_PAST is enabled this will be the median\n   * time of the chain tip's previous entry's median time.\n   * @returns {Boolean}\n   */\n\n  isFinal(height, time) {\n    const THRESHOLD = consensus.LOCKTIME_THRESHOLD;\n\n    if (this.locktime === 0)\n      return true;\n\n    if (this.locktime < (this.locktime < THRESHOLD ? height : time))\n      return true;\n\n    for (const input of this.inputs) {\n      if (input.sequence !== 0xffffffff)\n        return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Verify the absolute locktime of a transaction.\n   * Called by OP_CHECKLOCKTIMEVERIFY.\n   * @param {Number} index - Index of input being verified.\n   * @param {Number} predicate - Locktime to verify against.\n   * @returns {Boolean}\n   */\n\n  verifyLocktime(index, predicate) {\n    const THRESHOLD = consensus.LOCKTIME_THRESHOLD;\n    const input = this.inputs[index];\n\n    assert(input, 'Input does not exist.');\n    assert(predicate >= 0, 'Locktime must be non-negative.');\n\n    // Locktimes must be of the same type (blocks or seconds).\n    if ((this.locktime < THRESHOLD) !== (predicate < THRESHOLD))\n      return false;\n\n    if (predicate > this.locktime)\n      return false;\n\n    if (input.sequence === 0xffffffff)\n      return false;\n\n    return true;\n  }\n\n  /**\n   * Verify the relative locktime of an input.\n   * Called by OP_CHECKSEQUENCEVERIFY.\n   * @param {Number} index - Index of input being verified.\n   * @param {Number} predicate - Relative locktime to verify against.\n   * @returns {Boolean}\n   */\n\n  verifySequence(index, predicate) {\n    const DISABLE_FLAG = consensus.SEQUENCE_DISABLE_FLAG;\n    const TYPE_FLAG = consensus.SEQUENCE_TYPE_FLAG;\n    const MASK = consensus.SEQUENCE_MASK;\n    const input = this.inputs[index];\n\n    assert(input, 'Input does not exist.');\n    assert(predicate >= 0, 'Locktime must be non-negative.');\n\n    // For future softfork capability.\n    if (predicate & DISABLE_FLAG)\n      return true;\n\n    // Version must be >=2.\n    if (this.version < 2)\n      return false;\n\n    // Cannot use the disable flag without\n    // the predicate also having the disable\n    // flag (for future softfork capability).\n    if (input.sequence & DISABLE_FLAG)\n      return false;\n\n    // Locktimes must be of the same type (blocks or seconds).\n    if ((input.sequence & TYPE_FLAG) !== (predicate & TYPE_FLAG))\n      return false;\n\n    if ((predicate & MASK) > (input.sequence & MASK))\n      return false;\n\n    return true;\n  }\n\n  /**\n   * Calculate legacy (inaccurate) sigop count.\n   * @returns {Number} sigop count\n   */\n\n  getLegacySigops() {\n    if (this._sigops !== -1)\n      return this._sigops;\n\n    let total = 0;\n\n    for (const input of this.inputs)\n      total += input.script.getSigops(false);\n\n    for (const output of this.outputs)\n      total += output.script.getSigops(false);\n\n    if (!this.mutable)\n      this._sigops = total;\n\n    return total;\n  }\n\n  /**\n   * Calculate accurate sigop count, taking into account redeem scripts.\n   * @param {CoinView} view\n   * @param {VerifyFlags} flags\n   * @returns {Number} sigop count\n   */\n\n  getScripthashSigops(view, flags) {\n    if (this.isCoinbase())\n      return 0;\n\n    let total = 0;\n\n    for (const input of this.inputs) {\n      const coin = view.getOutputFor(input);\n\n      if (!coin)\n        continue;\n\n      if (!coin.script.isScripthash())\n        continue;\n\n      total += coin.script.getScripthashSigops(input.script, flags);\n    }\n\n    return total;\n  }\n\n  /**\n   * Calculate sigops count.\n   * @param {CoinView} view\n   * @param {VerifyFlags?} flags\n   * @returns {Number} sigop count\n   */\n\n  getSigopsCount(view, flags) {\n    if (flags === null)\n      flags = Script.flags.STANDARD_VERIFY_FLAGS;\n\n    let cost = this.getLegacySigops();\n\n    if (flags & Script.flags.VERIFY_P2SH)\n      cost += this.getScripthashSigops(view, flags);\n\n    return cost;\n  }\n\n  /**\n   * Calculate sigop count.\n   * @param {CoinView} view\n   * @param {VerifyFlags?} flags\n   * @returns {Number} sigop count\n   */\n\n  getSigops(view, flags) {\n    return this.getSigopsCount(view, flags);\n  }\n\n  /**\n   * Non-contextual sanity checks for the transaction.\n   * Will mostly verify coin and output values.\n   * @see CheckTransaction()\n   * @returns {Array} [result, reason, score]\n   */\n\n  isSane() {\n    const [valid] = this.checkSanity();\n    return valid;\n  }\n\n  /**\n   * Non-contextual sanity checks for the transaction.\n   * Will mostly verify coin and output values.\n   * @see CheckTransaction()\n   * @returns {Array} [valid, reason, score]\n   */\n\n  checkSanity() {\n    if (this.inputs.length === 0)\n      return [false, 'bad-txns-vin-empty', 100];\n\n    if (this.outputs.length === 0)\n      return [false, 'bad-txns-vout-empty', 100];\n\n    if (this.getSize() > consensus.MAX_TX_SIZE)\n      return [false, 'bad-txns-oversize', 100];\n\n    let total = 0;\n\n    for (const output of this.outputs) {\n      if (output.value < 0)\n        return [false, 'bad-txns-vout-negative', 100];\n\n      if (output.value > consensus.MAX_MONEY)\n        return [false, 'bad-txns-vout-toolarge', 100];\n\n      total += output.value;\n\n      if (total < 0 || total > consensus.MAX_MONEY)\n        return [false, 'bad-txns-txouttotal-toolarge', 100];\n    }\n\n    const prevout = new BufferSet();\n\n    for (const input of this.inputs) {\n      const key = input.prevout.toKey();\n\n      if (prevout.has(key))\n        return [false, 'bad-txns-inputs-duplicate', 100];\n\n      prevout.add(key);\n    }\n\n    if (this.isCoinbase()) {\n      const size = this.inputs[0].script.getSize();\n      if (size < 2 || size > consensus.MAX_COINBASE_SCRIPTSIG_SIZE)\n        return [false, 'bad-cb-length', 100];\n    } else {\n      for (const input of this.inputs) {\n        if (input.prevout.isNull())\n          return [false, 'bad-txns-prevout-null', 10];\n      }\n    }\n\n    return [true, 'valid', 0];\n  }\n\n  /**\n   * Non-contextual checks to determine whether the\n   * transaction has all standard output script\n   * types and standard input script size with only\n   * pushdatas in the code.\n   * Will mostly verify coin and output values.\n   * @see IsStandardTx()\n   * @returns {Array} [valid, reason, score]\n   */\n\n  isStandard() {\n    const [valid] = this.checkStandard();\n    return valid;\n  }\n\n  /**\n   * Non-contextual checks to determine whether the\n   * transaction has all standard output script\n   * types and standard input script size with only\n   * pushdatas in the code.\n   * Will mostly verify coin and output values.\n   * @see IsStandardTx()\n   * @returns {Array} [valid, reason, score]\n   */\n\n  checkStandard() {\n    if (this.version < 1 || this.version > policy.MAX_TX_VERSION)\n      return [false, 'version', 0];\n\n    // MAX_STANDARD_TX_SIZE\n    if (this.getSize() >= policy.MAX_TX_SIZE)\n      return [false, 'tx-size', 0];\n\n    for (const input of this.inputs) {\n      if (input.script.getSize() > 1650)\n        return [false, 'scriptsig-size', 0];\n\n      if (!input.script.isPushOnly())\n        return [false, 'scriptsig-not-pushonly', 0];\n    }\n\n    let nulldata = 0;\n\n    for (const output of this.outputs) {\n      if (!output.script.isStandard())\n        return [false, 'scriptpubkey', 0];\n\n      if (output.script.isNulldata()) {\n        nulldata++;\n        continue;\n      }\n\n      if (output.script.isMultisig() && !policy.BARE_MULTISIG)\n        return [false, 'bare-multisig', 0];\n\n      if (output.isDust(policy.MIN_RELAY))\n        return [false, 'dust', 0];\n    }\n\n    if (nulldata > 1)\n      return [false, 'multi-op-return', 0];\n\n    return [true, 'valid', 0];\n  }\n\n  /**\n   * Perform contextual checks to verify coin and input\n   * script standardness (including the redeem script).\n   * @see AreInputsStandard()\n   * @param {CoinView} view\n   * @param {VerifyFlags?} flags\n   * @returns {Boolean}\n   */\n\n  hasStandardInputs(view) {\n    if (this.isCoinbase())\n      return true;\n\n    for (const input of this.inputs) {\n      const coin = view.getOutputFor(input);\n\n      if (!coin)\n        return false;\n\n      if (coin.script.isPubkeyhash())\n        continue;\n\n      if (coin.script.isScripthash()) {\n        const redeem = input.script.getRedeem();\n\n        if (!redeem)\n          return false;\n\n        if (redeem.getSigops(true) > policy.MAX_P2SH_SIGOPS)\n          return false;\n\n        continue;\n      }\n\n      if (coin.script.isUnknown())\n        return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Perform contextual checks to verify input, output,\n   * and fee values, as well as coinbase spend maturity\n   * (coinbases can only be spent 100 blocks or more\n   * after they're created). Note that this function is\n   * consensus critical.\n   * @param {CoinView} view\n   * @param {Number} height - Height at which the\n   * transaction is being spent. In the mempool this is\n   * the chain height plus one at the time it entered the pool.\n   * @returns {Boolean}\n   */\n\n  verifyInputs(view, height) {\n    const [fee] = this.checkInputs(view, height);\n    return fee !== -1;\n  }\n\n  /**\n   * Perform contextual checks to verify input, output,\n   * and fee values, as well as coinbase spend maturity\n   * (coinbases can only be spent 100 blocks or more\n   * after they're created). Note that this function is\n   * consensus critical.\n   * @param {CoinView} view\n   * @param {Number} height - Height at which the\n   * transaction is being spent. In the mempool this is\n   * the chain height plus one at the time it entered the pool.\n   * @returns {Array} [fee, reason, score]\n   */\n\n  checkInputs(view, height) {\n    assert(typeof height === 'number');\n\n    let total = 0;\n\n    for (const {prevout} of this.inputs) {\n      const entry = view.getEntry(prevout);\n\n      if (!entry)\n        return [-1, 'bad-txns-inputs-missingorspent', 0];\n\n      if (entry.coinbase) {\n        if (height - entry.height < consensus.COINBASE_MATURITY)\n          return [-1, 'bad-txns-premature-spend-of-coinbase', 0];\n      }\n\n      const coin = view.getOutput(prevout);\n      assert(coin);\n\n      if (coin.value < 0 || coin.value > consensus.MAX_MONEY)\n        return [-1, 'bad-txns-inputvalues-outofrange', 100];\n\n      total += coin.value;\n\n      if (total < 0 || total > consensus.MAX_MONEY)\n        return [-1, 'bad-txns-inputvalues-outofrange', 100];\n    }\n\n    // Overflows already checked in `isSane()`.\n    const value = this.getOutputValue();\n\n    if (total < value)\n      return [-1, 'bad-txns-in-belowout', 100];\n\n    const fee = total - value;\n\n    if (fee < 0)\n      return [-1, 'bad-txns-fee-negative', 100];\n\n    if (fee > consensus.MAX_MONEY)\n      return [-1, 'bad-txns-fee-outofrange', 100];\n\n    return [fee, 'valid', 0];\n  }\n\n  /**\n   * Calculate the modified size of the transaction. This\n   * is used in the mempool for calculating priority.\n   * @param {Number?} size - The size to modify. If not present,\n   * virtual size will be used.\n   * @returns {Number} Modified size.\n   */\n\n  getModifiedSize(size) {\n    if (size == null)\n      size = this.getSize();\n\n    for (const input of this.inputs) {\n      const offset = 41 + Math.min(110, input.script.getSize());\n      if (size > offset)\n        size -= offset;\n    }\n\n    return size;\n  }\n\n  /**\n   * Calculate the transaction priority.\n   * @param {CoinView} view\n   * @param {Number} height\n   * @param {Number?} size - Size to calculate priority\n   * based on. If not present, virtual size will be used.\n   * @returns {Number}\n   */\n\n  getPriority(view, height, size) {\n    assert(typeof height === 'number', 'Must pass in height.');\n\n    if (this.isCoinbase())\n      return 0;\n\n    if (size == null)\n      size = this.getSize();\n\n    let sum = 0;\n\n    for (const {prevout} of this.inputs) {\n      const coin = view.getOutput(prevout);\n\n      if (!coin)\n        continue;\n\n      const coinHeight = view.getHeight(prevout);\n\n      if (coinHeight === -1)\n        continue;\n\n      if (coinHeight <= height) {\n        const age = height - coinHeight;\n        sum += coin.value * age;\n      }\n    }\n\n    return Math.floor(sum / size);\n  }\n\n  /**\n   * Calculate the transaction's on-chain value.\n   * @param {CoinView} view\n   * @returns {Number}\n   */\n\n  getChainValue(view) {\n    if (this.isCoinbase())\n      return 0;\n\n    let value = 0;\n\n    for (const {prevout} of this.inputs) {\n      const coin = view.getOutput(prevout);\n\n      if (!coin)\n        continue;\n\n      const height = view.getHeight(prevout);\n\n      if (height === -1)\n        continue;\n\n      value += coin.value;\n    }\n\n    return value;\n  }\n\n  /**\n   * Determine whether the transaction is above the\n   * free threshold in priority. A transaction which\n   * passed this test is most likely relayable\n   * without a fee.\n   * @param {CoinView} view\n   * @param {Number?} height - If not present, tx\n   * height or network height will be used.\n   * @param {Number?} size - If not present, modified\n   * size will be calculated and used.\n   * @returns {Boolean}\n   */\n\n  isFree(view, height, size) {\n    const priority = this.getPriority(view, height, size);\n    return priority > policy.FREE_THRESHOLD;\n  }\n\n  /**\n   * Calculate minimum fee in order for the transaction\n   * to be relayable (not the constant min relay fee).\n   * @param {Number?} size - If not present, max size\n   * estimation will be calculated and used.\n   * @param {Rate?} rate - Rate of satoshi per kB.\n   * @returns {Amount} fee\n   */\n\n  getMinFee(size, rate) {\n    if (size == null)\n      size = this.getSize();\n\n    return policy.getMinFee(size, rate);\n  }\n\n  /**\n   * Calculate the minimum fee in order for the transaction\n   * to be relayable, but _round to the nearest kilobyte\n   * when taking into account size.\n   * @param {Number?} size - If not present, max size\n   * estimation will be calculated and used.\n   * @param {Rate?} rate - Rate of satoshi per kB.\n   * @returns {Amount} fee\n   */\n\n  getRoundFee(size, rate) {\n    if (size == null)\n      size = this.getSize();\n\n    return policy.getRoundFee(size, rate);\n  }\n\n  /**\n   * Calculate the transaction's rate based on size\n   * and fees. Size will be calculated if not present.\n   * @param {CoinView} view\n   * @param {Number?} size\n   * @returns {Rate}\n   */\n\n  getRate(view, size) {\n    const fee = this.getFee(view);\n\n    if (fee < 0)\n      return 0;\n\n    if (size == null)\n      size = this.getSize();\n\n    return policy.getRate(size, fee);\n  }\n\n  /**\n   * Get all unique outpoint hashes.\n   * @returns {Hash[]} Outpoint hashes.\n   */\n\n  getPrevout() {\n    if (this.isCoinbase())\n      return [];\n\n    const prevout = new BufferSet();\n\n    for (const input of this.inputs)\n      prevout.add(input.prevout.hash);\n\n    return prevout.toArray();\n  }\n\n  /**\n   * Test a transaction against a bloom filter using\n   * the BIP37 matching algorithm. Note that this may\n   * update the filter depending on what the `update`\n   * value is.\n   * @see \"Filter matching algorithm\":\n   * @see https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki\n   * @param {BloomFilter} filter\n   * @returns {Boolean} True if the transaction matched.\n   */\n\n  isWatched(filter) {\n    let found = false;\n\n    // 1. Test the tx hash\n    if (filter.test(this.hash()))\n      found = true;\n\n    // 2. Test data elements in output scripts\n    //    (may need to update filter on match)\n    for (let i = 0; i < this.outputs.length; i++) {\n      const output = this.outputs[i];\n      // Test the output script\n      if (output.script.test(filter)) {\n        if (filter.update === 1 /* ALL */) {\n          const prevout = Outpoint.fromTX(this, i);\n          filter.add(prevout.toRaw());\n        } else if (filter.update === 2 /* PUBKEY_ONLY */) {\n          if (output.script.isPubkey() || output.script.isMultisig()) {\n            const prevout = Outpoint.fromTX(this, i);\n            filter.add(prevout.toRaw());\n          }\n        }\n        found = true;\n      }\n    }\n\n    if (found)\n      return found;\n\n    // 3. Test prev_out structure\n    // 4. Test data elements in input scripts\n    for (const input of this.inputs) {\n      const prevout = input.prevout;\n\n      // Test the COutPoint structure\n      if (filter.test(prevout.toRaw()))\n        return true;\n\n      // Test the input script\n      if (input.script.test(filter))\n        return true;\n    }\n\n    // 5. No match\n    return false;\n  }\n\n  /**\n   * Get little-endian tx hash.\n   * @returns {Hash}\n   */\n\n  rhash() {\n    return util.revHex(this.hash());\n  }\n\n  /**\n   * Get little-endian tx hash.\n   * @returns {Hash}\n   */\n\n  txid() {\n    return this.rhash();\n  }\n\n  /**\n   * Convert the tx to an inv item.\n   * @returns {InvItem}\n   */\n\n  toInv() {\n    return new InvItem(InvItem.types.TX, this.hash());\n  }\n\n  /**\n   * Inspect the transaction and return a more\n   * user-friendly representation of the data.\n   * @returns {Object}\n   */\n\n  [inspectSymbol]() {\n    return this.format();\n  }\n\n  /**\n   * Inspect the transaction and return a more\n   * user-friendly representation of the data.\n   * @param {CoinView} view\n   * @param {ChainEntry} entry\n   * @param {Number} index\n   * @returns {Object}\n   */\n\n  format(view, entry, index) {\n    let rate = 0;\n    let fee = 0;\n    let height = -1;\n    let block = null;\n    let time = 0;\n    let date = null;\n\n    if (view) {\n      fee = this.getFee(view);\n      rate = this.getRate(view);\n\n      // Rate can exceed 53 bits in testing.\n      if (!Number.isSafeInteger(rate))\n        rate = 0;\n    }\n\n    if (entry) {\n      height = entry.height;\n      block = util.revHex(entry.hash);\n      time = entry.time;\n      date = util.date(time);\n    }\n\n    if (index == null)\n      index = -1;\n\n    const hr = {\n      hash: this.txid(),\n      size: this.getSize(),\n      value: Amount.btc(this.getOutputValue()),\n      fee: Amount.btc(fee),\n      rate: Amount.btc(rate),\n      minFee: Amount.btc(this.getMinFee()),\n      height: height,\n      block: block,\n      time: time,\n      date: date,\n      index: index,\n      version: this.version,\n      inputs: this.inputs.map((input) => {\n        const coin = view ? view.getOutputFor(input) : null;\n        return input.format(coin);\n      }),\n      outputs: this.outputs,\n      locktime: this.locktime\n    };\n\n    if (this.slpToken) {\n      return {\n        ...hr,\n        slpToken: this.slpToken\n      };\n    }\n    return hr;\n  }\n\n  /**\n   * Convert the transaction to an object suitable\n   * for JSON serialization.\n   * @returns {Object}\n   */\n\n  toJSON() {\n    return this.getJSON();\n  }\n\n  /**\n   * Convert the transaction to an object suitable\n   * for JSON serialization. Note that the hashes\n   * will be reversed to abide by bitcoind's legacy\n   * of little-endian uint256s.\n   * @param {Network} network\n   * @param {CoinView} view\n   * @param {ChainEntry} entry\n   * @param {Number} index\n   * @returns {Object}\n   */\n\n  getJSON(network, view, entry, index) {\n    let rate, fee, height, block, time, date;\n\n    if (view) {\n      fee = this.getFee(view);\n      rate = this.getRate(view);\n\n      // Rate can exceed 53 bits in testing.\n      if (!Number.isSafeInteger(rate))\n        rate = 0;\n    }\n\n    if (entry) {\n      height = entry.height;\n      block = util.revHex(entry.hash);\n      time = entry.time;\n      date = util.date(time);\n    }\n\n    network = Network.get(network);\n\n    const json = {\n      hash: this.txid(),\n      fee: fee,\n      rate: rate,\n      mtime: util.now(),\n      height: height,\n      block: block,\n      time: time,\n      date: date,\n      index: index,\n      version: this.version,\n      inputs: this.inputs.map((input) => {\n        const coin = view ? view.getCoinFor(input) : null;\n        return input.getJSON(network, coin);\n      }),\n      outputs: this.outputs.map((output) => {\n        return output.getJSON(network);\n      }),\n      locktime: this.locktime,\n      hex: this.toRaw().toString('hex')\n    };\n\n    if (this.slpToken) {\n      return {\n        ...json,\n        slpToken: this.slpToken.getJSON()\n      };\n    }\n    return json;\n  }\n\n  /**\n   * Inject properties from a json object.\n   * @private\n   * @param {Object} json\n   */\n\n  fromJSON(json) {\n    assert(json, 'TX data is required.');\n    assert((json.version >>> 0) === json.version, 'Version must be a uint32.');\n    assert(Array.isArray(json.inputs), 'Inputs must be an array.');\n    assert(Array.isArray(json.outputs), 'Outputs must be an array.');\n    assert((json.locktime >>> 0) === json.locktime,\n      'Locktime must be a uint32.');\n\n    this.version = json.version;\n\n    for (const input of json.inputs)\n      this.inputs.push(Input.fromJSON(input));\n\n    for (const output of json.outputs)\n      this.outputs.push(Output.fromJSON(output));\n\n    this.locktime = json.locktime;\n\n    if (json.slpToken)\n      this.slpToken = SLP.TokenRecord().fromJSON(json.slpToken)\n\n    return this;\n  }\n\n  /**\n   * Instantiate a transaction from a\n   * jsonified transaction object.\n   * @param {Object} json - The jsonified transaction object.\n   * @returns {TX}\n   */\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n\n  /**\n   * Instantiate a transaction from a serialized Buffer.\n   * @param {Buffer} data\n   * @param {String?} enc - Encoding, can be `'hex'` or null.\n   * @returns {TX}\n   */\n\n  static fromRaw(data, enc) {\n    if (typeof data === 'string')\n      data = Buffer.from(data, enc);\n    return new this().fromRaw(data);\n  }\n\n  /**\n   * Instantiate a transaction from a buffer reader.\n   * @param {BufferReader} br\n   * @param {Boolean} block\n   * @returns {TX}\n   */\n\n  static fromReader(br, block) {\n    return new this().fromReader(br, block);\n  }\n\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   */\n\n  fromRaw(data) {\n    return this.fromReader(bio.read(data));\n  }\n\n  /**\n   * Inject properties from buffer reader.\n   * @private\n   * @param {BufferReader} br\n   * @param {Boolean} block\n   */\n\n  fromReader(br, block) {\n    const start = br.start();\n\n    this.version = br.readU32();\n\n    const inCount = br.readVarint();\n\n    for (let i = 0; i < inCount; i++)\n      this.inputs.push(Input.fromReader(br));\n\n    const outCount = br.readVarint();\n\n    for (let i = 0; i < outCount; i++)\n      this.outputs.push(Output.fromReader(br));\n\n    this.locktime = br.readU32();\n\n    if (block) {\n      this._offset = start;\n      this._block = true;\n    }\n\n    if (!this.mutable) {\n      this._raw = br.endData();\n      this._size = this._raw.length;\n    } else {\n      br.end();\n    }\n\n    return this;\n  }\n\n  /**\n   * Serialize transaction without witness.\n   * @private\n   * @returns {RawTX}\n   */\n\n  frameNormal() {\n    const raw = this.getNormalSizes();\n    const bw = bio.write(raw.size);\n    this.writeNormal(bw);\n    raw.data = bw.render();\n    return raw;\n  }\n\n  /**\n   * Serialize transaction without witness.\n   * @private\n   * @param {BufferWriter} bw\n   * @returns {RawTX}\n   */\n\n  writeNormal(bw) {\n    if (this.inputs.length === 0 && this.outputs.length !== 0)\n      throw new Error('Cannot serialize zero-input tx.');\n\n    bw.writeU32(this.version);\n\n    bw.writeVarint(this.inputs.length);\n\n    for (const input of this.inputs)\n      input.toWriter(bw);\n\n    bw.writeVarint(this.outputs.length);\n\n    for (const output of this.outputs)\n      output.toWriter(bw);\n\n    bw.writeU32(this.locktime);\n\n    return bw;\n  }\n\n  /**\n   * Calculate the real size of the transaction\n   * without the witness vector.\n   * @returns {RawTX}\n   */\n\n  getNormalSizes() {\n    let base = 0;\n\n    base += 4;\n\n    base += encoding.sizeVarint(this.inputs.length);\n\n    for (const input of this.inputs)\n      base += input.getSize();\n\n    base += encoding.sizeVarint(this.outputs.length);\n\n    for (const output of this.outputs)\n      base += output.getSize();\n\n    base += 4;\n\n    return new RawTX(base, 0);\n  }\n\n  /**\n   * Test whether an object is a TX.\n   * @param {Object} obj\n   * @returns {Boolean}\n   */\n\n  static isTX(obj) {\n    return obj instanceof TX;\n  }\n}\n\n/*\n * Helpers\n */\n\nclass RawTX {\n  constructor(size) {\n    this.data = null;\n    this.size = size;\n  }\n}\n\n/*\n * Expose\n */\n\nmodule.exports = TX;\n"]},"metadata":{},"sourceType":"module"}