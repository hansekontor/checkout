{"ast":null,"code":"/*!\n * script.js - script interpreter for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst bio = require('bufio');\n\nconst ripemd160 = require('bcrypto/lib/ripemd160');\n\nconst sha1 = require('bcrypto/lib/sha1');\n\nconst sha256 = require('bcrypto/lib/sha256');\n\nconst hash160 = require('bcrypto/lib/hash160');\n\nconst hash256 = require('bcrypto/lib/hash256');\n\nconst secp256k1 = require('bcrypto/lib/secp256k1');\n\nconst consensus = require('../protocol/consensus');\n\nconst policy = require('../protocol/policy');\n\nconst Opcode = require('./opcode');\n\nconst Stack = require('./stack');\n\nconst ScriptError = require('./scripterror');\n\nconst ScriptNum = require('./scriptnum');\n\nconst common = require('./common');\n\nconst Address = require('../primitives/address');\n\nconst Metrics = require('./metrics');\n\nconst opcodes = common.opcodes;\nconst scriptTypes = common.types;\nconst countBits = common.countBits;\nconst {\n  encoding\n} = bio;\n/*\n * Constants\n */\n\nconst EMPTY_BUFFER = Buffer.alloc(0);\nconst metrics = new Metrics();\n/**\n * Script\n * Represents a input or output script.\n * @alias module:script.Script\n * @property {Array} code - Parsed script code.\n * @property {Buffer?} raw - Serialized script.\n * @property {Number} length - Number of parsed opcodes.\n */\n\nclass Script {\n  /**\n   * Create a script.\n   * @constructor\n   * @param {Buffer|Array|Object} code\n   */\n  constructor(options) {\n    this.raw = EMPTY_BUFFER;\n    this.code = [];\n    if (options) this.fromOptions(options);\n  } //   /**\n  //    * Get length.\n  //    * @returns {Number}\n  //    */\n  //   get length() {\n  //     return this.code.length;\n  //   }\n  //   /**\n  //    * Set length.\n  //    * @param {Number} value\n  //    */\n  //   set length(value) {\n  //     this.code.length = value;\n  //   }\n  //   /**\n  //    * Inject properties from options object.\n  //    * @private\n  //    * @param {Object} options\n  //    */\n  //   fromOptions(options) {\n  //     assert(options, 'Script data is required.');\n  //     if (Buffer.isBuffer(options))\n  //       return this.fromRaw(options);\n  //     if (Array.isArray(options))\n  //       return this.fromArray(options);\n  //     if (options.raw) {\n  //       if (!options.code)\n  //         return this.fromRaw(options.raw);\n  //       assert(Buffer.isBuffer(options.raw), 'Raw must be a Buffer.');\n  //       this.raw = options.raw;\n  //     }\n  //     if (options.code) {\n  //       if (!options.raw)\n  //         return this.fromArray(options.code);\n  //       assert(Array.isArray(options.code), 'Code must be an array.');\n  //       this.code = options.code;\n  //     }\n  //     return this;\n  //   }\n  //   /**\n  //    * Insantiate script from options object.\n  //    * @param {Object} options\n  //    * @returns {Script}\n  //    */\n  //   static fromOptions(options) {\n  //     return new this().fromOptions(options);\n  //   }\n  //   /**\n  //    * Instantiate a value-only iterator.\n  //    * @returns {ScriptIterator}\n  //    */\n  //   values() {\n  //     return this.code.values();\n  //   }\n  //   /**\n  //    * Instantiate a key and value iterator.\n  //    * @returns {ScriptIterator}\n  //    */\n  //   entries() {\n  //     return this.code.entries();\n  //   }\n  //   /**\n  //    * Instantiate a value-only iterator.\n  //    * @returns {ScriptIterator}\n  //    */\n  //   [Symbol.iterator]() {\n  //     return this.code[Symbol.iterator]();\n  //   }\n  //   /**\n  //    * Convert the script to an array of\n  //    * Buffers (pushdatas) and Numbers\n  //    * (opcodes).\n  //    * @returns {Array}\n  //    */\n  //   toArray() {\n  //     return this.code.slice();\n  //   }\n  //   /**\n  //    * Inject properties from an array of\n  //    * of buffers and numbers.\n  //    * @private\n  //    * @param {Array} code\n  //    * @returns {Script}\n  //    */\n  //   fromArray(code) {\n  //     assert(Array.isArray(code));\n  //     this.clear();\n  //     for (const op of code)\n  //       this.push(op);\n  //     return this.compile();\n  //   }\n  //   /**\n  //    * Instantiate script from an array\n  //    * of buffers and numbers.\n  //    * @param {Array} code\n  //    * @returns {Script}\n  //    */\n  //   static fromArray(code) {\n  //     return new this().fromArray(code);\n  //   }\n  //   /**\n  //    * Convert script to stack items.\n  //    * @returns {Buffer[]}\n  //    */\n  //   toItems() {\n  //     const items = [];\n  //     for (const op of this.code) {\n  //       const data = op.toPush();\n  //       if (!data)\n  //         throw new Error('Non-push opcode in script.');\n  //       items.push(data);\n  //     }\n  //     return items;\n  //   }\n\n  /**\n   * Inject data from stack items.\n   * @private\n   * @param {Buffer[]} items\n   * @returns {Script}\n   */\n\n\n  fromItems(items) {\n    assert(Array.isArray(items));\n    this.clear();\n\n    for (const item of items) this.pushData(item);\n\n    return this.compile();\n  }\n  /**\n   * Instantiate script from stack items.\n   * @param {Buffer[]} items\n   * @returns {Script}\n   */\n\n\n  static fromItems(items) {\n    return new this().fromItems(items);\n  } //   /**\n  //    * Convert script to stack.\n  //    * @returns {Stack}\n  //    */\n  //   toStack() {\n  //     return new Stack(this.toItems());\n  //   }\n\n  /**\n   * Inject data from stack.\n   * @private\n   * @param {Stack} stack\n   * @returns {Script}\n   */\n\n\n  fromStack(stack) {\n    return this.fromItems(stack.items);\n  }\n  /**\n   * Instantiate script from stack.\n   * @param {Stack} stack\n   * @returns {Script}\n   */\n\n\n  static fromStack(stack) {\n    return new this().fromStack(stack);\n  } //   /**\n  //    * Clone the script.\n  //    * @returns {Script} Cloned script.\n  //    */\n  //   clone() {\n  //     return new this.constructor().inject(this);\n  //   }\n  //   /**\n  //    * Inject properties from script.\n  //    * Used for cloning.\n  //    * @private\n  //    * @param {Script} script\n  //    * @returns {Script}\n  //    */\n  //   inject(script) {\n  //     this.raw = script.raw;\n  //     this.code = script.code.slice();\n  //     return this;\n  //   }\n  //   /**\n  //    * Test equality against script.\n  //    * @param {Script} script\n  //    * @returns {Boolean}\n  //    */\n  //   equals(script) {\n  //     assert(Script.isScript(script));\n  //     return this.raw.equals(script.raw);\n  //   }\n  //   /**\n  //    * Compare against another script.\n  //    * @param {Script} script\n  //    * @returns {Number}\n  //    */\n  //   compare(script) {\n  //     assert(Script.isScript(script));\n  //     return this.raw.compare(script.raw);\n  //   }\n\n  /**\n   * Clear the script.\n   * @returns {Script}\n   */\n\n\n  clear() {\n    this.raw = EMPTY_BUFFER;\n    this.code.length = 0;\n    return this;\n  } //   /**\n  //    * Inspect the script.\n  //    * @returns {String} Human-readable script code.\n  //    */\n  //   inspect() {\n  //     return `<Script: ${this.toString()}>`;\n  //   }\n  //   /**\n  //    * Convert the script to a bitcoind test string.\n  //    * @returns {String} Human-readable script code.\n  //    */\n  //   toString() {\n  //     const out = [];\n  //     for (const op of this.code)\n  //       out.push(op.toFormat());\n  //     return out.join(' ');\n  //   }\n  //   /**\n  //    * Format the script as bitcoind asm.\n  //    * @param {Boolean?} decode - Attempt to decode hash types.\n  //    * @returns {String} Human-readable script.\n  //    */\n  //   toASM(decode) {\n  //     if (this.isNulldata())\n  //       decode = false;\n  //     const out = [];\n  //     for (const op of this.code)\n  //       out.push(op.toASM(decode));\n  //     return out.join(' ');\n  //   }\n  //   /**\n  //    * Re-encode the script internally. Useful if you\n  //    * changed something manually in the `code` array.\n  //    * @returns {Script}\n  //    */\n\n\n  compile() {\n    if (this.code.length === 0) return this.clear();\n    let size = 0;\n\n    for (const op of this.code) size += op.getSize();\n\n    const bw = bio.write(size);\n\n    for (const op of this.code) op.toWriter(bw);\n\n    this.raw = bw.render();\n    return this;\n  } //   /**\n  //    * Write the script to a buffer writer.\n  //    * @param {BufferWriter} bw\n  //    */\n  //   toWriter(bw) {\n  //     bw.writeVarBytes(this.raw);\n  //     return bw;\n  //   }\n\n  /**\n   * Encode the script to a Buffer. See {@link Script#encode}.\n   * @param {String} enc - Encoding, either `'hex'` or `null`.\n   * @returns {Buffer|String} Serialized script.\n   */\n\n\n  toRaw() {\n    return this.raw;\n  } //   /**\n  //    * Convert script to a hex string.\n  //    * @returns {String}\n  //    */\n  //   toJSON() {\n  //     return this.toRaw().toString('hex');\n  //   }\n  //   /**\n  //    * Inject properties from json object.\n  //    * @private\n  //    * @param {String} json\n  //    */\n\n\n  fromJSON(json) {\n    assert(typeof json === 'string', 'Code must be a string.');\n    return this.fromRaw(Buffer.from(json, 'hex'));\n  }\n  /**\n   * Instantiate script from a hex string.\n   * @params {String} json\n   * @returns {Script}\n   */\n\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  } //   /**\n  //    * Get the script's \"subscript\" starting at a separator.\n  //    * @param {Number} index - The last separator to sign/verify beyond.\n  //    * @returns {Script} Subscript.\n  //    */\n  //   getSubscript(index) {\n  //     if (index === 0)\n  //       return this.clone();\n  //     const script = new Script();\n  //     for (let i = index; i < this.code.length; i++) {\n  //       const op = this.code[i];\n  //       if (op.value === -1)\n  //         break;\n  //       script.code.push(op);\n  //     }\n  //     return script.compile();\n  //   }\n  //   /**\n  //    * Get the script's \"subscript\" starting at a separator.\n  //    * Remove all OP_CODESEPARATORs if present. This bizarre\n  //    * behavior is necessary for signing and verification when\n  //    * code separators are present.\n  //    * @returns {Script} Subscript.\n  //    */\n  //   removeSeparators() {\n  //     let found = false;\n  //     // Optimizing for the common case:\n  //     // Check for any separators first.\n  //     for (const op of this.code) {\n  //       if (op.value === -1)\n  //         break;\n  //       if (op.value === opcodes.OP_CODESEPARATOR) {\n  //         found = true;\n  //         break;\n  //       }\n  //     }\n  //     if (!found)\n  //       return this;\n  //     // Uncommon case: someone actually\n  //     // has a code separator. Go through\n  //     // and remove them all.\n  //     const script = new Script();\n  //     for (const op of this.code) {\n  //       if (op.value === -1)\n  //         break;\n  //       if (op.value !== opcodes.OP_CODESEPARATOR)\n  //         script.code.push(op);\n  //     }\n  //     return script.compile();\n  //   }\n  //   /**\n  //    * Get the value of the checkBits while calculated as little endian.\n  //    * @param {Buffer} abkam - Stack depth of the dummy element.\n  //    * @param {Number?} nKeysCount - Stack depth of the top pubkeys.\n  //    * @returns {Number}\n  //    */\n  //   bitcalculator(abkam, nKeysCount) {\n  //     let checkBits = 0;\n  //     const bitfield_size = ((nKeysCount + 7) / 8);\n  //     for (let i = 0; i < bitfield_size; i++) {\n  //       checkBits |= abkam[i] << (8 * i);\n  //     }\n  //     return checkBits;\n  //   }\n\n  /**\n   * Execute and interpret the script.\n   * @param {Stack} stack - Script execution stack.\n   * @param {Number?} flags - Script standard flags.\n   * @param {TX?} tx - Transaction being verified.\n   * @param {Number?} index - Index of input being verified.\n   * @param {Amount?} value - Previous output value.\n   * @param {Number?} sigchecks\n   * @throws {ScriptError} Will be thrown on VERIFY failures.\n   */\n\n\n  execute(stack, flags, tx, index, value, sigchecks) {\n    if (flags == null) flags = Script.flags.STANDARD_VERIFY_FLAGS;\n    if (this.getSize() > consensus.MAX_SCRIPT_SIZE) throw new ScriptError('SCRIPT_SIZE');\n    const state = [];\n    const alt = [];\n    let lastSep = 0;\n    let opCount = 0;\n    let negate = 0;\n    let nSigsRemaining = 0;\n    let nKeysRemaining = 0;\n    let checkBits;\n    let minimal = false;\n    if (flags & Script.flags.VERIFY_MINIMALDATA) minimal = true;\n\n    for (let ip = 0; ip < this.code.length; ip++) {\n      const op = this.code[ip];\n      if (op.value === -1) throw new ScriptError('BAD_OPCODE', op, ip);\n      if (op.data && op.data.length > consensus.MAX_SCRIPT_PUSH) throw new ScriptError('PUSH_SIZE', op, ip);\n      if (op.value > opcodes.OP_16 && ++opCount > consensus.MAX_SCRIPT_OPS) throw new ScriptError('OP_COUNT', op, ip);\n      if (op.isDisabled(flags)) throw new ScriptError('DISABLED_OPCODE', op, ip);\n\n      if (negate && !op.isBranch()) {\n        if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK) throw new ScriptError('STACK_SIZE', op, ip);\n        continue;\n      }\n\n      if (op.data && 0 <= op.value <= opcodes.OP_PUSHDATA4) {\n        if (minimal && !op.isMinimal()) throw new ScriptError('MINIMALDATA', op, ip);\n        stack.push(op.data);\n        if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK) throw new ScriptError('STACK_SIZE', op, ip);\n        continue;\n      }\n\n      switch (op.value) {\n        case opcodes.OP_0:\n          {\n            stack.pushInt(0);\n            break;\n          }\n\n        case opcodes.OP_1NEGATE:\n          {\n            stack.pushInt(-1);\n            break;\n          }\n\n        case opcodes.OP_1:\n        case opcodes.OP_2:\n        case opcodes.OP_3:\n        case opcodes.OP_4:\n        case opcodes.OP_5:\n        case opcodes.OP_6:\n        case opcodes.OP_7:\n        case opcodes.OP_8:\n        case opcodes.OP_9:\n        case opcodes.OP_10:\n        case opcodes.OP_11:\n        case opcodes.OP_12:\n        case opcodes.OP_13:\n        case opcodes.OP_14:\n        case opcodes.OP_15:\n        case opcodes.OP_16:\n          {\n            stack.pushInt(op.value - 0x50);\n            break;\n          }\n\n        case opcodes.OP_NOP:\n          {\n            break;\n          }\n\n        case opcodes.OP_CHECKLOCKTIMEVERIFY:\n          {\n            // OP_CHECKLOCKTIMEVERIFY = OP_NOP2\n            if (!(flags & Script.flags.VERIFY_CHECKLOCKTIMEVERIFY)) {\n              if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS) throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);\n              break;\n            }\n\n            if (!tx) throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const num = stack.getNum(-1, minimal, 5);\n            if (num.isNeg()) throw new ScriptError('NEGATIVE_LOCKTIME', op, ip);\n            const locktime = num.toDouble();\n            if (!tx.verifyLocktime(index, locktime)) throw new ScriptError('UNSATISFIED_LOCKTIME', op, ip);\n            break;\n          }\n\n        case opcodes.OP_CHECKSEQUENCEVERIFY:\n          {\n            // OP_CHECKSEQUENCEVERIFY = OP_NOP3\n            if (!(flags & Script.flags.VERIFY_CHECKSEQUENCEVERIFY)) {\n              if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS) throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);\n              break;\n            }\n\n            if (!tx) throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const num = stack.getNum(-1, minimal, 5);\n            if (num.isNeg()) throw new ScriptError('NEGATIVE_LOCKTIME', op, ip);\n            const locktime = num.toDouble();\n            if (!tx.verifySequence(index, locktime)) throw new ScriptError('UNSATISFIED_LOCKTIME', op, ip);\n            break;\n          }\n\n        case opcodes.OP_NOP1:\n        case opcodes.OP_NOP4:\n        case opcodes.OP_NOP5:\n        case opcodes.OP_NOP6:\n        case opcodes.OP_NOP7:\n        case opcodes.OP_NOP8:\n        case opcodes.OP_NOP9:\n        case opcodes.OP_NOP10:\n          {\n            if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS) throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);\n            break;\n          }\n\n        case opcodes.OP_IF:\n        case opcodes.OP_NOTIF:\n          {\n            let val = false;\n\n            if (!negate) {\n              if (stack.length < 1) throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);\n\n              if (flags & Script.flags.VERIFY_MINIMALIF) {\n                const item = stack.get(-1);\n                if (item.length > 1) throw new ScriptError('MINIMALIF');\n                if (item.length === 1 && item[0] !== 1) throw new ScriptError('MINIMALIF');\n              }\n\n              val = stack.getBool(-1);\n              if (op.value === opcodes.OP_NOTIF) val = !val;\n              stack.pop();\n            }\n\n            state.push(val);\n            if (!val) negate += 1;\n            break;\n          }\n\n        case opcodes.OP_ELSE:\n          {\n            if (state.length === 0) throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);\n            state[state.length - 1] = !state[state.length - 1];\n            if (!state[state.length - 1]) negate += 1;else negate -= 1;\n            break;\n          }\n\n        case opcodes.OP_ENDIF:\n          {\n            if (state.length === 0) throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);\n            if (!state.pop()) negate -= 1;\n            break;\n          }\n\n        case opcodes.OP_VERIFY:\n          {\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            if (!stack.getBool(-1)) throw new ScriptError('VERIFY', op, ip);\n            stack.pop();\n            break;\n          }\n\n        case opcodes.OP_RETURN:\n          {\n            throw new ScriptError('OP_RETURN', op, ip);\n          }\n\n        case opcodes.OP_TOALTSTACK:\n          {\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            alt.push(stack.pop());\n            break;\n          }\n\n        case opcodes.OP_FROMALTSTACK:\n          {\n            if (alt.length === 0) throw new ScriptError('INVALID_ALTSTACK_OPERATION', op, ip);\n            stack.push(alt.pop());\n            break;\n          }\n\n        case opcodes.OP_2DROP:\n          {\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.pop();\n            stack.pop();\n            break;\n          }\n\n        case opcodes.OP_2DUP:\n          {\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const v1 = stack.get(-2);\n            const v2 = stack.get(-1);\n            stack.push(v1);\n            stack.push(v2);\n            break;\n          }\n\n        case opcodes.OP_3DUP:\n          {\n            if (stack.length < 3) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const v1 = stack.get(-3);\n            const v2 = stack.get(-2);\n            const v3 = stack.get(-1);\n            stack.push(v1);\n            stack.push(v2);\n            stack.push(v3);\n            break;\n          }\n\n        case opcodes.OP_2OVER:\n          {\n            if (stack.length < 4) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const v1 = stack.get(-4);\n            const v2 = stack.get(-3);\n            stack.push(v1);\n            stack.push(v2);\n            break;\n          }\n\n        case opcodes.OP_2ROT:\n          {\n            if (stack.length < 6) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const v1 = stack.get(-6);\n            const v2 = stack.get(-5);\n            stack.erase(-6, -4);\n            stack.push(v1);\n            stack.push(v2);\n            break;\n          }\n\n        case opcodes.OP_2SWAP:\n          {\n            if (stack.length < 4) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.swap(-4, -2);\n            stack.swap(-3, -1);\n            break;\n          }\n\n        case opcodes.OP_IFDUP:\n          {\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n            if (stack.getBool(-1)) {\n              const val = stack.get(-1);\n              stack.push(val);\n            }\n\n            break;\n          }\n\n        case opcodes.OP_DEPTH:\n          {\n            stack.pushInt(stack.length);\n            break;\n          }\n\n        case opcodes.OP_DROP:\n          {\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.pop();\n            break;\n          }\n\n        case opcodes.OP_DUP:\n          {\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.push(stack.get(-1));\n            break;\n          }\n\n        case opcodes.OP_NIP:\n          {\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.remove(-2);\n            break;\n          }\n\n        case opcodes.OP_OVER:\n          {\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.push(stack.get(-2));\n            break;\n          }\n\n        case opcodes.OP_PICK:\n        case opcodes.OP_ROLL:\n          {\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const num = stack.getInt(-1, minimal, 4);\n            stack.pop();\n            if (num < 0 || num >= stack.length) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const val = stack.get(-num - 1);\n            if (op.value === opcodes.OP_ROLL) stack.remove(-num - 1);\n            stack.push(val);\n            break;\n          }\n\n        case opcodes.OP_ROT:\n          {\n            if (stack.length < 3) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.swap(-3, -2);\n            stack.swap(-2, -1);\n            break;\n          }\n\n        case opcodes.OP_SWAP:\n          {\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.swap(-2, -1);\n            break;\n          }\n\n        case opcodes.OP_TUCK:\n          {\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.insert(-2, stack.get(-1));\n            break;\n          }\n\n        case opcodes.OP_SIZE:\n          {\n            if (stack.length < 1) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.pushInt(stack.get(-1).length);\n            break;\n          }\n\n        case opcodes.OP_EQUAL:\n        case opcodes.OP_EQUALVERIFY:\n          {\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const v1 = stack.get(-2);\n            const v2 = stack.get(-1);\n            const res = v1.equals(v2);\n            stack.pop();\n            stack.pop();\n            stack.pushBool(res);\n\n            if (op.value === opcodes.OP_EQUALVERIFY) {\n              if (!res) throw new ScriptError('EQUALVERIFY', op, ip);\n              stack.pop();\n            }\n\n            break;\n          }\n\n        case opcodes.OP_1ADD:\n        case opcodes.OP_1SUB:\n        case opcodes.OP_NEGATE:\n        case opcodes.OP_ABS:\n        case opcodes.OP_NOT:\n        case opcodes.OP_0NOTEQUAL:\n          {\n            if (stack.length < 1) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            let num = stack.getNum(-1, minimal, 4);\n            let cmp;\n\n            switch (op.value) {\n              case opcodes.OP_1ADD:\n                num.iaddn(1);\n                break;\n\n              case opcodes.OP_1SUB:\n                num.isubn(1);\n                break;\n\n              case opcodes.OP_NEGATE:\n                num.ineg();\n                break;\n\n              case opcodes.OP_ABS:\n                num.iabs();\n                break;\n\n              case opcodes.OP_NOT:\n                cmp = num.isZero();\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              case opcodes.OP_0NOTEQUAL:\n                cmp = !num.isZero();\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              default:\n                assert(false, 'Fatal script error.');\n                break;\n            }\n\n            stack.pop();\n            stack.pushNum(num);\n            break;\n          }\n\n        case opcodes.OP_ADD:\n        case opcodes.OP_SUB:\n        case opcodes.OP_DIV:\n        case opcodes.OP_MOD:\n        case opcodes.OP_BOOLAND:\n        case opcodes.OP_BOOLOR:\n        case opcodes.OP_NUMEQUAL:\n        case opcodes.OP_NUMEQUALVERIFY:\n        case opcodes.OP_NUMNOTEQUAL:\n        case opcodes.OP_LESSTHAN:\n        case opcodes.OP_GREATERTHAN:\n        case opcodes.OP_LESSTHANOREQUAL:\n        case opcodes.OP_GREATERTHANOREQUAL:\n        case opcodes.OP_MIN:\n        case opcodes.OP_MAX:\n          {\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const n1 = stack.getNum(-2, minimal, 4);\n            const n2 = stack.getNum(-1, minimal, 4);\n            let num, cmp;\n\n            switch (op.value) {\n              case opcodes.OP_ADD:\n                num = n1.iadd(n2);\n                break;\n\n              case opcodes.OP_SUB:\n                num = n1.isub(n2);\n                break;\n\n              case opcodes.OP_DIV:\n                if (n2.isZero()) throw new ScriptError('DIV_BY_ZERO', op, ip);\n                num = n1.div(n2);\n                break;\n\n              case opcodes.OP_MOD:\n                if (n2.isZero()) throw new ScriptError('MOD_BY_ZERO', op, ip);\n                num = n1.mod(n2);\n                break;\n\n              case opcodes.OP_BOOLAND:\n                cmp = n1.toBool() && n2.toBool();\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              case opcodes.OP_BOOLOR:\n                cmp = n1.toBool() || n2.toBool();\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              case opcodes.OP_NUMEQUAL:\n                cmp = n1.eq(n2);\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              case opcodes.OP_NUMEQUALVERIFY:\n                cmp = n1.eq(n2);\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              case opcodes.OP_NUMNOTEQUAL:\n                cmp = !n1.eq(n2);\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              case opcodes.OP_LESSTHAN:\n                cmp = n1.lt(n2);\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              case opcodes.OP_GREATERTHAN:\n                cmp = n1.gt(n2);\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              case opcodes.OP_LESSTHANOREQUAL:\n                cmp = n1.lte(n2);\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              case opcodes.OP_GREATERTHANOREQUAL:\n                cmp = n1.gte(n2);\n                num = ScriptNum.fromBool(cmp);\n                break;\n\n              case opcodes.OP_MIN:\n                num = ScriptNum.min(n1, n2);\n                break;\n\n              case opcodes.OP_MAX:\n                num = ScriptNum.max(n1, n2);\n                break;\n\n              default:\n                assert(false, 'Fatal script error.');\n                break;\n            }\n\n            stack.pop();\n            stack.pop();\n            stack.pushNum(num);\n\n            if (op.value === opcodes.OP_NUMEQUALVERIFY) {\n              if (!stack.getBool(-1)) throw new ScriptError('NUMEQUALVERIFY', op, ip);\n              stack.pop();\n            }\n\n            break;\n          }\n\n        case opcodes.OP_WITHIN:\n          {\n            if (stack.length < 3) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const n1 = stack.getNum(-3, minimal, 4);\n            const n2 = stack.getNum(-2, minimal, 4);\n            const n3 = stack.getNum(-1, minimal, 4);\n            const val = n2.lte(n1) && n1.lt(n3);\n            stack.pop();\n            stack.pop();\n            stack.pop();\n            stack.pushBool(val);\n            break;\n          }\n\n        case opcodes.OP_RIPEMD160:\n          {\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.push(ripemd160.digest(stack.pop()));\n            break;\n          }\n\n        case opcodes.OP_SHA1:\n          {\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.push(sha1.digest(stack.pop()));\n            break;\n          }\n\n        case opcodes.OP_SHA256:\n          {\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.push(sha256.digest(stack.pop()));\n            break;\n          }\n\n        case opcodes.OP_HASH160:\n          {\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.push(hash160.digest(stack.pop()));\n            break;\n          }\n\n        case opcodes.OP_HASH256:\n          {\n            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            stack.push(hash256.digest(stack.pop()));\n            break;\n          }\n\n        case opcodes.OP_CODESEPARATOR:\n          {\n            lastSep = ip + 1;\n            break;\n          }\n\n        case opcodes.OP_CHECKSIG:\n        case opcodes.OP_CHECKSIGVERIFY:\n          {\n            if (!tx) throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const sig = stack.get(-2);\n            const key = stack.get(-1);\n            const subscript = this.getSubscript(lastSep);\n            if (!(flags & Script.flags.VERIFY_SIGHASH_FORKID) || !(sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID)) subscript.findAndDelete(sig);\n            checkTransactionSignature(sig, flags);\n            validateKey(key, flags);\n            let res = false;\n\n            if (sig.length > 0) {\n              const type = sig[sig.length - 1];\n              const hash = tx.signatureHash(index, subscript, value, type, flags);\n              res = verifySignature(hash, sig.slice(0, -1), key, flags);\n              metrics.sigchecks += 1;\n              sigchecks = metrics.sigchecks;\n            }\n\n            if (!res && flags & Script.flags.VERIFY_NULLFAIL) {\n              if (sig.length !== 0) throw new ScriptError('NULLFAIL', op, ip);\n            }\n\n            stack.pop();\n            stack.pop();\n            stack.pushBool(res);\n\n            if (op.value === opcodes.OP_CHECKSIGVERIFY) {\n              if (!res) throw new ScriptError('CHECKSIGVERIFY', op, ip);\n              stack.pop();\n            }\n\n            break;\n          }\n\n        case opcodes.OP_CHECKDATASIG:\n        case opcodes.OP_CHECKDATASIGVERIFY:\n          {\n            // (sig message pubkey -- bool)\n            if (stack.length < 3) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const sig = stack.get(-3);\n            const msg = stack.get(-2);\n            const key = stack.get(-1);\n            validateDataSignature(sig, flags);\n            validateKey(key, flags);\n            let res = false;\n\n            if (sig.length > 0) {\n              const hash = sha256.digest(msg);\n              res = verifySignature(hash, sig, key, flags);\n              metrics.sigchecks += 1;\n              sigchecks = metrics.sigchecks;\n            }\n\n            if (!res && flags & Script.flags.VERIFY_NULLFAIL) {\n              if (sig.length !== 0) throw new ScriptError('NULLFAIL', op, ip);\n            }\n\n            stack.pop();\n            stack.pop();\n            stack.pop();\n            stack.pushBool(res);\n\n            if (op.value === opcodes.OP_CHECKDATASIGVERIFY) {\n              if (!res) throw new ScriptError('CHECKDATASIGVERIFY', op, ip);\n              stack.pop();\n            }\n\n            break;\n          }\n\n        case opcodes.OP_CHECKMULTISIG:\n        case opcodes.OP_CHECKMULTISIGVERIFY:\n          {\n            if (!tx) throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n            let keyCount = 1;\n            let sigCount = 0;\n            let keyTop, sigTop;\n            if (stack.length < keyCount) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            let nKeysCount = stack.getInt(-keyCount, minimal, 4);\n            let okey = nKeysCount + 2;\n            let ikey, isig;\n            if (nKeysCount < 0 || nKeysCount > consensus.MAX_MULTISIG_PUBKEYS) throw new ScriptError('PUBKEY_COUNT', op, ip);\n            opCount += nKeysCount;\n            if (opCount > consensus.MAX_SCRIPT_OPS) throw new ScriptError('OP_COUNT', op, ip);\n            keyCount += 1;\n            keyTop = keyCount; // stack depth of nSigsCount\n\n            sigCount = keyTop + nKeysCount;\n            ikey = keyCount;\n            keyCount += nKeysCount;\n            if (stack.length < sigCount) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            let nSigsCount = stack.getInt(-sigCount, minimal, 4);\n            if (nSigsCount < 0 || nSigsCount > nKeysCount) throw new ScriptError('SIG_COUNT', op, ip); // stack depth of the top signature\n\n            sigTop = sigCount + 1; // stack depth of the dummy element\n\n            const dummy = sigTop + nSigsCount;\n            if (stack.length < dummy) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            keyCount += 1;\n            isig = keyCount;\n            keyCount += nSigsCount;\n            const subscript = this.getSubscript(lastSep);\n            let res = true;\n\n            if (flags & Script.flags.VERIFY_SCHNORR_MULTISIG && stack.get(-dummy).length !== 0) {\n              assert(consensus.MAX_MULTISIG_PUBKEYS < 32);\n              if (nKeysCount > 32) throw new ScriptError('INVALID_BITFIELD_SIZE', op, ip);\n              const bitfield_size = Math.floor((nKeysCount + 7) / 8);\n              const abkam = stack.get(-dummy);\n              if (abkam.length !== bitfield_size) throw new ScriptError('BITFIELD_SIZE', op, ip);\n              checkBits = this.bitcalculator(abkam, nKeysCount);\n              const mask = (1 << nKeysCount) - 1;\n              const numBits = countBits(checkBits);\n              if ((checkBits & mask) !== checkBits) throw new ScriptError('BIT_RANGE', op, ip);\n              if (numBits !== nSigsCount) throw new ScriptError('INVALID_BIT_COUNT', op, ip);\n              const bKey = keyTop + nKeysCount - 1;\n              const bSig = sigTop + nSigsCount - 1;\n              let ik3y = 0;\n\n              for (let is1g = 0; is1g < nSigsCount; is1g++, ik3y++) {\n                if (checkBits >> ik3y === 0) {\n                  throw new ScriptError('INVALID_BIT_RANGE', op, ip);\n                }\n\n                while ((checkBits >> ik3y & 0x01) === 0) {\n                  ik3y++;\n                }\n\n                if (ik3y >= nKeysCount) throw new ScriptError('PUBKEY_COUNT', op, ip);\n                const sig = stack.get(-bSig + is1g);\n                const key = stack.get(-bKey + ik3y); // Handle checkbits left over\n\n                if (!sig) continue;\n                checkTransactionSchnorrSig(sig, flags);\n                validateKey(key, flags);\n\n                if (sig.length > 0) {\n                  const type = sig[sig.length - 1];\n                  const hash = tx.signatureHash(index, subscript, value, type, flags);\n                  res = verifySignature(hash, sig.slice(0, -1), key, flags);\n                  metrics.sigchecks += 1;\n                  sigchecks = metrics.sigchecks;\n                }\n\n                while (keyCount > 1) {\n                  if (!res && flags & Script.flags.VERIFY_NULLFAIL) {\n                    if (okey === 0 && stack.get(-1).length !== 0) throw new ScriptError('NULLFAIL', op, ip);\n                  }\n\n                  if (okey > 0) okey -= 1;\n                  stack.pop();\n                  keyCount -= 1;\n                }\n              }\n\n              if (checkBits >> ik3y !== 0) throw new ScriptError('INVALID_BIT_COUNT', op, ip);\n              stack.pop();\n              stack.pushBool(res);\n            } else {\n              // Legacy Multisig (ECDSA / NULL)\n              // A bug causes CHECKMULTISIG to consume one extra\n              // argument whose contents were not checked in any way.\n              for (let j = 0; j < nSigsCount; j++) {\n                const sig = stack.get(-sigTop - j);\n                if (!(flags & Script.flags.VERIFY_SIGHASH_FORKID) || !(sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID)) subscript.findAndDelete(sig, flags);\n              }\n\n              nSigsRemaining = nSigsCount;\n              nKeysRemaining = nKeysCount;\n\n              while (res && nSigsCount > 0) {\n                const sig = stack.get(-isig);\n                const key = stack.get(-ikey);\n                checkTransactionECDSASignature(sig, flags);\n                validateKey(key, flags);\n\n                if (sig.length > 0) {\n                  const type = sig[sig.length - 1];\n                  const hash = tx.signatureHash(index, subscript, value, type, flags);\n\n                  if (checksig(hash, sig, key)) {\n                    isig += 1;\n                    nSigsCount -= 1;\n                  }\n                }\n\n                ikey += 1;\n                nKeysCount -= 1;\n                if (nSigsCount > nKeysCount) res = false;\n              }\n\n              while (keyCount > 1) {\n                if (!res && flags & Script.flags.VERIFY_NULLFAIL) {\n                  if (okey === 0 && stack.get(-1).length !== 0) throw new ScriptError('NULLFAIL', op, ip);\n                }\n\n                if (okey > 0) okey -= 1;\n                stack.pop();\n                keyCount -= 1;\n              }\n\n              if (stack.length < 1) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n              stack.pop();\n              stack.pushBool(res);\n\n              if (op.value === opcodes.OP_CHECKMULTISIGVERIFY) {\n                if (!res) throw new ScriptError('CHECKMULTISIGVERIFY', op, ip);\n                stack.pop();\n              }\n            }\n\n            break;\n          }\n        //\n        // Byte string operations\n        //\n\n        case opcodes.OP_CAT:\n          {\n            // (x1 x2 -- out)\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const v1 = stack.get(-2);\n            const v2 = stack.get(-1);\n\n            if (v1.length + v2.length > consensus.MAX_SCRIPT_PUSH) {\n              throw new ScriptError('PUSH_SIZE', op, ip);\n            }\n\n            stack.pop();\n            stack.pop();\n            stack.push(Buffer.concat([v1, v2]));\n            break;\n          }\n\n        case opcodes.OP_SPLIT:\n          {\n            // (in position -- x1 x2)\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const data = stack.get(-2); // Make sure the split point is appropriate.\n\n            const pos = stack.getInt(-1, minimal, 4);\n            if (pos < 0 || pos > data.length) throw new ScriptError('INVALID_SPLIT_RANGE', op, ip); // Prepare the results in their own buffer as `data`\n            // will be invalidated.\n\n            const n1 = data.slice(0, pos);\n            const n2 = data.slice(pos); // Replace existing stack values by the new values.\n\n            stack.set(-2, n1);\n            stack.set(-1, n2);\n            break;\n          }\n\n        case opcodes.OP_REVERSEBYTES:\n          {\n            if (stack.length < 1) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const data = stack.get(-1);\n            data.reverse();\n            break;\n          }\n        //\n        // Bitwise logic\n        //\n\n        case opcodes.OP_AND:\n        case opcodes.OP_OR:\n        case opcodes.OP_XOR:\n          {\n            // (x1 x2 - out)\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const v1 = stack.get(-2);\n            const v2 = stack.get(-1); // Inputs must be the same size\n\n            if (v1.length !== v2.length) throw new ScriptError('INVALID_OPERAND_SIZE', op, ip);\n            const raw = Buffer.alloc(v1.length);\n\n            switch (op.value) {\n              case opcodes.OP_AND:\n                for (let i = 0; i < v1.length; i++) {\n                  raw[i] = v1[i] & v2[i];\n                }\n\n                break;\n\n              case opcodes.OP_OR:\n                for (let i = 0; i < v1.length; i++) {\n                  raw[i] = v1[i] | v2[i];\n                }\n\n                break;\n\n              case opcodes.OP_XOR:\n                for (let i = 0; i < v1.length; i++) {\n                  raw[i] = v1[i] ^ v2[i];\n                }\n\n                break;\n\n              default:\n                break;\n            } // And pop v1 and v2.\n\n\n            stack.pop();\n            stack.pop();\n            stack.push(raw);\n            break;\n          }\n        //\n        // Conversion operations\n        //\n\n        case opcodes.OP_NUM2BIN:\n          {\n            // (in size -- out)\n            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            const size = stack.getInt(-1, minimal, 4);\n            if (size < 0 || size > consensus.MAX_SCRIPT_PUSH) throw new ScriptError('PUSH_SIZE', op, ip);\n            stack.pop();\n            const n = stack.get(-1);\n            const v = ScriptNum.toMinimal(Buffer.from(n)); // Try to see if we can fit that number in the number of\n            // byte requested.\n\n            if (v.length > size) // We definitively cannot.\n              throw new ScriptError('IMPOSSIBLE_ENCODING', op, ip); // We already have an element of the right size, we don't need to do\n            // anything.\n\n            if (v.length === size) {\n              stack.pop();\n              stack.push(v);\n              break;\n            }\n\n            const raw = Buffer.alloc(size);\n            v.copy(raw);\n            let signbit = 0x00;\n\n            if (v.length > 0) {\n              signbit = v[v.length - 1] & 0x80;\n              raw[v.length - 1] &= 0x7f;\n            }\n\n            raw[size - 1] = signbit;\n            stack.pop();\n            stack.push(raw);\n            break;\n          }\n\n        case opcodes.OP_BIN2NUM:\n          {\n            // (in -- out)\n            if (stack.length < 1) {\n              throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n            }\n\n            const n = stack.get(-1);\n            const v = ScriptNum.toMinimal(Buffer.from(n));\n            stack.pop();\n            stack.push(v); // The resulting number must be a valid number.\n\n            if (!ScriptNum.isMinimal(v) || v.length > 4) throw new ScriptError('INVALID_NUMBER_RANGE', op, ip);\n            break;\n          }\n\n        default:\n          {\n            throw new ScriptError('BAD_OPCODE', op, ip);\n          }\n      }\n    }\n\n    if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK) throw new ScriptError('STACK_SIZE');\n    if (state.length !== 0) throw new ScriptError('UNBALANCED_CONDITIONAL');\n  } //   /**\n  //    * Remove all matched data elements from\n  //    * a script's code (used to remove signatures\n  //    * before verification). Note that this\n  //    * compares and removes data on the _byte level_.\n  //    * It also reserializes the data to a single\n  //    * script with minimaldata encoding beforehand.\n  //    * A signature will _not_ be removed if it is\n  //    * not minimaldata.\n  //    * @see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-November/006878.html\n  //    * @see https://test.webbtc.com/tx/19aa42fee0fa57c45d3b16488198b27caaacc4ff5794510d0c17f173f05587ff\n  //    * @param {Buffer} data - Data element to match against.\n  //    * @returns {Number} Total.\n  //    */\n  //   findAndDelete(data) {\n  //     const target = Opcode.fromPush(data);\n  //     if (this.raw.length < target.getSize())\n  //       return 0;\n  //     let found = false;\n  //     for (const op of this.code) {\n  //       if (op.value === -1)\n  //         break;\n  //       if (op.equals(target)) {\n  //         found = true;\n  //         break;\n  //       }\n  //     }\n  //     if (!found)\n  //       return 0;\n  //     const code = [];\n  //     let total = 0;\n  //     for (const op of this.code) {\n  //       if (op.value === -1)\n  //         break;\n  //       if (op.equals(target)) {\n  //         total += 1;\n  //         continue;\n  //       }\n  //       code.push(op);\n  //     }\n  //     this.code = code;\n  //     this.compile();\n  //     return total;\n  //   }\n  //   /**\n  //    * Find a data element in a script.\n  //    * @param {Buffer} data - Data element to match against.\n  //    * @returns {Number} Index (`-1` if not present).\n  //    */\n  //   indexOf(data) {\n  //     for (let i = 0; i < this.code.length; i++) {\n  //       const op = this.code[i];\n  //       if (op.value === -1)\n  //         break;\n  //       if (!op.data)\n  //         continue;\n  //       if (op.data.equals(data))\n  //         return i;\n  //     }\n  //     return -1;\n  //   }\n  //   /**\n  //    * Test a script to see if it is likely\n  //    * to be script code (no weird opcodes).\n  //    * @param {Number?} flags - Script standard flags.\n  //    * @returns {Boolean}\n  //    */\n  //   isCode(flags) {\n  //     if (flags == null)\n  //       flags = Script.flags.STANDARD_VERIFY_FLAGS;\n  //     for (const op of this.code) {\n  //       if (op.value === -1)\n  //         return false;\n  //       if (op.isDisabled(flags))\n  //         return false;\n  //       switch (op.value) {\n  //         case opcodes.OP_RESERVED:\n  //         case opcodes.OP_NOP:\n  //         case opcodes.OP_VER:\n  //         case opcodes.OP_VERIF:\n  //         case opcodes.OP_VERNOTIF:\n  //         case opcodes.OP_RESERVED1:\n  //         case opcodes.OP_RESERVED2:\n  //         case opcodes.OP_NOP1:\n  //           return false;\n  //       }\n  //       if (op.value > opcodes.OP_CHECKSEQUENCEVERIFY)\n  //         return false;\n  //     }\n  //     return true;\n  //   }\n  //   /**\n  //    * Inject properties from a pay-to-pubkey script.\n  //    * @private\n  //    * @param {Buffer} key\n  //    */\n  //   fromPubkey(key) {\n  //     assert(Buffer.isBuffer(key) && (key.length === 33 || key.length === 65));\n  //     this.raw = Buffer.allocUnsafe(1 + key.length + 1);\n  //     this.raw[0] = key.length;\n  //     key.copy(this.raw, 1);\n  //     this.raw[1 + key.length] = opcodes.OP_CHECKSIG;\n  //     key = this.raw.slice(1, 1 + key.length);\n  //     this.code.length = 0;\n  //     this.code.push(Opcode.fromPush(key));\n  //     this.code.push(Opcode.fromOp(opcodes.OP_CHECKSIG));\n  //     return this;\n  //   }\n  //   /**\n  //    * Create a pay-to-pubkey script.\n  //    * @param {Buffer} key\n  //    * @returns {Script}\n  //    */\n  //   static fromPubkey(key) {\n  //     return new this().fromPubkey(key);\n  //   }\n  //   /**\n  //    * Inject properties from a pay-to-pubkeyhash script.\n  //    * @private\n  //    * @param {Buffer} hash\n  //    */\n  //   fromPubkeyhash(hash) {\n  //     assert(Buffer.isBuffer(hash) && hash.length === 20);\n  //     this.raw = Buffer.allocUnsafe(25);\n  //     this.raw[0] = opcodes.OP_DUP;\n  //     this.raw[1] = opcodes.OP_HASH160;\n  //     this.raw[2] = 0x14;\n  //     hash.copy(this.raw, 3);\n  //     this.raw[23] = opcodes.OP_EQUALVERIFY;\n  //     this.raw[24] = opcodes.OP_CHECKSIG;\n  //     hash = this.raw.slice(3, 23);\n  //     this.code.length = 0;\n  //     this.code.push(Opcode.fromOp(opcodes.OP_DUP));\n  //     this.code.push(Opcode.fromOp(opcodes.OP_HASH160));\n  //     this.code.push(Opcode.fromPush(hash));\n  //     this.code.push(Opcode.fromOp(opcodes.OP_EQUALVERIFY));\n  //     this.code.push(Opcode.fromOp(opcodes.OP_CHECKSIG));\n  //     return this;\n  //   }\n  //   /**\n  //    * Create a pay-to-pubkeyhash script.\n  //    * @param {Buffer} hash\n  //    * @returns {Script}\n  //    */\n  //   static fromPubkeyhash(hash) {\n  //     return new this().fromPubkeyhash(hash);\n  //   }\n  //   /**\n  //    * Inject properties from pay-to-multisig script.\n  //    * @private\n  //    * @param {Number} m\n  //    * @param {Number} n\n  //    * @param {Buffer[]} keys\n  //    */\n  //   fromMultisig(m, n, keys) {\n  //     assert((m & 0xff) === m && (n & 0xff) === n);\n  //     assert(Array.isArray(keys));\n  //     assert(keys.length === n, '`n` keys are required for multisig.');\n  //     assert(m >= 1 && m <= n);\n  //     assert(n >= 1 && n <= 15);\n  //     this.clear();\n  //     this.pushSmall(m);\n  //     for (const key of sortKeys(keys))\n  //       this.pushData(key);\n  //     this.pushSmall(n);\n  //     this.pushOp(opcodes.OP_CHECKMULTISIG);\n  //     return this.compile();\n  //   }\n  //   /**\n  //    * Create a pay-to-multisig script.\n  //    * @param {Number} m\n  //    * @param {Number} n\n  //    * @param {Buffer[]} keys\n  //    * @returns {Script}\n  //    */\n  //   static fromMultisig(m, n, keys) {\n  //     return new this().fromMultisig(m, n, keys);\n  //   }\n  //   /**\n  //    * Inject properties from a pay-to-scripthash script.\n  //    * @private\n  //    * @param {Buffer} hash\n  //    */\n  //   fromScripthash(hash) {\n  //     assert(Buffer.isBuffer(hash) && hash.length === 20);\n  //     this.raw = Buffer.allocUnsafe(23);\n  //     this.raw[0] = opcodes.OP_HASH160;\n  //     this.raw[1] = 0x14;\n  //     hash.copy(this.raw, 2);\n  //     this.raw[22] = opcodes.OP_EQUAL;\n  //     hash = this.raw.slice(2, 22);\n  //     this.code.length = 0;\n  //     this.code.push(Opcode.fromOp(opcodes.OP_HASH160));\n  //     this.code.push(Opcode.fromPush(hash));\n  //     this.code.push(Opcode.fromOp(opcodes.OP_EQUAL));\n  //     return this;\n  //   }\n  //   /**\n  //    * Create a pay-to-scripthash script.\n  //    * @param {Buffer} hash\n  //    * @returns {Script}\n  //    */\n  //   static fromScripthash(hash) {\n  //     return new this().fromScripthash(hash);\n  //   }\n  //   /**\n  //    * Inject properties from a nulldata/opreturn script.\n  //    * @private\n  //    * @param {Buffer} flags\n  //    */\n  //   fromNulldata(flags) {\n  //     assert(Buffer.isBuffer(flags));\n  //     assert(flags.length <= policy.MAX_OP_RETURN, 'Nulldata too large.');\n  //     this.clear();\n  //     this.pushOp(opcodes.OP_RETURN);\n  //     this.pushData(flags);\n  //     return this.compile();\n  //   }\n  //   /**\n  //    * Create a nulldata/opreturn script.\n  //    * @param {Buffer} flags\n  //    * @returns {Script}\n  //    */\n  //   static fromNulldata(flags) {\n  //     return new this().fromNulldata(flags);\n  //   }\n\n  /**\n   * Inject properties from an address.\n   * @private\n   * @param {Address|AddressString} address\n   */\n\n\n  fromAddress(address) {\n    if (typeof address === 'string') address = Address.fromString(address);\n    assert(address instanceof Address, 'Not an address.');\n    if (address.isPubkeyhash()) return this.fromPubkeyhash(address.hash);\n    if (address.isScripthash()) return this.fromScripthash(address.hash);\n    throw new Error('Unknown address type.');\n  }\n  /**\n   * Create an output script from an address.\n   * @param {Address|AddressString} address\n   * @returns {Script}\n   */\n\n\n  static fromAddress(address) {\n    return new this().fromAddress(address);\n  } //   /**\n  //    * Grab and deserialize the redeem script.\n  //    * @returns {Script|null} Redeem script.\n  //    */\n  //   getRedeem() {\n  //     let data = null;\n  //     for (const op of this.code) {\n  //       if (op.value === -1)\n  //         return null;\n  //       if (op.value > opcodes.OP_16)\n  //         return null;\n  //       data = op.data;\n  //     }\n  //     if (!data)\n  //       return null;\n  //     return Script.fromRaw(data);\n  //   }\n  //   /**\n  //    * Get the standard script type.\n  //    * @returns {ScriptType}\n  //    */\n  //   getType() {\n  //     if (this.isPubkey())\n  //       return scriptTypes.PUBKEY;\n  //     if (this.isPubkeyhash())\n  //       return scriptTypes.PUBKEYHASH;\n  //     if (this.isScripthash())\n  //       return scriptTypes.SCRIPTHASH;\n  //     if (this.isMultisig())\n  //       return scriptTypes.MULTISIG;\n  //     if (this.isNulldata())\n  //       return scriptTypes.NULLDATA;\n  //     return scriptTypes.NONSTANDARD;\n  //   }\n  //   /**\n  //    * Test whether a script is of an unknown/non-standard type.\n  //    * @returns {Boolean}\n  //    */\n  //   isUnknown() {\n  //     return this.getType() === scriptTypes.NONSTANDARD;\n  //   }\n  //   /**\n  //    * Test whether the script is standard by policy standards.\n  //    * @returns {Boolean}\n  //    */\n  //   isStandard() {\n  //     const [m, n] = this.getMultisig();\n  //     if (m !== -1) {\n  //       if (n < 1 || n > 3)\n  //         return false;\n  //       if (m < 1 || m > n)\n  //         return false;\n  //       return true;\n  //     }\n  //     if (this.isNulldata())\n  //       return this.raw.length <= policy.MAX_OP_RETURN_BYTES;\n  //     return this.getType() !== scriptTypes.NONSTANDARD;\n  //   }\n  //   /**\n  //    * Calculate the size of the script\n  //    * excluding the varint size bytes.\n  //    * @returns {Number}\n  //    */\n  //   getSize() {\n  //     return this.raw.length;\n  //   }\n\n  /**\n   * Calculate the size of the script\n   * including the varint size bytes.\n   * @returns {Number}\n   */\n\n\n  getVarSize() {\n    return encoding.sizeVarBytes(this.raw);\n  } //   /**\n  //    * \"Guess\" the address of the input script.\n  //    * This method is not 100% reliable.\n  //    * @returns {Address|null}\n  //    */\n  //   getInputAddress() {\n  //     return Address.fromInputScript(this);\n  //   }\n  //   /**\n  //    * Get the address of the script if present. Note that\n  //    * pubkey and multisig scripts will be treated as though\n  //    * they are pubkeyhash and scripthashes respectively.\n  //    * @returns {Address|null}\n  //    */\n  //   getAddress() {\n  //     return Address.fromScript(this);\n  //   }\n\n  /**\n   * Get the hash160 of the raw script.\n   * @param {String?} enc\n   * @returns {Hash}\n   */\n\n\n  hash160(enc) {\n    let hash = hash160.digest(this.toRaw());\n    if (enc === 'hex') hash = hash.toString('hex');\n    return hash;\n  } //   /**\n  //    * Get the sha256 of the raw script.\n  //    * @param {String?} enc\n  //    * @returns {Hash}\n  //    */\n  //   sha256(enc) {\n  //     let hash = sha256.digest(this.toRaw());\n  //     if (enc === 'hex')\n  //       hash = hash.toString('hex');\n  //     return hash;\n  //   }\n  //   /**\n  //    * Test whether the output script is pay-to-pubkey.\n  //    * @param {Boolean} [minimal=false] - Minimaldata only.\n  //    * @returns {Boolean}\n  //    */\n  //   isPubkey(minimal) {\n  //     if (minimal) {\n  //       return this.raw.length >= 35\n  //         && (this.raw[0] === 33 || this.raw[0] === 65)\n  //         && this.raw[0] + 2 === this.raw.length\n  //         && this.raw[this.raw.length - 1] === opcodes.OP_CHECKSIG;\n  //     }\n  //     if (this.code.length !== 2)\n  //       return false;\n  //     const size = this.getLength(0);\n  //     return (size === 33 || size === 65)\n  //       && this.getOp(1) === opcodes.OP_CHECKSIG;\n  //   }\n\n  /**\n   * Get P2PK key if present.\n   * @param {Boolean} [minimal=false] - Minimaldata only.\n   * @returns {Buffer|null}\n   */\n\n\n  getPubkey(minimal) {\n    if (!this.isPubkey(minimal)) return null;\n    if (minimal) return this.raw.slice(1, 1 + this.raw[0]);\n    return this.getData(0);\n  }\n  /**\n   * Test whether the output script is pay-to-pubkeyhash.\n   * @param {Boolean} [minimal=false] - Minimaldata only.\n   * @returns {Boolean}\n   */\n\n\n  isPubkeyhash(minimal) {\n    if (minimal || this.raw.length === 25) {\n      return this.raw.length === 25 && this.raw[0] === opcodes.OP_DUP && this.raw[1] === opcodes.OP_HASH160 && this.raw[2] === 0x14 && this.raw[23] === opcodes.OP_EQUALVERIFY && this.raw[24] === opcodes.OP_CHECKSIG;\n    }\n\n    if (this.code.length !== 5) return false;\n    return this.getOp(0) === opcodes.OP_DUP && this.getOp(1) === opcodes.OP_HASH160 && this.getLength(2) === 20 && this.getOp(3) === opcodes.OP_EQUALVERIFY && this.getOp(4) === opcodes.OP_CHECKSIG;\n  }\n  /**\n   * Get P2PKH hash if present.\n   * @param {Boolean} [minimal=false] - Minimaldata only.\n   * @returns {Buffer|null}\n   */\n\n\n  getPubkeyhash(minimal) {\n    if (!this.isPubkeyhash(minimal)) return null;\n    if (minimal) return this.raw.slice(3, 23);\n    return this.getData(2);\n  }\n  /**\n     * Test whether the output script is pay-to-multisig.\n     * @param {Boolean} [minimal=true] - Minimaldata only.\n     * @returns {Boolean}\n     */\n\n\n  isMultisig(minimal) {\n    if (this.code.length < 4 || this.code.length > 19) return false;\n    if (this.getOp(-1) !== opcodes.OP_CHECKMULTISIG) return false;\n    const m = this.getSmall(0);\n    if (m < 1) return false;\n    const n = this.getSmall(-2);\n    if (n < 1 || m > n) return false;\n    if (this.code.length !== n + 3) return false;\n\n    for (let i = 1; i < n + 1; i++) {\n      const op = this.code[i];\n      const size = op.toLength();\n      if (size !== 33 && size !== 65) return false;\n      if (minimal && !op.isMinimal()) return false;\n    }\n\n    return true;\n  } //   /**\n  //    * Get multisig m and n values if present.\n  //    * @param {Boolean} [minimal=false] - Minimaldata only.\n  //    * @returns {Array} [m, n]\n  //    */\n  //   getMultisig(minimal) {\n  //     if (!this.isMultisig(minimal))\n  //       return [-1, -1];\n  //     return [this.getSmall(0), this.getSmall(-2)];\n  //   }\n\n  /**\n   * Test whether the output script is pay-to-scripthash. Note that\n   * bitcoin itself requires scripthashes to be in strict minimaldata\n   * encoding. Using `OP_HASH160 OP_PUSHDATA1 [hash] OP_EQUAL` will\n   * _not_ be recognized as a scripthash.\n   * @returns {Boolean}\n   */\n\n\n  isScripthash() {\n    return this.raw.length === 23 && this.raw[0] === opcodes.OP_HASH160 && this.raw[1] === 0x14 && this.raw[22] === opcodes.OP_EQUAL;\n  }\n  /**\n   * Get P2SH hash if present.\n   * @returns {Buffer|null}\n   */\n\n\n  getScripthash() {\n    if (!this.isScripthash()) return null;\n    return this.getData(1);\n  } //   /**\n  //    * Test whether the output script is nulldata/opreturn.\n  //    * @param {Boolean} [minimal=false] - Minimaldata only.\n  //    * @returns {Boolean}\n  //    */\n  //   isNulldata(minimal) {\n  //     if (this.code.length === 0)\n  //       return false;\n  //     if (this.getOp(0) !== opcodes.OP_RETURN)\n  //       return false;\n  //     if (this.code.length === 1)\n  //       return true;\n  //     if (minimal) {\n  //       if (this.raw.length > policy.MAX_OP_RETURN_BYTES)\n  //         return false;\n  //     }\n  //     for (let i = 1; i < this.code.length; i++) {\n  //       const op = this.code[i];\n  //       if (op.value === -1)\n  //         return false;\n  //       if (op.value > opcodes.OP_16)\n  //         return false;\n  //       if (minimal && !op.isMinimal())\n  //         return false;\n  //     }\n  //     return true;\n  //   }\n  //   /**\n  //    * Get OP_RETURN data if present.\n  //    * @param {Boolean} [minimal=false] - Minimaldata only.\n  //    * @returns {Buffer|null}\n  //    */\n  //   getNulldata(minimal) {\n  //     if (!this.isNulldata(minimal))\n  //       return null;\n  //     for (let i = 1; i < this.code.length; i++) {\n  //       const op = this.code[i];\n  //       const data = op.toPush();\n  //       if (data)\n  //         return data;\n  //     }\n  //     return EMPTY_BUFFER;\n  //   }\n  //   /**\n  //    * Test whether the output script is a witness program.\n  //    * Note that this will return true even for malformed\n  //    * witness v0 programs.\n  //    * @returns {Boolean}\n  //    */\n  //   isProgram() {\n  //     if (this.raw.length < 4 || this.raw.length > 42)\n  //       return false;\n  //     if (this.raw[0] !== opcodes.OP_0\n  //       && (this.raw[0] < opcodes.OP_1 || this.raw[0] > opcodes.OP_16)) {\n  //       return false;\n  //     }\n  //     if (this.raw[1] + 2 !== this.raw.length)\n  //       return false;\n  //     return true;\n  //   }\n  //   /**\n  //    * Test whether the output script is unspendable.\n  //    * @returns {Boolean}\n  //    */\n  //   isUnspendable() {\n  //     if (this.raw.length > consensus.MAX_SCRIPT_SIZE)\n  //       return true;\n  //     return this.raw.length > 0 && this.raw[0] === opcodes.OP_RETURN;\n  //   }\n  //   /**\n  //    * \"Guess\" the type of the input script.\n  //    * This method is not 100% reliable.\n  //    * @returns {ScriptType}\n  //    */\n  //   getInputType() {\n  //     if (this.isPubkeyInput())\n  //       return scriptTypes.PUBKEY;\n  //     if (this.isPubkeyhashInput())\n  //       return scriptTypes.PUBKEYHASH;\n  //     if (this.isScripthashInput())\n  //       return scriptTypes.SCRIPTHASH;\n  //     if (this.isMultisigInput())\n  //       return scriptTypes.MULTISIG;\n  //     return scriptTypes.NONSTANDARD;\n  //   }\n  //   /**\n  //    * \"Guess\" whether the input script is an unknown/non-standard type.\n  //    * This method is not 100% reliable.\n  //    * @returns {Boolean}\n  //    */\n  //   isUnknownInput() {\n  //     return this.getInputType() === scriptTypes.NONSTANDARD;\n  //   }\n  //   /**\n  //    * \"Guess\" whether the input script is pay-to-pubkey.\n  //    * This method is not 100% reliable.\n  //    * @returns {Boolean}\n  //    */\n  //   isPubkeyInput() {\n  //     if (this.code.length !== 1)\n  //       return false;\n  //     const size = this.getLength(0);\n  //     return size >= 9 && size <= 73;\n  //   }\n  //   /**\n  //    * Get P2PK signature if present.\n  //    * @returns {Buffer|null}\n  //    */\n  //   getPubkeyInput() {\n  //     if (!this.isPubkeyInput())\n  //       return null;\n  //     return this.getData(0);\n  //   }\n  //   /**\n  //    * \"Guess\" whether the input script is pay-to-pubkeyhash.\n  //    * This method is not 100% reliable.\n  //    * @returns {Boolean}\n  //    */\n  //   isPubkeyhashInput() {\n  //     if (this.code.length !== 2)\n  //       return false;\n  //     const sig = this.getLength(0);\n  //     const key = this.getLength(1);\n  //     return sig >= 9 && sig <= 73\n  //       && (key === 33 || key === 65);\n  //   }\n  //   /**\n  //    * Get P2PKH signature and key if present.\n  //    * @returns {Array} [sig, key]\n  //    */\n  //   getPubkeyhashInput() {\n  //     if (!this.isPubkeyhashInput())\n  //       return [null, null];\n  //     return [this.getData(0), this.getData(1)];\n  //   }\n  //   /**\n  //    * \"Guess\" whether the input script is pay-to-multisig.\n  //    * This method is not 100% reliable.\n  //    * @returns {Boolean}\n  //    */\n  //   isMultisigInput() {\n  //     if (this.code.length < 2)\n  //       return false;\n  //     if (this.getOp(0) !== opcodes.OP_0)\n  //       return false;\n  //     if (this.getOp(1) > opcodes.OP_PUSHDATA4)\n  //       return false;\n  //     // We need to rule out scripthash\n  //     // because it may look like multisig.\n  //     if (this.isScripthashInput())\n  //       return false;\n  //     for (let i = 1; i < this.code.length; i++) {\n  //       const size = this.getLength(i);\n  //       if (size < 9 || size > 73)\n  //         return false;\n  //     }\n  //     return true;\n  //   }\n  //   /**\n  //    * Get multisig signatures if present.\n  //    * @returns {Buffer[]|null}\n  //    */\n  //   getMultisigInput() {\n  //     if (!this.isMultisigInput())\n  //       return null;\n  //     const sigs = [];\n  //     for (let i = 1; i < this.code.length; i++)\n  //       sigs.push(this.getData(i));\n  //     return sigs;\n  //   }\n  //   /**\n  //    * \"Guess\" whether the input script is pay-to-scripthash.\n  //    * This method is not 100% reliable.\n  //    * @returns {Boolean}\n  //    */\n  //   isScripthashInput() {\n  //     if (this.code.length < 1)\n  //       return false;\n  //     // Grab the raw redeem script.\n  //     const raw = this.getData(-1);\n  //     // Last data element should be an array\n  //     // for the redeem script.\n  //     if (!raw)\n  //       return false;\n  //     // Testing for scripthash inputs requires\n  //     // some evil magic to work. We do it by\n  //     // ruling things _out_. This test will not\n  //     // be correct 100% of the time. We rule\n  //     // out that the last data element is: a\n  //     // null dummy, a valid signature, a valid\n  //     // key, and we ensure that it is at least\n  //     // a script that does not use undefined\n  //     // opcodes.\n  //     if (raw.length === 0)\n  //       return false;\n  //     if (common.isDERSignatureEncoding(raw.slice(0, -1)))\n  //       return false;\n  //     if (common.isKeyEncoding(raw))\n  //       return false;\n  //     const redeem = Script.fromRaw(raw);\n  //     if (!redeem.isCode())\n  //       return false;\n  //     if (redeem.isUnspendable())\n  //       return false;\n  //     if (!this.isPushOnly())\n  //       return false;\n  //     return true;\n  //   }\n  //   /**\n  //    * Get P2SH redeem script if present.\n  //    * @returns {Buffer|null}\n  //    */\n  //   getScripthashInput() {\n  //     if (!this.isScripthashInput())\n  //       return null;\n  //     return this.getData(-1);\n  //   }\n  //   /**\n  //    * Get coinbase height.\n  //    * @returns {Number} `-1` if not present.\n  //    */\n  //   getCoinbaseHeight() {\n  //     return Script.getCoinbaseHeight(this.raw);\n  //   }\n  //   /**\n  //    * Get coinbase height.\n  //    * @param {Buffer} raw - Raw script.\n  //    * @returns {Number} `-1` if not present.\n  //    */\n  //   static getCoinbaseHeight(raw) {\n  //     if (raw.length === 0)\n  //       return -1;\n  //     if (raw[0] >= opcodes.OP_1 && raw[0] <= opcodes.OP_16)\n  //       return raw[0] - 0x50;\n  //     if (raw[0] > 0x06)\n  //       return -1;\n  //     const op = Opcode.fromRaw(raw);\n  //     const num = op.toNum();\n  //     if (!num)\n  //       return 1;\n  //     if (num.isNeg())\n  //       return -1;\n  //     if (!op.equals(Opcode.fromNum(num)))\n  //       return -1;\n  //     return num.toDouble();\n  //   }\n  //   /**\n  //    * Test the script against a bloom filter.\n  //    * @param {Bloom} filter\n  //    * @returns {Boolean}\n  //    */\n  //   test(filter) {\n  //     for (const op of this.code) {\n  //       if (op.value === -1)\n  //         break;\n  //       if (!op.data || op.data.length === 0)\n  //         continue;\n  //       if (filter.test(op.data))\n  //         return true;\n  //     }\n  //     return false;\n  //   }\n  //   /**\n  //    * Test the script to see if it contains only push ops.\n  //    * Push ops are: OP_1NEGATE, OP_0-OP_16 and all PUSHDATAs.\n  //    * @returns {Boolean}\n  //    */\n\n\n  isPushOnly() {\n    for (const op of this.code) {\n      if (op.value === -1) return false;\n      if (op.value > opcodes.OP_16) return false;\n    }\n\n    return true;\n  } //   /**\n  //    * Count the sigops in the script.\n  //    * @param {Boolean} accurate - Whether to enable accurate counting. This will\n  //    * take into account the `n` value for OP_CHECKMULTISIG(VERIFY).\n  //    * @returns {Number} sigop count\n  //    */\n  //   getSigops(accurate, flags) {\n  //     if (flags & Script.flags.VERIFY_ZERO_SIGOPS)\n  //       return 0;\n  //     let total = 0;\n  //     let lastOp = -1;\n  //     for (const op of this.code) {\n  //       if (op.value === -1)\n  //         break;\n  //       switch (op.value) {\n  //         case opcodes.OP_CHECKSIG:\n  //         case opcodes.OP_CHECKSIGVERIFY:\n  //           total += 1;\n  //           break;\n  //         case opcodes.OP_CHECKSDATAIG:\n  //         case opcodes.OP_CHECKDATASIGVERIFY:\n  //           if (flags & Script.flags.VERIFY_CHECKDATASIG) {\n  //             total += 1;\n  //           }\n  //           break;\n  //         case opcodes.OP_CHECKMULTISIG:\n  //         case opcodes.OP_CHECKMULTISIGVERIFY:\n  //           if (accurate && lastOp >= opcodes.OP_1 && lastOp <= opcodes.OP_16)\n  //             total += lastOp - 0x50;\n  //           else\n  //             total += consensus.MAX_MULTISIG_PUBKEYS;\n  //           break;\n  //       }\n  //       lastOp = op.value;\n  //     }\n  //     return total;\n  //   }\n  //   /**\n  //    * Count the sigops in the script, taking into account redeem scripts.\n  //    * @param {Script} input - Input script, needed for access to redeem script.\n  //    * @param {VerifyFlags} flags\n  //    * @returns {Number} sigop count\n  //    */\n  //   getScripthashSigops(input, flags) {\n  //     if (!this.isScripthash())\n  //       return this.getSigops(true, flags);\n  //     const redeem = input.getRedeem();\n  //     if (!redeem)\n  //       return 0;\n  //     return redeem.getSigops(true, flags);\n  //   }\n  //   /*\n  //    * Mutation\n  //    */\n  //   get(index) {\n  //     if (index < 0)\n  //       index += this.code.length;\n  //     if (index < 0 || index >= this.code.length)\n  //       return null;\n  //     return this.code[index];\n  //   }\n  //   pop() {\n  //     const op = this.code.pop();\n  //     return op || null;\n  //   }\n  //   shift() {\n  //     const op = this.code.shift();\n  //     return op || null;\n  //   }\n  //   remove(index) {\n  //     if (index < 0)\n  //       index += this.code.length;\n  //     if (index < 0 || index >= this.code.length)\n  //       return null;\n  //     const items = this.code.splice(index, 1);\n  //     if (items.length === 0)\n  //       return null;\n  //     return items[0];\n  //   }\n  //   set(index, op) {\n  //     if (index < 0)\n  //       index += this.code.length;\n  //     assert(Opcode.isOpcode(op));\n  //     assert(index >= 0 && index <= this.code.length);\n  //     this.code[index] = op;\n  //     return this;\n  //   }\n\n\n  push(op) {\n    assert(Opcode.isOpcode(op));\n    this.code.push(op);\n    return this;\n  } //   unshift(op) {\n  //     assert(Opcode.isOpcode(op));\n  //     this.code.unshift(op);\n  //     return this;\n  //   }\n  //   insert(index, op) {\n  //     if (index < 0)\n  //       index += this.code.length;\n  //     assert(Opcode.isOpcode(op));\n  //     assert(index >= 0 && index <= this.code.length);\n  //     this.code.splice(index, 0, op);\n  //     return this;\n  //   }\n  //   /*\n  //    * Op\n  //    */\n  //   getOp(index) {\n  //     const op = this.get(index);\n  //     return op ? op.value : -1;\n  //   }\n  //   popOp() {\n  //     const op = this.pop();\n  //     return op ? op.value : -1;\n  //   }\n  //   shiftOp() {\n  //     const op = this.shift();\n  //     return op ? op.value : -1;\n  //   }\n  //   removeOp(index) {\n  //     const op = this.remove(index);\n  //     return op ? op.value : -1;\n  //   }\n  //   setOp(index, value) {\n  //     return this.set(index, Opcode.fromOp(value));\n  //   }\n  //   pushOp(value) {\n  //     return this.push(Opcode.fromOp(value));\n  //   }\n  //   unshiftOp(value) {\n  //     return this.unshift(Opcode.fromOp(value));\n  //   }\n  //   insertOp(index, value) {\n  //     return this.insert(index, Opcode.fromOp(value));\n  //   }\n\n  /*\n   * Data\n   */\n\n\n  getData(index) {\n    const op = this.get(index);\n    return op ? op.data : null;\n  } //   popData() {\n  //     const op = this.pop();\n  //     return op ? op.data : null;\n  //   }\n  //   shiftData() {\n  //     const op = this.shift();\n  //     return op ? op.data : null;\n  //   }\n  //   removeData(index) {\n  //     const op = this.remove(index);\n  //     return op ? op.data : null;\n  //   }\n  //   setData(index, data) {\n  //     return this.set(index, Opcode.fromData(data));\n  //   }\n\n\n  pushData(data) {\n    return this.push(Opcode.fromData(data));\n  } //   unshiftData(data) {\n  //     return this.unshift(Opcode.fromData(data));\n  //   }\n  //   insertData(index, data) {\n  //     return this.insert(index, Opcode.fromData(data));\n  //   }\n  //   /*\n  //    * Length\n  //    */\n  //   getLength(index) {\n  //     const op = this.get(index);\n  //     return op ? op.toLength() : -1;\n  //   }\n  //   /*\n  //    * Push\n  //    */\n  //   getPush(index) {\n  //     const op = this.get(index);\n  //     return op ? op.toPush() : null;\n  //   }\n  //   popPush() {\n  //     const op = this.pop();\n  //     return op ? op.toPush() : null;\n  //   }\n  //   shiftPush() {\n  //     const op = this.shift();\n  //     return op ? op.toPush() : null;\n  //   }\n  //   removePush(index) {\n  //     const op = this.remove(index);\n  //     return op ? op.toPush() : null;\n  //   }\n  //   setPush(index, data) {\n  //     return this.set(index, Opcode.fromPush(data));\n  //   }\n  //   pushPush(data) {\n  //     return this.push(Opcode.fromPush(data));\n  //   }\n  //   unshiftPush(data) {\n  //     return this.unshift(Opcode.fromPush(data));\n  //   }\n  //   insertPush(index, data) {\n  //     return this.insert(index, Opcode.fromPush(data));\n  //   }\n  //   /*\n  //    * String\n  //    */\n  //   getString(index, enc) {\n  //     const op = this.get(index);\n  //     return op ? op.toString(enc) : null;\n  //   }\n  //   popString(enc) {\n  //     const op = this.pop();\n  //     return op ? op.toString(enc) : null;\n  //   }\n  //   shiftString(enc) {\n  //     const op = this.shift();\n  //     return op ? op.toString(enc) : null;\n  //   }\n  //   removeString(index, enc) {\n  //     const op = this.remove(index);\n  //     return op ? op.toString(enc) : null;\n  //   }\n  //   setString(index, str, enc) {\n  //     return this.set(index, Opcode.fromString(str, enc));\n  //   }\n  //   pushString(str, enc) {\n  //     return this.push(Opcode.fromString(str, enc));\n  //   }\n  //   unshiftString(str, enc) {\n  //     return this.unshift(Opcode.fromString(str, enc));\n  //   }\n  //   insertString(index, str, enc) {\n  //     return this.insert(index, Opcode.fromString(str, enc));\n  //   }\n  //   /*\n  //    * Small\n  //    */\n  //   getSmall(index) {\n  //     const op = this.get(index);\n  //     return op ? op.toSmall() : -1;\n  //   }\n  //   popSmall() {\n  //     const op = this.pop();\n  //     return op ? op.toSmall() : -1;\n  //   }\n  //   shiftSmall() {\n  //     const op = this.shift();\n  //     return op ? op.toSmall() : -1;\n  //   }\n  //   removeSmall(index) {\n  //     const op = this.remove(index);\n  //     return op ? op.toSmall() : -1;\n  //   }\n  //   setSmall(index, num) {\n  //     return this.set(index, Opcode.fromSmall(num));\n  //   }\n  //   pushSmall(num) {\n  //     return this.push(Opcode.fromSmall(num));\n  //   }\n  //   unshiftSmall(num) {\n  //     return this.unshift(Opcode.fromSmall(num));\n  //   }\n  //   insertSmall(index, num) {\n  //     return this.insert(index, Opcode.fromSmall(num));\n  //   }\n  //   /*\n  //    * Num\n  //    */\n  //   getNum(index, minimal, limit) {\n  //     const op = this.get(index);\n  //     return op ? op.toNum(minimal, limit) : null;\n  //   }\n  //   popNum(minimal, limit) {\n  //     const op = this.pop();\n  //     return op ? op.toNum(minimal, limit) : null;\n  //   }\n  //   shiftNum(minimal, limit) {\n  //     const op = this.shift();\n  //     return op ? op.toNum(minimal, limit) : null;\n  //   }\n  //   removeNum(index, minimal, limit) {\n  //     const op = this.remove(index);\n  //     return op ? op.toNum(minimal, limit) : null;\n  //   }\n  //   setNum(index, num) {\n  //     return this.set(index, Opcode.fromNum(num));\n  //   }\n  //   pushNum(num) {\n  //     return this.push(Opcode.fromNum(num));\n  //   }\n  //   unshiftNum(num) {\n  //     return this.unshift(Opcode.fromNum(num));\n  //   }\n  //   insertNum(index, num) {\n  //     return this.insert(index, Opcode.fromNum(num));\n  //   }\n  //   /*\n  //    * Int\n  //    */\n  //   getInt(index, minimal, limit) {\n  //     const op = this.get(index);\n  //     return op ? op.toInt(minimal, limit) : -1;\n  //   }\n  //   popInt(minimal, limit) {\n  //     const op = this.pop();\n  //     return op ? op.toInt(minimal, limit) : -1;\n  //   }\n  //   shiftInt(minimal, limit) {\n  //     const op = this.shift();\n  //     return op ? op.toInt(minimal, limit) : -1;\n  //   }\n  //   removeInt(index, minimal, limit) {\n  //     const op = this.remove(index);\n  //     return op ? op.toInt(minimal, limit) : -1;\n  //   }\n  //   setInt(index, num) {\n  //     return this.set(index, Opcode.fromInt(num));\n  //   }\n  //   pushInt(num) {\n  //     return this.push(Opcode.fromInt(num));\n  //   }\n  //   unshiftInt(num) {\n  //     return this.unshift(Opcode.fromInt(num));\n  //   }\n  //   insertInt(index, num) {\n  //     return this.insert(index, Opcode.fromInt(num));\n  //   }\n  //   /*\n  //    * Bool\n  //    */\n  //   getBool(index) {\n  //     const op = this.get(index);\n  //     return op ? op.toBool() : false;\n  //   }\n  //   popBool() {\n  //     const op = this.pop();\n  //     return op ? op.toBool() : false;\n  //   }\n  //   shiftBool() {\n  //     const op = this.shift();\n  //     return op ? op.toBool() : false;\n  //   }\n  //   removeBool(index) {\n  //     const op = this.remove(index);\n  //     return op ? op.toBool() : false;\n  //   }\n  //   setBool(index, value) {\n  //     return this.set(index, Opcode.fromBool(value));\n  //   }\n  //   pushBool(value) {\n  //     return this.push(Opcode.fromBool(value));\n  //   }\n  //   unshiftBool(value) {\n  //     return this.unshift(Opcode.fromBool(value));\n  //   }\n  //   insertBool(index, value) {\n  //     return this.insert(index, Opcode.fromBool(value));\n  //   }\n  //   /*\n  //    * Symbol\n  //    */\n  //   getSym(index) {\n  //     const op = this.get(index);\n  //     return op ? op.toSymbol() : null;\n  //   }\n  //   popSym() {\n  //     const op = this.pop();\n  //     return op ? op.toSymbol() : null;\n  //   }\n  //   shiftSym() {\n  //     const op = this.shift();\n  //     return op ? op.toSymbol() : null;\n  //   }\n  //   removeSym(index) {\n  //     const op = this.remove(index);\n  //     return op ? op.toSymbol() : null;\n  //   }\n  //   setSym(index, symbol) {\n  //     return this.set(index, Opcode.fromSymbol(symbol));\n  //   }\n  //   pushSym(symbol) {\n  //     return this.push(Opcode.fromSymbol(symbol));\n  //   }\n  //   unshiftSym(symbol) {\n  //     return this.unshift(Opcode.fromSymbol(symbol));\n  //   }\n  //   insertSym(index, symbol) {\n  //     return this.insert(index, Opcode.fromSymbol(symbol));\n  //   }\n  //   /**\n  //    * Inject properties from bitcoind test string.\n  //    * @private\n  //    * @param {String} items - Script string.\n  //    * @throws Parse error.\n  //    */\n  //   fromString(code) {\n  //     assert(typeof code === 'string');\n  //     code = code.trim();\n  //     if (code.length === 0)\n  //       return this;\n  //     const items = code.split(/\\s+/);\n  //     const bw = bio.write();\n  //     for (const item of items) {\n  //       let symbol = item;\n  //       if (symbol.charCodeAt(0) & 32)\n  //         symbol = symbol.toUpperCase();\n  //       if (!/^OP_/.test(symbol))\n  //         symbol = `OP_${symbol}`;\n  //       const value = opcodes[symbol];\n  //       if (value == null) {\n  //         if (item[0] === '\\'') {\n  //           assert(item[item.length - 1] === '\\'', 'Invalid string.');\n  //           const str = item.slice(1, -1);\n  //           const op = Opcode.fromString(str);\n  //           bw.writeBytes(op.toRaw());\n  //           continue;\n  //         }\n  //         if (/^-?\\d+$/.test(item)) {\n  //           const num = ScriptNum.fromString(item, 10);\n  //           const op = Opcode.fromNum(num);\n  //           bw.writeBytes(op.toRaw());\n  //           continue;\n  //         }\n  //         assert(item.indexOf('0x') === 0, 'Unknown opcode.');\n  //         const hex = item.substring(2);\n  //         const data = Buffer.from(hex, 'hex');\n  //         assert(data.length === hex.length / 2, 'Invalid hex string.');\n  //         bw.writeBytes(data);\n  //         continue;\n  //       }\n  //       bw.writeU8(value);\n  //     }\n  //     return this.fromRaw(bw.render());\n  //   }\n  //   /**\n  //    * Parse a bitcoind test script\n  //    * string into a script object.\n  //    * @param {String} items - Script string.\n  //    * @returns {Script}\n  //    * @throws Parse error.\n  //    */\n  //   static fromString(code) {\n  //     return new this().fromString(code);\n  //   }\n\n  /**\n   * Verify an input and output script, and a witness if present.\n   * @param {Script} input\n   * @param {Null} witness\n   * @param {Script} output\n   * @param {TX} tx\n   * @param {Number} index\n   * @param {Amount} value\n   * @param {VerifyFlags} flags\n   * @param {Number?} sigchecks\n   * @throws {ScriptError}\n   */\n\n\n  static verify(input, witness, output, tx, index, value, flags, sigchecks) {\n    if (flags == null) flags = Script.flags.STANDARD_VERIFY_FLAGS;\n\n    if (flags & Script.flags.VERIFY_SIGPUSHONLY) {\n      if (!input.isPushOnly()) throw new ScriptError('SIG_PUSHONLY');\n    }\n\n    if (flags & Script.flags.VERIFY_SIGHASH_FORKID) flags |= Script.flags.VERIFY_STRICTENC; // Setup a stack.\n\n    let stack = new Stack(); // Execute the input script\n\n    input.execute(stack, flags, tx, index, value, metrics.sigchecks); // Copy the stack for P2SH\n\n    let copy;\n    if (flags & Script.flags.VERIFY_P2SH) copy = stack.clone(); // Execute the previous output script.\n\n    output.execute(stack, flags, tx, index, value, metrics.sigchecks); // Verify the stack values.\n\n    if (stack.length === 0 || !stack.getBool(-1)) throw new ScriptError('EVAL_FALSE'); // If the script is P2SH, execute the real output script\n\n    if (flags & Script.flags.VERIFY_P2SH && output.isScripthash()) {\n      // P2SH can only have push ops in the scriptSig\n      if (!input.isPushOnly()) throw new ScriptError('SIG_PUSHONLY'); // Reset the stack\n\n      stack = copy; // Stack should not be empty at this point\n\n      if (stack.length === 0) throw new ScriptError('EVAL_FALSE'); // Grab the real redeem script\n\n      const raw = stack.pop();\n      const redeem = Script.fromRaw(raw);\n\n      if ((flags & Script.flags.VERIFY_DISALLOW_SEGWIT_RECOVERY) === 0 && stack.length === 0 && redeem.isProgram()) {\n        // Before activation all transaction count a value of 0\n        if (!(flags & Script.flags.REPORT_SIGCHECKS)) {\n          metrics.sigchecks = 0;\n        }\n\n        return;\n      } // Execute the redeem script.\n\n\n      redeem.execute(stack, flags, tx, index, value, 0, metrics.sigchecks); // Verify the the stack values.\n\n      if (stack.length === 0 || !stack.getBool(-1)) throw new ScriptError('EVAL_FALSE');\n    } // Ensure there is nothing left on the stack.\n\n\n    if (flags & Script.flags.VERIFY_CLEANSTACK) {\n      assert((flags & Script.flags.VERIFY_P2SH) !== 0);\n      if (stack.length !== 1) throw new ScriptError('CLEANSTACK');\n    }\n\n    if (flags & Script.flags.VERIFY_INPUT_SIGCHECKS) {\n      if (input.getSize() < metrics.sigchecks * 43 - 60) throw new ScriptError('INPUT_SIGCHECKS');\n    }\n\n    if (!(flags & Script.flags.REPORT_SIGCHECKS)) {\n      metrics.sigchecks = 0;\n    }\n  } //   /**\n  //    * Inject properties from buffer reader.\n  //    * @private\n  //    * @param {BufferReader} br\n  //    */\n  //   fromReader(br) {\n  //     return this.fromRaw(br.readVarBytes());\n  //   }\n\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer}\n   */\n\n\n  fromRaw(data) {\n    const br = bio.read(data);\n    this.raw = data;\n\n    while (br.left()) this.code.push(Opcode.fromReader(br));\n\n    return this;\n  } //   /**\n  //    * Create a script from buffer reader.\n  //    * @param {BufferReader} br\n  //    * @param {String?} enc - Either `\"hex\"` or `null`.\n  //    * @returns {Script}\n  //    */\n  //   static fromReader(br) {\n  //     return new this().fromReader(br);\n  //   }\n  //   /**\n  //    * Create a script from a serialized buffer.\n  //    * @param {Buffer|String} data - Serialized script.\n  //    * @param {String?} enc - Either `\"hex\"` or `null`.\n  //    * @returns {Script}\n  //    */\n\n\n  static fromRaw(data, enc) {\n    if (typeof data === 'string') data = Buffer.from(data, enc);\n    return new this().fromRaw(data);\n  } //   /**\n  //    * Test whether an object a Script.\n  //    * @param {Object} obj\n  //    * @returns {Boolean}\n  //    */\n  //   static isScript(obj) {\n  //     return obj instanceof Script;\n  //   }\n\n\n} // /**\n//  * Script opcodes.\n//  * @enum {Number}\n//  * @default\n//  */\n// Script.opcodes = common.opcodes;\n// /**\n//  * Opcodes by value.\n//  * @const {RevMap}\n//  */\n// Script.opcodesByVal = common.opcodesByVal;\n\n/**\n * Script and locktime flags. See {@link VerifyFlags}.\n * @enum {Number}\n */\n\n\nScript.flags = common.flags;\n/**\n * Sighash Types.\n * @enum {SighashType}\n * @default\n */\n\nScript.hashType = common.hashType; // /**\n//  * Sighash types by value.\n//  * @const {RevMap}\n//  */\n// Script.hashTypeByVal = common.hashTypeByVal;\n// /**\n//  * Output script types.\n//  * @enum {Number}\n//  */\n// Script.types = common.types;\n// /**\n//  * Output script types by value.\n//  * @const {RevMap}\n//  */\n// Script.typesByVal = common.typesByVal;\n// /*\n//  * Helpers\n//  */\n// function sortKeys(keys) {\n//   return keys.slice().sort((a, b) => {\n//     return a.compare(b);\n//   });\n// }\n// /**\n//  * Test whether the data element is a valid key if VERIFY_STRICTENC is enabled.\n//  * @param {Buffer} key\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n// function validateKey(key, flags) {\n//   assert(Buffer.isBuffer(key));\n//   assert(typeof flags === 'number');\n//   if (flags & Script.flags.VERIFY_STRICTENC) {\n//     if (!common.isKeyEncoding(key))\n//       throw new ScriptError('PUBKEYTYPE');\n//   }\n//   if ((flags & Script.flags.VERIFY_COMPRESSED_PUBKEYTYPE)\n//     && !common.isCompressedEncoding(key)) {\n//     throw new ScriptError('NONCOMPRESSED_PUBKEY');\n//   };\n//   return true;\n// }\n// /**\n//  * Test whether the raw element is a valid signature based\n//  * on the encoding, S value, and sighash type.\n//  * In an ECDSA-only context, 64-byte signatures are bannned\n//  * when Schnorr Flag is set.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n// function validateECDSASignature(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n//   if (common.isSchnorr(sig))\n//     throw new ScriptError('SIG_BADLENGTH');\n//   if ((flags & Script.flags.VERIFY_DERSIG)\n//       || (flags & Script.flags.VERIFY_LOW_S)\n//       || (flags & Script.flags.VERIFY_STRICTENC)) {\n//     if (!common.isDERSignatureEncoding(sig))\n//       throw new ScriptError('SIG_DER');\n//   }\n//   if (flags & Script.flags.VERIFY_LOW_S) {\n//     if (!common.isLowDER(sig))\n//       throw new ScriptError('SIG_HIGH_S');\n//   }\n//   return true;\n// }\n// /**\n//  * Test whether the tx element is a valid signature based\n//  * on the encoding, S value, and sighash type. Requires\n//  * VERIFY_STRICTENC, VERIFY_SIGHASH_FORKID to be enabled respectively.\n//  * Note that this will allow zero-length signatures.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n// function checkSighashEncoding(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n//   if (flags & Script.flags.VERIFY_STRICTENC) {\n//     if (!common.isHashType(sig))\n//       throw new ScriptError('SIG_HASHTYPE');\n//     const usesFork = sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID;\n//     const forkEnabled = flags & Script.flags.VERIFY_SIGHASH_FORKID;\n//     if (!forkEnabled && usesFork)\n//       throw new ScriptError('ILLEGAL_FORKID');\n//     if (forkEnabled && !usesFork)\n//       throw new ScriptError('MUST_USE_FORKID');\n//   }\n//   return true;\n// }\n// /**\n//  * Test whether the transaction tested against\n//  * the Sighash Encoding is a valid Schnorr Signature.\n//  * Requires Sighash\n//  * @param {Buffer} sig\n//  * @param {VeirfyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n// function checkTransactionSignature(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n//   // allow empty sigs\n//   if (sig.length === 0)\n//     return true;\n//   validateSchnorrSignature(sig.slice(0, -1), flags);\n//   return checkSighashEncoding(sig, flags);\n// }\n// /**\n//  * Test whether the transaction is tested\n//  * against the sighash encoding w schnorr / ecdsa\n//  * for multisig opcodes.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  */\n// function checkTransactionSchnorrSig(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n//   // Allow empty sigs.\n//   if (sig.length === 0)\n//     return true;\n//   if (!isSchnorrEncoded(sig.slice(0, -1), flags))\n//     return validateECDSASignature(sig.slice(0, -1), flags);\n//   return checkSighashEncoding(sig, flags);\n// }\n// /**\n//  * Test whether the transaction tested against\n//  * the Sighash Encoding is a valid ECDSA Signature.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n// function checkTransactionECDSASignature(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n//   // Allow empty sigs\n//   if (sig.length === 0)\n//     return true;\n//   validateECDSASignature(sig.slice(0, -1), flags);\n//   return checkSighashEncoding(sig, flags);\n// }\n// /**\n//  * Test whether the data element is a valid signature based\n//  * on the encoding, S value, and sighash type. Requires\n//  * VERIFY_DERSIG|VERIFY_LOW_S|VERIFY_STRICTENC, and VERIFY_LOW_S\n//  * to be enabled respectively. Note that this will allow zero-length\n//  * signatures.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n// function validateDataSignature(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n//   // Allow empty sigs\n//   if (sig.length === 0)\n//     return true;\n//   return validateSchnorrSignature(sig.slice(0, sig.length), flags);\n// }\n// /**\n//  * Test whether the Signature is valid in context\n//  * 64-byte signatures are interpreted as schnorr signatures.\n//  * Always correctly encoded when Verify_SCHNORR flag is set.\n//  * @param {Buffer} sig\n//  * @param {Buffer} msg - Signature hash.\n//  * @param {VerifyFlags?} flags\n//  * @returns {Promise}\n//  * @throws {ScriptError}\n//  */\n// function validateSchnorrSignature(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n//   if (common.isSchnorr(sig))\n//     return true;\n//   return validateECDSASignature(sig, flags);\n// }\n// /**\n//  * Test whether the current signature is schnorr encoded.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n// function isSchnorrEncoded(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n//   if (common.isSchnorr(sig))\n//     return true;\n//   throw new ScriptError('SIG_NONSCHNORR');\n// }\n// /**\n//  * Test whether the signature from the stack\n//  * is valid in either Schnorr or DER Format.\n//  * Always encoded correctly when Schnorr flag is set.\n//  * @param {Buffer} hash\n//  * @param {Buffer} sig\n//  * @param {Buffer} key\n//  * @param {Number} flags\n//  */\n// function verifySignature(hash, sig, key, flags) {\n//   assert(Buffer.isBuffer(hash));\n//   assert(Buffer.isBuffer(sig));\n//   assert(Buffer.isBuffer(key));\n//   assert(typeof flags === 'number');\n//   let res = false;\n//   if (sig.length === 64) {\n//     res = secp256k1.schnorrVerify(hash, sig, key, flags);\n//   } else {\n//     res = secp256k1.verifyDER(hash, sig, key, flags);\n//   }\n//   return res;\n// }\n// /**\n//  * Verify a signature, taking into account sighash type.\n//  * @param {Buffer} msg - Signature hash.\n//  * @param {Buffer} sig\n//  * @param {Buffer} key\n//  * @returns {Boolean}\n//  */\n// function checksig(msg, sig, key) {\n//   return secp256k1.verifyDER(msg, sig.slice(0, -1), key);\n// }\n\n/*\n * Expose\n */\n\nmodule.exports = Script;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/script/script.js"],"names":["assert","require","bio","ripemd160","sha1","sha256","hash160","hash256","secp256k1","consensus","policy","Opcode","Stack","ScriptError","ScriptNum","common","Address","Metrics","opcodes","scriptTypes","types","countBits","encoding","EMPTY_BUFFER","Buffer","alloc","metrics","Script","constructor","options","raw","code","fromOptions","fromItems","items","Array","isArray","clear","item","pushData","compile","fromStack","stack","length","size","op","getSize","bw","write","toWriter","render","toRaw","fromJSON","json","fromRaw","from","execute","flags","tx","index","value","sigchecks","STANDARD_VERIFY_FLAGS","MAX_SCRIPT_SIZE","state","alt","lastSep","opCount","negate","nSigsRemaining","nKeysRemaining","checkBits","minimal","VERIFY_MINIMALDATA","ip","data","MAX_SCRIPT_PUSH","OP_16","MAX_SCRIPT_OPS","isDisabled","isBranch","MAX_SCRIPT_STACK","OP_PUSHDATA4","isMinimal","push","OP_0","pushInt","OP_1NEGATE","OP_1","OP_2","OP_3","OP_4","OP_5","OP_6","OP_7","OP_8","OP_9","OP_10","OP_11","OP_12","OP_13","OP_14","OP_15","OP_NOP","OP_CHECKLOCKTIMEVERIFY","VERIFY_CHECKLOCKTIMEVERIFY","VERIFY_DISCOURAGE_UPGRADABLE_NOPS","num","getNum","isNeg","locktime","toDouble","verifyLocktime","OP_CHECKSEQUENCEVERIFY","VERIFY_CHECKSEQUENCEVERIFY","verifySequence","OP_NOP1","OP_NOP4","OP_NOP5","OP_NOP6","OP_NOP7","OP_NOP8","OP_NOP9","OP_NOP10","OP_IF","OP_NOTIF","val","VERIFY_MINIMALIF","get","getBool","pop","OP_ELSE","OP_ENDIF","OP_VERIFY","OP_RETURN","OP_TOALTSTACK","OP_FROMALTSTACK","OP_2DROP","OP_2DUP","v1","v2","OP_3DUP","v3","OP_2OVER","OP_2ROT","erase","OP_2SWAP","swap","OP_IFDUP","OP_DEPTH","OP_DROP","OP_DUP","OP_NIP","remove","OP_OVER","OP_PICK","OP_ROLL","getInt","OP_ROT","OP_SWAP","OP_TUCK","insert","OP_SIZE","OP_EQUAL","OP_EQUALVERIFY","res","equals","pushBool","OP_1ADD","OP_1SUB","OP_NEGATE","OP_ABS","OP_NOT","OP_0NOTEQUAL","cmp","iaddn","isubn","ineg","iabs","isZero","fromBool","pushNum","OP_ADD","OP_SUB","OP_DIV","OP_MOD","OP_BOOLAND","OP_BOOLOR","OP_NUMEQUAL","OP_NUMEQUALVERIFY","OP_NUMNOTEQUAL","OP_LESSTHAN","OP_GREATERTHAN","OP_LESSTHANOREQUAL","OP_GREATERTHANOREQUAL","OP_MIN","OP_MAX","n1","n2","iadd","isub","div","mod","toBool","eq","lt","gt","lte","gte","min","max","OP_WITHIN","n3","OP_RIPEMD160","digest","OP_SHA1","OP_SHA256","OP_HASH160","OP_HASH256","OP_CODESEPARATOR","OP_CHECKSIG","OP_CHECKSIGVERIFY","sig","key","subscript","getSubscript","VERIFY_SIGHASH_FORKID","hashType","SIGHASH_FORKID","findAndDelete","checkTransactionSignature","validateKey","type","hash","signatureHash","verifySignature","slice","VERIFY_NULLFAIL","OP_CHECKDATASIG","OP_CHECKDATASIGVERIFY","msg","validateDataSignature","OP_CHECKMULTISIG","OP_CHECKMULTISIGVERIFY","keyCount","sigCount","keyTop","sigTop","nKeysCount","okey","ikey","isig","MAX_MULTISIG_PUBKEYS","nSigsCount","dummy","VERIFY_SCHNORR_MULTISIG","bitfield_size","Math","floor","abkam","bitcalculator","mask","numBits","bKey","bSig","ik3y","is1g","checkTransactionSchnorrSig","j","checkTransactionECDSASignature","checksig","OP_CAT","concat","OP_SPLIT","pos","set","OP_REVERSEBYTES","reverse","OP_AND","OP_OR","OP_XOR","i","OP_NUM2BIN","n","v","toMinimal","copy","signbit","OP_BIN2NUM","fromAddress","address","fromString","isPubkeyhash","fromPubkeyhash","isScripthash","fromScripthash","Error","getVarSize","sizeVarBytes","enc","toString","getPubkey","isPubkey","getData","getOp","getLength","getPubkeyhash","isMultisig","m","getSmall","toLength","getScripthash","isPushOnly","isOpcode","fromData","verify","input","witness","output","VERIFY_SIGPUSHONLY","VERIFY_STRICTENC","VERIFY_P2SH","clone","redeem","VERIFY_DISALLOW_SEGWIT_RECOVERY","isProgram","REPORT_SIGCHECKS","VERIFY_CLEANSTACK","VERIFY_INPUT_SIGCHECKS","br","read","left","fromReader","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,OAAD,CAAtB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAME,SAAS,GAAGF,OAAO,CAAC,uBAAD,CAAzB;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,kBAAD,CAApB;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,oBAAD,CAAtB;;AACA,MAAMK,OAAO,GAAGL,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMM,OAAO,GAAGN,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMO,SAAS,GAAGP,OAAO,CAAC,uBAAD,CAAzB;;AACA,MAAMQ,SAAS,GAAGR,OAAO,CAAC,uBAAD,CAAzB;;AACA,MAAMS,MAAM,GAAGT,OAAO,CAAC,oBAAD,CAAtB;;AACA,MAAMU,MAAM,GAAGV,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMW,KAAK,GAAGX,OAAO,CAAC,SAAD,CAArB;;AACA,MAAMY,WAAW,GAAGZ,OAAO,CAAC,eAAD,CAA3B;;AACA,MAAMa,SAAS,GAAGb,OAAO,CAAC,aAAD,CAAzB;;AACA,MAAMc,MAAM,GAAGd,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMe,OAAO,GAAGf,OAAO,CAAC,uBAAD,CAAvB;;AACA,MAAMgB,OAAO,GAAGhB,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAMiB,OAAO,GAAGH,MAAM,CAACG,OAAvB;AACA,MAAMC,WAAW,GAAGJ,MAAM,CAACK,KAA3B;AACA,MAAMC,SAAS,GAAGN,MAAM,CAACM,SAAzB;AACA,MAAM;AAACC,EAAAA;AAAD,IAAapB,GAAnB;AAGA;AACA;AACA;;AAEA,MAAMqB,YAAY,GAAGC,MAAM,CAACC,KAAP,CAAa,CAAb,CAArB;AACA,MAAMC,OAAO,GAAG,IAAIT,OAAJ,EAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMU,MAAN,CAAa;AACX;AACF;AACA;AACA;AACA;AAEEC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB,SAAKC,GAAL,GAAWP,YAAX;AACA,SAAKQ,IAAL,GAAY,EAAZ;AAEA,QAAIF,OAAJ,EACE,KAAKG,WAAL,CAAiBH,OAAjB;AACH,GAbU,CAeb;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;;;AAEEI,EAAAA,SAAS,CAACC,KAAD,EAAQ;AACflC,IAAAA,MAAM,CAACmC,KAAK,CAACC,OAAN,CAAcF,KAAd,CAAD,CAAN;AAEA,SAAKG,KAAL;;AAEA,SAAK,MAAMC,IAAX,IAAmBJ,KAAnB,EACE,KAAKK,QAAL,CAAcD,IAAd;;AAEF,WAAO,KAAKE,OAAL,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEkB,SAATP,SAAS,CAACC,KAAD,EAAQ;AACtB,WAAO,IAAI,IAAJ,GAAWD,SAAX,CAAqBC,KAArB,CAAP;AACD,GA7LU,CA+Lb;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;;;AAEEO,EAAAA,SAAS,CAACC,KAAD,EAAQ;AACf,WAAO,KAAKT,SAAL,CAAeS,KAAK,CAACR,KAArB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA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ACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;;;AAEEoR,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB,QAAI,OAAOA,OAAP,KAAmB,QAAvB,EACEA,OAAO,GAAGlR,OAAO,CAACmR,UAAR,CAAmBD,OAAnB,CAAV;AAEFlS,IAAAA,MAAM,CAACkS,OAAO,YAAYlR,OAApB,EAA6B,iBAA7B,CAAN;AAEA,QAAIkR,OAAO,CAACE,YAAR,EAAJ,EACE,OAAO,KAAKC,cAAL,CAAoBH,OAAO,CAACzD,IAA5B,CAAP;AAEF,QAAIyD,OAAO,CAACI,YAAR,EAAJ,EACE,OAAO,KAAKC,cAAL,CAAoBL,OAAO,CAACzD,IAA5B,CAAP;AAEF,UAAM,IAAI+D,KAAJ,CAAU,uBAAV,CAAN;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEoB,SAAXP,WAAW,CAACC,OAAD,EAAU;AAC1B,WAAO,IAAI,IAAJ,GAAWD,WAA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AEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAEES,EAAAA,UAAU,GAAG;AACX,SAAK,MAAM3Q,EAAX,IAAiB,KAAKd,IAAtB,EAA4B;AAC1B,UAAIc,EAAE,CAACe,KAAH,KAAa,CAAC,CAAlB,EACE,OAAO,KAAP;AAEF,UAAIf,EAAE,CAACe,KAAH,GAAW1C,OAAO,CAAC2D,KAAvB,EACE,OAAO,KAAP;AACH;;AAED,WAAO,IAAP;AACD,GAhiFU,CAkiFb;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;;;AAEEO,EAAAA,IAAI,CAACvC,EAAD,EAAK;AACP7C,IAAAA,MAAM,CAACW,MAAM,CAAC8S,QAAP,CAAgB5Q,EAAhB,CAAD,CAAN;AACA,SAAKd,IAAL,CAAUqD,IAAV,CAAevC,EAAf;AACA,WAAO,IAAP;AACD,GAxpFU,CA0pFb;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEE;AACF;AACA;;;AAEEkQ,EAAAA,OAAO,CAACpP,KAAD,EAAQ;AACb,UAAMd,EAAE,GAAG,KAAKmF,GAAL,CAASrE,KAAT,CAAX;AACA,WAAOd,EAAE,GAAGA,EAAE,CAAC8B,IAAN,GAAa,IAAtB;AACD,GA3tFU,CA6tFb;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAEEpC,EAAAA,QAAQ,CAACoC,IAAD,EAAO;AACb,WAAO,KAAKS,IAAL,CAAUzE,MAAM,CAAC+S,QAAP,CAAgB/O,IAAhB,CAAV,CAAP;AACD,GAlvFU,CAovFb;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAC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CAACqB,IAAD,EAAOgO,GAAP,EAAY;AACxB,QAAI,OAAOhO,IAAP,KAAgB,QAApB,EACEA,IAAI,GAAGnD,MAAM,CAAC+B,IAAP,CAAYoB,IAAZ,EAAkBgO,GAAlB,CAAP;AACF,WAAO,IAAI,IAAJ,GAAWrP,OAAX,CAAmBqB,IAAnB,CAAP;AACD,GAxvGU,CA0vGb;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAlwGa,C,CAqwGb;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;;;AAEAhD,MAAM,CAAC8B,KAAP,GAAe1C,MAAM,CAAC0C,KAAtB;AAEA;AACA;AACA;AACA;AACA;;AAEA9B,MAAM,CAACwM,QAAP,GAAkBpN,MAAM,CAACoN,QAAzB,C,CAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA0G,MAAM,CAACC,OAAP,GAAiBnT,MAAjB","sourcesContent":["/*!\n * script.js - script interpreter for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst bio = require('bufio');\nconst ripemd160 = require('bcrypto/lib/ripemd160');\nconst sha1 = require('bcrypto/lib/sha1');\nconst sha256 = require('bcrypto/lib/sha256');\nconst hash160 = require('bcrypto/lib/hash160');\nconst hash256 = require('bcrypto/lib/hash256');\nconst secp256k1 = require('bcrypto/lib/secp256k1');\nconst consensus = require('../protocol/consensus');\nconst policy = require('../protocol/policy');\nconst Opcode = require('./opcode');\nconst Stack = require('./stack');\nconst ScriptError = require('./scripterror');\nconst ScriptNum = require('./scriptnum');\nconst common = require('./common');\nconst Address = require('../primitives/address');\nconst Metrics = require('./metrics');\nconst opcodes = common.opcodes;\nconst scriptTypes = common.types;\nconst countBits = common.countBits;\nconst {encoding} = bio;\n\n\n/*\n * Constants\n */\n\nconst EMPTY_BUFFER = Buffer.alloc(0);\nconst metrics = new Metrics();\n\n/**\n * Script\n * Represents a input or output script.\n * @alias module:script.Script\n * @property {Array} code - Parsed script code.\n * @property {Buffer?} raw - Serialized script.\n * @property {Number} length - Number of parsed opcodes.\n */\n\nclass Script {\n  /**\n   * Create a script.\n   * @constructor\n   * @param {Buffer|Array|Object} code\n   */\n\n  constructor(options) {\n    this.raw = EMPTY_BUFFER;\n    this.code = [];\n\n    if (options)\n      this.fromOptions(options);\n  }\n\n//   /**\n//    * Get length.\n//    * @returns {Number}\n//    */\n\n//   get length() {\n//     return this.code.length;\n//   }\n\n//   /**\n//    * Set length.\n//    * @param {Number} value\n//    */\n\n//   set length(value) {\n//     this.code.length = value;\n//   }\n\n//   /**\n//    * Inject properties from options object.\n//    * @private\n//    * @param {Object} options\n//    */\n\n//   fromOptions(options) {\n//     assert(options, 'Script data is required.');\n\n//     if (Buffer.isBuffer(options))\n//       return this.fromRaw(options);\n\n//     if (Array.isArray(options))\n//       return this.fromArray(options);\n\n//     if (options.raw) {\n//       if (!options.code)\n//         return this.fromRaw(options.raw);\n//       assert(Buffer.isBuffer(options.raw), 'Raw must be a Buffer.');\n//       this.raw = options.raw;\n//     }\n\n//     if (options.code) {\n//       if (!options.raw)\n//         return this.fromArray(options.code);\n//       assert(Array.isArray(options.code), 'Code must be an array.');\n//       this.code = options.code;\n//     }\n\n//     return this;\n//   }\n\n//   /**\n//    * Insantiate script from options object.\n//    * @param {Object} options\n//    * @returns {Script}\n//    */\n\n//   static fromOptions(options) {\n//     return new this().fromOptions(options);\n//   }\n\n//   /**\n//    * Instantiate a value-only iterator.\n//    * @returns {ScriptIterator}\n//    */\n\n//   values() {\n//     return this.code.values();\n//   }\n\n//   /**\n//    * Instantiate a key and value iterator.\n//    * @returns {ScriptIterator}\n//    */\n\n//   entries() {\n//     return this.code.entries();\n//   }\n\n//   /**\n//    * Instantiate a value-only iterator.\n//    * @returns {ScriptIterator}\n//    */\n\n//   [Symbol.iterator]() {\n//     return this.code[Symbol.iterator]();\n//   }\n\n//   /**\n//    * Convert the script to an array of\n//    * Buffers (pushdatas) and Numbers\n//    * (opcodes).\n//    * @returns {Array}\n//    */\n\n//   toArray() {\n//     return this.code.slice();\n//   }\n\n//   /**\n//    * Inject properties from an array of\n//    * of buffers and numbers.\n//    * @private\n//    * @param {Array} code\n//    * @returns {Script}\n//    */\n\n//   fromArray(code) {\n//     assert(Array.isArray(code));\n\n//     this.clear();\n\n//     for (const op of code)\n//       this.push(op);\n\n//     return this.compile();\n//   }\n\n//   /**\n//    * Instantiate script from an array\n//    * of buffers and numbers.\n//    * @param {Array} code\n//    * @returns {Script}\n//    */\n\n//   static fromArray(code) {\n//     return new this().fromArray(code);\n//   }\n\n//   /**\n//    * Convert script to stack items.\n//    * @returns {Buffer[]}\n//    */\n\n//   toItems() {\n//     const items = [];\n\n//     for (const op of this.code) {\n//       const data = op.toPush();\n\n//       if (!data)\n//         throw new Error('Non-push opcode in script.');\n\n//       items.push(data);\n//     }\n\n//     return items;\n//   }\n\n  /**\n   * Inject data from stack items.\n   * @private\n   * @param {Buffer[]} items\n   * @returns {Script}\n   */\n\n  fromItems(items) {\n    assert(Array.isArray(items));\n\n    this.clear();\n\n    for (const item of items)\n      this.pushData(item);\n\n    return this.compile();\n  }\n\n  /**\n   * Instantiate script from stack items.\n   * @param {Buffer[]} items\n   * @returns {Script}\n   */\n\n  static fromItems(items) {\n    return new this().fromItems(items);\n  }\n\n//   /**\n//    * Convert script to stack.\n//    * @returns {Stack}\n//    */\n\n//   toStack() {\n//     return new Stack(this.toItems());\n//   }\n\n  /**\n   * Inject data from stack.\n   * @private\n   * @param {Stack} stack\n   * @returns {Script}\n   */\n\n  fromStack(stack) {\n    return this.fromItems(stack.items);\n  }\n\n  /**\n   * Instantiate script from stack.\n   * @param {Stack} stack\n   * @returns {Script}\n   */\n\n  static fromStack(stack) {\n    return new this().fromStack(stack);\n  }\n\n//   /**\n//    * Clone the script.\n//    * @returns {Script} Cloned script.\n//    */\n\n//   clone() {\n//     return new this.constructor().inject(this);\n//   }\n\n//   /**\n//    * Inject properties from script.\n//    * Used for cloning.\n//    * @private\n//    * @param {Script} script\n//    * @returns {Script}\n//    */\n\n//   inject(script) {\n//     this.raw = script.raw;\n//     this.code = script.code.slice();\n//     return this;\n//   }\n\n//   /**\n//    * Test equality against script.\n//    * @param {Script} script\n//    * @returns {Boolean}\n//    */\n\n//   equals(script) {\n//     assert(Script.isScript(script));\n//     return this.raw.equals(script.raw);\n//   }\n\n//   /**\n//    * Compare against another script.\n//    * @param {Script} script\n//    * @returns {Number}\n//    */\n\n//   compare(script) {\n//     assert(Script.isScript(script));\n//     return this.raw.compare(script.raw);\n//   }\n\n  /**\n   * Clear the script.\n   * @returns {Script}\n   */\n\n  clear() {\n    this.raw = EMPTY_BUFFER;\n    this.code.length = 0;\n    return this;\n  }\n\n//   /**\n//    * Inspect the script.\n//    * @returns {String} Human-readable script code.\n//    */\n\n//   inspect() {\n//     return `<Script: ${this.toString()}>`;\n//   }\n\n//   /**\n//    * Convert the script to a bitcoind test string.\n//    * @returns {String} Human-readable script code.\n//    */\n\n//   toString() {\n//     const out = [];\n\n//     for (const op of this.code)\n//       out.push(op.toFormat());\n\n//     return out.join(' ');\n//   }\n\n//   /**\n//    * Format the script as bitcoind asm.\n//    * @param {Boolean?} decode - Attempt to decode hash types.\n//    * @returns {String} Human-readable script.\n//    */\n\n//   toASM(decode) {\n//     if (this.isNulldata())\n//       decode = false;\n\n//     const out = [];\n\n//     for (const op of this.code)\n//       out.push(op.toASM(decode));\n\n//     return out.join(' ');\n//   }\n\n//   /**\n//    * Re-encode the script internally. Useful if you\n//    * changed something manually in the `code` array.\n//    * @returns {Script}\n//    */\n\n  compile() {\n    if (this.code.length === 0)\n      return this.clear();\n\n    let size = 0;\n\n    for (const op of this.code)\n      size += op.getSize();\n\n    const bw = bio.write(size);\n\n    for (const op of this.code)\n      op.toWriter(bw);\n\n    this.raw = bw.render();\n\n    return this;\n  }\n\n//   /**\n//    * Write the script to a buffer writer.\n//    * @param {BufferWriter} bw\n//    */\n\n//   toWriter(bw) {\n//     bw.writeVarBytes(this.raw);\n//     return bw;\n//   }\n\n  /**\n   * Encode the script to a Buffer. See {@link Script#encode}.\n   * @param {String} enc - Encoding, either `'hex'` or `null`.\n   * @returns {Buffer|String} Serialized script.\n   */\n\n  toRaw() {\n    return this.raw;\n  }\n\n//   /**\n//    * Convert script to a hex string.\n//    * @returns {String}\n//    */\n\n//   toJSON() {\n//     return this.toRaw().toString('hex');\n//   }\n\n//   /**\n//    * Inject properties from json object.\n//    * @private\n//    * @param {String} json\n//    */\n\n  fromJSON(json) {\n    assert(typeof json === 'string', 'Code must be a string.');\n    return this.fromRaw(Buffer.from(json, 'hex'));\n  }\n\n  /**\n   * Instantiate script from a hex string.\n   * @params {String} json\n   * @returns {Script}\n   */\n\n  static fromJSON(json) {\n    return new this().fromJSON(json);\n  }\n\n//   /**\n//    * Get the script's \"subscript\" starting at a separator.\n//    * @param {Number} index - The last separator to sign/verify beyond.\n//    * @returns {Script} Subscript.\n//    */\n\n//   getSubscript(index) {\n//     if (index === 0)\n//       return this.clone();\n\n//     const script = new Script();\n\n//     for (let i = index; i < this.code.length; i++) {\n//       const op = this.code[i];\n\n//       if (op.value === -1)\n//         break;\n\n//       script.code.push(op);\n//     }\n\n//     return script.compile();\n//   }\n\n//   /**\n//    * Get the script's \"subscript\" starting at a separator.\n//    * Remove all OP_CODESEPARATORs if present. This bizarre\n//    * behavior is necessary for signing and verification when\n//    * code separators are present.\n//    * @returns {Script} Subscript.\n//    */\n\n//   removeSeparators() {\n//     let found = false;\n\n//     // Optimizing for the common case:\n//     // Check for any separators first.\n//     for (const op of this.code) {\n//       if (op.value === -1)\n//         break;\n\n//       if (op.value === opcodes.OP_CODESEPARATOR) {\n//         found = true;\n//         break;\n//       }\n//     }\n\n//     if (!found)\n//       return this;\n\n//     // Uncommon case: someone actually\n//     // has a code separator. Go through\n//     // and remove them all.\n//     const script = new Script();\n\n//     for (const op of this.code) {\n//       if (op.value === -1)\n//         break;\n\n//       if (op.value !== opcodes.OP_CODESEPARATOR)\n//         script.code.push(op);\n//     }\n\n//     return script.compile();\n//   }\n\n//   /**\n//    * Get the value of the checkBits while calculated as little endian.\n//    * @param {Buffer} abkam - Stack depth of the dummy element.\n//    * @param {Number?} nKeysCount - Stack depth of the top pubkeys.\n//    * @returns {Number}\n//    */\n\n//   bitcalculator(abkam, nKeysCount) {\n//     let checkBits = 0;\n\n//     const bitfield_size = ((nKeysCount + 7) / 8);\n\n//     for (let i = 0; i < bitfield_size; i++) {\n//       checkBits |= abkam[i] << (8 * i);\n//     }\n\n//     return checkBits;\n//   }\n\n  /**\n   * Execute and interpret the script.\n   * @param {Stack} stack - Script execution stack.\n   * @param {Number?} flags - Script standard flags.\n   * @param {TX?} tx - Transaction being verified.\n   * @param {Number?} index - Index of input being verified.\n   * @param {Amount?} value - Previous output value.\n   * @param {Number?} sigchecks\n   * @throws {ScriptError} Will be thrown on VERIFY failures.\n   */\n\n  execute(stack, flags, tx, index, value, sigchecks) {\n    if (flags == null)\n      flags = Script.flags.STANDARD_VERIFY_FLAGS;\n\n    if (this.getSize() > consensus.MAX_SCRIPT_SIZE)\n      throw new ScriptError('SCRIPT_SIZE');\n\n    const state = [];\n    const alt = [];\n\n    let lastSep = 0;\n    let opCount = 0;\n    let negate = 0;\n    let nSigsRemaining = 0;\n    let nKeysRemaining = 0;\n    let checkBits;\n    let minimal = false;\n\n    if (flags & Script.flags.VERIFY_MINIMALDATA)\n      minimal = true;\n\n    for (let ip = 0; ip < this.code.length; ip++) {\n      const op = this.code[ip];\n\n      if (op.value === -1)\n        throw new ScriptError('BAD_OPCODE', op, ip);\n\n      if (op.data && op.data.length > consensus.MAX_SCRIPT_PUSH)\n        throw new ScriptError('PUSH_SIZE', op, ip);\n\n      if (op.value > opcodes.OP_16 && ++opCount > consensus.MAX_SCRIPT_OPS)\n        throw new ScriptError('OP_COUNT', op, ip);\n\n      if (op.isDisabled(flags))\n        throw new ScriptError('DISABLED_OPCODE', op, ip);\n\n      if (negate && !op.isBranch()) {\n        if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK)\n          throw new ScriptError('STACK_SIZE', op, ip);\n        continue;\n      }\n\n      if (op.data && 0 <= op.value <= opcodes.OP_PUSHDATA4) {\n        if (minimal && !op.isMinimal())\n          throw new ScriptError('MINIMALDATA', op, ip);\n\n        stack.push(op.data);\n\n        if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK)\n          throw new ScriptError('STACK_SIZE', op, ip);\n\n        continue;\n      }\n\n      switch (op.value) {\n        case opcodes.OP_0: {\n          stack.pushInt(0);\n          break;\n        }\n        case opcodes.OP_1NEGATE: {\n          stack.pushInt(-1);\n          break;\n        }\n        case opcodes.OP_1:\n        case opcodes.OP_2:\n        case opcodes.OP_3:\n        case opcodes.OP_4:\n        case opcodes.OP_5:\n        case opcodes.OP_6:\n        case opcodes.OP_7:\n        case opcodes.OP_8:\n        case opcodes.OP_9:\n        case opcodes.OP_10:\n        case opcodes.OP_11:\n        case opcodes.OP_12:\n        case opcodes.OP_13:\n        case opcodes.OP_14:\n        case opcodes.OP_15:\n        case opcodes.OP_16: {\n          stack.pushInt(op.value - 0x50);\n          break;\n        }\n        case opcodes.OP_NOP: {\n          break;\n        }\n        case opcodes.OP_CHECKLOCKTIMEVERIFY: {\n          // OP_CHECKLOCKTIMEVERIFY = OP_NOP2\n          if (!(flags & Script.flags.VERIFY_CHECKLOCKTIMEVERIFY)) {\n            if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n              throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);\n            break;\n          }\n\n          if (!tx)\n            throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const num = stack.getNum(-1, minimal, 5);\n\n          if (num.isNeg())\n            throw new ScriptError('NEGATIVE_LOCKTIME', op, ip);\n\n          const locktime = num.toDouble();\n\n          if (!tx.verifyLocktime(index, locktime))\n            throw new ScriptError('UNSATISFIED_LOCKTIME', op, ip);\n\n          break;\n        }\n        case opcodes.OP_CHECKSEQUENCEVERIFY: {\n          // OP_CHECKSEQUENCEVERIFY = OP_NOP3\n          if (!(flags & Script.flags.VERIFY_CHECKSEQUENCEVERIFY)) {\n            if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n              throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);\n            break;\n          }\n\n          if (!tx)\n            throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const num = stack.getNum(-1, minimal, 5);\n\n          if (num.isNeg())\n            throw new ScriptError('NEGATIVE_LOCKTIME', op, ip);\n\n          const locktime = num.toDouble();\n\n          if (!tx.verifySequence(index, locktime))\n            throw new ScriptError('UNSATISFIED_LOCKTIME', op, ip);\n\n          break;\n        }\n        case opcodes.OP_NOP1:\n        case opcodes.OP_NOP4:\n        case opcodes.OP_NOP5:\n        case opcodes.OP_NOP6:\n        case opcodes.OP_NOP7:\n        case opcodes.OP_NOP8:\n        case opcodes.OP_NOP9:\n        case opcodes.OP_NOP10: {\n          if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n            throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);\n          break;\n        }\n        case opcodes.OP_IF:\n        case opcodes.OP_NOTIF: {\n          let val = false;\n\n          if (!negate) {\n            if (stack.length < 1)\n              throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);\n\n            if (flags & Script.flags.VERIFY_MINIMALIF) {\n              const item = stack.get(-1);\n\n              if (item.length > 1)\n                throw new ScriptError('MINIMALIF');\n\n              if (item.length === 1 && item[0] !== 1)\n                throw new ScriptError('MINIMALIF');\n            }\n\n            val = stack.getBool(-1);\n\n            if (op.value === opcodes.OP_NOTIF)\n              val = !val;\n\n            stack.pop();\n          }\n\n          state.push(val);\n\n          if (!val)\n            negate += 1;\n\n          break;\n        }\n        case opcodes.OP_ELSE: {\n          if (state.length === 0)\n            throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);\n\n          state[state.length - 1] = !state[state.length - 1];\n\n          if (!state[state.length - 1])\n            negate += 1;\n          else\n            negate -= 1;\n\n          break;\n        }\n        case opcodes.OP_ENDIF: {\n          if (state.length === 0)\n            throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);\n\n          if (!state.pop())\n            negate -= 1;\n\n          break;\n        }\n        case opcodes.OP_VERIFY: {\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          if (!stack.getBool(-1))\n            throw new ScriptError('VERIFY', op, ip);\n\n          stack.pop();\n\n          break;\n        }\n        case opcodes.OP_RETURN: {\n          throw new ScriptError('OP_RETURN', op, ip);\n        }\n        case opcodes.OP_TOALTSTACK: {\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          alt.push(stack.pop());\n          break;\n        }\n        case opcodes.OP_FROMALTSTACK: {\n          if (alt.length === 0)\n            throw new ScriptError('INVALID_ALTSTACK_OPERATION', op, ip);\n\n          stack.push(alt.pop());\n          break;\n        }\n        case opcodes.OP_2DROP: {\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.pop();\n          stack.pop();\n          break;\n        }\n        case opcodes.OP_2DUP: {\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const v1 = stack.get(-2);\n          const v2 = stack.get(-1);\n\n          stack.push(v1);\n          stack.push(v2);\n          break;\n        }\n        case opcodes.OP_3DUP: {\n          if (stack.length < 3)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const v1 = stack.get(-3);\n          const v2 = stack.get(-2);\n          const v3 = stack.get(-1);\n\n          stack.push(v1);\n          stack.push(v2);\n          stack.push(v3);\n          break;\n        }\n        case opcodes.OP_2OVER: {\n          if (stack.length < 4)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const v1 = stack.get(-4);\n          const v2 = stack.get(-3);\n\n          stack.push(v1);\n          stack.push(v2);\n          break;\n        }\n        case opcodes.OP_2ROT: {\n          if (stack.length < 6)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const v1 = stack.get(-6);\n          const v2 = stack.get(-5);\n\n          stack.erase(-6, -4);\n          stack.push(v1);\n          stack.push(v2);\n          break;\n        }\n        case opcodes.OP_2SWAP: {\n          if (stack.length < 4)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.swap(-4, -2);\n          stack.swap(-3, -1);\n          break;\n        }\n        case opcodes.OP_IFDUP: {\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          if (stack.getBool(-1)) {\n            const val = stack.get(-1);\n            stack.push(val);\n          }\n\n          break;\n        }\n        case opcodes.OP_DEPTH: {\n          stack.pushInt(stack.length);\n          break;\n        }\n        case opcodes.OP_DROP: {\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.pop();\n          break;\n        }\n        case opcodes.OP_DUP: {\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.push(stack.get(-1));\n          break;\n        }\n        case opcodes.OP_NIP: {\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.remove(-2);\n          break;\n        }\n        case opcodes.OP_OVER: {\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.push(stack.get(-2));\n          break;\n        }\n        case opcodes.OP_PICK:\n        case opcodes.OP_ROLL: {\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const num = stack.getInt(-1, minimal, 4);\n          stack.pop();\n\n          if (num < 0 || num >= stack.length)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const val = stack.get(-num - 1);\n\n          if (op.value === opcodes.OP_ROLL)\n            stack.remove(-num - 1);\n\n          stack.push(val);\n          break;\n        }\n        case opcodes.OP_ROT: {\n          if (stack.length < 3)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.swap(-3, -2);\n          stack.swap(-2, -1);\n          break;\n        }\n        case opcodes.OP_SWAP: {\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.swap(-2, -1);\n          break;\n        }\n        case opcodes.OP_TUCK: {\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.insert(-2, stack.get(-1));\n          break;\n        }\n        case opcodes.OP_SIZE: {\n          if (stack.length < 1)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.pushInt(stack.get(-1).length);\n          break;\n        }\n        case opcodes.OP_EQUAL:\n        case opcodes.OP_EQUALVERIFY: {\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const v1 = stack.get(-2);\n          const v2 = stack.get(-1);\n\n          const res = v1.equals(v2);\n\n          stack.pop();\n          stack.pop();\n\n          stack.pushBool(res);\n\n          if (op.value === opcodes.OP_EQUALVERIFY) {\n            if (!res)\n              throw new ScriptError('EQUALVERIFY', op, ip);\n            stack.pop();\n          }\n\n          break;\n        }\n        case opcodes.OP_1ADD:\n        case opcodes.OP_1SUB:\n        case opcodes.OP_NEGATE:\n        case opcodes.OP_ABS:\n        case opcodes.OP_NOT:\n        case opcodes.OP_0NOTEQUAL: {\n          if (stack.length < 1)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          let num = stack.getNum(-1, minimal, 4);\n          let cmp;\n\n          switch (op.value) {\n            case opcodes.OP_1ADD:\n              num.iaddn(1);\n              break;\n            case opcodes.OP_1SUB:\n              num.isubn(1);\n              break;\n            case opcodes.OP_NEGATE:\n              num.ineg();\n              break;\n            case opcodes.OP_ABS:\n              num.iabs();\n              break;\n            case opcodes.OP_NOT:\n              cmp = num.isZero();\n              num = ScriptNum.fromBool(cmp);\n              break;\n            case opcodes.OP_0NOTEQUAL:\n              cmp = !num.isZero();\n              num = ScriptNum.fromBool(cmp);\n              break;\n            default:\n              assert(false, 'Fatal script error.');\n              break;\n          }\n\n          stack.pop();\n          stack.pushNum(num);\n\n          break;\n        }\n        case opcodes.OP_ADD:\n        case opcodes.OP_SUB:\n        case opcodes.OP_DIV:\n        case opcodes.OP_MOD:\n        case opcodes.OP_BOOLAND:\n        case opcodes.OP_BOOLOR:\n        case opcodes.OP_NUMEQUAL:\n        case opcodes.OP_NUMEQUALVERIFY:\n        case opcodes.OP_NUMNOTEQUAL:\n        case opcodes.OP_LESSTHAN:\n        case opcodes.OP_GREATERTHAN:\n        case opcodes.OP_LESSTHANOREQUAL:\n        case opcodes.OP_GREATERTHANOREQUAL:\n        case opcodes.OP_MIN:\n        case opcodes.OP_MAX: {\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const n1 = stack.getNum(-2, minimal, 4);\n          const n2 = stack.getNum(-1, minimal, 4);\n          let num, cmp;\n\n          switch (op.value) {\n            case opcodes.OP_ADD:\n              num = n1.iadd(n2);\n              break;\n            case opcodes.OP_SUB:\n              num = n1.isub(n2);\n              break;\n            case opcodes.OP_DIV:\n              if (n2.isZero())\n                throw new ScriptError('DIV_BY_ZERO', op, ip);\n              num = n1.div(n2);\n              break;\n            case opcodes.OP_MOD:\n              if (n2.isZero())\n                throw new ScriptError('MOD_BY_ZERO', op, ip);\n              num = n1.mod(n2);\n              break;\n            case opcodes.OP_BOOLAND:\n              cmp = n1.toBool() && n2.toBool();\n              num = ScriptNum.fromBool(cmp);\n              break;\n            case opcodes.OP_BOOLOR:\n              cmp = n1.toBool() || n2.toBool();\n              num = ScriptNum.fromBool(cmp);\n              break;\n            case opcodes.OP_NUMEQUAL:\n              cmp = n1.eq(n2);\n              num = ScriptNum.fromBool(cmp);\n              break;\n            case opcodes.OP_NUMEQUALVERIFY:\n              cmp = n1.eq(n2);\n              num = ScriptNum.fromBool(cmp);\n              break;\n            case opcodes.OP_NUMNOTEQUAL:\n              cmp = !n1.eq(n2);\n              num = ScriptNum.fromBool(cmp);\n              break;\n            case opcodes.OP_LESSTHAN:\n              cmp = n1.lt(n2);\n              num = ScriptNum.fromBool(cmp);\n              break;\n            case opcodes.OP_GREATERTHAN:\n              cmp = n1.gt(n2);\n              num = ScriptNum.fromBool(cmp);\n              break;\n            case opcodes.OP_LESSTHANOREQUAL:\n              cmp = n1.lte(n2);\n              num = ScriptNum.fromBool(cmp);\n              break;\n            case opcodes.OP_GREATERTHANOREQUAL:\n              cmp = n1.gte(n2);\n              num = ScriptNum.fromBool(cmp);\n              break;\n            case opcodes.OP_MIN:\n              num = ScriptNum.min(n1, n2);\n              break;\n            case opcodes.OP_MAX:\n              num = ScriptNum.max(n1, n2);\n              break;\n            default:\n              assert(false, 'Fatal script error.');\n              break;\n          }\n\n          stack.pop();\n          stack.pop();\n          stack.pushNum(num);\n\n          if (op.value === opcodes.OP_NUMEQUALVERIFY) {\n            if (!stack.getBool(-1))\n              throw new ScriptError('NUMEQUALVERIFY', op, ip);\n            stack.pop();\n          }\n\n          break;\n        }\n        case opcodes.OP_WITHIN: {\n          if (stack.length < 3)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const n1 = stack.getNum(-3, minimal, 4);\n          const n2 = stack.getNum(-2, minimal, 4);\n          const n3 = stack.getNum(-1, minimal, 4);\n\n          const val = n2.lte(n1) && n1.lt(n3);\n\n          stack.pop();\n          stack.pop();\n          stack.pop();\n\n          stack.pushBool(val);\n          break;\n        }\n        case opcodes.OP_RIPEMD160: {\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.push(ripemd160.digest(stack.pop()));\n          break;\n        }\n        case opcodes.OP_SHA1: {\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.push(sha1.digest(stack.pop()));\n          break;\n        }\n        case opcodes.OP_SHA256: {\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.push(sha256.digest(stack.pop()));\n          break;\n        }\n        case opcodes.OP_HASH160: {\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.push(hash160.digest(stack.pop()));\n          break;\n        }\n        case opcodes.OP_HASH256: {\n          if (stack.length === 0)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.push(hash256.digest(stack.pop()));\n          break;\n        }\n        case opcodes.OP_CODESEPARATOR: {\n          lastSep = ip + 1;\n          break;\n        }\n        case opcodes.OP_CHECKSIG:\n        case opcodes.OP_CHECKSIGVERIFY: {\n          if (!tx)\n            throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const sig = stack.get(-2);\n          const key = stack.get(-1);\n\n          const subscript = this.getSubscript(lastSep);\n\n          if (!(flags & Script.flags.VERIFY_SIGHASH_FORKID)\n            || !(sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID))\n            subscript.findAndDelete(sig);\n\n          checkTransactionSignature(sig, flags);\n          validateKey(key, flags);\n\n          let res = false;\n\n          if (sig.length > 0) {\n            const type = sig[sig.length - 1];\n            const hash = tx.signatureHash(\n              index,\n              subscript,\n              value,\n              type,\n              flags\n            );\n            res = verifySignature(hash, sig.slice(0, -1), key, flags);\n            metrics.sigchecks += 1;\n            sigchecks = metrics.sigchecks;\n          }\n\n          if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {\n            if (sig.length !== 0)\n              throw new ScriptError('NULLFAIL', op, ip);\n          }\n\n          stack.pop();\n          stack.pop();\n\n          stack.pushBool(res);\n\n          if (op.value === opcodes.OP_CHECKSIGVERIFY) {\n            if (!res)\n              throw new ScriptError('CHECKSIGVERIFY', op, ip);\n            stack.pop();\n          }\n\n          break;\n        }\n        case opcodes.OP_CHECKDATASIG:\n        case opcodes.OP_CHECKDATASIGVERIFY: {\n          // (sig message pubkey -- bool)\n          if (stack.length < 3)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const sig = stack.get(-3);\n          const msg = stack.get(-2);\n          const key = stack.get(-1);\n\n          validateDataSignature(sig, flags);\n          validateKey(key, flags);\n\n          let res = false;\n\n          if (sig.length > 0) {\n            const hash = sha256.digest(msg);\n            res = verifySignature(hash, sig, key, flags);\n            metrics.sigchecks += 1;\n\t    sigchecks = metrics.sigchecks;\n          }\n\n          if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {\n            if (sig.length !== 0)\n              throw new ScriptError('NULLFAIL', op, ip);\n          }\n\n          stack.pop();\n          stack.pop();\n          stack.pop();\n\n          stack.pushBool(res);\n\n          if (op.value === opcodes.OP_CHECKDATASIGVERIFY) {\n            if (!res)\n              throw new ScriptError('CHECKDATASIGVERIFY', op, ip);\n            stack.pop();\n          }\n\n          break;\n        }\n        case opcodes.OP_CHECKMULTISIG:\n        case opcodes.OP_CHECKMULTISIGVERIFY: {\n          if (!tx)\n            throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');\n\n          let keyCount = 1;\n          let sigCount = 0;\n          let keyTop, sigTop;\n\n          if (stack.length < keyCount)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          let nKeysCount = stack.getInt(-keyCount, minimal, 4);\n          let okey = nKeysCount + 2;\n          let ikey, isig;\n\n          if (nKeysCount < 0 || nKeysCount > consensus.MAX_MULTISIG_PUBKEYS)\n            throw new ScriptError('PUBKEY_COUNT', op, ip);\n\n          opCount += nKeysCount;\n\n          if (opCount > consensus.MAX_SCRIPT_OPS)\n            throw new ScriptError('OP_COUNT', op, ip);\n\n          keyCount += 1;\n          keyTop = keyCount;\n\n          // stack depth of nSigsCount\n          sigCount = keyTop + nKeysCount;\n\n          ikey = keyCount;\n          keyCount += nKeysCount;\n\n          if (stack.length < sigCount)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          let nSigsCount = stack.getInt(-sigCount, minimal, 4);\n\n          if (nSigsCount < 0 || nSigsCount > nKeysCount)\n            throw new ScriptError('SIG_COUNT', op, ip);\n\n          // stack depth of the top signature\n          sigTop = sigCount + 1;\n\n          // stack depth of the dummy element\n          const dummy = sigTop + nSigsCount;\n\n          if (stack.length < dummy)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          keyCount += 1;\n          isig = keyCount;\n          keyCount += nSigsCount;\n\n          const subscript = this.getSubscript(lastSep);\n          let res = true;\n\n          if ((flags & Script.flags.VERIFY_SCHNORR_MULTISIG)\n             && stack.get(-dummy).length !== 0) {\n              assert(consensus.MAX_MULTISIG_PUBKEYS < 32)\n\n            if (nKeysCount > 32)\n              throw new ScriptError('INVALID_BITFIELD_SIZE', op, ip);\n\n            const bitfield_size = Math.floor((nKeysCount + 7) / 8);\n            const abkam = stack.get(-dummy);\n\n            if (abkam.length !== bitfield_size)\n              throw new ScriptError('BITFIELD_SIZE', op, ip);\n\n            checkBits = this.bitcalculator(abkam, nKeysCount);\n\n            const mask = (1 << nKeysCount) - 1;\n            const numBits = countBits(checkBits);\n\n            if ((checkBits & mask) !== checkBits)\n              throw new ScriptError('BIT_RANGE', op, ip);\n\n            if (numBits !== nSigsCount)\n              throw new ScriptError('INVALID_BIT_COUNT', op, ip);\n\n            const bKey = keyTop + nKeysCount - 1;\n            const bSig = sigTop + nSigsCount - 1;\n\n            let ik3y = 0;\n\n            for (let is1g = 0; is1g < nSigsCount; is1g++, ik3y++) {\n              if ((checkBits >> ik3y) === 0) {\n                throw new ScriptError('INVALID_BIT_RANGE', op, ip);\n              }\n\n              while (((checkBits >> ik3y) & 0x01) === 0) {\n                ik3y++;\n              }\n\n              if (ik3y >= nKeysCount)\n                throw new ScriptError('PUBKEY_COUNT', op, ip);\n\n              const sig = stack.get(-bSig + is1g);\n              const key = stack.get(-bKey + ik3y);\n\n              // Handle checkbits left over\n              if (!sig)\n                continue;\n\n              checkTransactionSchnorrSig(sig, flags);\n              validateKey(key, flags);\n\n              if (sig.length > 0) {\n                const type = sig[sig.length - 1];\n                const hash = tx.signatureHash(\n                  index,\n                  subscript,\n                  value,\n                  type,\n                  flags\n                );\n\n                res = verifySignature(hash, sig.slice(0, -1), key, flags);\n                metrics.sigchecks += 1;\n\t\t            sigchecks = metrics.sigchecks;\n              }\n\n              while (keyCount > 1) {\n                if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {\n                  if (okey === 0 && stack.get(-1).length !== 0)\n                    throw new ScriptError('NULLFAIL', op, ip);\n                }\n    \n                if (okey > 0)\n                  okey -= 1;\n    \n                stack.pop();\n    \n                keyCount -= 1;\n              }\n\n            }\n\n\n            if ((checkBits >> ik3y) !== 0)\n              throw new ScriptError('INVALID_BIT_COUNT', op, ip);\n\n            stack.pop();\n            stack.pushBool(res);\n\n          } else {\n            // Legacy Multisig (ECDSA / NULL)\n            // A bug causes CHECKMULTISIG to consume one extra\n            // argument whose contents were not checked in any way.\n\n          for (let j = 0; j < nSigsCount; j++) {\n            const sig = stack.get(-sigTop - j);\n            if (!(flags & Script.flags.VERIFY_SIGHASH_FORKID)\n              || !(sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID))\n              subscript.findAndDelete(sig, flags);\n          }\n\n          nSigsRemaining = nSigsCount;\n          nKeysRemaining = nKeysCount;\n\n          while (res && nSigsCount > 0) {\n            const sig = stack.get(-isig);\n            const key = stack.get(-ikey);\n\n            checkTransactionECDSASignature(sig, flags);\n            validateKey(key, flags);\n\n            if (sig.length > 0) {\n              const type = sig[sig.length - 1];\n              const hash = tx.signatureHash(\n                index,\n                subscript,\n                value,\n                type,\n                flags\n              );\n\n              if (checksig(hash, sig, key)) {\n                isig += 1;\n                nSigsCount -= 1;\n              }\n            }\n\n            ikey += 1;\n            nKeysCount -= 1;\n\n            if (nSigsCount > nKeysCount)\n              res = false;\n          }\n\n          while (keyCount > 1) {\n            if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {\n              if (okey === 0 && stack.get(-1).length !== 0)\n                throw new ScriptError('NULLFAIL', op, ip);\n            }\n\n            if (okey > 0)\n              okey -= 1;\n\n            stack.pop();\n\n            keyCount -= 1;\n          }\n\n          if (stack.length < 1)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          stack.pop();\n\n          stack.pushBool(res);\n\n          if (op.value === opcodes.OP_CHECKMULTISIGVERIFY) {\n            if (!res)\n              throw new ScriptError('CHECKMULTISIGVERIFY', op, ip);\n            stack.pop();\n           }\n          }\n\n          break;\n        }\n\n        //\n        // Byte string operations\n        //\n        case opcodes.OP_CAT: {\n          // (x1 x2 -- out)\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const v1 = stack.get(-2);\n          const v2 = stack.get(-1);\n          if (v1.length + v2.length > consensus.MAX_SCRIPT_PUSH) {\n            throw new ScriptError('PUSH_SIZE', op, ip);\n          }\n          stack.pop();\n          stack.pop();\n\n          stack.push(Buffer.concat([v1, v2]));\n\n          break;\n        }\n\n        case opcodes.OP_SPLIT: {\n          // (in position -- x1 x2)\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const data = stack.get(-2);\n\n          // Make sure the split point is appropriate.\n          const pos = stack.getInt(-1, minimal, 4);\n          if (pos < 0 || pos > data.length)\n            throw new ScriptError('INVALID_SPLIT_RANGE', op, ip);\n\n          // Prepare the results in their own buffer as `data`\n          // will be invalidated.\n          const n1 = data.slice(0, pos);\n          const n2 = data.slice(pos);\n\n          // Replace existing stack values by the new values.\n          stack.set(-2, n1);\n          stack.set(-1, n2);\n          break;\n        }\n        case opcodes.OP_REVERSEBYTES: {\n         if (stack.length < 1)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const data = stack.get(-1);\n\n          data.reverse();\n\n          break;\n        }\n\n        //\n        // Bitwise logic\n        //\n        case opcodes.OP_AND:\n        case opcodes.OP_OR:\n        case opcodes.OP_XOR: {\n          // (x1 x2 - out)\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const v1 = stack.get(-2);\n          const v2 = stack.get(-1);\n\n          // Inputs must be the same size\n          if (v1.length !== v2.length)\n            throw new ScriptError('INVALID_OPERAND_SIZE', op, ip);\n\n          const raw = Buffer.alloc(v1.length);\n\n          switch (op.value) {\n            case opcodes.OP_AND:\n              for (let i = 0; i < v1.length; i++) {\n                raw[i] = v1[i] & v2[i];\n              }\n              break;\n            case opcodes.OP_OR:\n              for (let i = 0; i < v1.length; i++) {\n                raw[i] = v1[i] | v2[i];\n              }\n              break;\n            case opcodes.OP_XOR:\n              for (let i = 0; i < v1.length; i++) {\n                raw[i] = v1[i] ^ v2[i];\n              }\n              break;\n            default:\n              break;\n          }\n\n          // And pop v1 and v2.\n          stack.pop();\n          stack.pop();\n\n          stack.push(raw);\n\n          break;\n        }\n\n        //\n        // Conversion operations\n        //\n        case opcodes.OP_NUM2BIN: {\n          // (in size -- out)\n          if (stack.length < 2)\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n\n          const size = stack.getInt(-1, minimal, 4);\n          if (size < 0 || size > consensus.MAX_SCRIPT_PUSH)\n            throw new ScriptError('PUSH_SIZE', op, ip);\n\n          stack.pop();\n\n          const n = stack.get(-1);\n          const v = ScriptNum.toMinimal(Buffer.from(n));\n\n          // Try to see if we can fit that number in the number of\n          // byte requested.\n          if (v.length > size)\n            // We definitively cannot.\n            throw new ScriptError('IMPOSSIBLE_ENCODING', op, ip);\n\n          // We already have an element of the right size, we don't need to do\n          // anything.\n          if (v.length === size) {\n            stack.pop();\n            stack.push(v);\n            break;\n          }\n\n          const raw = Buffer.alloc(size);\n          v.copy(raw);\n\n          let signbit = 0x00;\n          if (v.length > 0) {\n            signbit = v[v.length - 1] & 0x80;\n            raw[v.length - 1] &= 0x7f;\n          }\n\n          raw[size-1] = signbit;\n\n          stack.pop();\n          stack.push(raw);\n\n          break;\n        }\n\n        case opcodes.OP_BIN2NUM: {\n          // (in -- out)\n          if (stack.length < 1) {\n            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);\n          }\n\n          const n = stack.get(-1);\n          const v = ScriptNum.toMinimal(Buffer.from(n));\n\n          stack.pop();\n          stack.push(v);\n\n          // The resulting number must be a valid number.\n          if (!ScriptNum.isMinimal(v) || v.length > 4)\n            throw new ScriptError('INVALID_NUMBER_RANGE', op, ip);\n\n          break;\n        }\n\n        default: {\n          throw new ScriptError('BAD_OPCODE', op, ip);\n        }\n      }\n    }\n\n    if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK)\n      throw new ScriptError('STACK_SIZE');\n\n    if (state.length !== 0)\n      throw new ScriptError('UNBALANCED_CONDITIONAL');\n  }\n\n//   /**\n//    * Remove all matched data elements from\n//    * a script's code (used to remove signatures\n//    * before verification). Note that this\n//    * compares and removes data on the _byte level_.\n//    * It also reserializes the data to a single\n//    * script with minimaldata encoding beforehand.\n//    * A signature will _not_ be removed if it is\n//    * not minimaldata.\n//    * @see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-November/006878.html\n//    * @see https://test.webbtc.com/tx/19aa42fee0fa57c45d3b16488198b27caaacc4ff5794510d0c17f173f05587ff\n//    * @param {Buffer} data - Data element to match against.\n//    * @returns {Number} Total.\n//    */\n\n//   findAndDelete(data) {\n//     const target = Opcode.fromPush(data);\n\n//     if (this.raw.length < target.getSize())\n//       return 0;\n\n//     let found = false;\n\n//     for (const op of this.code) {\n//       if (op.value === -1)\n//         break;\n\n//       if (op.equals(target)) {\n//         found = true;\n//         break;\n//       }\n//     }\n\n//     if (!found)\n//       return 0;\n\n//     const code = [];\n\n//     let total = 0;\n\n//     for (const op of this.code) {\n//       if (op.value === -1)\n//         break;\n\n//       if (op.equals(target)) {\n//         total += 1;\n//         continue;\n//       }\n\n//       code.push(op);\n//     }\n\n//     this.code = code;\n//     this.compile();\n\n//     return total;\n//   }\n\n//   /**\n//    * Find a data element in a script.\n//    * @param {Buffer} data - Data element to match against.\n//    * @returns {Number} Index (`-1` if not present).\n//    */\n\n//   indexOf(data) {\n//     for (let i = 0; i < this.code.length; i++) {\n//       const op = this.code[i];\n\n//       if (op.value === -1)\n//         break;\n\n//       if (!op.data)\n//         continue;\n\n//       if (op.data.equals(data))\n//         return i;\n//     }\n\n//     return -1;\n//   }\n\n//   /**\n//    * Test a script to see if it is likely\n//    * to be script code (no weird opcodes).\n//    * @param {Number?} flags - Script standard flags.\n//    * @returns {Boolean}\n//    */\n\n//   isCode(flags) {\n//     if (flags == null)\n//       flags = Script.flags.STANDARD_VERIFY_FLAGS;\n\n//     for (const op of this.code) {\n//       if (op.value === -1)\n//         return false;\n\n//       if (op.isDisabled(flags))\n//         return false;\n\n//       switch (op.value) {\n//         case opcodes.OP_RESERVED:\n//         case opcodes.OP_NOP:\n//         case opcodes.OP_VER:\n//         case opcodes.OP_VERIF:\n//         case opcodes.OP_VERNOTIF:\n//         case opcodes.OP_RESERVED1:\n//         case opcodes.OP_RESERVED2:\n//         case opcodes.OP_NOP1:\n//           return false;\n//       }\n\n//       if (op.value > opcodes.OP_CHECKSEQUENCEVERIFY)\n//         return false;\n//     }\n\n//     return true;\n//   }\n\n//   /**\n//    * Inject properties from a pay-to-pubkey script.\n//    * @private\n//    * @param {Buffer} key\n//    */\n\n//   fromPubkey(key) {\n//     assert(Buffer.isBuffer(key) && (key.length === 33 || key.length === 65));\n\n//     this.raw = Buffer.allocUnsafe(1 + key.length + 1);\n//     this.raw[0] = key.length;\n//     key.copy(this.raw, 1);\n//     this.raw[1 + key.length] = opcodes.OP_CHECKSIG;\n\n//     key = this.raw.slice(1, 1 + key.length);\n\n//     this.code.length = 0;\n//     this.code.push(Opcode.fromPush(key));\n//     this.code.push(Opcode.fromOp(opcodes.OP_CHECKSIG));\n\n//     return this;\n//   }\n\n//   /**\n//    * Create a pay-to-pubkey script.\n//    * @param {Buffer} key\n//    * @returns {Script}\n//    */\n\n//   static fromPubkey(key) {\n//     return new this().fromPubkey(key);\n//   }\n\n//   /**\n//    * Inject properties from a pay-to-pubkeyhash script.\n//    * @private\n//    * @param {Buffer} hash\n//    */\n\n//   fromPubkeyhash(hash) {\n//     assert(Buffer.isBuffer(hash) && hash.length === 20);\n\n//     this.raw = Buffer.allocUnsafe(25);\n//     this.raw[0] = opcodes.OP_DUP;\n//     this.raw[1] = opcodes.OP_HASH160;\n//     this.raw[2] = 0x14;\n//     hash.copy(this.raw, 3);\n//     this.raw[23] = opcodes.OP_EQUALVERIFY;\n//     this.raw[24] = opcodes.OP_CHECKSIG;\n\n//     hash = this.raw.slice(3, 23);\n\n//     this.code.length = 0;\n//     this.code.push(Opcode.fromOp(opcodes.OP_DUP));\n//     this.code.push(Opcode.fromOp(opcodes.OP_HASH160));\n//     this.code.push(Opcode.fromPush(hash));\n//     this.code.push(Opcode.fromOp(opcodes.OP_EQUALVERIFY));\n//     this.code.push(Opcode.fromOp(opcodes.OP_CHECKSIG));\n\n//     return this;\n//   }\n\n//   /**\n//    * Create a pay-to-pubkeyhash script.\n//    * @param {Buffer} hash\n//    * @returns {Script}\n//    */\n\n//   static fromPubkeyhash(hash) {\n//     return new this().fromPubkeyhash(hash);\n//   }\n\n//   /**\n//    * Inject properties from pay-to-multisig script.\n//    * @private\n//    * @param {Number} m\n//    * @param {Number} n\n//    * @param {Buffer[]} keys\n//    */\n\n//   fromMultisig(m, n, keys) {\n//     assert((m & 0xff) === m && (n & 0xff) === n);\n//     assert(Array.isArray(keys));\n//     assert(keys.length === n, '`n` keys are required for multisig.');\n//     assert(m >= 1 && m <= n);\n//     assert(n >= 1 && n <= 15);\n\n//     this.clear();\n\n//     this.pushSmall(m);\n\n//     for (const key of sortKeys(keys))\n//       this.pushData(key);\n\n//     this.pushSmall(n);\n//     this.pushOp(opcodes.OP_CHECKMULTISIG);\n\n//     return this.compile();\n//   }\n\n//   /**\n//    * Create a pay-to-multisig script.\n//    * @param {Number} m\n//    * @param {Number} n\n//    * @param {Buffer[]} keys\n//    * @returns {Script}\n//    */\n\n//   static fromMultisig(m, n, keys) {\n//     return new this().fromMultisig(m, n, keys);\n//   }\n\n//   /**\n//    * Inject properties from a pay-to-scripthash script.\n//    * @private\n//    * @param {Buffer} hash\n//    */\n\n//   fromScripthash(hash) {\n//     assert(Buffer.isBuffer(hash) && hash.length === 20);\n\n//     this.raw = Buffer.allocUnsafe(23);\n//     this.raw[0] = opcodes.OP_HASH160;\n//     this.raw[1] = 0x14;\n//     hash.copy(this.raw, 2);\n//     this.raw[22] = opcodes.OP_EQUAL;\n\n//     hash = this.raw.slice(2, 22);\n\n//     this.code.length = 0;\n//     this.code.push(Opcode.fromOp(opcodes.OP_HASH160));\n//     this.code.push(Opcode.fromPush(hash));\n//     this.code.push(Opcode.fromOp(opcodes.OP_EQUAL));\n\n//     return this;\n//   }\n\n//   /**\n//    * Create a pay-to-scripthash script.\n//    * @param {Buffer} hash\n//    * @returns {Script}\n//    */\n\n//   static fromScripthash(hash) {\n//     return new this().fromScripthash(hash);\n//   }\n\n//   /**\n//    * Inject properties from a nulldata/opreturn script.\n//    * @private\n//    * @param {Buffer} flags\n//    */\n\n//   fromNulldata(flags) {\n//     assert(Buffer.isBuffer(flags));\n//     assert(flags.length <= policy.MAX_OP_RETURN, 'Nulldata too large.');\n\n//     this.clear();\n//     this.pushOp(opcodes.OP_RETURN);\n//     this.pushData(flags);\n\n//     return this.compile();\n//   }\n\n//   /**\n//    * Create a nulldata/opreturn script.\n//    * @param {Buffer} flags\n//    * @returns {Script}\n//    */\n\n//   static fromNulldata(flags) {\n//     return new this().fromNulldata(flags);\n//   }\n\n  /**\n   * Inject properties from an address.\n   * @private\n   * @param {Address|AddressString} address\n   */\n\n  fromAddress(address) {\n    if (typeof address === 'string')\n      address = Address.fromString(address);\n\n    assert(address instanceof Address, 'Not an address.');\n\n    if (address.isPubkeyhash())\n      return this.fromPubkeyhash(address.hash);\n\n    if (address.isScripthash())\n      return this.fromScripthash(address.hash);\n\n    throw new Error('Unknown address type.');\n  }\n\n  /**\n   * Create an output script from an address.\n   * @param {Address|AddressString} address\n   * @returns {Script}\n   */\n\n  static fromAddress(address) {\n    return new this().fromAddress(address);\n  }\n\n//   /**\n//    * Grab and deserialize the redeem script.\n//    * @returns {Script|null} Redeem script.\n//    */\n\n//   getRedeem() {\n//     let data = null;\n\n//     for (const op of this.code) {\n//       if (op.value === -1)\n//         return null;\n\n//       if (op.value > opcodes.OP_16)\n//         return null;\n\n//       data = op.data;\n//     }\n\n//     if (!data)\n//       return null;\n\n//     return Script.fromRaw(data);\n//   }\n\n//   /**\n//    * Get the standard script type.\n//    * @returns {ScriptType}\n//    */\n\n//   getType() {\n//     if (this.isPubkey())\n//       return scriptTypes.PUBKEY;\n\n//     if (this.isPubkeyhash())\n//       return scriptTypes.PUBKEYHASH;\n\n//     if (this.isScripthash())\n//       return scriptTypes.SCRIPTHASH;\n\n//     if (this.isMultisig())\n//       return scriptTypes.MULTISIG;\n\n//     if (this.isNulldata())\n//       return scriptTypes.NULLDATA;\n\n//     return scriptTypes.NONSTANDARD;\n//   }\n\n//   /**\n//    * Test whether a script is of an unknown/non-standard type.\n//    * @returns {Boolean}\n//    */\n\n//   isUnknown() {\n//     return this.getType() === scriptTypes.NONSTANDARD;\n//   }\n\n//   /**\n//    * Test whether the script is standard by policy standards.\n//    * @returns {Boolean}\n//    */\n\n//   isStandard() {\n//     const [m, n] = this.getMultisig();\n\n//     if (m !== -1) {\n//       if (n < 1 || n > 3)\n//         return false;\n\n//       if (m < 1 || m > n)\n//         return false;\n\n//       return true;\n//     }\n\n//     if (this.isNulldata())\n//       return this.raw.length <= policy.MAX_OP_RETURN_BYTES;\n\n//     return this.getType() !== scriptTypes.NONSTANDARD;\n//   }\n\n//   /**\n//    * Calculate the size of the script\n//    * excluding the varint size bytes.\n//    * @returns {Number}\n//    */\n\n//   getSize() {\n//     return this.raw.length;\n//   }\n\n  /**\n   * Calculate the size of the script\n   * including the varint size bytes.\n   * @returns {Number}\n   */\n\n  getVarSize() {\n    return encoding.sizeVarBytes(this.raw);\n  }\n\n//   /**\n//    * \"Guess\" the address of the input script.\n//    * This method is not 100% reliable.\n//    * @returns {Address|null}\n//    */\n\n//   getInputAddress() {\n//     return Address.fromInputScript(this);\n//   }\n\n//   /**\n//    * Get the address of the script if present. Note that\n//    * pubkey and multisig scripts will be treated as though\n//    * they are pubkeyhash and scripthashes respectively.\n//    * @returns {Address|null}\n//    */\n\n//   getAddress() {\n//     return Address.fromScript(this);\n//   }\n\n  /**\n   * Get the hash160 of the raw script.\n   * @param {String?} enc\n   * @returns {Hash}\n   */\n\n  hash160(enc) {\n    let hash = hash160.digest(this.toRaw());\n    if (enc === 'hex')\n      hash = hash.toString('hex');\n    return hash;\n  }\n\n//   /**\n//    * Get the sha256 of the raw script.\n//    * @param {String?} enc\n//    * @returns {Hash}\n//    */\n\n//   sha256(enc) {\n//     let hash = sha256.digest(this.toRaw());\n//     if (enc === 'hex')\n//       hash = hash.toString('hex');\n//     return hash;\n//   }\n\n//   /**\n//    * Test whether the output script is pay-to-pubkey.\n//    * @param {Boolean} [minimal=false] - Minimaldata only.\n//    * @returns {Boolean}\n//    */\n\n//   isPubkey(minimal) {\n//     if (minimal) {\n//       return this.raw.length >= 35\n//         && (this.raw[0] === 33 || this.raw[0] === 65)\n//         && this.raw[0] + 2 === this.raw.length\n//         && this.raw[this.raw.length - 1] === opcodes.OP_CHECKSIG;\n//     }\n\n//     if (this.code.length !== 2)\n//       return false;\n\n//     const size = this.getLength(0);\n\n//     return (size === 33 || size === 65)\n//       && this.getOp(1) === opcodes.OP_CHECKSIG;\n//   }\n\n  /**\n   * Get P2PK key if present.\n   * @param {Boolean} [minimal=false] - Minimaldata only.\n   * @returns {Buffer|null}\n   */\n\n  getPubkey(minimal) {\n    if (!this.isPubkey(minimal))\n      return null;\n\n    if (minimal)\n      return this.raw.slice(1, 1 + this.raw[0]);\n\n    return this.getData(0);\n  }\n\n  /**\n   * Test whether the output script is pay-to-pubkeyhash.\n   * @param {Boolean} [minimal=false] - Minimaldata only.\n   * @returns {Boolean}\n   */\n\n  isPubkeyhash(minimal) {\n    if (minimal || this.raw.length === 25) {\n      return this.raw.length === 25\n        && this.raw[0] === opcodes.OP_DUP\n        && this.raw[1] === opcodes.OP_HASH160\n        && this.raw[2] === 0x14\n        && this.raw[23] === opcodes.OP_EQUALVERIFY\n        && this.raw[24] === opcodes.OP_CHECKSIG;\n    }\n\n    if (this.code.length !== 5)\n      return false;\n\n    return this.getOp(0) === opcodes.OP_DUP\n      && this.getOp(1) === opcodes.OP_HASH160\n      && this.getLength(2) === 20\n      && this.getOp(3) === opcodes.OP_EQUALVERIFY\n      && this.getOp(4) === opcodes.OP_CHECKSIG;\n  }\n\n  /**\n   * Get P2PKH hash if present.\n   * @param {Boolean} [minimal=false] - Minimaldata only.\n   * @returns {Buffer|null}\n   */\n\n  getPubkeyhash(minimal) {\n    if (!this.isPubkeyhash(minimal))\n      return null;\n\n    if (minimal)\n      return this.raw.slice(3, 23);\n\n    return this.getData(2);\n  }\n\n/**\n   * Test whether the output script is pay-to-multisig.\n   * @param {Boolean} [minimal=true] - Minimaldata only.\n   * @returns {Boolean}\n   */\n\n  isMultisig(minimal) {\n    if (this.code.length < 4 || this.code.length > 19)\n      return false;\n\n    if (this.getOp(-1) !== opcodes.OP_CHECKMULTISIG)\n      return false;\n\n    const m = this.getSmall(0);\n\n    if (m < 1)\n      return false;\n\n    const n = this.getSmall(-2);\n\n\n    if (n < 1 || m > n)\n      return false;\n\n    if (this.code.length !== n + 3)\n      return false;\n\n    for (let i = 1; i < n + 1; i++) {\n      const op = this.code[i];\n      const size = op.toLength();\n\n      if (size !== 33 && size !== 65)\n        return false;\n\n      if (minimal && !op.isMinimal())\n        return false;\n    }\n\n    return true;\n  }\n\n//   /**\n//    * Get multisig m and n values if present.\n//    * @param {Boolean} [minimal=false] - Minimaldata only.\n//    * @returns {Array} [m, n]\n//    */\n\n//   getMultisig(minimal) {\n//     if (!this.isMultisig(minimal))\n//       return [-1, -1];\n\n//     return [this.getSmall(0), this.getSmall(-2)];\n//   }\n\n  /**\n   * Test whether the output script is pay-to-scripthash. Note that\n   * bitcoin itself requires scripthashes to be in strict minimaldata\n   * encoding. Using `OP_HASH160 OP_PUSHDATA1 [hash] OP_EQUAL` will\n   * _not_ be recognized as a scripthash.\n   * @returns {Boolean}\n   */\n\n  isScripthash() {\n    return this.raw.length === 23\n      && this.raw[0] === opcodes.OP_HASH160\n      && this.raw[1] === 0x14\n      && this.raw[22] === opcodes.OP_EQUAL;\n  }\n\n  /**\n   * Get P2SH hash if present.\n   * @returns {Buffer|null}\n   */\n\n  getScripthash() {\n    if (!this.isScripthash())\n      return null;\n\n    return this.getData(1);\n  }\n\n//   /**\n//    * Test whether the output script is nulldata/opreturn.\n//    * @param {Boolean} [minimal=false] - Minimaldata only.\n//    * @returns {Boolean}\n//    */\n\n//   isNulldata(minimal) {\n//     if (this.code.length === 0)\n//       return false;\n\n//     if (this.getOp(0) !== opcodes.OP_RETURN)\n//       return false;\n\n//     if (this.code.length === 1)\n//       return true;\n\n//     if (minimal) {\n//       if (this.raw.length > policy.MAX_OP_RETURN_BYTES)\n//         return false;\n//     }\n\n//     for (let i = 1; i < this.code.length; i++) {\n//       const op = this.code[i];\n\n//       if (op.value === -1)\n//         return false;\n\n//       if (op.value > opcodes.OP_16)\n//         return false;\n\n//       if (minimal && !op.isMinimal())\n//         return false;\n//     }\n\n//     return true;\n//   }\n\n//   /**\n//    * Get OP_RETURN data if present.\n//    * @param {Boolean} [minimal=false] - Minimaldata only.\n//    * @returns {Buffer|null}\n//    */\n\n//   getNulldata(minimal) {\n//     if (!this.isNulldata(minimal))\n//       return null;\n\n//     for (let i = 1; i < this.code.length; i++) {\n//       const op = this.code[i];\n//       const data = op.toPush();\n//       if (data)\n//         return data;\n//     }\n\n//     return EMPTY_BUFFER;\n//   }\n\n//   /**\n//    * Test whether the output script is a witness program.\n//    * Note that this will return true even for malformed\n//    * witness v0 programs.\n//    * @returns {Boolean}\n//    */\n\n//   isProgram() {\n//     if (this.raw.length < 4 || this.raw.length > 42)\n//       return false;\n\n//     if (this.raw[0] !== opcodes.OP_0\n//       && (this.raw[0] < opcodes.OP_1 || this.raw[0] > opcodes.OP_16)) {\n//       return false;\n//     }\n\n//     if (this.raw[1] + 2 !== this.raw.length)\n//       return false;\n\n//     return true;\n//   }\n\n//   /**\n//    * Test whether the output script is unspendable.\n//    * @returns {Boolean}\n//    */\n\n//   isUnspendable() {\n//     if (this.raw.length > consensus.MAX_SCRIPT_SIZE)\n//       return true;\n\n//     return this.raw.length > 0 && this.raw[0] === opcodes.OP_RETURN;\n//   }\n\n//   /**\n//    * \"Guess\" the type of the input script.\n//    * This method is not 100% reliable.\n//    * @returns {ScriptType}\n//    */\n\n//   getInputType() {\n//     if (this.isPubkeyInput())\n//       return scriptTypes.PUBKEY;\n\n//     if (this.isPubkeyhashInput())\n//       return scriptTypes.PUBKEYHASH;\n\n//     if (this.isScripthashInput())\n//       return scriptTypes.SCRIPTHASH;\n\n//     if (this.isMultisigInput())\n//       return scriptTypes.MULTISIG;\n\n//     return scriptTypes.NONSTANDARD;\n//   }\n\n//   /**\n//    * \"Guess\" whether the input script is an unknown/non-standard type.\n//    * This method is not 100% reliable.\n//    * @returns {Boolean}\n//    */\n\n//   isUnknownInput() {\n//     return this.getInputType() === scriptTypes.NONSTANDARD;\n//   }\n\n//   /**\n//    * \"Guess\" whether the input script is pay-to-pubkey.\n//    * This method is not 100% reliable.\n//    * @returns {Boolean}\n//    */\n\n//   isPubkeyInput() {\n//     if (this.code.length !== 1)\n//       return false;\n\n//     const size = this.getLength(0);\n\n//     return size >= 9 && size <= 73;\n//   }\n\n//   /**\n//    * Get P2PK signature if present.\n//    * @returns {Buffer|null}\n//    */\n\n//   getPubkeyInput() {\n//     if (!this.isPubkeyInput())\n//       return null;\n\n//     return this.getData(0);\n//   }\n\n//   /**\n//    * \"Guess\" whether the input script is pay-to-pubkeyhash.\n//    * This method is not 100% reliable.\n//    * @returns {Boolean}\n//    */\n\n//   isPubkeyhashInput() {\n//     if (this.code.length !== 2)\n//       return false;\n\n//     const sig = this.getLength(0);\n//     const key = this.getLength(1);\n\n//     return sig >= 9 && sig <= 73\n//       && (key === 33 || key === 65);\n//   }\n\n//   /**\n//    * Get P2PKH signature and key if present.\n//    * @returns {Array} [sig, key]\n//    */\n\n//   getPubkeyhashInput() {\n//     if (!this.isPubkeyhashInput())\n//       return [null, null];\n\n//     return [this.getData(0), this.getData(1)];\n//   }\n\n//   /**\n//    * \"Guess\" whether the input script is pay-to-multisig.\n//    * This method is not 100% reliable.\n//    * @returns {Boolean}\n//    */\n\n//   isMultisigInput() {\n//     if (this.code.length < 2)\n//       return false;\n\n//     if (this.getOp(0) !== opcodes.OP_0)\n//       return false;\n\n//     if (this.getOp(1) > opcodes.OP_PUSHDATA4)\n//       return false;\n\n//     // We need to rule out scripthash\n//     // because it may look like multisig.\n//     if (this.isScripthashInput())\n//       return false;\n\n//     for (let i = 1; i < this.code.length; i++) {\n//       const size = this.getLength(i);\n//       if (size < 9 || size > 73)\n//         return false;\n//     }\n\n//     return true;\n//   }\n\n//   /**\n//    * Get multisig signatures if present.\n//    * @returns {Buffer[]|null}\n//    */\n\n//   getMultisigInput() {\n//     if (!this.isMultisigInput())\n//       return null;\n\n//     const sigs = [];\n\n//     for (let i = 1; i < this.code.length; i++)\n//       sigs.push(this.getData(i));\n\n//     return sigs;\n//   }\n\n//   /**\n//    * \"Guess\" whether the input script is pay-to-scripthash.\n//    * This method is not 100% reliable.\n//    * @returns {Boolean}\n//    */\n\n//   isScripthashInput() {\n//     if (this.code.length < 1)\n//       return false;\n\n//     // Grab the raw redeem script.\n//     const raw = this.getData(-1);\n\n//     // Last data element should be an array\n//     // for the redeem script.\n//     if (!raw)\n//       return false;\n\n//     // Testing for scripthash inputs requires\n//     // some evil magic to work. We do it by\n//     // ruling things _out_. This test will not\n//     // be correct 100% of the time. We rule\n//     // out that the last data element is: a\n//     // null dummy, a valid signature, a valid\n//     // key, and we ensure that it is at least\n//     // a script that does not use undefined\n//     // opcodes.\n//     if (raw.length === 0)\n//       return false;\n\n//     if (common.isDERSignatureEncoding(raw.slice(0, -1)))\n//       return false;\n\n//     if (common.isKeyEncoding(raw))\n//       return false;\n\n//     const redeem = Script.fromRaw(raw);\n\n//     if (!redeem.isCode())\n//       return false;\n\n//     if (redeem.isUnspendable())\n//       return false;\n\n//     if (!this.isPushOnly())\n//       return false;\n\n//     return true;\n//   }\n\n//   /**\n//    * Get P2SH redeem script if present.\n//    * @returns {Buffer|null}\n//    */\n\n//   getScripthashInput() {\n//     if (!this.isScripthashInput())\n//       return null;\n\n//     return this.getData(-1);\n//   }\n\n//   /**\n//    * Get coinbase height.\n//    * @returns {Number} `-1` if not present.\n//    */\n\n//   getCoinbaseHeight() {\n//     return Script.getCoinbaseHeight(this.raw);\n//   }\n\n//   /**\n//    * Get coinbase height.\n//    * @param {Buffer} raw - Raw script.\n//    * @returns {Number} `-1` if not present.\n//    */\n\n//   static getCoinbaseHeight(raw) {\n//     if (raw.length === 0)\n//       return -1;\n\n//     if (raw[0] >= opcodes.OP_1 && raw[0] <= opcodes.OP_16)\n//       return raw[0] - 0x50;\n\n//     if (raw[0] > 0x06)\n//       return -1;\n\n//     const op = Opcode.fromRaw(raw);\n//     const num = op.toNum();\n\n//     if (!num)\n//       return 1;\n\n//     if (num.isNeg())\n//       return -1;\n\n//     if (!op.equals(Opcode.fromNum(num)))\n//       return -1;\n\n//     return num.toDouble();\n//   }\n\n//   /**\n//    * Test the script against a bloom filter.\n//    * @param {Bloom} filter\n//    * @returns {Boolean}\n//    */\n\n//   test(filter) {\n//     for (const op of this.code) {\n//       if (op.value === -1)\n//         break;\n\n//       if (!op.data || op.data.length === 0)\n//         continue;\n\n//       if (filter.test(op.data))\n//         return true;\n//     }\n\n//     return false;\n//   }\n\n//   /**\n//    * Test the script to see if it contains only push ops.\n//    * Push ops are: OP_1NEGATE, OP_0-OP_16 and all PUSHDATAs.\n//    * @returns {Boolean}\n//    */\n\n  isPushOnly() {\n    for (const op of this.code) {\n      if (op.value === -1)\n        return false;\n\n      if (op.value > opcodes.OP_16)\n        return false;\n    }\n\n    return true;\n  }\n\n//   /**\n//    * Count the sigops in the script.\n//    * @param {Boolean} accurate - Whether to enable accurate counting. This will\n//    * take into account the `n` value for OP_CHECKMULTISIG(VERIFY).\n//    * @returns {Number} sigop count\n//    */\n\n//   getSigops(accurate, flags) {\n//     if (flags & Script.flags.VERIFY_ZERO_SIGOPS)\n//       return 0;\n\n//     let total = 0;\n//     let lastOp = -1;\n\n//     for (const op of this.code) {\n//       if (op.value === -1)\n//         break;\n\n//       switch (op.value) {\n//         case opcodes.OP_CHECKSIG:\n//         case opcodes.OP_CHECKSIGVERIFY:\n//           total += 1;\n//           break;\n//         case opcodes.OP_CHECKSDATAIG:\n//         case opcodes.OP_CHECKDATASIGVERIFY:\n//           if (flags & Script.flags.VERIFY_CHECKDATASIG) {\n//             total += 1;\n//           }\n//           break;\n//         case opcodes.OP_CHECKMULTISIG:\n//         case opcodes.OP_CHECKMULTISIGVERIFY:\n//           if (accurate && lastOp >= opcodes.OP_1 && lastOp <= opcodes.OP_16)\n//             total += lastOp - 0x50;\n//           else\n//             total += consensus.MAX_MULTISIG_PUBKEYS;\n//           break;\n//       }\n\n//       lastOp = op.value;\n//     }\n\n//     return total;\n//   }\n\n//   /**\n//    * Count the sigops in the script, taking into account redeem scripts.\n//    * @param {Script} input - Input script, needed for access to redeem script.\n//    * @param {VerifyFlags} flags\n//    * @returns {Number} sigop count\n//    */\n\n//   getScripthashSigops(input, flags) {\n//     if (!this.isScripthash())\n//       return this.getSigops(true, flags);\n\n//     const redeem = input.getRedeem();\n\n//     if (!redeem)\n//       return 0;\n\n//     return redeem.getSigops(true, flags);\n//   }\n\n//   /*\n//    * Mutation\n//    */\n\n//   get(index) {\n//     if (index < 0)\n//       index += this.code.length;\n\n//     if (index < 0 || index >= this.code.length)\n//       return null;\n\n//     return this.code[index];\n//   }\n\n//   pop() {\n//     const op = this.code.pop();\n//     return op || null;\n//   }\n\n//   shift() {\n//     const op = this.code.shift();\n//     return op || null;\n//   }\n\n//   remove(index) {\n//     if (index < 0)\n//       index += this.code.length;\n\n//     if (index < 0 || index >= this.code.length)\n//       return null;\n\n//     const items = this.code.splice(index, 1);\n\n//     if (items.length === 0)\n//       return null;\n\n//     return items[0];\n//   }\n\n//   set(index, op) {\n//     if (index < 0)\n//       index += this.code.length;\n\n//     assert(Opcode.isOpcode(op));\n//     assert(index >= 0 && index <= this.code.length);\n\n//     this.code[index] = op;\n\n//     return this;\n//   }\n\n  push(op) {\n    assert(Opcode.isOpcode(op));\n    this.code.push(op);\n    return this;\n  }\n\n//   unshift(op) {\n//     assert(Opcode.isOpcode(op));\n//     this.code.unshift(op);\n//     return this;\n//   }\n\n//   insert(index, op) {\n//     if (index < 0)\n//       index += this.code.length;\n\n//     assert(Opcode.isOpcode(op));\n//     assert(index >= 0 && index <= this.code.length);\n\n//     this.code.splice(index, 0, op);\n\n//     return this;\n//   }\n\n//   /*\n//    * Op\n//    */\n\n//   getOp(index) {\n//     const op = this.get(index);\n//     return op ? op.value : -1;\n//   }\n\n//   popOp() {\n//     const op = this.pop();\n//     return op ? op.value : -1;\n//   }\n\n//   shiftOp() {\n//     const op = this.shift();\n//     return op ? op.value : -1;\n//   }\n\n//   removeOp(index) {\n//     const op = this.remove(index);\n//     return op ? op.value : -1;\n//   }\n\n//   setOp(index, value) {\n//     return this.set(index, Opcode.fromOp(value));\n//   }\n\n//   pushOp(value) {\n//     return this.push(Opcode.fromOp(value));\n//   }\n\n//   unshiftOp(value) {\n//     return this.unshift(Opcode.fromOp(value));\n//   }\n\n//   insertOp(index, value) {\n//     return this.insert(index, Opcode.fromOp(value));\n//   }\n\n  /*\n   * Data\n   */\n\n  getData(index) {\n    const op = this.get(index);\n    return op ? op.data : null;\n  }\n\n//   popData() {\n//     const op = this.pop();\n//     return op ? op.data : null;\n//   }\n\n//   shiftData() {\n//     const op = this.shift();\n//     return op ? op.data : null;\n//   }\n\n//   removeData(index) {\n//     const op = this.remove(index);\n//     return op ? op.data : null;\n//   }\n\n//   setData(index, data) {\n//     return this.set(index, Opcode.fromData(data));\n//   }\n\n  pushData(data) {\n    return this.push(Opcode.fromData(data));\n  }\n\n//   unshiftData(data) {\n//     return this.unshift(Opcode.fromData(data));\n//   }\n\n//   insertData(index, data) {\n//     return this.insert(index, Opcode.fromData(data));\n//   }\n\n//   /*\n//    * Length\n//    */\n\n//   getLength(index) {\n//     const op = this.get(index);\n//     return op ? op.toLength() : -1;\n//   }\n\n//   /*\n//    * Push\n//    */\n\n//   getPush(index) {\n//     const op = this.get(index);\n//     return op ? op.toPush() : null;\n//   }\n\n//   popPush() {\n//     const op = this.pop();\n//     return op ? op.toPush() : null;\n//   }\n\n//   shiftPush() {\n//     const op = this.shift();\n//     return op ? op.toPush() : null;\n//   }\n\n//   removePush(index) {\n//     const op = this.remove(index);\n//     return op ? op.toPush() : null;\n//   }\n\n//   setPush(index, data) {\n//     return this.set(index, Opcode.fromPush(data));\n//   }\n\n//   pushPush(data) {\n//     return this.push(Opcode.fromPush(data));\n//   }\n\n//   unshiftPush(data) {\n//     return this.unshift(Opcode.fromPush(data));\n//   }\n\n//   insertPush(index, data) {\n//     return this.insert(index, Opcode.fromPush(data));\n//   }\n\n//   /*\n//    * String\n//    */\n\n//   getString(index, enc) {\n//     const op = this.get(index);\n//     return op ? op.toString(enc) : null;\n//   }\n\n//   popString(enc) {\n//     const op = this.pop();\n//     return op ? op.toString(enc) : null;\n//   }\n\n//   shiftString(enc) {\n//     const op = this.shift();\n//     return op ? op.toString(enc) : null;\n//   }\n\n//   removeString(index, enc) {\n//     const op = this.remove(index);\n//     return op ? op.toString(enc) : null;\n//   }\n\n//   setString(index, str, enc) {\n//     return this.set(index, Opcode.fromString(str, enc));\n//   }\n\n//   pushString(str, enc) {\n//     return this.push(Opcode.fromString(str, enc));\n//   }\n\n//   unshiftString(str, enc) {\n//     return this.unshift(Opcode.fromString(str, enc));\n//   }\n\n//   insertString(index, str, enc) {\n//     return this.insert(index, Opcode.fromString(str, enc));\n//   }\n\n//   /*\n//    * Small\n//    */\n\n//   getSmall(index) {\n//     const op = this.get(index);\n//     return op ? op.toSmall() : -1;\n//   }\n\n//   popSmall() {\n//     const op = this.pop();\n//     return op ? op.toSmall() : -1;\n//   }\n\n//   shiftSmall() {\n//     const op = this.shift();\n//     return op ? op.toSmall() : -1;\n//   }\n\n//   removeSmall(index) {\n//     const op = this.remove(index);\n//     return op ? op.toSmall() : -1;\n//   }\n\n//   setSmall(index, num) {\n//     return this.set(index, Opcode.fromSmall(num));\n//   }\n\n//   pushSmall(num) {\n//     return this.push(Opcode.fromSmall(num));\n//   }\n\n//   unshiftSmall(num) {\n//     return this.unshift(Opcode.fromSmall(num));\n//   }\n\n//   insertSmall(index, num) {\n//     return this.insert(index, Opcode.fromSmall(num));\n//   }\n\n//   /*\n//    * Num\n//    */\n\n//   getNum(index, minimal, limit) {\n//     const op = this.get(index);\n//     return op ? op.toNum(minimal, limit) : null;\n//   }\n\n//   popNum(minimal, limit) {\n//     const op = this.pop();\n//     return op ? op.toNum(minimal, limit) : null;\n//   }\n\n//   shiftNum(minimal, limit) {\n//     const op = this.shift();\n//     return op ? op.toNum(minimal, limit) : null;\n//   }\n\n//   removeNum(index, minimal, limit) {\n//     const op = this.remove(index);\n//     return op ? op.toNum(minimal, limit) : null;\n//   }\n\n//   setNum(index, num) {\n//     return this.set(index, Opcode.fromNum(num));\n//   }\n\n//   pushNum(num) {\n//     return this.push(Opcode.fromNum(num));\n//   }\n\n//   unshiftNum(num) {\n//     return this.unshift(Opcode.fromNum(num));\n//   }\n\n//   insertNum(index, num) {\n//     return this.insert(index, Opcode.fromNum(num));\n//   }\n\n//   /*\n//    * Int\n//    */\n\n//   getInt(index, minimal, limit) {\n//     const op = this.get(index);\n//     return op ? op.toInt(minimal, limit) : -1;\n//   }\n\n//   popInt(minimal, limit) {\n//     const op = this.pop();\n//     return op ? op.toInt(minimal, limit) : -1;\n//   }\n\n//   shiftInt(minimal, limit) {\n//     const op = this.shift();\n//     return op ? op.toInt(minimal, limit) : -1;\n//   }\n\n//   removeInt(index, minimal, limit) {\n//     const op = this.remove(index);\n//     return op ? op.toInt(minimal, limit) : -1;\n//   }\n\n//   setInt(index, num) {\n//     return this.set(index, Opcode.fromInt(num));\n//   }\n\n//   pushInt(num) {\n//     return this.push(Opcode.fromInt(num));\n//   }\n\n//   unshiftInt(num) {\n//     return this.unshift(Opcode.fromInt(num));\n//   }\n\n//   insertInt(index, num) {\n//     return this.insert(index, Opcode.fromInt(num));\n//   }\n\n//   /*\n//    * Bool\n//    */\n\n//   getBool(index) {\n//     const op = this.get(index);\n//     return op ? op.toBool() : false;\n//   }\n\n//   popBool() {\n//     const op = this.pop();\n//     return op ? op.toBool() : false;\n//   }\n\n//   shiftBool() {\n//     const op = this.shift();\n//     return op ? op.toBool() : false;\n//   }\n\n//   removeBool(index) {\n//     const op = this.remove(index);\n//     return op ? op.toBool() : false;\n//   }\n\n//   setBool(index, value) {\n//     return this.set(index, Opcode.fromBool(value));\n//   }\n\n//   pushBool(value) {\n//     return this.push(Opcode.fromBool(value));\n//   }\n\n//   unshiftBool(value) {\n//     return this.unshift(Opcode.fromBool(value));\n//   }\n\n//   insertBool(index, value) {\n//     return this.insert(index, Opcode.fromBool(value));\n//   }\n\n//   /*\n//    * Symbol\n//    */\n\n//   getSym(index) {\n//     const op = this.get(index);\n//     return op ? op.toSymbol() : null;\n//   }\n\n//   popSym() {\n//     const op = this.pop();\n//     return op ? op.toSymbol() : null;\n//   }\n\n//   shiftSym() {\n//     const op = this.shift();\n//     return op ? op.toSymbol() : null;\n//   }\n\n//   removeSym(index) {\n//     const op = this.remove(index);\n//     return op ? op.toSymbol() : null;\n//   }\n\n//   setSym(index, symbol) {\n//     return this.set(index, Opcode.fromSymbol(symbol));\n//   }\n\n//   pushSym(symbol) {\n//     return this.push(Opcode.fromSymbol(symbol));\n//   }\n\n//   unshiftSym(symbol) {\n//     return this.unshift(Opcode.fromSymbol(symbol));\n//   }\n\n//   insertSym(index, symbol) {\n//     return this.insert(index, Opcode.fromSymbol(symbol));\n//   }\n\n//   /**\n//    * Inject properties from bitcoind test string.\n//    * @private\n//    * @param {String} items - Script string.\n//    * @throws Parse error.\n//    */\n\n//   fromString(code) {\n//     assert(typeof code === 'string');\n\n//     code = code.trim();\n\n//     if (code.length === 0)\n//       return this;\n\n//     const items = code.split(/\\s+/);\n//     const bw = bio.write();\n\n//     for (const item of items) {\n//       let symbol = item;\n\n//       if (symbol.charCodeAt(0) & 32)\n//         symbol = symbol.toUpperCase();\n\n//       if (!/^OP_/.test(symbol))\n//         symbol = `OP_${symbol}`;\n\n//       const value = opcodes[symbol];\n\n//       if (value == null) {\n//         if (item[0] === '\\'') {\n//           assert(item[item.length - 1] === '\\'', 'Invalid string.');\n//           const str = item.slice(1, -1);\n//           const op = Opcode.fromString(str);\n//           bw.writeBytes(op.toRaw());\n//           continue;\n//         }\n\n//         if (/^-?\\d+$/.test(item)) {\n//           const num = ScriptNum.fromString(item, 10);\n//           const op = Opcode.fromNum(num);\n//           bw.writeBytes(op.toRaw());\n//           continue;\n//         }\n\n//         assert(item.indexOf('0x') === 0, 'Unknown opcode.');\n\n//         const hex = item.substring(2);\n//         const data = Buffer.from(hex, 'hex');\n\n//         assert(data.length === hex.length / 2, 'Invalid hex string.');\n\n//         bw.writeBytes(data);\n\n//         continue;\n//       }\n\n//       bw.writeU8(value);\n//     }\n\n//     return this.fromRaw(bw.render());\n//   }\n\n//   /**\n//    * Parse a bitcoind test script\n//    * string into a script object.\n//    * @param {String} items - Script string.\n//    * @returns {Script}\n//    * @throws Parse error.\n//    */\n\n//   static fromString(code) {\n//     return new this().fromString(code);\n//   }\n\n  /**\n   * Verify an input and output script, and a witness if present.\n   * @param {Script} input\n   * @param {Null} witness\n   * @param {Script} output\n   * @param {TX} tx\n   * @param {Number} index\n   * @param {Amount} value\n   * @param {VerifyFlags} flags\n   * @param {Number?} sigchecks\n   * @throws {ScriptError}\n   */\n\n  static verify(input, witness, output, tx, index, value, flags, sigchecks) {\n    if (flags == null)\n      flags = Script.flags.STANDARD_VERIFY_FLAGS;\n\n    if (flags & Script.flags.VERIFY_SIGPUSHONLY) {\n      if (!input.isPushOnly())\n        throw new ScriptError('SIG_PUSHONLY');\n    }\n\n    if (flags & Script.flags.VERIFY_SIGHASH_FORKID)\n      flags |= Script.flags.VERIFY_STRICTENC;\n\n    // Setup a stack.\n    let stack = new Stack();\n\n    // Execute the input script\n    input.execute(stack, flags, tx, index, value, metrics.sigchecks);\n\n    // Copy the stack for P2SH\n    let copy;\n    if (flags & Script.flags.VERIFY_P2SH)\n      copy = stack.clone();\n\n    // Execute the previous output script.\n    output.execute(stack, flags, tx, index, value, metrics.sigchecks);\n\n    // Verify the stack values.\n    if (stack.length === 0 || !stack.getBool(-1))\n      throw new ScriptError('EVAL_FALSE');\n\n    // If the script is P2SH, execute the real output script\n    if ((flags & Script.flags.VERIFY_P2SH) && output.isScripthash()) {\n      // P2SH can only have push ops in the scriptSig\n      if (!input.isPushOnly())\n        throw new ScriptError('SIG_PUSHONLY');\n\n      // Reset the stack\n      stack = copy;\n\n      // Stack should not be empty at this point\n      if (stack.length === 0)\n        throw new ScriptError('EVAL_FALSE');\n\n      // Grab the real redeem script\n      const raw = stack.pop();\n      const redeem = Script.fromRaw(raw);\n\n      if ((flags & Script.flags.VERIFY_DISALLOW_SEGWIT_RECOVERY) === 0\n         && stack.length === 0 && redeem.isProgram()) {\n\n        // Before activation all transaction count a value of 0\n        if (!(flags & Script.flags.REPORT_SIGCHECKS)) {\n          metrics.sigchecks = 0;\n        }\n        return;\n      }\n\n        // Execute the redeem script.\n      redeem.execute(stack, flags, tx, index, value, 0, metrics.sigchecks);\n\n      // Verify the the stack values.\n      if (stack.length === 0 || !stack.getBool(-1))\n        throw new ScriptError('EVAL_FALSE');\n    }\n\n    // Ensure there is nothing left on the stack.\n    if (flags & Script.flags.VERIFY_CLEANSTACK) {\n      assert((flags & Script.flags.VERIFY_P2SH) !== 0);\n      if (stack.length !== 1)\n        throw new ScriptError('CLEANSTACK');\n    }\n\n    if (flags & Script.flags.VERIFY_INPUT_SIGCHECKS) {\n      if (input.getSize() < metrics.sigchecks * 43 - 60)\n        throw new ScriptError('INPUT_SIGCHECKS');\n    }\n\n    if (!(flags & Script.flags.REPORT_SIGCHECKS)) {\n      metrics.sigchecks = 0;\n    }\n  }\n\n//   /**\n//    * Inject properties from buffer reader.\n//    * @private\n//    * @param {BufferReader} br\n//    */\n\n//   fromReader(br) {\n//     return this.fromRaw(br.readVarBytes());\n//   }\n\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer}\n   */\n\n  fromRaw(data) {\n    const br = bio.read(data);\n\n    this.raw = data;\n\n    while (br.left())\n      this.code.push(Opcode.fromReader(br));\n\n    return this;\n  }\n\n//   /**\n//    * Create a script from buffer reader.\n//    * @param {BufferReader} br\n//    * @param {String?} enc - Either `\"hex\"` or `null`.\n//    * @returns {Script}\n//    */\n\n//   static fromReader(br) {\n//     return new this().fromReader(br);\n//   }\n\n//   /**\n//    * Create a script from a serialized buffer.\n//    * @param {Buffer|String} data - Serialized script.\n//    * @param {String?} enc - Either `\"hex\"` or `null`.\n//    * @returns {Script}\n//    */\n\n  static fromRaw(data, enc) {\n    if (typeof data === 'string')\n      data = Buffer.from(data, enc);\n    return new this().fromRaw(data);\n  }\n\n//   /**\n//    * Test whether an object a Script.\n//    * @param {Object} obj\n//    * @returns {Boolean}\n//    */\n\n//   static isScript(obj) {\n//     return obj instanceof Script;\n//   }\n}\n\n// /**\n//  * Script opcodes.\n//  * @enum {Number}\n//  * @default\n//  */\n\n// Script.opcodes = common.opcodes;\n\n// /**\n//  * Opcodes by value.\n//  * @const {RevMap}\n//  */\n\n// Script.opcodesByVal = common.opcodesByVal;\n\n/**\n * Script and locktime flags. See {@link VerifyFlags}.\n * @enum {Number}\n */\n\nScript.flags = common.flags;\n\n/**\n * Sighash Types.\n * @enum {SighashType}\n * @default\n */\n\nScript.hashType = common.hashType;\n\n// /**\n//  * Sighash types by value.\n//  * @const {RevMap}\n//  */\n\n// Script.hashTypeByVal = common.hashTypeByVal;\n\n// /**\n//  * Output script types.\n//  * @enum {Number}\n//  */\n\n// Script.types = common.types;\n\n// /**\n//  * Output script types by value.\n//  * @const {RevMap}\n//  */\n\n// Script.typesByVal = common.typesByVal;\n\n// /*\n//  * Helpers\n//  */\n\n// function sortKeys(keys) {\n//   return keys.slice().sort((a, b) => {\n//     return a.compare(b);\n//   });\n// }\n\n// /**\n//  * Test whether the data element is a valid key if VERIFY_STRICTENC is enabled.\n//  * @param {Buffer} key\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n\n// function validateKey(key, flags) {\n//   assert(Buffer.isBuffer(key));\n//   assert(typeof flags === 'number');\n\n//   if (flags & Script.flags.VERIFY_STRICTENC) {\n//     if (!common.isKeyEncoding(key))\n//       throw new ScriptError('PUBKEYTYPE');\n//   }\n\n//   if ((flags & Script.flags.VERIFY_COMPRESSED_PUBKEYTYPE)\n//     && !common.isCompressedEncoding(key)) {\n//     throw new ScriptError('NONCOMPRESSED_PUBKEY');\n//   };\n\n//   return true;\n// }\n\n// /**\n//  * Test whether the raw element is a valid signature based\n//  * on the encoding, S value, and sighash type.\n//  * In an ECDSA-only context, 64-byte signatures are bannned\n//  * when Schnorr Flag is set.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n\n// function validateECDSASignature(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n\n//   if (common.isSchnorr(sig))\n//     throw new ScriptError('SIG_BADLENGTH');\n\n//   if ((flags & Script.flags.VERIFY_DERSIG)\n//       || (flags & Script.flags.VERIFY_LOW_S)\n//       || (flags & Script.flags.VERIFY_STRICTENC)) {\n//     if (!common.isDERSignatureEncoding(sig))\n//       throw new ScriptError('SIG_DER');\n//   }\n\n//   if (flags & Script.flags.VERIFY_LOW_S) {\n//     if (!common.isLowDER(sig))\n//       throw new ScriptError('SIG_HIGH_S');\n//   }\n\n//   return true;\n// }\n\n// /**\n//  * Test whether the tx element is a valid signature based\n//  * on the encoding, S value, and sighash type. Requires\n//  * VERIFY_STRICTENC, VERIFY_SIGHASH_FORKID to be enabled respectively.\n//  * Note that this will allow zero-length signatures.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n\n// function checkSighashEncoding(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n\n//   if (flags & Script.flags.VERIFY_STRICTENC) {\n//     if (!common.isHashType(sig))\n//       throw new ScriptError('SIG_HASHTYPE');\n\n//     const usesFork = sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID;\n//     const forkEnabled = flags & Script.flags.VERIFY_SIGHASH_FORKID;\n\n//     if (!forkEnabled && usesFork)\n//       throw new ScriptError('ILLEGAL_FORKID');\n\n//     if (forkEnabled && !usesFork)\n//       throw new ScriptError('MUST_USE_FORKID');\n//   }\n\n//   return true;\n// }\n\n// /**\n//  * Test whether the transaction tested against\n//  * the Sighash Encoding is a valid Schnorr Signature.\n//  * Requires Sighash\n//  * @param {Buffer} sig\n//  * @param {VeirfyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n\n// function checkTransactionSignature(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n\n//   // allow empty sigs\n//   if (sig.length === 0)\n//     return true;\n\n//   validateSchnorrSignature(sig.slice(0, -1), flags);\n\n//   return checkSighashEncoding(sig, flags);\n// }\n\n// /**\n//  * Test whether the transaction is tested\n//  * against the sighash encoding w schnorr / ecdsa\n//  * for multisig opcodes.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  */\n\n// function checkTransactionSchnorrSig(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n\n//   // Allow empty sigs.\n//   if (sig.length === 0)\n//     return true;\n\n//   if (!isSchnorrEncoded(sig.slice(0, -1), flags))\n//     return validateECDSASignature(sig.slice(0, -1), flags);\n\n//   return checkSighashEncoding(sig, flags);\n// }\n\n// /**\n//  * Test whether the transaction tested against\n//  * the Sighash Encoding is a valid ECDSA Signature.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n\n// function checkTransactionECDSASignature(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n\n//   // Allow empty sigs\n//   if (sig.length === 0)\n//     return true;\n\n//   validateECDSASignature(sig.slice(0, -1), flags);\n\n//   return checkSighashEncoding(sig, flags);\n// }\n\n// /**\n//  * Test whether the data element is a valid signature based\n//  * on the encoding, S value, and sighash type. Requires\n//  * VERIFY_DERSIG|VERIFY_LOW_S|VERIFY_STRICTENC, and VERIFY_LOW_S\n//  * to be enabled respectively. Note that this will allow zero-length\n//  * signatures.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n\n// function validateDataSignature(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n\n//   // Allow empty sigs\n//   if (sig.length === 0)\n//     return true;\n\n//   return validateSchnorrSignature(sig.slice(0, sig.length), flags);\n// }\n\n// /**\n//  * Test whether the Signature is valid in context\n//  * 64-byte signatures are interpreted as schnorr signatures.\n//  * Always correctly encoded when Verify_SCHNORR flag is set.\n//  * @param {Buffer} sig\n//  * @param {Buffer} msg - Signature hash.\n//  * @param {VerifyFlags?} flags\n//  * @returns {Promise}\n//  * @throws {ScriptError}\n//  */\n\n// function validateSchnorrSignature(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n\n//   if (common.isSchnorr(sig))\n//     return true;\n\n//   return validateECDSASignature(sig, flags);\n// }\n\n// /**\n//  * Test whether the current signature is schnorr encoded.\n//  * @param {Buffer} sig\n//  * @param {VerifyFlags?} flags\n//  * @returns {Boolean}\n//  * @throws {ScriptError}\n//  */\n\n// function isSchnorrEncoded(sig, flags) {\n//   assert(Buffer.isBuffer(sig));\n//   assert(typeof flags === 'number');\n\n//   if (common.isSchnorr(sig))\n//     return true;\n\n//   throw new ScriptError('SIG_NONSCHNORR');\n// }\n\n// /**\n//  * Test whether the signature from the stack\n//  * is valid in either Schnorr or DER Format.\n//  * Always encoded correctly when Schnorr flag is set.\n//  * @param {Buffer} hash\n//  * @param {Buffer} sig\n//  * @param {Buffer} key\n//  * @param {Number} flags\n//  */\n\n// function verifySignature(hash, sig, key, flags) {\n//   assert(Buffer.isBuffer(hash));\n//   assert(Buffer.isBuffer(sig));\n//   assert(Buffer.isBuffer(key));\n//   assert(typeof flags === 'number');\n\n//   let res = false;\n\n//   if (sig.length === 64) {\n//     res = secp256k1.schnorrVerify(hash, sig, key, flags);\n//   } else {\n//     res = secp256k1.verifyDER(hash, sig, key, flags);\n//   }\n\n//   return res;\n// }\n\n// /**\n//  * Verify a signature, taking into account sighash type.\n//  * @param {Buffer} msg - Signature hash.\n//  * @param {Buffer} sig\n//  * @param {Buffer} key\n//  * @returns {Boolean}\n//  */\n\n// function checksig(msg, sig, key) {\n//   return secp256k1.verifyDER(msg, sig.slice(0, -1), key);\n// }\n\n/*\n * Expose\n */\n\nmodule.exports = Script;\n"]},"metadata":{},"sourceType":"module"}