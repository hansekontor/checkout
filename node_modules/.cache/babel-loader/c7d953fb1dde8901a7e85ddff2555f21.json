{"ast":null,"code":"/*!\n * bcrypt.js - bcrypt for javascript\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on joyent/node-bcrypt-pbkdf:\n *   Copyright (c) 2016, Joyent Inc\n *   https://github.com/joyent/node-bcrypt-pbkdf\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/Bcrypt\n *   http://www.usenix.org/events/usenix99/provos/provos_html/node1.html\n *   https://hackernoon.com/the-bcrypt-protocol-is-kind-of-a-mess-4aace5eb31bd\n *   https://github.com/openbsd/src/blob/master/lib/libc/crypt/bcrypt.c\n *   https://github.com/openssh/openssh-portable\n *   https://github.com/openssh/openssh-portable/blob/master/openbsd-compat/bcrypt_pbkdf.c\n *   https://github.com/openssh/openssh-portable/blob/master/openbsd-compat/blowfish.c\n *   https://github.com/joyent/node-bcrypt-pbkdf/blob/master/index.js\n */\n'use strict';\n\nconst assert = require('./internal/assert');\n\nconst SHA512 = require('./sha512');\n\nconst Blowfish = require('./js/ciphers/blowfish');\n/*\n * Constants\n */\n\n\nconst CIPHERTEXT192 = Buffer.from('OrpheanBeholderScryDoubt', 'binary');\nconst BCRYPT_BLOCKS192 = 6;\nconst BCRYPT_SIZE192 = 24;\nconst BCRYPT_SALT192 = 16;\nconst BCRYPT_HASH192 = 23;\nconst CIPHERTEXT256 = Buffer.from('OxychromaticBlowfishSwatDynamite', 'binary');\nconst BCRYPT_BLOCKS256 = 8;\nconst BCRYPT_SIZE256 = 32;\nconst NUL = Buffer.alloc(1, 0x00);\n/*\n * Bcrypt\n */\n\nfunction hash192(pass, salt, rounds) {\n  if (typeof pass === 'string') pass = Buffer.from(pass, 'utf8');\n  if (typeof salt === 'string') salt = Buffer.from(salt, 'utf8');\n  if (salt == null) salt = Buffer.alloc(0);\n  assert(Buffer.isBuffer(pass));\n  assert(Buffer.isBuffer(salt));\n  assert(rounds >>> 0 === rounds);\n  if (rounds < 4 || rounds > 31) throw new RangeError('Invalid rounds.');\n  return _hash192(pass, salt, rounds, Buffer.alloc(BCRYPT_SIZE192));\n}\n\nfunction derive(pass, salt, rounds) {\n  let minor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'b';\n  if (typeof pass === 'string') pass = Buffer.from(pass, 'utf8');\n  if (typeof salt === 'string') salt = Buffer.from(salt, 'utf8');\n  assert(Buffer.isBuffer(pass));\n  assert(Buffer.isBuffer(salt));\n  assert(rounds >>> 0 === rounds);\n  assert(typeof minor === 'string');\n  if (salt.length !== BCRYPT_SALT192) throw new RangeError('Invalid salt length.');\n\n  switch (minor) {\n    case 'a':\n      pass = Buffer.concat([pass, NUL]);\n      pass = pass.slice(0, pass.length & 0xff);\n      break;\n\n    case 'b':\n      if (pass.length > 72) pass = pass.slice(0, 73);else pass = Buffer.concat([pass, NUL]);\n      break;\n\n    default:\n      throw new Error('Invalid minor version.');\n  }\n\n  return hash192(pass, salt, rounds).slice(0, BCRYPT_HASH192);\n}\n\nfunction generate(pass, salt, rounds) {\n  let minor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'b';\n\n  if (typeof salt === 'string') {\n    const [i, data] = decode64(salt, 0, BCRYPT_SALT192);\n    if (i !== salt.length || data == null) throw new Error('Invalid salt string.');\n    salt = data;\n  }\n\n  const hash = derive(pass, salt, rounds, minor);\n  return encode(minor, rounds, salt, hash);\n}\n\nfunction verify(pass, record) {\n  const [minor, rounds, salt, expect] = decode(record);\n  const hash = derive(pass, salt, rounds, minor);\n  let res = 0;\n\n  for (let i = 0; i < BCRYPT_HASH192; i++) res |= hash[i] ^ expect[i];\n\n  return res - 1 >>> 31 !== 0;\n}\n/*\n * PBKDF\n */\n\n\nfunction hash256(pass, salt, rounds) {\n  if (typeof pass === 'string') pass = Buffer.from(pass, 'utf8');\n  if (typeof salt === 'string') salt = Buffer.from(salt, 'utf8');\n  if (salt == null) salt = Buffer.alloc(0);\n  assert(Buffer.isBuffer(pass));\n  assert(Buffer.isBuffer(salt));\n  assert(rounds >>> 0 === rounds);\n  if (rounds < 4 || rounds > 31) throw new RangeError('Invalid rounds.');\n  return _hash256(pass, salt, rounds, Buffer.alloc(BCRYPT_SIZE256));\n}\n\nfunction pbkdf(pass, salt, rounds, size) {\n  if (typeof pass === 'string') pass = Buffer.from(pass, 'utf8');\n  if (typeof salt === 'string') salt = Buffer.from(salt, 'utf8');\n  if (salt == null) salt = Buffer.alloc(0);\n  assert(Buffer.isBuffer(pass));\n  assert(Buffer.isBuffer(salt));\n  assert(rounds >>> 0 === rounds);\n  assert(size >>> 0 === size);\n  const out = Buffer.alloc(BCRYPT_SIZE256);\n  const tmpout = Buffer.alloc(BCRYPT_SIZE256);\n  const countsalt = Buffer.alloc(salt.length + 4);\n  const key = Buffer.alloc(size);\n\n  if (rounds < 1 || pass.length === 0 || salt.length === 0 || size === 0 || size > out.length ** 2 || salt.length > 1 << 20) {\n    throw new Error('Invalid bcrypt parameters.');\n  }\n\n  const stride = (size + out.length - 1) / out.length >>> 0;\n  const amount = (size + stride - 1) / stride >>> 0;\n  salt.copy(countsalt, 0);\n  const sha2pass = SHA512.digest(pass);\n  let sha2salt = Buffer.alloc(0);\n  let keylen = size;\n  let amt = amount;\n\n  for (let count = 1; keylen > 0; count++) {\n    countsalt[salt.length + 0] = count >>> 24;\n    countsalt[salt.length + 1] = count >>> 16;\n    countsalt[salt.length + 2] = count >>> 8;\n    countsalt[salt.length + 3] = count;\n    sha2salt = SHA512.digest(countsalt);\n\n    _hash256(sha2pass, sha2salt, 6, tmpout);\n\n    tmpout.copy(out, 0);\n\n    for (let i = 1; i < rounds; i++) {\n      sha2salt = SHA512.digest(tmpout);\n\n      _hash256(sha2pass, sha2salt, 6, tmpout);\n\n      for (let j = 0; j < out.length; j++) out[j] ^= tmpout[j];\n    }\n\n    amt = Math.min(amt, keylen);\n    let i = 0;\n\n    for (; i < amt; i++) {\n      const dest = i * stride + (count - 1);\n      if (dest >= size) break;\n      key[dest] = out[i];\n    }\n\n    keylen -= i;\n  }\n\n  return key;\n}\n/*\n * Hashing\n */\n\n\nfunction _hash192(pass, salt, rounds, out) {\n  const state = new Blowfish();\n  const cdata = new Uint32Array(BCRYPT_BLOCKS192);\n  state.init(pass, salt);\n  const r = 2 ** rounds;\n\n  for (let i = 0; i < r; i++) {\n    state.expand0state(pass);\n    state.expand0state(salt);\n  }\n\n  for (let i = 0; i < BCRYPT_BLOCKS192; i++) cdata[i] = state.stream2word(CIPHERTEXT192);\n\n  for (let i = 0; i < 64; i++) state.enc(cdata);\n\n  for (let i = 0; i < BCRYPT_BLOCKS192; i++) {\n    out[4 * i + 0] = cdata[i] >>> 24;\n    out[4 * i + 1] = cdata[i] >>> 16;\n    out[4 * i + 2] = cdata[i] >>> 8;\n    out[4 * i + 3] = cdata[i];\n  }\n\n  return out;\n}\n\nfunction _hash256(pass, salt, rounds, out) {\n  const state = new Blowfish();\n  const cdata = new Uint32Array(BCRYPT_BLOCKS256);\n  state.init(pass, salt);\n  const r = 2 ** rounds;\n\n  for (let i = 0; i < r; i++) {\n    state.expand0state(salt);\n    state.expand0state(pass);\n  }\n\n  for (let i = 0; i < BCRYPT_BLOCKS256; i++) cdata[i] = state.stream2word(CIPHERTEXT256);\n\n  for (let i = 0; i < 64; i++) state.enc(cdata);\n\n  for (let i = 0; i < BCRYPT_BLOCKS256; i++) {\n    out[4 * i + 3] = cdata[i] >>> 24;\n    out[4 * i + 2] = cdata[i] >>> 16;\n    out[4 * i + 1] = cdata[i] >>> 8;\n    out[4 * i + 0] = cdata[i];\n  }\n\n  return out;\n}\n/*\n * Encoding\n */\n\n\nfunction encode(minor, rounds, salt, hash) {\n  assert(typeof minor === 'string');\n  assert(rounds >>> 0 === rounds);\n  assert(Buffer.isBuffer(salt));\n  assert(Buffer.isBuffer(hash));\n  assert(minor === 'a' || minor === 'b');\n  assert(rounds >= 4 && rounds <= 31);\n  assert(salt.length === BCRYPT_SALT192);\n  assert(hash.length === BCRYPT_HASH192);\n  let logr = rounds.toString(10);\n  if (rounds < 10) logr = '0' + logr;\n  return `$2${minor}$${logr}$${encode64(salt)}${encode64(hash)}`;\n}\n\nfunction decode(str) {\n  assert(typeof str === 'string');\n  if (str.length < 46) throw new Error('Invalid bcrypt string.');\n  if (str[0] !== '$' || str[1] !== '2') throw new Error('Invalid major version.');\n  const minor = str[2];\n\n  switch (minor) {\n    case 'a':\n    case 'b':\n      break;\n\n    default:\n      throw new Error('Invalid minor version.');\n  }\n\n  if (str[3] !== '$') throw new Error('Invalid bcrypt string.');\n  const p = str.charCodeAt(4) - 0x30;\n  const q = str.charCodeAt(5) - 0x30;\n  if (p < 0 || p > 9 || q < 0 || q > 9) throw new Error('Invalid bcrypt string.');\n  const rounds = p * 10 + q;\n  if (rounds < 4 || rounds > 31) throw new Error('Invalid log rounds.');\n  if (str[6] !== '$') throw new Error('Invalid bcrypt string.');\n  let i = 7;\n  let salt, hash;\n  [i, salt] = decode64(str, i, BCRYPT_SALT192);\n  if (salt == null) throw new Error('Invalid salt.');\n  [i, hash] = decode64(str, i, BCRYPT_HASH192);\n  if (hash == null) throw new Error('Invalid hash.');\n  if (i !== str.length) throw new Error('Invalid bcrypt string.');\n  return [minor, rounds, salt, hash];\n}\n/*\n * Base64\n */\n\n\nconst CHARSET = './ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nconst TABLE = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, -1, -1, -1, -1, -1, -1, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, -1, -1, -1, -1, -1, -1, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, -1, -1, -1, -1, -1];\n\nfunction encode64(data) {\n  assert(Buffer.isBuffer(data));\n  let p = 0;\n  let s = '';\n  let a, b;\n\n  while (p < data.length) {\n    a = data[p++];\n    s += CHARSET[a >>> 2];\n    a = (a & 3) << 4;\n\n    if (p >= data.length) {\n      s += CHARSET[a];\n      break;\n    }\n\n    b = data[p++];\n    a |= b >>> 4 & 15;\n    s += CHARSET[a];\n    a = (b & 0x0f) << 2;\n\n    if (p >= data.length) {\n      s += CHARSET[a];\n      break;\n    }\n\n    b = data[p++];\n    a |= b >>> 6 & 3;\n    s += CHARSET[a];\n    s += CHARSET[b & 63];\n  }\n\n  return s;\n}\n\nfunction decode64(s, i, len) {\n  assert(typeof s === 'string');\n  assert(i >>> 0 === i);\n  assert(len >>> 0 === len);\n  const data = Buffer.alloc(len);\n  let p = 0;\n  let a, b, c, d;\n\n  while (p < len) {\n    a = unbase64(s, i++);\n    if (a === -1) return [i, null];\n    b = unbase64(s, i++);\n    if (b === -1) return [i, null];\n    data[p++] = a << 2 | (b & 48) >>> 4;\n    if (p >= len) break;\n    c = unbase64(s, i++);\n    if (c === -1) return [i, null];\n    data[p++] = (b & 15) << 4 | (c & 60) >>> 2;\n    if (p >= len) break;\n    d = unbase64(s, i++);\n    if (d === -1) return [i, null];\n    data[p++] = (c & 3) << 6 | d;\n  }\n\n  return [i, data];\n}\n\nfunction unbase64(s, i) {\n  if (i >= s.length) return -1;\n  const ch = s.charCodeAt(i);\n  if (ch & 0xff80) return -1;\n  return TABLE[ch];\n}\n/*\n * Expose\n */\n\n\nexports.native = 0;\nexports.hash192 = hash192;\nexports.derive = derive;\nexports.generate = generate;\nexports.verify = verify;\nexports.hash256 = hash256;\nexports.pbkdf = pbkdf;","map":null,"metadata":{},"sourceType":"script"}