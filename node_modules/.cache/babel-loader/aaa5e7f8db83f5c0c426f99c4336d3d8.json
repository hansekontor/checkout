{"ast":null,"code":"/*!\n * asn1.js - asn1 parsing for bcoin\n * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n *\n * Parts of this software are based on asn1.js.\n * https://github.com/indutny/asn1.js\n *\n * Copyright Fedor Indutny, 2013.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n'use strict';\n\nconst bio = require('bufio');\n\nconst ASN1 = exports;\n/**\n * Read next tag.\n * @param {BufferReader} br\n * @returns {Object}\n */\n\nASN1.readTag = function readTag(br) {\n  let type = br.readU8();\n  const primitive = (type & 0x20) === 0;\n\n  if ((type & 0x1f) === 0x1f) {\n    let oct = type;\n    type = 0;\n\n    while ((oct & 0x80) === 0x80) {\n      oct = br.readU8();\n      type <<= 7;\n      type |= oct & 0x7f;\n    }\n  } else {\n    type &= 0x1f;\n  }\n\n  return {\n    type: type,\n    primitive: primitive,\n    size: ASN1.readSize(br, primitive)\n  };\n};\n/**\n * Read tag size.\n * @param {BufferReader} br\n * @param {Boolean} primitive\n * @returns {Number}\n * @throws on indefinite size\n */\n\n\nASN1.readSize = function readSize(br, primitive) {\n  let size = br.readU8(); // Indefinite form\n\n  if (!primitive && size === 0x80) throw new Error('Indefinite size.'); // Definite form\n\n  if ((size & 0x80) === 0) {\n    // Short form\n    return size;\n  } // Long form\n\n\n  const bytes = size & 0x7f;\n  if (bytes > 3) throw new Error('Length octet is too long.');\n  size = 0;\n\n  for (let i = 0; i < bytes; i++) {\n    size <<= 8;\n    size |= br.readU8();\n  }\n\n  return size;\n};\n/**\n * Read implicit SEQ.\n * @param {BufferReader} br\n * @returns {Buffer}\n */\n\n\nASN1.readSeq = function readSeq(br) {\n  const tag = ASN1.implicit(br, 0x10);\n  return br.readBytes(tag.size);\n};\n/**\n * Read next tag and assert implicit.\n * @param {BufferReader} br\n * @param {Number} type\n * @returns {Object}\n * @throws on unexpected tag\n */\n\n\nASN1.implicit = function implicit(br, type) {\n  const tag = ASN1.readTag(br);\n  if (tag.type !== type) throw new Error(`Unexpected tag: ${tag.type}.`);\n  return tag;\n};\n/**\n * Read implicit tag.\n * @param {BufferReader} br\n * @param {Number} type\n * @returns {Boolean}\n */\n\n\nASN1.explicit = function explicit(br, type) {\n  const offset = br.offset;\n  const tag = ASN1.readTag(br);\n\n  if (tag.type !== type) {\n    br.offset = offset;\n    return false;\n  }\n\n  return true;\n};\n/**\n * Read next implicit SEQ and return a new reader.\n * @param {BufferReader} br\n * @returns {BufferReader}\n */\n\n\nASN1.seq = function seq(br) {\n  return bio.read(ASN1.readSeq(br), true);\n};\n/**\n * Read implicit int.\n * @param {BufferReader} br\n * @param {Boolean?} cast\n * @returns {Buffer|Number}\n */\n\n\nASN1.readInt = function readInt(br, cast) {\n  const tag = ASN1.implicit(br, 0x02);\n  const num = br.readBytes(tag.size);\n  if (cast) return num.readUIntBE(0, num.length);\n  return num;\n};\n/**\n * Read explicit int.\n * @param {BufferReader} br\n * @param {Number} type\n * @param {Boolean?} readNum\n * @returns {Buffer|Number} `-1` on not present.\n */\n\n\nASN1.readExplicitInt = function readExplicitInt(br, type, readNum) {\n  if (!ASN1.explicit(br, type)) return -1;\n  return ASN1.readInt(br, readNum);\n};\n/**\n * Read and align an implicit bitstr.\n * @param {BufferReader} br\n * @returns {Buffer}\n */\n\n\nASN1.readBitstr = function readBitstr(br) {\n  const tag = ASN1.implicit(br, 0x03);\n  const str = br.readBytes(tag.size);\n  return ASN1.alignBitstr(str);\n};\n/**\n * Read an implicit string (any type).\n * @param {BufferReader} br\n * @returns {String}\n */\n\n\nASN1.readString = function readString(br) {\n  const tag = ASN1.readTag(br);\n\n  switch (tag.type) {\n    case 0x03:\n      {\n        // bitstr\n        const str = br.readBytes(tag.size);\n        return ASN1.alignBitstr(str).toString('utf8');\n      }\n    // Note:\n    // Fuck all these.\n\n    case 0x04: // octstr\n\n    case 0x12: // numstr\n\n    case 0x13: // prinstr\n\n    case 0x14: // t61str\n\n    case 0x15: // videostr\n\n    case 0x16: // ia5str\n\n    case 0x19: // graphstr\n\n    case 0x0c: // utf8str\n\n    case 0x1a: // iso646str\n\n    case 0x1b: // genstr\n\n    case 0x1c: // unistr\n\n    case 0x1d: // charstr\n\n    case 0x1e:\n      {\n        // bmpstr\n        return br.readString(tag.size, 'utf8');\n      }\n\n    default:\n      {\n        throw new Error(`Unexpected tag: ${tag.type}.`);\n      }\n  }\n};\n/**\n * Align a bitstr.\n * @param {Buffer} data\n * @returns {Buffer}\n */\n\n\nASN1.alignBitstr = function alignBitstr(data) {\n  const padding = data[0];\n  const bits = (data.length - 1) * 8 - padding;\n  const buf = data.slice(1);\n  const shift = 8 - bits % 8;\n  if (shift === 8 || buf.length === 0) return buf;\n  const out = Buffer.allocUnsafe(buf.length);\n  out[0] = buf[0] >>> shift;\n\n  for (let i = 1; i < buf.length; i++) {\n    out[i] = buf[i - 1] << 8 - shift;\n    out[i] |= buf[i] >>> shift;\n  }\n\n  return out;\n};\n/**\n * Read an entire certificate.\n * @param {BufferReader} br\n * @returns {Object}\n */\n\n\nASN1.readCert = function readCert(br) {\n  const buf = br;\n  buf.start();\n  br = ASN1.seq(buf);\n  return {\n    tbs: ASN1.readTBS(br),\n    sigAlg: ASN1.readAlgIdent(br),\n    sig: ASN1.readBitstr(br),\n    raw: buf.endData(true)\n  };\n};\n/**\n * Read only the TBS certificate.\n * @param {BufferReader} br\n * @returns {Object}\n */\n\n\nASN1.readTBS = function readTBS(br) {\n  const buf = br;\n  buf.start();\n  br = ASN1.seq(buf);\n  return {\n    version: ASN1.readExplicitInt(br, 0x00, true),\n    serial: ASN1.readInt(br),\n    sig: ASN1.readAlgIdent(br),\n    issuer: ASN1.readName(br),\n    validity: ASN1.readValidity(br),\n    subject: ASN1.readName(br),\n    pubkey: ASN1.readPubkey(br),\n    raw: buf.endData(true)\n  };\n};\n/**\n * Read an implicit pubkey.\n * @param {BufferReader} br\n * @returns {Object}\n */\n\n\nASN1.readPubkey = function readPubkey(br) {\n  br = ASN1.seq(br);\n  return {\n    alg: ASN1.readAlgIdent(br),\n    pubkey: ASN1.readBitstr(br)\n  };\n};\n/**\n * Read implicit name.\n * @param {BufferReader} br\n * @returns {Object[]}\n */\n\n\nASN1.readName = function readName(br) {\n  const values = [];\n  br = ASN1.seq(br);\n\n  while (br.left()) {\n    ASN1.implicit(br, 0x11); // set\n\n    ASN1.implicit(br, 0x10); // seq\n\n    values.push({\n      type: ASN1.readOID(br),\n      value: ASN1.readString(br)\n    });\n  }\n\n  return values;\n};\n/**\n * Read implicit validity timerange.\n * @param {BufferReader} br\n * @returns {Object}\n */\n\n\nASN1.readValidity = function readValidity(br) {\n  br = ASN1.seq(br);\n  return {\n    notBefore: ASN1.readTime(br),\n    notAfter: ASN1.readTime(br)\n  };\n};\n/**\n * Read implicit timestamp.\n * @param {BufferReader} br\n * @returns {Number}\n */\n\n\nASN1.readTime = function readTime(br) {\n  const tag = ASN1.readTag(br);\n  const str = br.readString(tag.size, 'ascii');\n  let year, mon, day, hour, min, sec;\n\n  switch (tag.type) {\n    case 0x17:\n      // utctime\n      year = str.slice(0, 2) | 0;\n      mon = str.slice(2, 4) | 0;\n      day = str.slice(4, 6) | 0;\n      hour = str.slice(6, 8) | 0;\n      min = str.slice(8, 10) | 0;\n      sec = str.slice(10, 12) | 0;\n      if (year < 70) year = 2000 + year;else year = 1900 + year;\n      break;\n\n    case 0x18:\n      // gentime\n      year = str.slice(0, 4) | 0;\n      mon = str.slice(4, 6) | 0;\n      day = str.slice(6, 8) | 0;\n      hour = str.slice(8, 10) | 0;\n      min = str.slice(10, 12) | 0;\n      sec = str.slice(12, 14) | 0;\n      break;\n\n    default:\n      throw new Error(`Unexpected tag: ${tag.type}.`);\n  }\n\n  return Date.UTC(year, mon - 1, day, hour, min, sec, 0) / 1000;\n};\n/**\n * Read and format OID to string.\n * @param {BufferReader} br\n * @returns {String}\n */\n\n\nASN1.readOID = function readOID(br) {\n  const tag = ASN1.implicit(br, 0x06);\n  const data = br.readBytes(tag.size);\n  return ASN1.formatOID(data);\n};\n/**\n * Format an OID buffer to a string.\n * @param {Buffer} data\n * @returns {String}\n */\n\n\nASN1.formatOID = function formatOID(data) {\n  const br = bio.read(data);\n  const ids = [];\n  let ident = 0;\n  let subident = 0;\n\n  while (br.left()) {\n    subident = br.readU8();\n    ident <<= 7;\n    ident |= subident & 0x7f;\n\n    if ((subident & 0x80) === 0) {\n      ids.push(ident);\n      ident = 0;\n    }\n  }\n\n  if (subident & 0x80) ids.push(ident);\n  const first = ids[0] / 40 | 0;\n  const second = ids[0] % 40;\n  const result = [first, second].concat(ids.slice(1));\n  return result.join('.');\n};\n/**\n * Read algorithm identifier.\n * @param {BufferReader} br\n * @returns {Object}\n */\n\n\nASN1.readAlgIdent = function readAlgIdent(br) {\n  let params = null;\n  br = ASN1.seq(br);\n  const alg = ASN1.readOID(br);\n\n  if (br.left() > 0) {\n    const tag = ASN1.readTag(br);\n    params = br.readBytes(tag.size);\n    if (params.length === 0) params = null;\n  }\n\n  return {\n    alg: alg,\n    params: params\n  };\n};\n/**\n * Read RSA public key.\n * @param {BufferReader} br\n * @returns {Object}\n */\n\n\nASN1.readRSAPublic = function readRSAPublic(br) {\n  br = ASN1.seq(br);\n  return {\n    modulus: ASN1.readInt(br),\n    publicExponent: ASN1.readInt(br)\n  };\n};\n/**\n * Read RSA private key.\n * @param {BufferReader} br\n * @returns {Object}\n */\n\n\nASN1.readRSAPrivate = function readRSAPrivate(br) {\n  br = ASN1.seq(br);\n  return {\n    version: ASN1.readInt(br, true),\n    modulus: ASN1.readInt(br),\n    publicExponent: ASN1.readInt(br),\n    privateExponent: ASN1.readInt(br),\n    prime1: ASN1.readInt(br),\n    prime2: ASN1.readInt(br),\n    exponent1: ASN1.readInt(br),\n    exponent2: ASN1.readInt(br),\n    coefficient: ASN1.readInt(br)\n  };\n};\n/**\n * Read RSA public key from buffer.\n * @param {Buffer} data\n * @returns {Object}\n */\n\n\nASN1.parseRSAPublic = function parseRSAPublic(data) {\n  return ASN1.readRSAPublic(bio.read(data, true));\n};\n/**\n * Read RSA private key from buffer.\n * @param {Buffer} data\n * @returns {Object}\n */\n\n\nASN1.parseRSAPrivate = function parseRSAPrivate(data) {\n  return ASN1.readRSAPrivate(bio.read(data, true));\n};\n/**\n * Read certificate from buffer.\n * @param {Buffer} data\n * @returns {Object}\n */\n\n\nASN1.parseCert = function parseCert(data) {\n  return ASN1.readCert(bio.read(data, true));\n};\n/**\n * Read TBS certificate from buffer.\n * @param {Buffer} data\n * @returns {Object}\n */\n\n\nASN1.parseTBS = function parseTBS(data) {\n  return ASN1.readTBS(bio.read(data, true));\n};","map":null,"metadata":{},"sourceType":"script"}