{"ast":null,"code":"/*!\n * struct.js - struct object for bcoin\n * Copyright (c) 2018, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst enforce = require('./enforce');\n\nconst BufferReader = require('./reader');\n\nconst BufferWriter = require('./writer');\n\nconst StaticWriter = require('./staticwriter');\n\nconst {\n  custom\n} = require('./custom');\n/**\n * Struct\n */\n\n\nclass Struct {\n  constructor() {}\n\n  inject(obj) {\n    enforce(obj instanceof this.constructor, 'obj', 'struct');\n    return this.decode(obj.encode());\n  }\n\n  clone() {\n    const copy = new this.constructor();\n    return copy.inject(this);\n  }\n  /*\n   * Bindable\n   */\n\n\n  getSize(extra) {\n    return -1;\n  }\n\n  write(bw, extra) {\n    return bw;\n  }\n\n  read(br, extra) {\n    return this;\n  }\n\n  toString() {\n    return Object.prototype.toString.call(this);\n  }\n\n  fromString(str, extra) {\n    return this;\n  }\n\n  getJSON() {\n    return this;\n  }\n\n  fromJSON(json, extra) {\n    return this;\n  }\n\n  fromOptions(options, extra) {\n    return this;\n  }\n\n  from(options, extra) {\n    return this.fromOptions(options, extra);\n  }\n\n  format() {\n    return this.getJSON();\n  }\n  /*\n   * API\n   */\n\n\n  encode(extra) {\n    const size = this.getSize(extra);\n    const bw = size === -1 ? new BufferWriter() : new StaticWriter(size);\n    this.write(bw, extra);\n    return bw.render();\n  }\n\n  decode(data, extra) {\n    const br = new BufferReader(data);\n    this.read(br, extra);\n    return this;\n  }\n\n  toHex(extra) {\n    return this.encode(extra).toString('hex');\n  }\n\n  fromHex(str, extra) {\n    enforce(typeof str === 'string', 'str', 'string');\n    const size = str.length >>> 1;\n    const data = Buffer.from(str, 'hex');\n    if (data.length !== size) throw new Error('Invalid hex string.');\n    return this.decode(data, extra);\n  }\n\n  toBase64(extra) {\n    return this.encode(extra).toString('base64');\n  }\n\n  fromBase64(str, extra) {\n    enforce(typeof str === 'string', 'str', 'string');\n    const data = Buffer.from(str, 'base64');\n    if (str.length > size64(data.length)) throw new Error('Invalid base64 string.');\n    return this.decode(data, extra);\n  }\n\n  toJSON() {\n    return this.getJSON();\n  }\n\n  [custom]() {\n    return this.format();\n  }\n  /*\n   * Static API\n   */\n\n\n  static read(br, extra) {\n    return new this().read(br, extra);\n  }\n\n  static decode(data, extra) {\n    return new this().decode(data, extra);\n  }\n\n  static fromHex(str, extra) {\n    return new this().fromHex(str, extra);\n  }\n\n  static fromBase64(str, extra) {\n    return new this().fromBase64(str, extra);\n  }\n\n  static fromString(str, extra) {\n    return new this().fromString(str, extra);\n  }\n\n  static fromJSON(json, extra) {\n    return new this().fromJSON(json, extra);\n  }\n\n  static fromOptions(options, extra) {\n    return new this().fromOptions(options, extra);\n  }\n\n  static from(options, extra) {\n    return new this().from(options, extra);\n  }\n  /*\n   * Aliases\n   */\n\n\n  toWriter(bw, extra) {\n    return this.write(bw, extra);\n  }\n\n  fromReader(br, extra) {\n    return this.read(br, extra);\n  }\n\n  toRaw(extra) {\n    return this.encode(extra);\n  }\n\n  fromRaw(data, extra) {\n    return this.decode(data, extra);\n  }\n  /*\n   * Static Aliases\n   */\n\n\n  static fromReader(br, extra) {\n    return this.read(br, extra);\n  }\n\n  static fromRaw(data, extra) {\n    return this.decode(data, extra);\n  }\n\n}\n/*\n * Helpers\n */\n\n\nfunction size64(size) {\n  const expect = 4 * size / 3 + 3 & ~3;\n  return expect >>> 0;\n}\n/*\n * Expose\n */\n\n\nmodule.exports = Struct;","map":null,"metadata":{},"sourceType":"script"}