{"ast":null,"code":"/*!\n * x509.js - X509 for javascript\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on indutny/asn1.js:\n *   Copyright Fedor Indutny, 2013.\n *   https://github.com/indutny/asn1.js\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/X.509\n *   https://tools.ietf.org/html/rfc4158\n *   https://www.ietf.org/rfc/rfc2560.txt\n *   https://www.ietf.org/rfc/rfc5280.txt\n *   https://github.com/indutny/asn1.js/blob/master/rfc/2560/index.js\n *   https://github.com/indutny/asn1.js/blob/master/rfc/5280/index.js\n *   https://github.com/indutny/asn1.js/blob/master/lib/asn1/base/node.js\n *   https://github.com/indutny/asn1.js/blob/master/lib/asn1/encoders/der.js\n *   https://github.com/indutny/asn1.js/blob/master/lib/asn1/decoders/der.js\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst asn1 = require('./asn1');\n\nconst pem = require('./pem');\n\nconst {\n  types\n} = asn1;\n/**\n * Certificate\n */\n// Certificate  ::=  SEQUENCE  {\n//      tbsCertificate       TBSCertificate,\n//      signatureAlgorithm   AlgorithmIdentifier,\n//      signature            BIT STRING  }\n\nclass Certificate extends asn1.Sequence {\n  constructor() {\n    super();\n    this.tbsCertificate = new TBSCertificate();\n    this.signatureAlgorithm = new AlgorithmIdentifier();\n    this.signature = new asn1.BitString();\n  }\n\n  get isRaw() {\n    return true;\n  }\n\n  getBodySize() {\n    let size = 0;\n    size += this.tbsCertificate.getSize();\n    size += this.signatureAlgorithm.getSize();\n    size += this.signature.getSize();\n    return size;\n  }\n\n  writeBody(bw) {\n    this.tbsCertificate.write(bw);\n    this.signatureAlgorithm.write(bw);\n    this.signature.write(bw);\n    return bw;\n  }\n\n  readBody(br) {\n    this.tbsCertificate.read(br);\n    this.signatureAlgorithm.read(br);\n    this.signature.read(br);\n    return this;\n  }\n\n  clean() {\n    return this.tbsCertificate.clean() && this.signatureAlgorithm.clean() && this.signature.clean();\n  }\n\n  toPEM() {\n    return pem.toPEM(this.encode(), 'CERTIFICATE');\n  }\n\n  fromPEM(str) {\n    const data = pem.fromPEM(str, 'CERTIFICATE');\n    return this.decode(data);\n  }\n\n  format() {\n    return {\n      type: this.constructor.name,\n      tbsCertificate: this.tbsCertificate,\n      signatureAlgorithm: this.signatureAlgorithm,\n      signature: this.signature\n    };\n  }\n\n}\n/**\n * TBSCertificate\n */\n// TBSCertificate  ::=  SEQUENCE  {\n//      version         [0]  Version DEFAULT v1,\n//      serialNumber         CertificateSerialNumber,\n//      signature            AlgorithmIdentifier,\n//      issuer               Name,\n//      validity             Validity,\n//      subject              Name,\n//      subjectPublicKeyInfo SubjectPublicKeyInfo,\n//      issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,\n//      subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,\n//      extensions      [3]  Extensions OPTIONAL }\n//\n// Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }\n\n\nclass TBSCertificate extends asn1.Sequence {\n  constructor() {\n    super();\n    this.version = new asn1.Unsigned().explicit(0).optional();\n    this.serialNumber = new asn1.Integer();\n    this.signature = new AlgorithmIdentifier();\n    this.issuer = new RDNSequence();\n    this.validity = new Validity();\n    this.subject = new RDNSequence();\n    this.subjectPublicKeyInfo = new SubjectPublicKeyInfo();\n    this.issuerUniqueID = new asn1.BitString().implicit(1).optional();\n    this.subjectUniqueID = new asn1.BitString().implicit(2).optional();\n    this.extensions = new Extensions().explicit(3).optional();\n  }\n\n  get isRaw() {\n    return true;\n  }\n\n  getBodySize() {\n    let size = 0;\n    size += this.version.getSize();\n    size += this.serialNumber.getSize();\n    size += this.signature.getSize();\n    size += this.issuer.getSize();\n    size += this.validity.getSize();\n    size += this.subject.getSize();\n    size += this.subjectPublicKeyInfo.getSize();\n    size += this.issuerUniqueID.getSize();\n    size += this.subjectUniqueID.getSize();\n    size += this.extensions.getSize();\n    return size;\n  }\n\n  writeBody(bw) {\n    this.version.write(bw);\n    this.serialNumber.write(bw);\n    this.signature.write(bw);\n    this.issuer.write(bw);\n    this.validity.write(bw);\n    this.subject.write(bw);\n    this.subjectPublicKeyInfo.write(bw);\n    this.issuerUniqueID.write(bw);\n    this.subjectUniqueID.write(bw);\n    this.extensions.write(bw);\n    return bw;\n  }\n\n  readBody(br) {\n    this.version.read(br);\n    this.serialNumber.read(br);\n    this.signature.read(br);\n    this.issuer.read(br);\n    this.validity.read(br);\n    this.subject.read(br);\n    this.subjectPublicKeyInfo.read(br);\n    this.issuerUniqueID.read(br);\n    this.subjectUniqueID.read(br);\n    this.extensions.read(br);\n    return this;\n  }\n\n  clean() {\n    return this.version.clean() && this.serialNumber.clean() && this.signature.clean() && this.issuer.clean() && this.validity.clean() && this.subject.clean() && this.subjectPublicKeyInfo.clean() && this.issuerUniqueID.clean() && this.subjectUniqueID.clean() && this.extensions.clean();\n  }\n\n  toPEM() {\n    return pem.toPEM(this.encode(), 'TBS CERTIFICATE');\n  }\n\n  fromPEM(str) {\n    const data = pem.fromPEM(str, 'TBS CERTIFICATE');\n    return this.decode(data);\n  }\n\n  format() {\n    return {\n      type: this.constructor.name,\n      version: this.version,\n      serialNumber: this.serialNumber,\n      signature: this.signature,\n      issuer: this.issuer,\n      validity: this.validity,\n      subject: this.subject,\n      subjectPublicKeyInfo: this.subjectPublicKeyInfo,\n      issuerUniqueID: this.issuerUniqueID,\n      subjectUniqueID: this.subjectUniqueID,\n      extensions: this.extensions\n    };\n  }\n\n}\n/**\n * AlgorithmIdentifier\n */\n// AlgorithmIdentifier  ::=  SEQUENCE  {\n//      algorithm               OBJECT IDENTIFIER,\n//      parameters              ANY DEFINED BY algorithm OPTIONAL  }\n\n\nclass AlgorithmIdentifier extends asn1.Sequence {\n  constructor(algorithm, parameters) {\n    super();\n    this.algorithm = new asn1.OID(algorithm);\n    this.parameters = new asn1.Any(parameters).optional();\n  }\n\n  getBodySize() {\n    let size = 0;\n    size += this.algorithm.getSize();\n    size += this.parameters.getSize();\n    return size;\n  }\n\n  writeBody(bw) {\n    this.algorithm.write(bw);\n    this.parameters.write(bw);\n    return bw;\n  }\n\n  readBody(br) {\n    this.algorithm.read(br);\n    this.parameters.read(br);\n    return this;\n  }\n\n  clean() {\n    return this.algorithm.clean() && this.parameters.clean();\n  }\n\n  format() {\n    return {\n      type: this.constructor.name,\n      algorithm: this.algorithm,\n      parameters: this.parameters\n    };\n  }\n\n}\n/**\n * RDNSequence\n */\n// Name ::= CHOICE { -- only one possibility for now --\n//      rdnSequence  RDNSequence }\n//\n// RDNSequence ::= SEQUENCE OF RelativeDistinguishedName\n\n\nclass RDNSequence extends asn1.Sequence {\n  constructor() {\n    super();\n    this.names = [];\n  }\n\n  getBodySize() {\n    let size = 0;\n\n    for (const rdn of this.names) size += rdn.getSize();\n\n    return size;\n  }\n\n  writeBody(bw) {\n    for (const rdn of this.names) rdn.write(bw);\n\n    return bw;\n  }\n\n  readBody(br) {\n    while (br.left()) {\n      const rdn = RDN.read(br);\n      this.names.push(rdn);\n    }\n\n    return this;\n  }\n\n  clean() {\n    return this.names.length === 0;\n  }\n\n  format() {\n    return {\n      type: this.constructor.name,\n      names: this.names\n    };\n  }\n\n}\n/**\n * RDN\n */\n// RelativeDistinguishedName ::=\n//      SET SIZE (1..MAX) OF AttributeTypeAndValue\n//\n\n\nclass RDN extends asn1.Set {\n  constructor(id, value) {\n    super();\n    this.attributes = [new Attribute(id, value)];\n  }\n\n  getBodySize() {\n    let size = 0;\n    assert(this.attributes.length >= 1);\n\n    for (const attr of this.attributes) size += attr.getSize();\n\n    return size;\n  }\n\n  writeBody(bw) {\n    assert(this.attributes.length >= 1);\n\n    for (const attr of this.attributes) attr.write(bw);\n\n    return bw;\n  }\n\n  readBody(br) {\n    this.attributes[0].read(br);\n\n    while (br.left()) {\n      const attr = Attribute.read(br);\n      this.attributes.push(attr);\n    }\n\n    return this;\n  }\n\n  clean() {\n    return this.attributes.length === 1 && this.attributes[0].clean();\n  }\n\n  format() {\n    return {\n      type: this.constructor.name,\n      attributes: this.attributes\n    };\n  }\n\n}\n/**\n * Attribute\n */\n// AttributeTypeAndValue ::= SEQUENCE {\n//      type     AttributeType,\n//      value    AttributeValue }\n//\n// AttributeType ::= OBJECT IDENTIFIER\n//\n// AttributeValue ::= ANY -- DEFINED BY AttributeType\n\n\nclass Attribute extends asn1.Sequence {\n  constructor(id, value) {\n    super();\n    this.id = new asn1.OID(id);\n    this.value = new asn1.Any(value);\n  }\n\n  getBodySize() {\n    let size = 0;\n    size += this.id.getSize();\n    size += this.value.getSize();\n    return size;\n  }\n\n  writeBody(bw) {\n    this.id.write(bw);\n    this.value.write(bw);\n    return bw;\n  }\n\n  readBody(br) {\n    this.id.read(br);\n    this.value.read(br);\n    return this;\n  }\n\n  clean() {\n    return this.id.clean() && this.value.clean();\n  }\n\n  format() {\n    return {\n      type: this.constructor.name,\n      id: this.id,\n      value: this.value\n    };\n  }\n\n}\n/**\n * Validity\n */\n// Validity ::= SEQUENCE {\n//      notBefore      Time,\n//      notAfter       Time  }\n\n\nclass Validity extends asn1.Sequence {\n  constructor() {\n    super();\n    this.notBefore = new Time();\n    this.notAfter = new Time();\n  }\n\n  getBodySize() {\n    let size = 0;\n    size += this.notBefore.getSize();\n    size += this.notAfter.getSize();\n    return size;\n  }\n\n  writeBody(bw) {\n    this.notBefore.write(bw);\n    this.notAfter.write(bw);\n    return bw;\n  }\n\n  readBody(br) {\n    this.notBefore.read(br);\n    this.notAfter.read(br);\n    return this;\n  }\n\n  clean() {\n    return this.notBefore.clean() && this.notAfter.clean();\n  }\n\n  format() {\n    return {\n      type: this.constructor.name,\n      notBefore: this.notBefore,\n      notAfter: this.notAfter\n    };\n  }\n\n}\n/**\n * Time\n */\n// Time ::= CHOICE {\n//      utcTime        UTCTime,\n//      generalTime    GeneralizedTime }\n\n\nclass Time extends asn1.Choice {\n  constructor(options) {\n    super(new asn1.UTCTime(), options);\n  }\n\n  choices() {\n    return [types.UTCTIME, types.GENTIME];\n  }\n\n} // SubjectPublicKeyInfo  ::=  SEQUENCE  {\n//      algorithm            AlgorithmIdentifier,\n//      subjectPublicKey     BIT STRING  }\n\n\nclass SubjectPublicKeyInfo extends asn1.Sequence {\n  constructor(algorithm, parameters, publicKey) {\n    super();\n    this.algorithm = new AlgorithmIdentifier(algorithm, parameters);\n    this.publicKey = new asn1.BitString(publicKey);\n  }\n\n  get isRaw() {\n    return true;\n  }\n\n  getBodySize() {\n    let size = 0;\n    size += this.algorithm.getSize();\n    size += this.publicKey.getSize();\n    return size;\n  }\n\n  writeBody(bw) {\n    this.algorithm.write(bw);\n    this.publicKey.write(bw);\n    return bw;\n  }\n\n  readBody(br) {\n    this.algorithm.read(br);\n    this.publicKey.read(br);\n    return this;\n  }\n\n  clean() {\n    return this.algorithm.clean() && this.publicKey.clean();\n  }\n\n  toPEM() {\n    return pem.toPEM(this.encode(), 'PUBLIC KEY');\n  }\n\n  fromPEM(str) {\n    const data = pem.fromPEM(str, 'PUBLIC KEY');\n    return this.decode(data);\n  }\n\n  format() {\n    return {\n      type: this.constructor.name,\n      algorithm: this.algorithm,\n      publicKey: this.publicKey\n    };\n  }\n\n}\n/**\n * Extensions\n */\n\n\nclass Extensions extends asn1.Sequence {\n  constructor() {\n    super();\n    this.extensions = [];\n  }\n\n  getBodySize() {\n    let size = 0;\n\n    for (const ext of this.extensions) size += ext.getSize();\n\n    return size;\n  }\n\n  writeBody(bw) {\n    for (const ext of this.extensions) ext.write(bw);\n\n    return bw;\n  }\n\n  readBody(br) {\n    for (const ext of this.extensions) ext.read(br);\n\n    return this;\n  }\n\n  clean() {\n    return this.extensions.length === 0;\n  }\n\n  format() {\n    return {\n      type: this.constructor.name,\n      extensions: this.extensions\n    };\n  }\n\n}\n/**\n * Extension\n */\n// Extension  ::=  SEQUENCE  {\n//      extnID      OBJECT IDENTIFIER,\n//      critical    BOOLEAN DEFAULT FALSE,\n//      extnValue   OCTET STRING }\n\n\nclass Extension extends asn1.Sequence {\n  constructor() {\n    super();\n    this.extnID = new asn1.OID();\n    this.critical = new asn1.Bool().optional();\n    this.extnValue = new asn1.OctString();\n  }\n\n  getBodySize() {\n    let size = 0;\n    size += this.extnID.getSize();\n    size += this.critical.getSize();\n    size += this.extnValue.getSize();\n    return size;\n  }\n\n  writeBody(bw) {\n    this.extnID.write(bw);\n    this.critical.write(bw);\n    this.extnValue.write(bw);\n    return bw;\n  }\n\n  readBody(br) {\n    this.extnID.read(br);\n    this.critical.read(br);\n    this.extnValue.read(br);\n    return this;\n  }\n\n  clean() {\n    return this.extnID.clean() && this.critical.clean() && this.extnValue.clean();\n  }\n\n  format() {\n    return {\n      type: this.constructor.name,\n      extnID: this.extnID,\n      critical: this.critical,\n      extnValue: this.extnValue\n    };\n  }\n\n}\n/**\n * DigestInfo\n */\n// See: https://www.ietf.org/rfc/rfc3447.txt\n// Section 9.2\n//\n// DigestInfo ::= SEQUENCE {\n//   digestAlgorithm AlgorithmIdentifier,\n//   digest OCTET STRING\n// }\n\n\nclass DigestInfo extends asn1.Sequence {\n  constructor(algorithm, digest) {\n    super();\n    this.algorithm = new AlgorithmIdentifier(algorithm);\n    this.algorithm.parameters.optional(false);\n    this.digest = new asn1.OctString(digest);\n  }\n\n  getBodySize() {\n    let size = 0;\n    size += this.algorithm.getSize();\n    size += this.digest.getSize();\n    return size;\n  }\n\n  writeBody(bw) {\n    this.algorithm.write(bw);\n    this.digest.write(bw);\n    return bw;\n  }\n\n  readBody(br) {\n    this.algorithm.read(br);\n    this.digest.read(br);\n    return this;\n  }\n\n  clean() {\n    return this.algorithm.clean() && this.digest.clean();\n  }\n\n  format() {\n    return {\n      type: this.constructor.name,\n      algorithm: this.algorithm,\n      digest: this.digest\n    };\n  }\n\n}\n/*\n * Expose\n */\n\n\nexports.Certificate = Certificate;\nexports.TBSCertificate = TBSCertificate;\nexports.AlgorithmIdentifier = AlgorithmIdentifier;\nexports.RDNSequence = RDNSequence;\nexports.RDN = RDN;\nexports.Attribute = Attribute;\nexports.Validity = Validity;\nexports.Time = Time;\nexports.SubjectPublicKeyInfo = SubjectPublicKeyInfo;\nexports.Extensions = Extensions;\nexports.Extension = Extension;\nexports.DigestInfo = DigestInfo;","map":null,"metadata":{},"sourceType":"script"}