{"ast":null,"code":"/*!\n * paymentrequest.js - bip70 paymentrequest for bcoin\n * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst ProtoReader = require('./utils/protoreader');\n\nconst ProtoWriter = require('./utils/protowriter');\n\nconst PaymentDetails = require('./paymentdetails');\n\nconst x509 = require('./x509');\n/**\n * BIP70 Payment Request\n */\n\n\nclass PaymentRequest {\n  /**\n   * Create a payment request.\n   * @constructor\n   * @param {Object?} options\n   * @property {Number} version\n   * @property {String|null} pkiType\n   * @property {Buffer|null} pkiData\n   * @property {PaymentDetails} paymentDetails\n   * @property {Buffer|null} signature\n   */\n  constructor(options) {\n    this.version = -1;\n    this.pkiType = null;\n    this.pkiData = null;\n    this.paymentDetails = new PaymentDetails();\n    this.signature = null;\n    if (options) this.fromOptions(options);\n  }\n  /**\n   * Inject properties from options.\n   * @private\n   * @param {Object} options\n   * @returns {PaymentRequest}\n   */\n\n\n  fromOptions(options) {\n    if (options.version != null) {\n      assert((options.version | 0) === options.version);\n      this.version = options.version;\n    }\n\n    if (options.pkiType != null) {\n      assert(typeof options.pkiType === 'string');\n      this.pkiType = options.pkiType;\n    }\n\n    if (options.pkiData) {\n      assert(Buffer.isBuffer(options.pkiData));\n      this.pkiData = options.pkiData;\n    }\n\n    if (options.paymentDetails) this.paymentDetails.fromOptions(options.paymentDetails);\n\n    if (options.signature) {\n      assert(Buffer.isBuffer(options.signature));\n      this.signature = options.signature;\n    }\n\n    if (options.chain) this.setChain(options.chain);\n    return this;\n  }\n  /**\n   * Instantiate payment request from options.\n   * @param {Object} options\n   * @returns {PaymentRequest}\n   */\n\n\n  static fromOptions(options) {\n    return new PaymentRequest().fromOptions(options);\n  }\n  /**\n   * Inject properties from serialized data.\n   * @private\n   * @param {Buffer} data\n   * @returns {PaymentRequest}\n   */\n\n\n  fromRaw(data) {\n    const br = new ProtoReader(data);\n    this.version = br.readFieldU32(1, true);\n    this.pkiType = br.readFieldString(2, true);\n    this.pkiData = br.readFieldBytes(3, true);\n    this.paymentDetails.fromRaw(br.readFieldBytes(4));\n    this.signature = br.readFieldBytes(5, true);\n    return this;\n  }\n  /**\n   * Instantiate payment request from serialized data.\n   * @param {Buffer} data\n   * @returns {PaymentRequest}\n   */\n\n\n  static fromRaw(data, enc) {\n    if (typeof data === 'string') data = Buffer.from(data, enc);\n    return new PaymentRequest().fromRaw(data);\n  }\n  /**\n   * Serialize the payment request (protobuf).\n   * @returns {Buffer}\n   */\n\n\n  toRaw() {\n    const bw = new ProtoWriter();\n    if (this.version !== -1) bw.writeFieldU32(1, this.version);\n    if (this.pkiType != null) bw.writeFieldString(2, this.pkiType);\n    if (this.pkiData) bw.writeFieldBytes(3, this.pkiData);\n    bw.writeFieldBytes(4, this.paymentDetails.toRaw());\n    if (this.signature) bw.writeFieldBytes(5, this.signature);\n    return bw.render();\n  }\n  /**\n   * Get payment request signature algorithm.\n   * @returns {Object|null}\n   */\n\n\n  getAlgorithm() {\n    if (!this.pkiType) throw new Error('No PKI type available.');\n    const parts = this.pkiType.split('+');\n    if (parts.length !== 2) throw new Error('Could not parse PKI algorithm.');\n    if (parts[0] !== 'x509') throw new Error(`Unknown PKI type: ${parts[0]}.`);\n    if (parts[1] !== 'sha1' && parts[1] !== 'sha256') throw new Error(`Unknown hash algorithm: ${parts[1]}.`);\n    return new Algorithm(parts[0], parts[1]);\n  }\n  /**\n   * Serialize payment request for sighash.\n   * @returns {Buffer}\n   */\n\n\n  signatureData() {\n    const signature = this.signature;\n    this.signature = Buffer.alloc(0);\n    const data = this.toRaw();\n    this.signature = signature;\n    return data;\n  }\n  /**\n   * Set x509 certificate chain.\n   * @param {Buffer[]} chain\n   */\n\n\n  setChain(chain) {\n    const bw = new ProtoWriter();\n    assert(Array.isArray(chain), 'Chain must be an array.');\n\n    for (const cert of chain) {\n      assert(Buffer.isBuffer(cert), 'Certificates must be DER.');\n      bw.writeFieldBytes(1, cert);\n    }\n\n    this.pkiData = bw.render();\n  }\n  /**\n   * Get x509 certificate chain.\n   * @returns {Buffer[]}\n   */\n\n\n  getChain() {\n    const chain = [];\n    if (!this.pkiData) return chain;\n    const br = new ProtoReader(this.pkiData);\n\n    while (br.nextTag() === 1) chain.push(br.readFieldBytes(1));\n\n    return chain;\n  }\n  /**\n   * Sign payment request (chain must be set).\n   * @param {Buffer} key\n   * @param {Buffer[]?} certs\n   */\n\n\n  sign(key, certs) {\n    if (certs) this.setChain(certs);\n    if (!this.pkiType) this.pkiType = 'x509+sha256';\n    const alg = this.getAlgorithm();\n    const msg = this.signatureData();\n    const chain = this.getChain();\n    this.signature = x509.signSubject(alg.hash, msg, key, chain);\n  }\n  /**\n   * Verify payment request signature.\n   * @returns {Boolean}\n   */\n\n\n  verify() {\n    if (!this.pkiType || this.pkiType === 'none') return false;\n    if (!this.signature) return false;\n    let alg;\n\n    try {\n      alg = this.getAlgorithm();\n    } catch (e) {\n      return false;\n    }\n\n    const msg = this.signatureData();\n    const sig = this.signature;\n    const chain = this.getChain();\n\n    try {\n      return x509.verifySubject(alg.hash, msg, sig, chain);\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n   * Verify x509 certificate chain.\n   * @returns {Boolean}\n   */\n\n\n  verifyChain() {\n    if (!this.pkiType || this.pkiType === 'none') return false;\n\n    try {\n      return x509.verifyChain(this.getChain());\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n   * Get root certificate authority.\n   * @returns {Object|null}\n   */\n\n\n  getCA() {\n    if (!this.pkiType || this.pkiType === 'none') throw new Error('No CA found (pkiType).');\n    const chain = this.getChain();\n    if (chain.length === 0) throw new Error('No CA found (chain).');\n    const root = x509.parse(chain[chain.length - 1]);\n    return new CA(root);\n  }\n\n}\n/**\n * Algorithm\n */\n\n\nclass Algorithm {\n  /**\n   * Create an algorithm.\n   * @constructor\n   * @ignore\n   */\n  constructor(key, hash) {\n    this.key = key;\n    this.hash = hash;\n  }\n\n}\n/**\n * CA\n */\n\n\nclass CA {\n  /**\n   * Create a CA.\n   * @constructor\n   * @ignore\n   */\n  constructor(root) {\n    this.name = x509.getCAName(root);\n    this.trusted = x509.isTrusted(root);\n    this.cert = root;\n  }\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = PaymentRequest;","map":null,"metadata":{},"sourceType":"script"}