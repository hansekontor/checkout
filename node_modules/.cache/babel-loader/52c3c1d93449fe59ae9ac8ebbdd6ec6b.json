{"ast":null,"code":"/*!\n * mtx.js - mutable transaction object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n'use strict';\n\nconst assert = require('bsert');\n\nconst {\n  encoding\n} = require('bufio');\n\nconst {\n  BufferMap\n} = require('buffer-map');\n\nconst Script = require('../script/script');\n\nconst TX = require('./tx');\n\nconst Input = require('./input');\n\nconst Output = require('./output');\n\nconst Coin = require('./coin');\n\nconst Outpoint = require('./outpoint');\n\nconst CoinView = require('../coins/coinview');\n\nconst Address = require('./address');\n\nconst consensus = require('../protocol/consensus');\n\nconst policy = require('../protocol/policy');\n\nconst Amount = require('../btc/amount');\n\nconst Stack = require('../script/stack');\n\nconst util = require('../utils/util');\n\nconst {\n  inspectSymbol\n} = require('../utils');\n/**\n * MTX\n * A mutable transaction object.\n * @alias module:primitives.MTX\n * @extends TX\n * @property {Number} changeIndex\n * @property {CoinView} view\n */\n\n\nclass MTX extends TX {\n  /**\n   * Create a mutable transaction.\n   * @alias module:primitives.MTX\n   * @constructor\n   * @param {Object} options\n   */\n  constructor(options) {\n    super();\n    this.mutable = true;\n    this.changeIndex = -1;\n    this.view = new CoinView();\n    if (options) this.fromOptions(options);\n  }\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n\n  fromOptions(options) {\n    if (options.version != null) {\n      assert(options.version >>> 0 === options.version, 'Version must a be uint32.');\n      this.version = options.version;\n    }\n\n    if (options.inputs) {\n      assert(Array.isArray(options.inputs), 'Inputs must be an array.');\n\n      for (const input of options.inputs) this.addInput(input);\n    }\n\n    if (options.outputs) {\n      assert(Array.isArray(options.outputs), 'Outputs must be an array.');\n\n      for (const output of options.outputs) this.addOutput(output);\n    }\n\n    if (options.locktime != null) {\n      assert(options.locktime >>> 0 === options.locktime, 'Locktime must be a uint32.');\n      this.locktime = options.locktime;\n    }\n\n    if (options.changeIndex != null) {\n      if (options.changeIndex !== -1) {\n        assert(options.changeIndex >>> 0 === options.changeIndex, 'Change index must be a uint32.');\n        this.changeIndex = options.changeIndex;\n      } else {\n        this.changeIndex = -1;\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Instantiate MTX from options.\n   * @param {Object} options\n   * @returns {MTX}\n   */\n\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  } //   /**\n  //    * Clone the transaction. Note that\n  //    * this will not carry over the view.\n  //    * @returns {MTX}\n  //    */\n  //   clone() {\n  //     const mtx = new this.constructor();\n  //     mtx.inject(this);\n  //     mtx.changeIndex = this.changeIndex;\n  //     return mtx;\n  //   }\n  //   /**\n  //    * Add an input to the transaction.\n  //    * @param {Input|Object} options\n  //    * @returns {Input}\n  //    *\n  //    * @example\n  //    * mtx.addInput({ prevout: { hash: ... }, script: ... });\n  //    * mtx.addInput(new Input());\n  //    */\n  //   addInput(options) {\n  //     const input = Input.fromOptions(options);\n  //     this.inputs.push(input);\n  //     return input;\n  //   }\n  //   /**\n  //    * Add an outpoint as an input.\n  //    * @param {Outpoint|Object} outpoint\n  //    * @returns {Input}\n  //    *\n  //    * @example\n  //    * mtx.addOutpoint({ hash: ..., index: 0 });\n  //    * mtx.addOutpoint(new Outpoint(hash, index));\n  //    */\n  //   addOutpoint(outpoint) {\n  //     const prevout = Outpoint.fromOptions(outpoint);\n  //     const input = Input.fromOutpoint(prevout);\n  //     this.inputs.push(input);\n  //     return input;\n  //   }\n\n  /**\n   * Add a coin as an input. Note that this will\n   * add the coin to the internal coin viewpoint.\n   * @param {Coin} coin\n   * @returns {Input}\n   *\n   * @example\n   * mtx.addCoin(Coin.fromTX(tx, 0, -1));\n   */\n\n\n  addCoin(coin) {\n    assert(coin instanceof Coin, 'Cannot add non-coin.');\n    const input = Input.fromCoin(coin);\n    this.inputs.push(input);\n    this.view.addCoin(coin);\n    return input;\n  } //   /**\n  //    * Add a transaction as an input. Note that\n  //    * this will add the coin to the internal\n  //    * coin viewpoint.\n  //    * @param {TX} tx\n  //    * @param {Number} index\n  //    * @param {Number?} height\n  //    * @returns {Input}\n  //    *\n  //    * @example\n  //    * mtx.addTX(tx, 0);\n  //    */\n  //   addTX(tx, index, height) {\n  //     assert(tx instanceof TX, 'Cannot add non-transaction.');\n  //     if (height == null)\n  //       height = -1;\n  //     const input = Input.fromTX(tx, index);\n  //     this.inputs.push(input);\n  //     this.view.addIndex(tx, index, height);\n  //     return input;\n  //   }\n\n  /**\n   * Add an output.\n   * @param {Address|Script|Output|Object} script - Script or output options.\n   * @param {Amount?} value\n   * @returns {Output}\n   *\n   * @example\n   * mtx.addOutput(new Output());\n   * mtx.addOutput({ address: ..., value: 100000 });\n   * mtx.addOutput(address, 100000);\n   * mtx.addOutput(script, 100000);\n   */\n\n\n  addOutput(script, value) {\n    let output;\n    if (value != null) output = Output.fromScript(script, value);else output = Output.fromOptions(script);\n    this.outputs.push(output);\n    return output;\n  } //   /**\n  //    * Verify all transaction inputs.\n  //    * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n  //    * @returns {Boolean} Whether the inputs are valid.\n  //    * @throws {ScriptError} on invalid inputs\n  //    */\n  //   check(flags) {\n  //     return super.check(this.view, flags);\n  //   }\n  //   /**\n  //    * Verify the transaction inputs on the worker pool\n  //    * (if workers are enabled).\n  //    * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n  //    * @param {WorkerPool?} pool\n  //    * @returns {Promise}\n  //    */\n  //   checkAsync(flags, pool) {\n  //     return super.checkAsync(this.view, flags, pool);\n  //   }\n\n  /**\n   * Verify all transaction inputs.\n   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n   * @returns {Boolean} Whether the inputs are valid.\n   */\n\n\n  verify(flags) {\n    try {\n      this.check(flags);\n    } catch (e) {\n      if (e.type === 'ScriptError') return false;\n      throw e;\n    }\n\n    return true;\n  } //   /**\n  //    * Verify the transaction inputs on the worker pool\n  //    * (if workers are enabled).\n  //    * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n  //    * @param {WorkerPool?} pool\n  //    * @returns {Promise}\n  //    */\n  //   async verifyAsync(flags, pool) {\n  //     try {\n  //       await this.checkAsync(flags, pool);\n  //     } catch (e) {\n  //       if (e.type === 'ScriptError')\n  //         return false;\n  //       throw e;\n  //     }\n  //     return true;\n  //   }\n  //   /**\n  //    * Calculate the fee for the transaction.\n  //    * @returns {Amount} fee (zero if not all coins are available).\n  //    */\n  //   getFee() {\n  //     return super.getFee(this.view);\n  //   }\n  //   /**\n  //    * Calculate the total input value.\n  //    * @returns {Amount} value\n  //    */\n  //   getInputValue() {\n  //     return super.getInputValue(this.view);\n  //   }\n  //   /**\n  //    * Get all input addresses.\n  //    * @returns {Address[]} addresses\n  //    */\n  //   getInputAddresses() {\n  //     return super.getInputAddresses(this.view);\n  //   }\n  //   /**\n  //    * Get all addresses.\n  //    * @returns {Address[]} addresses\n  //    */\n  //   getAddresses() {\n  //     return super.getAddresses(this.view);\n  //   }\n  //   /**\n  //    * Get all input address hashes.\n  //    * @returns {Hash[]} hashes\n  //    */\n  //   getInputHashes(enc) {\n  //     return super.getInputHashes(this.view, enc);\n  //   }\n  //   /**\n  //    * Get all address hashes.\n  //    * @returns {Hash[]} hashes\n  //    */\n  //   getHashes(enc) {\n  //     return super.getHashes(this.view, enc);\n  //   }\n  //   /**\n  //    * Test whether the transaction has\n  //    * all coins available/filled.\n  //    * @returns {Boolean}\n  //    */\n  //   hasCoins() {\n  //     return super.hasCoins(this.view);\n  //   }\n  //   /**\n  //    * Calculate virtual sigop count.\n  //    * @param {VerifyFlags?} flags\n  //    * @returns {Number} sigop count\n  //    */\n  //   getSigops(flags) {\n  //     return super.getSigops(this.view, flags);\n  //   }\n  //   /**\n  //    *  Calculate sigops count.\n  //    *  @param {CoinView} view\n  //    *  @param {VerifyFlags?} flags\n  //    *  @returns {Number} sigop count\n  //    */\n  //   getSigopsCount(flags) {\n  //     return super.getSigopsCount(this.view, flags);\n  //   }\n  //   /**\n  //    * Perform contextual checks to verify input, output,\n  //    * and fee values, as well as coinbase spend maturity\n  //    * (coinbases can only be spent 100 blocks or more\n  //    * after they're created). Note that this function is\n  //    * consensus critical.\n  //    * @param {Number} height - Height at which the\n  //    * transaction is being spent. In the mempool this is\n  //    * the chain height plus one at the time it entered the pool.\n  //    * @returns {Boolean}\n  //    */\n  //   verifyInputs(height) {\n  //     const [fee] = this.checkInputs(height);\n  //     return fee !== -1;\n  //   }\n  //   /**\n  //    * Perform contextual checks to verify input, output,\n  //    * and fee values, as well as coinbase spend maturity\n  //    * (coinbases can only be spent 100 blocks or more\n  //    * after they're created). Note that this function is\n  //    * consensus critical.\n  //    * @param {Number} height - Height at which the\n  //    * transaction is being spent. In the mempool this is\n  //    * the chain height plus one at the time it entered the pool.\n  //    * @returns {Array} [fee, reason, score]\n  //    */\n  //   checkInputs(height) {\n  //     return super.checkInputs(this.view, height);\n  //   }\n\n  /**\n   * Build input script (or witness) templates (with\n   * OP_0 in place of signatures).\n   * @param {Number} index - Input index.\n   * @param {Coin|Output} coin\n   * @param {KeyRing} ring\n   * @returns {Boolean} Whether the script was able to be built.\n   */\n\n\n  scriptInput(index, coin, ring) {\n    const input = this.inputs[index];\n    assert(input, 'Input does not exist.');\n    assert(coin, 'No coin passed.'); // Don't bother with any below calculation\n    // if the output is already templated.\n\n    if (input.script.raw.length !== 0) return true; // Get the previous output's script\n\n    const prev = coin.script; // This is easily the hardest part about\n    // building a transaction with segwit:\n    // figuring out where the redeem script\n    // and witness redeem scripts go.\n\n    const sh = prev.getScripthash();\n\n    if (sh) {\n      const redeem = ring.getRedeem(sh);\n      if (!redeem) return false; // Regular P2SH.\n\n      const vector = this.scriptVector(redeem, ring);\n      if (!vector) return false;\n      vector.push(redeem.toRaw());\n      input.script.fromStack(vector);\n      return true;\n    }\n\n    const vector = this.scriptVector(prev, ring);\n    if (!vector) return false;\n    input.script.fromStack(vector);\n    return true;\n  }\n  /**\n   * Build script for a single vector\n   * based on a previous script.\n   * @param {Script} prev\n   * @param {Buffer} ring\n   * @return {Stack}\n   */\n\n\n  scriptVector(prev, ring) {\n    // P2PK\n    const pk = prev.getPubkey();\n\n    if (pk) {\n      if (!pk.equals(ring.publicKey)) return null;\n      const stack = new Stack();\n      stack.pushInt(0);\n      return stack;\n    } // P2PKH\n\n\n    const pkh = prev.getPubkeyhash();\n\n    if (pkh) {\n      if (!pkh.equals(ring.getKeyHash())) return null;\n      const stack = new Stack();\n      stack.pushInt(0);\n      stack.pushData(ring.publicKey);\n      return stack;\n    } // Multisig\n\n\n    const [, n] = prev.getMultisig();\n\n    if (n !== -1) {\n      if (prev.indexOf(ring.publicKey) === -1) return null; // Technically we should create m signature slots,\n      // but we create n signature slots so we can order\n      // the signatures properly.\n\n      const stack = new Stack();\n      stack.pushInt(0); // Fill script with `n` signature slots.\n\n      for (let i = 0; i < n; i++) stack.pushInt(0);\n\n      return stack;\n    }\n\n    return null;\n  } //   /**\n  //    * Sign a transaction input on the worker pool\n  //    * (if workers are enabled).\n  //    * @param {Number} index\n  //    * @param {Coin|Output} coin\n  //    * @param {KeyRing} ring\n  //    * @param {SighashType?} type\n  //    * @param {WorkerPool?} pool\n  //    * @returns {Promise}\n  //    */\n  //   async signInputAsync(index, coin, ring, type, pool) {\n  //     if (!pool)\n  //       return this.signInput(index, coin, ring, type);\n  //     return await pool.signInput(this, index, coin, ring, type, pool);\n  //   }\n  //   /**\n  //    * Sign an input.\n  //    * @param {Number} index - Index of input being signed.\n  //    * @param {Coin|Output} coin\n  //    * @param {KeyRing} ring - Private key.\n  //    * @param {SighashType} type\n  //    * @returns {Boolean} Whether the input was able to be signed.\n  //    */\n  //   signInput(index, coin, ring, type) {\n  //     const input = this.inputs[index];\n  //     const key = ring.privateKey;\n  //     assert(input, 'Input does not exist.');\n  //     assert(coin, 'No coin passed.');\n  //     // Get the previous output's script\n  //     const value = coin.value;\n  //     let prev = coin.script;\n  //     const vector = input.script;\n  //     let redeem = false;\n  //     if (type == null)\n  //       type = Script.hashType.ALL;\n  //     type |= Script.hashType.SIGHASH_FORKID;\n  //     const flags = Script.flags.VERIFY_SIGHASH_FORKID;\n  //     // Grab regular p2sh redeem script.\n  //     if (prev.isScripthash()) {\n  //       prev = input.script.getRedeem();\n  //       if (!prev)\n  //         throw new Error('Input has not been templated.');\n  //       redeem = true;\n  //     }\n  //     // Create our signature.\n  //     const sig = this.signature(index, prev, value, key, type, flags);\n  //     if (redeem) {\n  //       const stack = vector.toStack();\n  //       const redeem = stack.pop();\n  //       const result = this.signVector(prev, stack, sig, ring);\n  //       if (!result)\n  //         return false;\n  //       result.push(redeem);\n  //       vector.fromStack(result);\n  //       return true;\n  //     }\n  //     const stack = vector.toStack();\n  //     const result = this.signVector(prev, stack, sig, ring);\n  //     if (!result)\n  //       return false;\n  //     vector.fromStack(result);\n  //     return true;\n  //   }\n  //   /**\n  //    * Add a signature to a vector\n  //    * based on a previous script.\n  //    * @param {Script} prev\n  //    * @param {Stack} vector\n  //    * @param {Buffer} sig\n  //    * @param {KeyRing} ring\n  //    * @return {Boolean}\n  //    */\n  //   signVector(prev, vector, sig, ring) {\n  //     // P2PK\n  //     const pk = prev.getPubkey();\n  //     if (pk) {\n  //       // Make sure the pubkey is ours.\n  //       if (!ring.publicKey.equals(pk))\n  //         return null;\n  //       if (vector.length === 0)\n  //         throw new Error('Input has not been templated.');\n  //       // Already signed.\n  //       if (vector.get(0).length > 0)\n  //         return vector;\n  //       vector.set(0, sig);\n  //       return vector;\n  //     }\n  //     // P2PKH\n  //     const pkh = prev.getPubkeyhash();\n  //     if (pkh) {\n  //       // Make sure the pubkey hash is ours.\n  //       if (!ring.getKeyHash().equals(pkh))\n  //         return null;\n  //       if (vector.length !== 2)\n  //         throw new Error('Input has not been templated.');\n  //       if (vector.get(1).length === 0)\n  //         throw new Error('Input has not been templated.');\n  //       // Already signed.\n  //       if (vector.get(0).length > 0)\n  //         return vector;\n  //       vector.set(0, sig);\n  //       return vector;\n  //     }\n  //     // Multisig\n  //     const [m, n] = prev.getMultisig();\n  //     if (m !== -1) {\n  //       if (vector.length < 2)\n  //         throw new Error('Input has not been templated.');\n  //       if (vector.get(0).length !== 0)\n  //         throw new Error('Input has not been templated.');\n  //       // Too many signature slots. Abort.\n  //       if (vector.length - 1 > n)\n  //         throw new Error('Input has not been templated.');\n  //       // Count the number of current signatures.\n  //       let total = 0;\n  //       for (let i = 1; i < vector.length; i++) {\n  //         const item = vector.get(i);\n  //         if (item.length > 0)\n  //           total += 1;\n  //       }\n  //       // Signatures are already finalized.\n  //       if (total === m && vector.length - 1 === m)\n  //         return vector;\n  //       // Add some signature slots for us to use if\n  //       // there was for some reason not enough.\n  //       while (vector.length - 1 < n)\n  //         vector.pushInt(0);\n  //       // Grab the redeem script's keys to figure\n  //       // out where our key should go.\n  //       const keys = [];\n  //       for (const op of prev.code) {\n  //         if (op.data)\n  //           keys.push(op.data);\n  //       }\n  //       // Find the key index so we can place\n  //       // the signature in the same index.\n  //       let keyIndex = -1;\n  //       for (let i = 0; i < keys.length; i++) {\n  //         const key = keys[i];\n  //         if (key.equals(ring.publicKey)) {\n  //           keyIndex = i;\n  //           break;\n  //         }\n  //       }\n  //       // Our public key is not in the prev_out\n  //       // script. We tried to sign a transaction\n  //       // that is not redeemable by us.\n  //       if (keyIndex === -1)\n  //         return null;\n  //       // Offset key index by one to turn it into\n  //       // \"sig index\". Accounts for OP_0 byte at\n  //       // the start.\n  //       keyIndex += 1;\n  //       // Add our signature to the correct slot\n  //       // and increment the total number of\n  //       // signatures.\n  //       if (keyIndex < vector.length && total < m) {\n  //         if (vector.get(keyIndex).length === 0) {\n  //           vector.set(keyIndex, sig);\n  //           total += 1;\n  //         }\n  //       }\n  //       // All signatures added. Finalize.\n  //       if (total >= m) {\n  //         // Remove empty slots left over.\n  //         for (let i = vector.length - 1; i >= 1; i--) {\n  //           const item = vector.get(i);\n  //           if (item.length === 0)\n  //             vector.remove(i);\n  //         }\n  //         // Remove signatures which are not required.\n  //         // This should never happen.\n  //         while (total > m) {\n  //           vector.pop();\n  //           total -= 1;\n  //         }\n  //         // Sanity checks.\n  //         assert(total === m);\n  //         assert(vector.length - 1 === m);\n  //       }\n  //       return vector;\n  //     }\n  //     return null;\n  //   }\n  //   /**\n  //    * Test whether the transaction is fully-signed.\n  //    * @returns {Boolean}\n  //    */\n  //   isSigned() {\n  //     for (let i = 0; i < this.inputs.length; i++) {\n  //       const {prevout} = this.inputs[i];\n  //       const coin = this.view.getOutput(prevout);\n  //       if (!coin)\n  //         return false;\n  //       if (!this.isInputSigned(i, coin))\n  //         return false;\n  //     }\n  //     return true;\n  //   }\n  //   /**\n  //    * Test whether an input is fully-signed.\n  //    * @param {Number} index\n  //    * @param {Coin|Output} coin\n  //    * @returns {Boolean}\n  //    */\n  //   isInputSigned(index, coin) {\n  //     const input = this.inputs[index];\n  //     assert(input, 'Input does not exist.');\n  //     assert(coin, 'No coin passed.');\n  //     const vector = input.script;\n  //     let prev = coin.script;\n  //     let redeem = false;\n  //     // Grab redeem script if possible.\n  //     if (prev.isScripthash()) {\n  //       prev = input.script.getRedeem();\n  //       if (!prev)\n  //         return false;\n  //       redeem = true;\n  //     }\n  //     const stack = vector.toStack();\n  //     if (redeem)\n  //       stack.pop();\n  //     return this.isVectorSigned(prev, stack);\n  //   }\n  //   /**\n  //    * Test whether a vector is fully-signed.\n  //    * @param {Script} prev\n  //    * @param {Stack} vector\n  //    * @returns {Boolean}\n  //    */\n  //   isVectorSigned(prev, vector) {\n  //     if (prev.isPubkey()) {\n  //       if (vector.length !== 1)\n  //         return false;\n  //       if (vector.get(0).length === 0)\n  //         return false;\n  //       return true;\n  //     }\n  //     if (prev.isPubkeyhash()) {\n  //       if (vector.length !== 2)\n  //         return false;\n  //       if (vector.get(0).length === 0)\n  //         return false;\n  //       if (vector.get(1).length === 0)\n  //         return false;\n  //       return true;\n  //     }\n  //     const [m] = prev.getMultisig();\n  //     if (m !== -1) {\n  //       // Ensure we have the correct number\n  //       // of required signatures.\n  //       if (vector.length - 1 !== m)\n  //         return false;\n  //       // Ensure all members are signatures.\n  //       for (let i = 1; i < vector.length; i++) {\n  //         const item = vector.get(i);\n  //         if (item.length === 0)\n  //           return false;\n  //       }\n  //       return true;\n  //     }\n  //     return false;\n  //   }\n  //   /**\n  //    * Build input scripts (or witnesses).\n  //    * @param {KeyRing} ring - Address used to sign. The address\n  //    * must be able to redeem the coin.\n  //    * @returns {Number} Number of inputs templated.\n  //    */\n  //   template(ring) {\n  //     if (Array.isArray(ring)) {\n  //       let total = 0;\n  //       for (const key of ring)\n  //         total += this.template(key);\n  //       return total;\n  //     }\n  //     let total = 0;\n  //     for (let i = 0; i < this.inputs.length; i++) {\n  //       const {prevout} = this.inputs[i];\n  //       const coin = this.view.getOutput(prevout);\n  //       if (!coin)\n  //         continue;\n  //       if (!ring.ownOutput(coin))\n  //         continue;\n  //       // Build script for input\n  //       if (!this.scriptInput(i, coin, ring))\n  //         continue;\n  //       total += 1;\n  //     }\n  //     return total;\n  //   }\n  //   /**\n  //    * Built input scripts (or witnesses) and sign the inputs.\n  //    * @param {KeyRing} ring - Address used to sign. The address\n  //    * must be able to redeem the coin.\n  //    * @param {SighashType} type\n  //    * @returns {Number} Number of inputs signed.\n  //    */\n  //   sign(ring, type) {\n  //     if (Array.isArray(ring)) {\n  //       let total = 0;\n  //       for (const key of ring)\n  //         total += this.sign(key, type);\n  //       return total;\n  //     }\n  //     assert(ring.privateKey, 'No private key available.');\n  //     let total = 0;\n  //     for (let i = 0; i < this.inputs.length; i++) {\n  //       const {prevout} = this.inputs[i];\n  //       const coin = this.view.getOutput(prevout);\n  //       if (!coin)\n  //         continue;\n  //       if (!ring.ownOutput(coin))\n  //         continue;\n  //       // Build script for input\n  //       if (!this.scriptInput(i, coin, ring))\n  //         continue;\n  //       // Sign input\n  //       if (!this.signInput(i, coin, ring, type))\n  //         continue;\n  //       total += 1;\n  //     }\n  //     return total;\n  //   }\n  //   /**\n  //    * Sign the transaction inputs on the worker pool\n  //    * (if workers are enabled).\n  //    * @param {KeyRing} ring\n  //    * @param {SighashType?} type\n  //    * @param {WorkerPool?} pool\n  //    * @returns {Promise}\n  //    */\n  //   async signAsync(ring, type, pool) {\n  //     if (!pool)\n  //       return this.sign(ring, type);\n  //     return await pool.sign(this, ring, type);\n  //   }\n  //   /**\n  //    * Estimate maximum possible size.\n  //    * @param {Function?} estimate - Input script size estimator.\n  //    * @returns {Number}\n  //    */\n  //   async estimateSize(estimate) {\n  //     let total = 0;\n  //     // Calculate the size, minus the input scripts.\n  //     total += 4;\n  //     total += encoding.sizeVarint(this.inputs.length);\n  //     total += this.inputs.length * 40;\n  //     total += encoding.sizeVarint(this.outputs.length);\n  //     for (const output of this.outputs)\n  //       total += output.getSize();\n  //     total += 4;\n  //     // Add size for signatures and public keys\n  //     for (const {prevout} of this.inputs) {\n  //       const coin = this.view.getOutput(prevout);\n  //       // We're out of luck here.\n  //       // Just assume it's a p2pkh.\n  //       if (!coin) {\n  //         total += 110;\n  //         continue;\n  //       }\n  //       // Previous output script.\n  //       const prev = coin.script;\n  //       // P2PK\n  //       if (prev.isPubkey()) {\n  //         // varint script size\n  //         total += 1;\n  //         // OP_PUSHDATA0 [signature]\n  //         total += 1 + 73;\n  //         continue;\n  //       }\n  //       // P2PKH\n  //       if (prev.isPubkeyhash()) {\n  //         // varint script size\n  //         total += 1;\n  //         // OP_PUSHDATA0 [signature]\n  //         total += 1 + 73;\n  //         // OP_PUSHDATA0 [key]\n  //         total += 1 + 33;\n  //         continue;\n  //       }\n  //       const [m] = prev.getMultisig();\n  //       if (m !== -1) {\n  //         let size = 0;\n  //         // Bare Multisig\n  //         // OP_0\n  //         size += 1;\n  //         // OP_PUSHDATA0 [signature] ...\n  //         size += (1 + 73) * m;\n  //         // varint len\n  //         size += encoding.sizeVarint(size);\n  //         total += size;\n  //         continue;\n  //       }\n  //       // Call out to the custom estimator.\n  //       if (estimate) {\n  //         const size = await estimate(prev);\n  //         if (size !== -1) {\n  //           total += size;\n  //           continue;\n  //         }\n  //       }\n  //       // P2SH\n  //       if (prev.isScripthash()) {\n  //         // varint size\n  //         total += 1;\n  //         // 2-of-3 multisig input\n  //         total += 149;\n  //         continue;\n  //       }\n  //       // Unknown.\n  //       total += 110;\n  //     }\n  //     return total;\n  //   }\n  //   /**\n  //    * Select necessary coins based on total output value.\n  //    * @param {Coin[]} coins\n  //    * @param {Object?} options\n  //    * @returns {CoinSelection}\n  //    * @throws on not enough funds available.\n  //    */\n  //   selectCoins(coins, options) {\n  //     const selector = new CoinSelector(this, options);\n  //     return selector.select(coins);\n  //   }\n  //   /**\n  //    * Attempt to subtract a fee from a single output.\n  //    * @param {Number} index\n  //    * @param {Amount} fee\n  //    */\n  //   subtractIndex(index, fee) {\n  //     assert(typeof index === 'number');\n  //     assert(typeof fee === 'number');\n  //     const output = this.outputs[index];\n  //     if (!output)\n  //       throw new Error('Subtraction index does not exist.');\n  //     if (output.value < fee + output.getDustThreshold())\n  //       throw new Error('Could not subtract fee.');\n  //     output.value -= fee;\n  //   }\n  //   /**\n  //    * Attempt to subtract a fee from all outputs evenly.\n  //    * @param {Amount} fee\n  //    */\n  //   subtractFee(fee) {\n  //     assert(typeof fee === 'number');\n  //     let outputs = 0;\n  //     for (const output of this.outputs) {\n  //       // Ignore nulldatas and\n  //       // other OP_RETURN scripts.\n  //       if (output.script.isUnspendable())\n  //         continue;\n  //       outputs += 1;\n  //     }\n  //     if (outputs === 0)\n  //       throw new Error('Could not subtract fee.');\n  //     const left = fee % outputs;\n  //     const share = (fee - left) / outputs;\n  //     // First pass, remove even shares.\n  //     for (const output of this.outputs) {\n  //       if (output.script.isUnspendable())\n  //         continue;\n  //       if (output.value < share + output.getDustThreshold())\n  //         throw new Error('Could not subtract fee.');\n  //       output.value -= share;\n  //     }\n  //     // Second pass, remove the remainder\n  //     // for the one unlucky output.\n  //     for (const output of this.outputs) {\n  //       if (output.script.isUnspendable())\n  //         continue;\n  //       if (output.value >= left + output.getDustThreshold()) {\n  //         output.value -= left;\n  //         return;\n  //       }\n  //     }\n  //     throw new Error('Could not subtract fee.');\n  //   }\n  //   /**\n  //    * Select coins and fill the inputs.\n  //    * @param {Coin[]} coins\n  //    * @param {Object} options - See {@link MTX#selectCoins} options.\n  //    * @returns {CoinSelector}\n  //    */\n  //   async fund(coins, options) {\n  //     assert(options, 'Options are required.');\n  //     assert(options.changeAddress, 'Change address is required.');\n  //     assert(this.inputs.length === 0, 'TX is already funded.');\n  //     // Select necessary coins.\n  //     const select = await this.selectCoins(coins, options);\n  //     // Add coins to transaction.\n  //     for (const coin of select.chosen)\n  //       this.addCoin(coin);\n  //     // Attempt to subtract fee.\n  //     if (select.subtractFee) {\n  //       const index = select.subtractIndex;\n  //       if (index !== -1)\n  //         this.subtractIndex(index, select.fee);\n  //       else\n  //         this.subtractFee(select.fee);\n  //     }\n  //     // Add a change output.\n  //     const output = new Output();\n  //     output.value = select.change;\n  //     output.script.fromAddress(select.changeAddress);\n  //     if (output.isDust(policy.MIN_RELAY)) {\n  //       // Do nothing. Change is added to fee.\n  //       this.changeIndex = -1;\n  //       assert.strictEqual(this.getFee(), select.fee + select.change);\n  //     } else {\n  //       this.outputs.push(output);\n  //       this.changeIndex = this.outputs.length - 1;\n  //       assert.strictEqual(this.getFee(), select.fee);\n  //     }\n  //     return select;\n  //   }\n  //   /**\n  //    * Sort inputs and outputs according to BIP69.\n  //    * @see https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki\n  //    */\n  //   sortMembers() {\n  //     let changeOutput = null;\n  //     if (this.changeIndex !== -1) {\n  //       changeOutput = this.outputs[this.changeIndex];\n  //       assert(changeOutput);\n  //     }\n  //     this.inputs.sort(sortInputs);\n  //     this.outputs.sort(sortOutputs);\n  //     if (this.changeIndex !== -1) {\n  //       this.changeIndex = this.outputs.indexOf(changeOutput);\n  //       assert(this.changeIndex !== -1);\n  //     }\n  //   }\n  //   /**\n  //    * Avoid fee sniping.\n  //    * @param {Number} - Current chain height.\n  //    * @see bitcoin/src/wallet/wallet.cpp\n  //    */\n  //   avoidFeeSniping(height) {\n  //     assert(typeof height === 'number', 'Must pass in height.');\n  //     if ((Math.random() * 10 | 0) === 0) {\n  //       height -= Math.random() * 100 | 0;\n  //       if (height < 0)\n  //         height = 0;\n  //     }\n  //     this.setLocktime(height);\n  //   }\n  //   /**\n  //    * Set locktime and sequences appropriately.\n  //    * @param {Number} locktime\n  //    */\n  //   setLocktime(locktime) {\n  //     assert((locktime >>> 0) === locktime, 'Locktime must be a uint32.');\n  //     assert(this.inputs.length > 0, 'Cannot set sequence with no inputs.');\n  //     for (const input of this.inputs) {\n  //       if (input.sequence === 0xffffffff)\n  //         input.sequence = 0xfffffffe;\n  //     }\n  //     this.locktime = locktime;\n  //   }\n  //   /**\n  //    * Set sequence locktime.\n  //    * @param {Number} index - Input index.\n  //    * @param {Number} locktime\n  //    * @param {Boolean?} seconds\n  //    */\n  //   setSequence(index, locktime, seconds) {\n  //     const input = this.inputs[index];\n  //     assert(input, 'Input does not exist.');\n  //     assert((locktime >>> 0) === locktime, 'Locktime must be a uint32.');\n  //     this.version = 2;\n  //     if (seconds) {\n  //       locktime >>>= consensus.SEQUENCE_GRANULARITY;\n  //       locktime &= consensus.SEQUENCE_MASK;\n  //       locktime |= consensus.SEQUENCE_TYPE_FLAG;\n  //     } else {\n  //       locktime &= consensus.SEQUENCE_MASK;\n  //     }\n  //     input.sequence = locktime;\n  //   }\n  //   /**\n  //    * Inspect the transaction.\n  //    * @returns {Object}\n  //    */\n  //   [inspectSymbol]() {\n  //     return this.format();\n  //   }\n  //   /**\n  //    * Inspect the transaction.\n  //    * @returns {Object}\n  //    */\n  //   format() {\n  //     return super.format(this.view);\n  //   }\n  //   /**\n  //    * Convert transaction to JSON.\n  //    * @returns {Object}\n  //    */\n  //   toJSON() {\n  //     return super.toJSON(null, this.view);\n  //   }\n  //   /**\n  //    * Convert transaction to JSON.\n  //    * @param {Network} network\n  //    * @returns {Object}\n  //    */\n  //   getJSON(network) {\n  //     return super.getJSON(network, this.view);\n  //   }\n  //   /**\n  //    * Inject properties from a json object\n  //    * @param {Object} json\n  //    */\n  //   fromJSON(json) {\n  //     super.fromJSON(json);\n  //     for (let i = 0; i < json.inputs.length; i++) {\n  //       const input = json.inputs[i];\n  //       const {prevout} = input;\n  //       if (!input.coin)\n  //         continue;\n  //       const coin = Coin.fromJSON(input.coin);\n  //       coin.hash = util.fromRev(prevout.hash);\n  //       coin.index = prevout.index;\n  //       this.view.addCoin(coin);\n  //     }\n  //     return this;\n  //   }\n  //   /**\n  //    * Instantiate a transaction from a\n  //    * jsonified transaction object.\n  //    * @param {Object} json - The jsonified transaction object.\n  //    * @returns {MTX}\n  //    */\n  //   static fromJSON(json) {\n  //     return new this().fromJSON(json);\n  //   }\n  //   /**\n  //    * Instantiate a transaction from a buffer reader.\n  //    * @param {BufferReader} br\n  //    * @returns {MTX}\n  //    */\n  //   static fromReader(br) {\n  //     return new this().fromReader(br);\n  //   }\n  //   /**\n  //    * Instantiate a transaction from a serialized Buffer.\n  //    * @param {Buffer} data\n  //    * @param {String?} enc - Encoding, can be `'hex'` or null.\n  //    * @returns {MTX}\n  //    */\n  //   static fromRaw(data, enc) {\n  //     if (typeof data === 'string')\n  //       data = Buffer.from(data, enc);\n  //     return new this().fromRaw(data);\n  //   }\n  //   /**\n  //    * Convert the MTX to a TX.\n  //    * @returns {TX}\n  //    */\n  //   toTX() {\n  //     return new TX().inject(this);\n  //   }\n  //   /**\n  //    * Convert the MTX to a TX.\n  //    * @returns {Array} [tx, view]\n  //    */\n  //   commit() {\n  //     return [this.toTX(), this.view];\n  //   }\n  //   /**\n  //    * Instantiate MTX from TX.\n  //    * @param {TX} tx\n  //    * @returns {MTX}\n  //    */\n  //   static fromTX(tx) {\n  //     return new this().inject(tx);\n  //   }\n  //   /**\n  //    * Test whether an object is an MTX.\n  //    * @param {Object} obj\n  //    * @returns {Boolean}\n  //    */\n  //   static isMTX(obj) {\n  //     return obj instanceof MTX;\n  //   }\n\n\n} // /**\n//  * Coin Selector\n//  * @alias module:primitives.CoinSelector\n//  */\n// class CoinSelector {\n//   /**\n//    * Create a coin selector.\n//    * @constructor\n//    * @param {TX} tx\n//    * @param {Object?} options\n//    */\n//   constructor(tx, options) {\n//     this.tx = tx.clone();\n//     this.coins = [];\n//     this.outputValue = 0;\n//     this.index = 0;\n//     this.chosen = [];\n//     this.change = 0;\n//     this.fee = CoinSelector.MIN_FEE;\n//     this.selection = 'value';\n//     this.subtractFee = false;\n//     this.subtractIndex = -1;\n//     this.height = -1;\n//     this.depth = -1;\n//     this.hardFee = -1;\n//     this.rate = CoinSelector.FEE_RATE;\n//     this.maxFee = -1;\n//     this.round = false;\n//     this.changeAddress = null;\n//     this.inputs = new BufferMap();\n//     // Needed for size estimation.\n//     this.estimate = null;\n//     this.injectInputs();\n//     if (options)\n//       this.fromOptions(options);\n//   }\n//   /**\n//    * Initialize selector options.\n//    * @param {Object} options\n//    * @private\n//    */\n//   fromOptions(options) {\n//     if (options.selection) {\n//       assert(typeof options.selection === 'string');\n//       this.selection = options.selection;\n//     }\n//     if (options.subtractFee != null) {\n//       if (typeof options.subtractFee === 'number') {\n//         assert(Number.isSafeInteger(options.subtractFee));\n//         assert(options.subtractFee >= -1);\n//         this.subtractIndex = options.subtractFee;\n//         this.subtractFee = this.subtractIndex !== -1;\n//       } else {\n//         assert(typeof options.subtractFee === 'boolean');\n//         this.subtractFee = options.subtractFee;\n//       }\n//     }\n//     if (options.subtractIndex != null) {\n//       assert(Number.isSafeInteger(options.subtractIndex));\n//       assert(options.subtractIndex >= -1);\n//       this.subtractIndex = options.subtractIndex;\n//       this.subtractFee = this.subtractIndex !== -1;\n//     }\n//     if (options.height != null) {\n//       assert(Number.isSafeInteger(options.height));\n//       assert(options.height >= -1);\n//       this.height = options.height;\n//     }\n//     if (options.confirmations != null) {\n//       assert(Number.isSafeInteger(options.confirmations));\n//       assert(options.confirmations >= -1);\n//       this.depth = options.confirmations;\n//     }\n//     if (options.depth != null) {\n//       assert(Number.isSafeInteger(options.depth));\n//       assert(options.depth >= -1);\n//       this.depth = options.depth;\n//     }\n//     if (options.hardFee != null) {\n//       assert(Number.isSafeInteger(options.hardFee));\n//       assert(options.hardFee >= -1);\n//       this.hardFee = options.hardFee;\n//     }\n//     if (options.rate != null) {\n//       assert(Number.isSafeInteger(options.rate));\n//       assert(options.rate >= 0);\n//       this.rate = options.rate;\n//     }\n//     if (options.maxFee != null) {\n//       assert(Number.isSafeInteger(options.maxFee));\n//       assert(options.maxFee >= -1);\n//       this.maxFee = options.maxFee;\n//     }\n//     if (options.round != null) {\n//       assert(typeof options.round === 'boolean');\n//       this.round = options.round;\n//     }\n//     if (options.changeAddress) {\n//       const addr = options.changeAddress;\n//       if (typeof addr === 'string') {\n//         this.changeAddress = Address.fromString(addr);\n//       } else {\n//         assert(addr instanceof Address);\n//         this.changeAddress = addr;\n//       }\n//     }\n//     if (options.estimate) {\n//       assert(typeof options.estimate === 'function');\n//       this.estimate = options.estimate;\n//     }\n//     if (options.inputs) {\n//       assert(Array.isArray(options.inputs));\n//       for (let i = 0; i < options.inputs.length; i++) {\n//         const prevout = options.inputs[i];\n//         assert(prevout && typeof prevout === 'object');\n//         const {hash, index} = prevout;\n//         assert(Buffer.isBuffer(hash));\n//         assert(typeof index === 'number');\n//         this.inputs.set(Outpoint.toKey(hash, index), i);\n//       }\n//     }\n//     return this;\n//   }\n//   /**\n//    * Attempt to inject existing inputs.\n//    * @private\n//    */\n//   injectInputs() {\n//     if (this.tx.inputs.length > 0) {\n//       for (let i = 0; i < this.tx.inputs.length; i++) {\n//         const {prevout} = this.tx.inputs[i];\n//         this.inputs.set(prevout.toKey(), i);\n//       }\n//     }\n//   }\n//   /**\n//    * Initialize the selector with coins to select from.\n//    * @param {Coin[]} coins\n//    */\n//   init(coins) {\n//     this.coins = coins.slice();\n//     this.outputValue = this.tx.getOutputValue();\n//     this.index = 0;\n//     this.chosen = [];\n//     this.change = 0;\n//     this.fee = CoinSelector.MIN_FEE;\n//     this.tx.inputs.length = 0;\n//     switch (this.selection) {\n//       case 'all':\n//       case 'random':\n//         this.coins.sort(sortRandom);\n//         break;\n//       case 'age':\n//         this.coins.sort(sortAge);\n//         break;\n//       case 'value':\n//         this.coins.sort(sortValue);\n//         break;\n//       default:\n//         throw new FundingError(`Bad selection type: ${this.selection}.`);\n//     }\n//   }\n//   /**\n//    * Calculate total value required.\n//    * @returns {Amount}\n//    */\n//   total() {\n//     if (this.subtractFee)\n//       return this.outputValue;\n//     return this.outputValue + this.fee;\n//   }\n//   /**\n//    * Test whether the selector has\n//    * completely funded the transaction.\n//    * @returns {Boolean}\n//    */\n//   isFull() {\n//     return this.tx.getInputValue() >= this.total();\n//   }\n//   /**\n//    * Test whether a coin is spendable\n//    * with regards to the options.\n//    * @param {Coin} coin\n//    * @returns {Boolean}\n//    */\n//   isSpendable(coin) {\n//     if (this.tx.view.hasEntry(coin))\n//       return false;\n//     if (this.height === -1)\n//       return true;\n//     if (coin.coinbase) {\n//       if (coin.height === -1)\n//         return false;\n//       if (this.height + 1 < coin.height + consensus.COINBASE_MATURITY)\n//         return false;\n//       return true;\n//     }\n//     if (this.depth === -1)\n//       return true;\n//     const depth = coin.getDepth(this.height);\n//     if (depth < this.depth)\n//       return false;\n//     return true;\n//   }\n//   /**\n//    * Get the current fee based on a size.\n//    * @param {Number} size\n//    * @returns {Amount}\n//    */\n//   getFee(size) {\n//     // This is mostly here for testing.\n//     // i.e. A fee rounded to the nearest\n//     // kb is easier to predict ahead of time.\n//     if (this.round) {\n//       const fee = policy.getRoundFee(size, this.rate);\n//       return Math.min(fee, CoinSelector.MAX_FEE);\n//     }\n//     const fee = policy.getMinFee(size, this.rate);\n//     return Math.min(fee, CoinSelector.MAX_FEE);\n//   }\n//   /**\n//    * Fund the transaction with more\n//    * coins if the `output value + fee`\n//    * total was updated.\n//    */\n//   fund() {\n//     // Ensure all preferred inputs first.\n//     if (this.inputs.size > 0) {\n//       const coins = [];\n//       for (let i = 0; i < this.inputs.size; i++)\n//         coins.push(null);\n//       for (const coin of this.coins) {\n//         const {hash, index} = coin;\n//         const key = Outpoint.toKey(hash, index);\n//         const i = this.inputs.get(key);\n//         if (i != null) {\n//           coins[i] = coin;\n//           this.inputs.delete(key);\n//         }\n//       }\n//       if (this.inputs.size > 0)\n//         throw new Error('Could not resolve preferred inputs.');\n//       for (const coin of coins) {\n//         this.tx.addCoin(coin);\n//         this.chosen.push(coin);\n//       }\n//     }\n//     while (this.index < this.coins.length) {\n//       const coin = this.coins[this.index++];\n//       if (!this.isSpendable(coin))\n//         continue;\n//       this.tx.addCoin(coin);\n//       this.chosen.push(coin);\n//       if (this.selection === 'all')\n//         continue;\n//       if (this.isFull())\n//         break;\n//     }\n//   }\n//   /**\n//    * Initiate selection from `coins`.\n//    * @param {Coin[]} coins\n//    * @returns {CoinSelector}\n//    */\n//   async select(coins) {\n//     this.init(coins);\n//     if (this.hardFee !== -1) {\n//       this.selectHard();\n//     } else {\n//       // This is potentially asynchronous:\n//       // it may invoke the size estimator\n//       // required for redeem scripts (we\n//       // may be calling out to a wallet\n//       // or something similar).\n//       await this.selectEstimate();\n//     }\n//     if (!this.isFull()) {\n//       // Still failing to get enough funds.\n//       throw new FundingError(\n//         'Not enough funds.',\n//         this.tx.getInputValue(),\n//         this.total());\n//     }\n//     // How much money is left after filling outputs.\n//     this.change = this.tx.getInputValue() - this.total();\n//     return this;\n//   }\n//   /**\n//    * Initialize selection based on size estimate.\n//    */\n//   async selectEstimate() {\n//     // Set minimum fee and do\n//     // an initial round of funding.\n//     this.fee = CoinSelector.MIN_FEE;\n//     this.fund();\n//     // Add dummy output for change.\n//     const change = new Output();\n//     if (this.changeAddress) {\n//       change.script.fromAddress(this.changeAddress);\n//     } else {\n//       // In case we don't have a change address,\n//       // we use a fake p2pkh output to gauge size.\n//       change.script.fromPubkeyhash(Buffer.allocUnsafe(20));\n//     }\n//     this.tx.outputs.push(change);\n//     // Keep recalculating the fee and funding\n//     // until we reach some sort of equilibrium.\n//     do {\n//       const size = await this.tx.estimateSize(this.estimate);\n//       this.fee = this.getFee(size);\n//       if (this.maxFee > 0 && this.fee > this.maxFee)\n//         throw new FundingError('Fee is too high.');\n//       // Failed to get enough funds, add more coins.\n//       if (!this.isFull())\n//         this.fund();\n//     } while (!this.isFull() && this.index < this.coins.length);\n//   }\n//   /**\n//    * Initiate selection based on a hard fee.\n//    */\n//   selectHard() {\n//     this.fee = Math.min(this.hardFee, CoinSelector.MAX_FEE);\n//     this.fund();\n//   }\n// }\n// /**\n//  * Default fee rate\n//  * for coin selection.\n//  * @const {Amount}\n//  * @default\n//  */\n// CoinSelector.FEE_RATE = 10000;\n// /**\n//  * Minimum fee to start with\n//  * during coin selection.\n//  * @const {Amount}\n//  * @default\n//  */\n// CoinSelector.MIN_FEE = 10000;\n// /**\n//  * Maximum fee to allow\n//  * after coin selection.\n//  * @const {Amount}\n//  * @default\n//  */\n// CoinSelector.MAX_FEE = consensus.COIN / 10;\n// /**\n//  * Funding Error\n//  * An error thrown from the coin selector.\n//  * @ignore\n//  * @extends Error\n//  * @property {String} message - Error message.\n//  * @property {Amount} availableFunds\n//  * @property {Amount} requiredFunds\n//  */\n// class FundingError extends Error {\n//   /**\n//    * Create a funding error.\n//    * @constructor\n//    * @param {String} msg\n//    * @param {Amount} available\n//    * @param {Amount} required\n//    */\n//   constructor(msg, available, required) {\n//     super();\n//     this.type = 'FundingError';\n//     this.message = msg;\n//     this.availableFunds = -1;\n//     this.requiredFunds = -1;\n//     if (available != null) {\n//       this.message += ` (available=${Amount.btc(available)},`;\n//       this.message += ` required=${Amount.btc(required)})`;\n//       this.availableFunds = available;\n//       this.requiredFunds = required;\n//     }\n//     if (Error.captureStackTrace)\n//       Error.captureStackTrace(this, FundingError);\n//   }\n// }\n// /*\n//  * Helpers\n//  */\n// function sortAge(a, b) {\n//   a = a.height === -1 ? 0x7fffffff : a.height;\n//   b = b.height === -1 ? 0x7fffffff : b.height;\n//   return a - b;\n// }\n// function sortRandom(a, b) {\n//   return Math.random() > 0.5 ? 1 : -1;\n// }\n// function sortValue(a, b) {\n//   if (a.height === -1 && b.height !== -1)\n//     return 1;\n//   if (a.height !== -1 && b.height === -1)\n//     return -1;\n//   return b.value - a.value;\n// }\n// function sortInputs(a, b) {\n//   return a.compare(b);\n// }\n// function sortOutputs(a, b) {\n//   return a.compare(b);\n// }\n\n/*\n * Expose\n */\n\n\nexports = MTX;\nexports.MTX = MTX;\nexports.Selector = CoinSelector;\nexports.FundingError = FundingError;\nmodule.exports = exports;","map":{"version":3,"sources":["/home/henrik/Documents/dev/checkoutmin/src/utils/bcash/primitives/mtx.js"],"names":["assert","require","encoding","BufferMap","Script","TX","Input","Output","Coin","Outpoint","CoinView","Address","consensus","policy","Amount","Stack","util","inspectSymbol","MTX","constructor","options","mutable","changeIndex","view","fromOptions","version","inputs","Array","isArray","input","addInput","outputs","output","addOutput","locktime","addCoin","coin","fromCoin","push","script","value","fromScript","verify","flags","check","e","type","scriptInput","index","ring","raw","length","prev","sh","getScripthash","redeem","getRedeem","vector","scriptVector","toRaw","fromStack","pk","getPubkey","equals","publicKey","stack","pushInt","pkh","getPubkeyhash","getKeyHash","pushData","n","getMultisig","indexOf","i","exports","Selector","CoinSelector","FundingError","module"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,OAAD,CAAtB;;AACA,MAAM;AAACC,EAAAA;AAAD,IAAaD,OAAO,CAAC,OAAD,CAA1B;;AACA,MAAM;AAACE,EAAAA;AAAD,IAAcF,OAAO,CAAC,YAAD,CAA3B;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,kBAAD,CAAtB;;AACA,MAAMI,EAAE,GAAGJ,OAAO,CAAC,MAAD,CAAlB;;AACA,MAAMK,KAAK,GAAGL,OAAO,CAAC,SAAD,CAArB;;AACA,MAAMM,MAAM,GAAGN,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMO,IAAI,GAAGP,OAAO,CAAC,QAAD,CAApB;;AACA,MAAMQ,QAAQ,GAAGR,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAMS,QAAQ,GAAGT,OAAO,CAAC,mBAAD,CAAxB;;AACA,MAAMU,OAAO,GAAGV,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAMW,SAAS,GAAGX,OAAO,CAAC,uBAAD,CAAzB;;AACA,MAAMY,MAAM,GAAGZ,OAAO,CAAC,oBAAD,CAAtB;;AACA,MAAMa,MAAM,GAAGb,OAAO,CAAC,eAAD,CAAtB;;AACA,MAAMc,KAAK,GAAGd,OAAO,CAAC,iBAAD,CAArB;;AACA,MAAMe,IAAI,GAAGf,OAAO,CAAC,eAAD,CAApB;;AACA,MAAM;AAACgB,EAAAA;AAAD,IAAkBhB,OAAO,CAAC,UAAD,CAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMiB,GAAN,SAAkBb,EAAlB,CAAqB;AACnB;AACF;AACA;AACA;AACA;AACA;AAEEc,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB;AAEA,SAAKC,OAAL,GAAe,IAAf;AACA,SAAKC,WAAL,GAAmB,CAAC,CAApB;AACA,SAAKC,IAAL,GAAY,IAAIb,QAAJ,EAAZ;AAEA,QAAIU,OAAJ,EACE,KAAKI,WAAL,CAAiBJ,OAAjB;AACH;AAED;AACF;AACA;AACA;AACA;;;AAEEI,EAAAA,WAAW,CAACJ,OAAD,EAAU;AACnB,QAAIA,OAAO,CAACK,OAAR,IAAmB,IAAvB,EAA6B;AAC3BzB,MAAAA,MAAM,CAAEoB,OAAO,CAACK,OAAR,KAAoB,CAArB,KAA4BL,OAAO,CAACK,OAArC,EACJ,2BADI,CAAN;AAEA,WAAKA,OAAL,GAAeL,OAAO,CAACK,OAAvB;AACD;;AAED,QAAIL,OAAO,CAACM,MAAZ,EAAoB;AAClB1B,MAAAA,MAAM,CAAC2B,KAAK,CAACC,OAAN,CAAcR,OAAO,CAACM,MAAtB,CAAD,EAAgC,0BAAhC,CAAN;;AACA,WAAK,MAAMG,KAAX,IAAoBT,OAAO,CAACM,MAA5B,EACE,KAAKI,QAAL,CAAcD,KAAd;AACH;;AAED,QAAIT,OAAO,CAACW,OAAZ,EAAqB;AACnB/B,MAAAA,MAAM,CAAC2B,KAAK,CAACC,OAAN,CAAcR,OAAO,CAACW,OAAtB,CAAD,EAAiC,2BAAjC,CAAN;;AACA,WAAK,MAAMC,MAAX,IAAqBZ,OAAO,CAACW,OAA7B,EACE,KAAKE,SAAL,CAAeD,MAAf;AACH;;AAED,QAAIZ,OAAO,CAACc,QAAR,IAAoB,IAAxB,EAA8B;AAC5BlC,MAAAA,MAAM,CAAEoB,OAAO,CAACc,QAAR,KAAqB,CAAtB,KAA6Bd,OAAO,CAACc,QAAtC,EACJ,4BADI,CAAN;AAEA,WAAKA,QAAL,GAAgBd,OAAO,CAACc,QAAxB;AACD;;AAED,QAAId,OAAO,CAACE,WAAR,IAAuB,IAA3B,EAAiC;AAC/B,UAAIF,OAAO,CAACE,WAAR,KAAwB,CAAC,CAA7B,EAAgC;AAC9BtB,QAAAA,MAAM,CAAEoB,OAAO,CAACE,WAAR,KAAwB,CAAzB,KAAgCF,OAAO,CAACE,WAAzC,EACJ,gCADI,CAAN;AAEA,aAAKA,WAAL,GAAmBF,OAAO,CAACE,WAA3B;AACD,OAJD,MAIO;AACL,aAAKA,WAAL,GAAmB,CAAC,CAApB;AACD;AACF;;AAED,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEoB,SAAXE,WAAW,CAACJ,OAAD,EAAU;AAC1B,WAAO,IAAI,IAAJ,GAAWI,WAAX,CAAuBJ,OAAvB,CAAP;AACD,GAvEkB,CAyErB;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEEe,EAAAA,OAAO,CAACC,IAAD,EAAO;AACZpC,IAAAA,MAAM,CAACoC,IAAI,YAAY5B,IAAjB,EAAuB,sBAAvB,CAAN;AAEA,UAAMqB,KAAK,GAAGvB,KAAK,CAAC+B,QAAN,CAAeD,IAAf,CAAd;AAEA,SAAKV,MAAL,CAAYY,IAAZ,CAAiBT,KAAjB;AACA,SAAKN,IAAL,CAAUY,OAAV,CAAkBC,IAAlB;AAEA,WAAOP,KAAP;AACD,GA1IkB,CA4IrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEEI,EAAAA,SAAS,CAACM,MAAD,EAASC,KAAT,EAAgB;AACvB,QAAIR,MAAJ;AAEA,QAAIQ,KAAK,IAAI,IAAb,EACER,MAAM,GAAGzB,MAAM,CAACkC,UAAP,CAAkBF,MAAlB,EAA0BC,KAA1B,CAAT,CADF,KAGER,MAAM,GAAGzB,MAAM,CAACiB,WAAP,CAAmBe,MAAnB,CAAT;AAEF,SAAKR,OAAL,CAAaO,IAAb,CAAkBN,MAAlB;AAEA,WAAOA,MAAP;AACD,GAhMkB,CAkMrB;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;;;AAEEU,EAAAA,MAAM,CAACC,KAAD,EAAQ;AACZ,QAAI;AACF,WAAKC,KAAL,CAAWD,KAAX;AACD,KAFD,CAEE,OAAOE,CAAP,EAAU;AACV,UAAIA,CAAC,CAACC,IAAF,KAAW,aAAf,EACE,OAAO,KAAP;AACF,YAAMD,CAAN;AACD;;AACD,WAAO,IAAP;AACD,GAxOkB,CA0OrB;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEEE,EAAAA,WAAW,CAACC,KAAD,EAAQZ,IAAR,EAAca,IAAd,EAAoB;AAC7B,UAAMpB,KAAK,GAAG,KAAKH,MAAL,CAAYsB,KAAZ,CAAd;AAEAhD,IAAAA,MAAM,CAAC6B,KAAD,EAAQ,uBAAR,CAAN;AACA7B,IAAAA,MAAM,CAACoC,IAAD,EAAO,iBAAP,CAAN,CAJ6B,CAM7B;AACA;;AACA,QAAIP,KAAK,CAACU,MAAN,CAAaW,GAAb,CAAiBC,MAAjB,KAA4B,CAAhC,EACE,OAAO,IAAP,CAT2B,CAW7B;;AACA,UAAMC,IAAI,GAAGhB,IAAI,CAACG,MAAlB,CAZ6B,CAc7B;AACA;AACA;AACA;;AACA,UAAMc,EAAE,GAAGD,IAAI,CAACE,aAAL,EAAX;;AAEA,QAAID,EAAJ,EAAQ;AACN,YAAME,MAAM,GAAGN,IAAI,CAACO,SAAL,CAAeH,EAAf,CAAf;AAEA,UAAI,CAACE,MAAL,EACE,OAAO,KAAP,CAJI,CAMN;;AACA,YAAME,MAAM,GAAG,KAAKC,YAAL,CAAkBH,MAAlB,EAA0BN,IAA1B,CAAf;AAEA,UAAI,CAACQ,MAAL,EACE,OAAO,KAAP;AAEFA,MAAAA,MAAM,CAACnB,IAAP,CAAYiB,MAAM,CAACI,KAAP,EAAZ;AAEA9B,MAAAA,KAAK,CAACU,MAAN,CAAaqB,SAAb,CAAuBH,MAAvB;AAEA,aAAO,IAAP;AACD;;AAED,UAAMA,MAAM,GAAG,KAAKC,YAAL,CAAkBN,IAAlB,EAAwBH,IAAxB,CAAf;AAEA,QAAI,CAACQ,MAAL,EACE,OAAO,KAAP;AAEF5B,IAAAA,KAAK,CAACU,MAAN,CAAaqB,SAAb,CAAuBH,MAAvB;AAEA,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AAEEC,EAAAA,YAAY,CAACN,IAAD,EAAOH,IAAP,EAAa;AACvB;AACA,UAAMY,EAAE,GAAGT,IAAI,CAACU,SAAL,EAAX;;AACA,QAAID,EAAJ,EAAQ;AACN,UAAI,CAACA,EAAE,CAACE,MAAH,CAAUd,IAAI,CAACe,SAAf,CAAL,EACE,OAAO,IAAP;AAEF,YAAMC,KAAK,GAAG,IAAIlD,KAAJ,EAAd;AAEAkD,MAAAA,KAAK,CAACC,OAAN,CAAc,CAAd;AAEA,aAAOD,KAAP;AACD,KAZsB,CAcvB;;;AACA,UAAME,GAAG,GAAGf,IAAI,CAACgB,aAAL,EAAZ;;AACA,QAAID,GAAJ,EAAS;AACP,UAAI,CAACA,GAAG,CAACJ,MAAJ,CAAWd,IAAI,CAACoB,UAAL,EAAX,CAAL,EACE,OAAO,IAAP;AAEF,YAAMJ,KAAK,GAAG,IAAIlD,KAAJ,EAAd;AAEAkD,MAAAA,KAAK,CAACC,OAAN,CAAc,CAAd;AACAD,MAAAA,KAAK,CAACK,QAAN,CAAerB,IAAI,CAACe,SAApB;AAEA,aAAOC,KAAP;AACD,KA1BsB,CA4BvB;;;AACA,UAAM,GAAGM,CAAH,IAAQnB,IAAI,CAACoB,WAAL,EAAd;;AACA,QAAID,CAAC,KAAK,CAAC,CAAX,EAAc;AACZ,UAAInB,IAAI,CAACqB,OAAL,CAAaxB,IAAI,CAACe,SAAlB,MAAiC,CAAC,CAAtC,EACE,OAAO,IAAP,CAFU,CAIZ;AACA;AACA;;AACA,YAAMC,KAAK,GAAG,IAAIlD,KAAJ,EAAd;AAEAkD,MAAAA,KAAK,CAACC,OAAN,CAAc,CAAd,EATY,CAWZ;;AACA,WAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,CAApB,EAAuBG,CAAC,EAAxB,EACET,KAAK,CAACC,OAAN,CAAc,CAAd;;AAEF,aAAOD,KAAP;AACD;;AAED,WAAO,IAAP;AACD,GAtekB,CAwerB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAr1CqB,C,CAw1CrB;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAEAU,OAAO,GAAGzD,GAAV;AACAyD,OAAO,CAACzD,GAAR,GAAcA,GAAd;AACAyD,OAAO,CAACC,QAAR,GAAmBC,YAAnB;AACAF,OAAO,CAACG,YAAR,GAAuBA,YAAvB;AAEAC,MAAM,CAACJ,OAAP,GAAiBA,OAAjB","sourcesContent":["/*!\n * mtx.js - mutable transaction object for bcoin\n * Copyright (c) 2014-2015, Fedor Indutny (MIT License)\n * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcoin\n */\n\n'use strict';\n\nconst assert = require('bsert');\nconst {encoding} = require('bufio');\nconst {BufferMap} = require('buffer-map');\nconst Script = require('../script/script');\nconst TX = require('./tx');\nconst Input = require('./input');\nconst Output = require('./output');\nconst Coin = require('./coin');\nconst Outpoint = require('./outpoint');\nconst CoinView = require('../coins/coinview');\nconst Address = require('./address');\nconst consensus = require('../protocol/consensus');\nconst policy = require('../protocol/policy');\nconst Amount = require('../btc/amount');\nconst Stack = require('../script/stack');\nconst util = require('../utils/util');\nconst {inspectSymbol} = require('../utils');\n\n/**\n * MTX\n * A mutable transaction object.\n * @alias module:primitives.MTX\n * @extends TX\n * @property {Number} changeIndex\n * @property {CoinView} view\n */\n\nclass MTX extends TX {\n  /**\n   * Create a mutable transaction.\n   * @alias module:primitives.MTX\n   * @constructor\n   * @param {Object} options\n   */\n\n  constructor(options) {\n    super();\n\n    this.mutable = true;\n    this.changeIndex = -1;\n    this.view = new CoinView();\n\n    if (options)\n      this.fromOptions(options);\n  }\n\n  /**\n   * Inject properties from options object.\n   * @private\n   * @param {Object} options\n   */\n\n  fromOptions(options) {\n    if (options.version != null) {\n      assert((options.version >>> 0) === options.version,\n        'Version must a be uint32.');\n      this.version = options.version;\n    }\n\n    if (options.inputs) {\n      assert(Array.isArray(options.inputs), 'Inputs must be an array.');\n      for (const input of options.inputs)\n        this.addInput(input);\n    }\n\n    if (options.outputs) {\n      assert(Array.isArray(options.outputs), 'Outputs must be an array.');\n      for (const output of options.outputs)\n        this.addOutput(output);\n    }\n\n    if (options.locktime != null) {\n      assert((options.locktime >>> 0) === options.locktime,\n        'Locktime must be a uint32.');\n      this.locktime = options.locktime;\n    }\n\n    if (options.changeIndex != null) {\n      if (options.changeIndex !== -1) {\n        assert((options.changeIndex >>> 0) === options.changeIndex,\n          'Change index must be a uint32.');\n        this.changeIndex = options.changeIndex;\n      } else {\n        this.changeIndex = -1;\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Instantiate MTX from options.\n   * @param {Object} options\n   * @returns {MTX}\n   */\n\n  static fromOptions(options) {\n    return new this().fromOptions(options);\n  }\n\n//   /**\n//    * Clone the transaction. Note that\n//    * this will not carry over the view.\n//    * @returns {MTX}\n//    */\n\n//   clone() {\n//     const mtx = new this.constructor();\n//     mtx.inject(this);\n//     mtx.changeIndex = this.changeIndex;\n//     return mtx;\n//   }\n\n//   /**\n//    * Add an input to the transaction.\n//    * @param {Input|Object} options\n//    * @returns {Input}\n//    *\n//    * @example\n//    * mtx.addInput({ prevout: { hash: ... }, script: ... });\n//    * mtx.addInput(new Input());\n//    */\n\n//   addInput(options) {\n//     const input = Input.fromOptions(options);\n//     this.inputs.push(input);\n//     return input;\n//   }\n\n//   /**\n//    * Add an outpoint as an input.\n//    * @param {Outpoint|Object} outpoint\n//    * @returns {Input}\n//    *\n//    * @example\n//    * mtx.addOutpoint({ hash: ..., index: 0 });\n//    * mtx.addOutpoint(new Outpoint(hash, index));\n//    */\n\n//   addOutpoint(outpoint) {\n//     const prevout = Outpoint.fromOptions(outpoint);\n//     const input = Input.fromOutpoint(prevout);\n//     this.inputs.push(input);\n//     return input;\n//   }\n\n  /**\n   * Add a coin as an input. Note that this will\n   * add the coin to the internal coin viewpoint.\n   * @param {Coin} coin\n   * @returns {Input}\n   *\n   * @example\n   * mtx.addCoin(Coin.fromTX(tx, 0, -1));\n   */\n\n  addCoin(coin) {\n    assert(coin instanceof Coin, 'Cannot add non-coin.');\n\n    const input = Input.fromCoin(coin);\n\n    this.inputs.push(input);\n    this.view.addCoin(coin);\n\n    return input;\n  }\n\n//   /**\n//    * Add a transaction as an input. Note that\n//    * this will add the coin to the internal\n//    * coin viewpoint.\n//    * @param {TX} tx\n//    * @param {Number} index\n//    * @param {Number?} height\n//    * @returns {Input}\n//    *\n//    * @example\n//    * mtx.addTX(tx, 0);\n//    */\n\n//   addTX(tx, index, height) {\n//     assert(tx instanceof TX, 'Cannot add non-transaction.');\n\n//     if (height == null)\n//       height = -1;\n\n//     const input = Input.fromTX(tx, index);\n\n//     this.inputs.push(input);\n\n//     this.view.addIndex(tx, index, height);\n\n//     return input;\n//   }\n\n  /**\n   * Add an output.\n   * @param {Address|Script|Output|Object} script - Script or output options.\n   * @param {Amount?} value\n   * @returns {Output}\n   *\n   * @example\n   * mtx.addOutput(new Output());\n   * mtx.addOutput({ address: ..., value: 100000 });\n   * mtx.addOutput(address, 100000);\n   * mtx.addOutput(script, 100000);\n   */\n\n  addOutput(script, value) {\n    let output;\n\n    if (value != null)\n      output = Output.fromScript(script, value);\n    else\n      output = Output.fromOptions(script);\n\n    this.outputs.push(output);\n\n    return output;\n  }\n\n//   /**\n//    * Verify all transaction inputs.\n//    * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n//    * @returns {Boolean} Whether the inputs are valid.\n//    * @throws {ScriptError} on invalid inputs\n//    */\n\n//   check(flags) {\n//     return super.check(this.view, flags);\n//   }\n\n//   /**\n//    * Verify the transaction inputs on the worker pool\n//    * (if workers are enabled).\n//    * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n//    * @param {WorkerPool?} pool\n//    * @returns {Promise}\n//    */\n\n//   checkAsync(flags, pool) {\n//     return super.checkAsync(this.view, flags, pool);\n//   }\n\n  /**\n   * Verify all transaction inputs.\n   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]\n   * @returns {Boolean} Whether the inputs are valid.\n   */\n\n  verify(flags) {\n    try {\n      this.check(flags);\n    } catch (e) {\n      if (e.type === 'ScriptError')\n        return false;\n      throw e;\n    }\n    return true;\n  }\n\n//   /**\n//    * Verify the transaction inputs on the worker pool\n//    * (if workers are enabled).\n//    * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]\n//    * @param {WorkerPool?} pool\n//    * @returns {Promise}\n//    */\n\n//   async verifyAsync(flags, pool) {\n//     try {\n//       await this.checkAsync(flags, pool);\n//     } catch (e) {\n//       if (e.type === 'ScriptError')\n//         return false;\n//       throw e;\n//     }\n//     return true;\n//   }\n\n//   /**\n//    * Calculate the fee for the transaction.\n//    * @returns {Amount} fee (zero if not all coins are available).\n//    */\n\n//   getFee() {\n//     return super.getFee(this.view);\n//   }\n\n//   /**\n//    * Calculate the total input value.\n//    * @returns {Amount} value\n//    */\n\n//   getInputValue() {\n//     return super.getInputValue(this.view);\n//   }\n\n//   /**\n//    * Get all input addresses.\n//    * @returns {Address[]} addresses\n//    */\n\n//   getInputAddresses() {\n//     return super.getInputAddresses(this.view);\n//   }\n\n//   /**\n//    * Get all addresses.\n//    * @returns {Address[]} addresses\n//    */\n\n//   getAddresses() {\n//     return super.getAddresses(this.view);\n//   }\n\n//   /**\n//    * Get all input address hashes.\n//    * @returns {Hash[]} hashes\n//    */\n\n//   getInputHashes(enc) {\n//     return super.getInputHashes(this.view, enc);\n//   }\n\n//   /**\n//    * Get all address hashes.\n//    * @returns {Hash[]} hashes\n//    */\n\n//   getHashes(enc) {\n//     return super.getHashes(this.view, enc);\n//   }\n\n//   /**\n//    * Test whether the transaction has\n//    * all coins available/filled.\n//    * @returns {Boolean}\n//    */\n\n//   hasCoins() {\n//     return super.hasCoins(this.view);\n//   }\n\n//   /**\n//    * Calculate virtual sigop count.\n//    * @param {VerifyFlags?} flags\n//    * @returns {Number} sigop count\n//    */\n\n//   getSigops(flags) {\n//     return super.getSigops(this.view, flags);\n//   }\n\n//   /**\n//    *  Calculate sigops count.\n//    *  @param {CoinView} view\n//    *  @param {VerifyFlags?} flags\n//    *  @returns {Number} sigop count\n//    */\n\n//   getSigopsCount(flags) {\n//     return super.getSigopsCount(this.view, flags);\n//   }\n\n//   /**\n//    * Perform contextual checks to verify input, output,\n//    * and fee values, as well as coinbase spend maturity\n//    * (coinbases can only be spent 100 blocks or more\n//    * after they're created). Note that this function is\n//    * consensus critical.\n//    * @param {Number} height - Height at which the\n//    * transaction is being spent. In the mempool this is\n//    * the chain height plus one at the time it entered the pool.\n//    * @returns {Boolean}\n//    */\n\n//   verifyInputs(height) {\n//     const [fee] = this.checkInputs(height);\n//     return fee !== -1;\n//   }\n\n//   /**\n//    * Perform contextual checks to verify input, output,\n//    * and fee values, as well as coinbase spend maturity\n//    * (coinbases can only be spent 100 blocks or more\n//    * after they're created). Note that this function is\n//    * consensus critical.\n//    * @param {Number} height - Height at which the\n//    * transaction is being spent. In the mempool this is\n//    * the chain height plus one at the time it entered the pool.\n//    * @returns {Array} [fee, reason, score]\n//    */\n\n//   checkInputs(height) {\n//     return super.checkInputs(this.view, height);\n//   }\n\n  /**\n   * Build input script (or witness) templates (with\n   * OP_0 in place of signatures).\n   * @param {Number} index - Input index.\n   * @param {Coin|Output} coin\n   * @param {KeyRing} ring\n   * @returns {Boolean} Whether the script was able to be built.\n   */\n\n  scriptInput(index, coin, ring) {\n    const input = this.inputs[index];\n\n    assert(input, 'Input does not exist.');\n    assert(coin, 'No coin passed.');\n\n    // Don't bother with any below calculation\n    // if the output is already templated.\n    if (input.script.raw.length !== 0)\n      return true;\n\n    // Get the previous output's script\n    const prev = coin.script;\n\n    // This is easily the hardest part about\n    // building a transaction with segwit:\n    // figuring out where the redeem script\n    // and witness redeem scripts go.\n    const sh = prev.getScripthash();\n\n    if (sh) {\n      const redeem = ring.getRedeem(sh);\n\n      if (!redeem)\n        return false;\n\n      // Regular P2SH.\n      const vector = this.scriptVector(redeem, ring);\n\n      if (!vector)\n        return false;\n\n      vector.push(redeem.toRaw());\n\n      input.script.fromStack(vector);\n\n      return true;\n    }\n\n    const vector = this.scriptVector(prev, ring);\n\n    if (!vector)\n      return false;\n\n    input.script.fromStack(vector);\n\n    return true;\n  }\n\n  /**\n   * Build script for a single vector\n   * based on a previous script.\n   * @param {Script} prev\n   * @param {Buffer} ring\n   * @return {Stack}\n   */\n\n  scriptVector(prev, ring) {\n    // P2PK\n    const pk = prev.getPubkey();\n    if (pk) {\n      if (!pk.equals(ring.publicKey))\n        return null;\n\n      const stack = new Stack();\n\n      stack.pushInt(0);\n\n      return stack;\n    }\n\n    // P2PKH\n    const pkh = prev.getPubkeyhash();\n    if (pkh) {\n      if (!pkh.equals(ring.getKeyHash()))\n        return null;\n\n      const stack = new Stack();\n\n      stack.pushInt(0);\n      stack.pushData(ring.publicKey);\n\n      return stack;\n    }\n\n    // Multisig\n    const [, n] = prev.getMultisig();\n    if (n !== -1) {\n      if (prev.indexOf(ring.publicKey) === -1)\n        return null;\n\n      // Technically we should create m signature slots,\n      // but we create n signature slots so we can order\n      // the signatures properly.\n      const stack = new Stack();\n\n      stack.pushInt(0);\n\n      // Fill script with `n` signature slots.\n      for (let i = 0; i < n; i++)\n        stack.pushInt(0);\n\n      return stack;\n    }\n\n    return null;\n  }\n\n//   /**\n//    * Sign a transaction input on the worker pool\n//    * (if workers are enabled).\n//    * @param {Number} index\n//    * @param {Coin|Output} coin\n//    * @param {KeyRing} ring\n//    * @param {SighashType?} type\n//    * @param {WorkerPool?} pool\n//    * @returns {Promise}\n//    */\n\n//   async signInputAsync(index, coin, ring, type, pool) {\n//     if (!pool)\n//       return this.signInput(index, coin, ring, type);\n\n//     return await pool.signInput(this, index, coin, ring, type, pool);\n//   }\n\n//   /**\n//    * Sign an input.\n//    * @param {Number} index - Index of input being signed.\n//    * @param {Coin|Output} coin\n//    * @param {KeyRing} ring - Private key.\n//    * @param {SighashType} type\n//    * @returns {Boolean} Whether the input was able to be signed.\n//    */\n\n//   signInput(index, coin, ring, type) {\n//     const input = this.inputs[index];\n//     const key = ring.privateKey;\n\n//     assert(input, 'Input does not exist.');\n//     assert(coin, 'No coin passed.');\n\n//     // Get the previous output's script\n//     const value = coin.value;\n//     let prev = coin.script;\n//     const vector = input.script;\n//     let redeem = false;\n\n//     if (type == null)\n//       type = Script.hashType.ALL;\n\n//     type |= Script.hashType.SIGHASH_FORKID;\n//     const flags = Script.flags.VERIFY_SIGHASH_FORKID;\n\n//     // Grab regular p2sh redeem script.\n//     if (prev.isScripthash()) {\n//       prev = input.script.getRedeem();\n//       if (!prev)\n//         throw new Error('Input has not been templated.');\n//       redeem = true;\n//     }\n\n//     // Create our signature.\n//     const sig = this.signature(index, prev, value, key, type, flags);\n\n//     if (redeem) {\n//       const stack = vector.toStack();\n//       const redeem = stack.pop();\n\n//       const result = this.signVector(prev, stack, sig, ring);\n\n//       if (!result)\n//         return false;\n\n//       result.push(redeem);\n\n//       vector.fromStack(result);\n\n//       return true;\n//     }\n\n//     const stack = vector.toStack();\n//     const result = this.signVector(prev, stack, sig, ring);\n\n//     if (!result)\n//       return false;\n\n//     vector.fromStack(result);\n\n//     return true;\n//   }\n\n//   /**\n//    * Add a signature to a vector\n//    * based on a previous script.\n//    * @param {Script} prev\n//    * @param {Stack} vector\n//    * @param {Buffer} sig\n//    * @param {KeyRing} ring\n//    * @return {Boolean}\n//    */\n\n//   signVector(prev, vector, sig, ring) {\n//     // P2PK\n//     const pk = prev.getPubkey();\n//     if (pk) {\n//       // Make sure the pubkey is ours.\n//       if (!ring.publicKey.equals(pk))\n//         return null;\n\n//       if (vector.length === 0)\n//         throw new Error('Input has not been templated.');\n\n//       // Already signed.\n//       if (vector.get(0).length > 0)\n//         return vector;\n\n//       vector.set(0, sig);\n\n//       return vector;\n//     }\n\n//     // P2PKH\n//     const pkh = prev.getPubkeyhash();\n//     if (pkh) {\n//       // Make sure the pubkey hash is ours.\n//       if (!ring.getKeyHash().equals(pkh))\n//         return null;\n\n//       if (vector.length !== 2)\n//         throw new Error('Input has not been templated.');\n\n//       if (vector.get(1).length === 0)\n//         throw new Error('Input has not been templated.');\n\n//       // Already signed.\n//       if (vector.get(0).length > 0)\n//         return vector;\n\n//       vector.set(0, sig);\n\n//       return vector;\n//     }\n\n//     // Multisig\n//     const [m, n] = prev.getMultisig();\n//     if (m !== -1) {\n//       if (vector.length < 2)\n//         throw new Error('Input has not been templated.');\n\n//       if (vector.get(0).length !== 0)\n//         throw new Error('Input has not been templated.');\n\n//       // Too many signature slots. Abort.\n//       if (vector.length - 1 > n)\n//         throw new Error('Input has not been templated.');\n\n//       // Count the number of current signatures.\n//       let total = 0;\n//       for (let i = 1; i < vector.length; i++) {\n//         const item = vector.get(i);\n//         if (item.length > 0)\n//           total += 1;\n//       }\n\n//       // Signatures are already finalized.\n//       if (total === m && vector.length - 1 === m)\n//         return vector;\n\n//       // Add some signature slots for us to use if\n//       // there was for some reason not enough.\n//       while (vector.length - 1 < n)\n//         vector.pushInt(0);\n\n//       // Grab the redeem script's keys to figure\n//       // out where our key should go.\n//       const keys = [];\n//       for (const op of prev.code) {\n//         if (op.data)\n//           keys.push(op.data);\n//       }\n\n//       // Find the key index so we can place\n//       // the signature in the same index.\n//       let keyIndex = -1;\n\n//       for (let i = 0; i < keys.length; i++) {\n//         const key = keys[i];\n//         if (key.equals(ring.publicKey)) {\n//           keyIndex = i;\n//           break;\n//         }\n//       }\n\n//       // Our public key is not in the prev_out\n//       // script. We tried to sign a transaction\n//       // that is not redeemable by us.\n//       if (keyIndex === -1)\n//         return null;\n\n//       // Offset key index by one to turn it into\n//       // \"sig index\". Accounts for OP_0 byte at\n//       // the start.\n//       keyIndex += 1;\n\n//       // Add our signature to the correct slot\n//       // and increment the total number of\n//       // signatures.\n//       if (keyIndex < vector.length && total < m) {\n//         if (vector.get(keyIndex).length === 0) {\n//           vector.set(keyIndex, sig);\n//           total += 1;\n//         }\n//       }\n\n//       // All signatures added. Finalize.\n//       if (total >= m) {\n//         // Remove empty slots left over.\n//         for (let i = vector.length - 1; i >= 1; i--) {\n//           const item = vector.get(i);\n//           if (item.length === 0)\n//             vector.remove(i);\n//         }\n\n//         // Remove signatures which are not required.\n//         // This should never happen.\n//         while (total > m) {\n//           vector.pop();\n//           total -= 1;\n//         }\n\n//         // Sanity checks.\n//         assert(total === m);\n//         assert(vector.length - 1 === m);\n//       }\n\n//       return vector;\n//     }\n\n//     return null;\n//   }\n\n//   /**\n//    * Test whether the transaction is fully-signed.\n//    * @returns {Boolean}\n//    */\n\n//   isSigned() {\n//     for (let i = 0; i < this.inputs.length; i++) {\n//       const {prevout} = this.inputs[i];\n//       const coin = this.view.getOutput(prevout);\n\n//       if (!coin)\n//         return false;\n\n//       if (!this.isInputSigned(i, coin))\n//         return false;\n//     }\n\n//     return true;\n//   }\n\n//   /**\n//    * Test whether an input is fully-signed.\n//    * @param {Number} index\n//    * @param {Coin|Output} coin\n//    * @returns {Boolean}\n//    */\n\n//   isInputSigned(index, coin) {\n//     const input = this.inputs[index];\n\n//     assert(input, 'Input does not exist.');\n//     assert(coin, 'No coin passed.');\n\n//     const vector = input.script;\n//     let prev = coin.script;\n//     let redeem = false;\n\n//     // Grab redeem script if possible.\n//     if (prev.isScripthash()) {\n//       prev = input.script.getRedeem();\n//       if (!prev)\n//         return false;\n//       redeem = true;\n//     }\n\n//     const stack = vector.toStack();\n\n//     if (redeem)\n//       stack.pop();\n\n//     return this.isVectorSigned(prev, stack);\n//   }\n\n//   /**\n//    * Test whether a vector is fully-signed.\n//    * @param {Script} prev\n//    * @param {Stack} vector\n//    * @returns {Boolean}\n//    */\n\n//   isVectorSigned(prev, vector) {\n//     if (prev.isPubkey()) {\n//       if (vector.length !== 1)\n//         return false;\n\n//       if (vector.get(0).length === 0)\n//         return false;\n\n//       return true;\n//     }\n\n//     if (prev.isPubkeyhash()) {\n//       if (vector.length !== 2)\n//         return false;\n\n//       if (vector.get(0).length === 0)\n//         return false;\n\n//       if (vector.get(1).length === 0)\n//         return false;\n\n//       return true;\n//     }\n\n//     const [m] = prev.getMultisig();\n\n//     if (m !== -1) {\n//       // Ensure we have the correct number\n//       // of required signatures.\n//       if (vector.length - 1 !== m)\n//         return false;\n\n//       // Ensure all members are signatures.\n//       for (let i = 1; i < vector.length; i++) {\n//         const item = vector.get(i);\n//         if (item.length === 0)\n//           return false;\n//       }\n\n//       return true;\n//     }\n\n//     return false;\n//   }\n\n//   /**\n//    * Build input scripts (or witnesses).\n//    * @param {KeyRing} ring - Address used to sign. The address\n//    * must be able to redeem the coin.\n//    * @returns {Number} Number of inputs templated.\n//    */\n\n//   template(ring) {\n//     if (Array.isArray(ring)) {\n//       let total = 0;\n//       for (const key of ring)\n//         total += this.template(key);\n//       return total;\n//     }\n\n//     let total = 0;\n\n//     for (let i = 0; i < this.inputs.length; i++) {\n//       const {prevout} = this.inputs[i];\n//       const coin = this.view.getOutput(prevout);\n\n//       if (!coin)\n//         continue;\n\n//       if (!ring.ownOutput(coin))\n//         continue;\n\n//       // Build script for input\n//       if (!this.scriptInput(i, coin, ring))\n//         continue;\n\n//       total += 1;\n//     }\n\n//     return total;\n//   }\n\n//   /**\n//    * Built input scripts (or witnesses) and sign the inputs.\n//    * @param {KeyRing} ring - Address used to sign. The address\n//    * must be able to redeem the coin.\n//    * @param {SighashType} type\n//    * @returns {Number} Number of inputs signed.\n//    */\n\n//   sign(ring, type) {\n//     if (Array.isArray(ring)) {\n//       let total = 0;\n//       for (const key of ring)\n//         total += this.sign(key, type);\n//       return total;\n//     }\n\n//     assert(ring.privateKey, 'No private key available.');\n\n//     let total = 0;\n\n//     for (let i = 0; i < this.inputs.length; i++) {\n//       const {prevout} = this.inputs[i];\n//       const coin = this.view.getOutput(prevout);\n\n//       if (!coin)\n//         continue;\n\n//       if (!ring.ownOutput(coin))\n//         continue;\n\n//       // Build script for input\n//       if (!this.scriptInput(i, coin, ring))\n//         continue;\n\n//       // Sign input\n//       if (!this.signInput(i, coin, ring, type))\n//         continue;\n\n//       total += 1;\n//     }\n\n//     return total;\n//   }\n\n//   /**\n//    * Sign the transaction inputs on the worker pool\n//    * (if workers are enabled).\n//    * @param {KeyRing} ring\n//    * @param {SighashType?} type\n//    * @param {WorkerPool?} pool\n//    * @returns {Promise}\n//    */\n\n//   async signAsync(ring, type, pool) {\n//     if (!pool)\n//       return this.sign(ring, type);\n\n//     return await pool.sign(this, ring, type);\n//   }\n\n//   /**\n//    * Estimate maximum possible size.\n//    * @param {Function?} estimate - Input script size estimator.\n//    * @returns {Number}\n//    */\n\n//   async estimateSize(estimate) {\n//     let total = 0;\n\n//     // Calculate the size, minus the input scripts.\n//     total += 4;\n//     total += encoding.sizeVarint(this.inputs.length);\n//     total += this.inputs.length * 40;\n\n//     total += encoding.sizeVarint(this.outputs.length);\n\n//     for (const output of this.outputs)\n//       total += output.getSize();\n\n//     total += 4;\n\n//     // Add size for signatures and public keys\n//     for (const {prevout} of this.inputs) {\n//       const coin = this.view.getOutput(prevout);\n\n//       // We're out of luck here.\n//       // Just assume it's a p2pkh.\n//       if (!coin) {\n//         total += 110;\n//         continue;\n//       }\n\n//       // Previous output script.\n//       const prev = coin.script;\n\n//       // P2PK\n//       if (prev.isPubkey()) {\n//         // varint script size\n//         total += 1;\n//         // OP_PUSHDATA0 [signature]\n//         total += 1 + 73;\n//         continue;\n//       }\n\n//       // P2PKH\n//       if (prev.isPubkeyhash()) {\n//         // varint script size\n//         total += 1;\n//         // OP_PUSHDATA0 [signature]\n//         total += 1 + 73;\n//         // OP_PUSHDATA0 [key]\n//         total += 1 + 33;\n//         continue;\n//       }\n\n//       const [m] = prev.getMultisig();\n//       if (m !== -1) {\n//         let size = 0;\n//         // Bare Multisig\n//         // OP_0\n//         size += 1;\n//         // OP_PUSHDATA0 [signature] ...\n//         size += (1 + 73) * m;\n//         // varint len\n//         size += encoding.sizeVarint(size);\n//         total += size;\n//         continue;\n//       }\n\n//       // Call out to the custom estimator.\n//       if (estimate) {\n//         const size = await estimate(prev);\n//         if (size !== -1) {\n//           total += size;\n//           continue;\n//         }\n//       }\n\n//       // P2SH\n//       if (prev.isScripthash()) {\n//         // varint size\n//         total += 1;\n//         // 2-of-3 multisig input\n//         total += 149;\n//         continue;\n//       }\n\n//       // Unknown.\n//       total += 110;\n//     }\n\n//     return total;\n//   }\n\n//   /**\n//    * Select necessary coins based on total output value.\n//    * @param {Coin[]} coins\n//    * @param {Object?} options\n//    * @returns {CoinSelection}\n//    * @throws on not enough funds available.\n//    */\n\n//   selectCoins(coins, options) {\n//     const selector = new CoinSelector(this, options);\n//     return selector.select(coins);\n//   }\n\n//   /**\n//    * Attempt to subtract a fee from a single output.\n//    * @param {Number} index\n//    * @param {Amount} fee\n//    */\n\n//   subtractIndex(index, fee) {\n//     assert(typeof index === 'number');\n//     assert(typeof fee === 'number');\n\n//     const output = this.outputs[index];\n\n//     if (!output)\n//       throw new Error('Subtraction index does not exist.');\n\n//     if (output.value < fee + output.getDustThreshold())\n//       throw new Error('Could not subtract fee.');\n\n//     output.value -= fee;\n//   }\n\n//   /**\n//    * Attempt to subtract a fee from all outputs evenly.\n//    * @param {Amount} fee\n//    */\n\n//   subtractFee(fee) {\n//     assert(typeof fee === 'number');\n\n//     let outputs = 0;\n\n//     for (const output of this.outputs) {\n//       // Ignore nulldatas and\n//       // other OP_RETURN scripts.\n//       if (output.script.isUnspendable())\n//         continue;\n//       outputs += 1;\n//     }\n\n//     if (outputs === 0)\n//       throw new Error('Could not subtract fee.');\n\n//     const left = fee % outputs;\n//     const share = (fee - left) / outputs;\n\n//     // First pass, remove even shares.\n//     for (const output of this.outputs) {\n//       if (output.script.isUnspendable())\n//         continue;\n\n//       if (output.value < share + output.getDustThreshold())\n//         throw new Error('Could not subtract fee.');\n\n//       output.value -= share;\n//     }\n\n//     // Second pass, remove the remainder\n//     // for the one unlucky output.\n//     for (const output of this.outputs) {\n//       if (output.script.isUnspendable())\n//         continue;\n\n//       if (output.value >= left + output.getDustThreshold()) {\n//         output.value -= left;\n//         return;\n//       }\n//     }\n\n//     throw new Error('Could not subtract fee.');\n//   }\n\n//   /**\n//    * Select coins and fill the inputs.\n//    * @param {Coin[]} coins\n//    * @param {Object} options - See {@link MTX#selectCoins} options.\n//    * @returns {CoinSelector}\n//    */\n\n//   async fund(coins, options) {\n//     assert(options, 'Options are required.');\n//     assert(options.changeAddress, 'Change address is required.');\n//     assert(this.inputs.length === 0, 'TX is already funded.');\n\n//     // Select necessary coins.\n//     const select = await this.selectCoins(coins, options);\n\n//     // Add coins to transaction.\n//     for (const coin of select.chosen)\n//       this.addCoin(coin);\n\n//     // Attempt to subtract fee.\n//     if (select.subtractFee) {\n//       const index = select.subtractIndex;\n//       if (index !== -1)\n//         this.subtractIndex(index, select.fee);\n//       else\n//         this.subtractFee(select.fee);\n//     }\n\n//     // Add a change output.\n//     const output = new Output();\n//     output.value = select.change;\n//     output.script.fromAddress(select.changeAddress);\n\n//     if (output.isDust(policy.MIN_RELAY)) {\n//       // Do nothing. Change is added to fee.\n//       this.changeIndex = -1;\n//       assert.strictEqual(this.getFee(), select.fee + select.change);\n//     } else {\n//       this.outputs.push(output);\n//       this.changeIndex = this.outputs.length - 1;\n//       assert.strictEqual(this.getFee(), select.fee);\n//     }\n\n//     return select;\n//   }\n\n//   /**\n//    * Sort inputs and outputs according to BIP69.\n//    * @see https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki\n//    */\n\n//   sortMembers() {\n//     let changeOutput = null;\n\n//     if (this.changeIndex !== -1) {\n//       changeOutput = this.outputs[this.changeIndex];\n//       assert(changeOutput);\n//     }\n\n//     this.inputs.sort(sortInputs);\n//     this.outputs.sort(sortOutputs);\n\n//     if (this.changeIndex !== -1) {\n//       this.changeIndex = this.outputs.indexOf(changeOutput);\n//       assert(this.changeIndex !== -1);\n//     }\n//   }\n\n//   /**\n//    * Avoid fee sniping.\n//    * @param {Number} - Current chain height.\n//    * @see bitcoin/src/wallet/wallet.cpp\n//    */\n\n//   avoidFeeSniping(height) {\n//     assert(typeof height === 'number', 'Must pass in height.');\n\n//     if ((Math.random() * 10 | 0) === 0) {\n//       height -= Math.random() * 100 | 0;\n\n//       if (height < 0)\n//         height = 0;\n//     }\n\n//     this.setLocktime(height);\n//   }\n\n//   /**\n//    * Set locktime and sequences appropriately.\n//    * @param {Number} locktime\n//    */\n\n//   setLocktime(locktime) {\n//     assert((locktime >>> 0) === locktime, 'Locktime must be a uint32.');\n//     assert(this.inputs.length > 0, 'Cannot set sequence with no inputs.');\n\n//     for (const input of this.inputs) {\n//       if (input.sequence === 0xffffffff)\n//         input.sequence = 0xfffffffe;\n//     }\n\n//     this.locktime = locktime;\n//   }\n\n//   /**\n//    * Set sequence locktime.\n//    * @param {Number} index - Input index.\n//    * @param {Number} locktime\n//    * @param {Boolean?} seconds\n//    */\n\n//   setSequence(index, locktime, seconds) {\n//     const input = this.inputs[index];\n\n//     assert(input, 'Input does not exist.');\n//     assert((locktime >>> 0) === locktime, 'Locktime must be a uint32.');\n\n//     this.version = 2;\n\n//     if (seconds) {\n//       locktime >>>= consensus.SEQUENCE_GRANULARITY;\n//       locktime &= consensus.SEQUENCE_MASK;\n//       locktime |= consensus.SEQUENCE_TYPE_FLAG;\n//     } else {\n//       locktime &= consensus.SEQUENCE_MASK;\n//     }\n\n//     input.sequence = locktime;\n//   }\n\n//   /**\n//    * Inspect the transaction.\n//    * @returns {Object}\n//    */\n\n//   [inspectSymbol]() {\n//     return this.format();\n//   }\n\n//   /**\n//    * Inspect the transaction.\n//    * @returns {Object}\n//    */\n\n//   format() {\n//     return super.format(this.view);\n//   }\n\n//   /**\n//    * Convert transaction to JSON.\n//    * @returns {Object}\n//    */\n\n//   toJSON() {\n//     return super.toJSON(null, this.view);\n//   }\n\n//   /**\n//    * Convert transaction to JSON.\n//    * @param {Network} network\n//    * @returns {Object}\n//    */\n\n//   getJSON(network) {\n//     return super.getJSON(network, this.view);\n//   }\n\n//   /**\n//    * Inject properties from a json object\n//    * @param {Object} json\n//    */\n\n//   fromJSON(json) {\n//     super.fromJSON(json);\n\n//     for (let i = 0; i < json.inputs.length; i++) {\n//       const input = json.inputs[i];\n//       const {prevout} = input;\n\n//       if (!input.coin)\n//         continue;\n\n//       const coin = Coin.fromJSON(input.coin);\n\n//       coin.hash = util.fromRev(prevout.hash);\n//       coin.index = prevout.index;\n\n//       this.view.addCoin(coin);\n//     }\n\n//     return this;\n//   }\n\n//   /**\n//    * Instantiate a transaction from a\n//    * jsonified transaction object.\n//    * @param {Object} json - The jsonified transaction object.\n//    * @returns {MTX}\n//    */\n\n//   static fromJSON(json) {\n//     return new this().fromJSON(json);\n//   }\n\n//   /**\n//    * Instantiate a transaction from a buffer reader.\n//    * @param {BufferReader} br\n//    * @returns {MTX}\n//    */\n\n//   static fromReader(br) {\n//     return new this().fromReader(br);\n//   }\n\n//   /**\n//    * Instantiate a transaction from a serialized Buffer.\n//    * @param {Buffer} data\n//    * @param {String?} enc - Encoding, can be `'hex'` or null.\n//    * @returns {MTX}\n//    */\n\n//   static fromRaw(data, enc) {\n//     if (typeof data === 'string')\n//       data = Buffer.from(data, enc);\n//     return new this().fromRaw(data);\n//   }\n\n//   /**\n//    * Convert the MTX to a TX.\n//    * @returns {TX}\n//    */\n\n//   toTX() {\n//     return new TX().inject(this);\n//   }\n\n//   /**\n//    * Convert the MTX to a TX.\n//    * @returns {Array} [tx, view]\n//    */\n\n//   commit() {\n//     return [this.toTX(), this.view];\n//   }\n\n//   /**\n//    * Instantiate MTX from TX.\n//    * @param {TX} tx\n//    * @returns {MTX}\n//    */\n\n//   static fromTX(tx) {\n//     return new this().inject(tx);\n//   }\n\n//   /**\n//    * Test whether an object is an MTX.\n//    * @param {Object} obj\n//    * @returns {Boolean}\n//    */\n\n//   static isMTX(obj) {\n//     return obj instanceof MTX;\n//   }\n}\n\n// /**\n//  * Coin Selector\n//  * @alias module:primitives.CoinSelector\n//  */\n\n// class CoinSelector {\n//   /**\n//    * Create a coin selector.\n//    * @constructor\n//    * @param {TX} tx\n//    * @param {Object?} options\n//    */\n\n//   constructor(tx, options) {\n//     this.tx = tx.clone();\n//     this.coins = [];\n//     this.outputValue = 0;\n//     this.index = 0;\n//     this.chosen = [];\n//     this.change = 0;\n//     this.fee = CoinSelector.MIN_FEE;\n\n//     this.selection = 'value';\n//     this.subtractFee = false;\n//     this.subtractIndex = -1;\n//     this.height = -1;\n//     this.depth = -1;\n//     this.hardFee = -1;\n//     this.rate = CoinSelector.FEE_RATE;\n//     this.maxFee = -1;\n//     this.round = false;\n//     this.changeAddress = null;\n//     this.inputs = new BufferMap();\n\n//     // Needed for size estimation.\n//     this.estimate = null;\n\n//     this.injectInputs();\n\n//     if (options)\n//       this.fromOptions(options);\n//   }\n\n//   /**\n//    * Initialize selector options.\n//    * @param {Object} options\n//    * @private\n//    */\n\n//   fromOptions(options) {\n//     if (options.selection) {\n//       assert(typeof options.selection === 'string');\n//       this.selection = options.selection;\n//     }\n\n//     if (options.subtractFee != null) {\n//       if (typeof options.subtractFee === 'number') {\n//         assert(Number.isSafeInteger(options.subtractFee));\n//         assert(options.subtractFee >= -1);\n//         this.subtractIndex = options.subtractFee;\n//         this.subtractFee = this.subtractIndex !== -1;\n//       } else {\n//         assert(typeof options.subtractFee === 'boolean');\n//         this.subtractFee = options.subtractFee;\n//       }\n//     }\n\n//     if (options.subtractIndex != null) {\n//       assert(Number.isSafeInteger(options.subtractIndex));\n//       assert(options.subtractIndex >= -1);\n//       this.subtractIndex = options.subtractIndex;\n//       this.subtractFee = this.subtractIndex !== -1;\n//     }\n\n//     if (options.height != null) {\n//       assert(Number.isSafeInteger(options.height));\n//       assert(options.height >= -1);\n//       this.height = options.height;\n//     }\n\n//     if (options.confirmations != null) {\n//       assert(Number.isSafeInteger(options.confirmations));\n//       assert(options.confirmations >= -1);\n//       this.depth = options.confirmations;\n//     }\n\n//     if (options.depth != null) {\n//       assert(Number.isSafeInteger(options.depth));\n//       assert(options.depth >= -1);\n//       this.depth = options.depth;\n//     }\n\n//     if (options.hardFee != null) {\n//       assert(Number.isSafeInteger(options.hardFee));\n//       assert(options.hardFee >= -1);\n//       this.hardFee = options.hardFee;\n//     }\n\n//     if (options.rate != null) {\n//       assert(Number.isSafeInteger(options.rate));\n//       assert(options.rate >= 0);\n//       this.rate = options.rate;\n//     }\n\n//     if (options.maxFee != null) {\n//       assert(Number.isSafeInteger(options.maxFee));\n//       assert(options.maxFee >= -1);\n//       this.maxFee = options.maxFee;\n//     }\n\n//     if (options.round != null) {\n//       assert(typeof options.round === 'boolean');\n//       this.round = options.round;\n//     }\n\n//     if (options.changeAddress) {\n//       const addr = options.changeAddress;\n//       if (typeof addr === 'string') {\n//         this.changeAddress = Address.fromString(addr);\n//       } else {\n//         assert(addr instanceof Address);\n//         this.changeAddress = addr;\n//       }\n//     }\n\n//     if (options.estimate) {\n//       assert(typeof options.estimate === 'function');\n//       this.estimate = options.estimate;\n//     }\n\n//     if (options.inputs) {\n//       assert(Array.isArray(options.inputs));\n//       for (let i = 0; i < options.inputs.length; i++) {\n//         const prevout = options.inputs[i];\n//         assert(prevout && typeof prevout === 'object');\n//         const {hash, index} = prevout;\n//         assert(Buffer.isBuffer(hash));\n//         assert(typeof index === 'number');\n//         this.inputs.set(Outpoint.toKey(hash, index), i);\n//       }\n//     }\n\n//     return this;\n//   }\n\n//   /**\n//    * Attempt to inject existing inputs.\n//    * @private\n//    */\n\n//   injectInputs() {\n//     if (this.tx.inputs.length > 0) {\n//       for (let i = 0; i < this.tx.inputs.length; i++) {\n//         const {prevout} = this.tx.inputs[i];\n//         this.inputs.set(prevout.toKey(), i);\n//       }\n//     }\n//   }\n\n//   /**\n//    * Initialize the selector with coins to select from.\n//    * @param {Coin[]} coins\n//    */\n\n//   init(coins) {\n//     this.coins = coins.slice();\n//     this.outputValue = this.tx.getOutputValue();\n//     this.index = 0;\n//     this.chosen = [];\n//     this.change = 0;\n//     this.fee = CoinSelector.MIN_FEE;\n//     this.tx.inputs.length = 0;\n\n//     switch (this.selection) {\n//       case 'all':\n//       case 'random':\n//         this.coins.sort(sortRandom);\n//         break;\n//       case 'age':\n//         this.coins.sort(sortAge);\n//         break;\n//       case 'value':\n//         this.coins.sort(sortValue);\n//         break;\n//       default:\n//         throw new FundingError(`Bad selection type: ${this.selection}.`);\n//     }\n//   }\n\n//   /**\n//    * Calculate total value required.\n//    * @returns {Amount}\n//    */\n\n//   total() {\n//     if (this.subtractFee)\n//       return this.outputValue;\n//     return this.outputValue + this.fee;\n//   }\n\n//   /**\n//    * Test whether the selector has\n//    * completely funded the transaction.\n//    * @returns {Boolean}\n//    */\n\n//   isFull() {\n//     return this.tx.getInputValue() >= this.total();\n//   }\n\n//   /**\n//    * Test whether a coin is spendable\n//    * with regards to the options.\n//    * @param {Coin} coin\n//    * @returns {Boolean}\n//    */\n\n//   isSpendable(coin) {\n//     if (this.tx.view.hasEntry(coin))\n//       return false;\n\n//     if (this.height === -1)\n//       return true;\n\n//     if (coin.coinbase) {\n//       if (coin.height === -1)\n//         return false;\n\n//       if (this.height + 1 < coin.height + consensus.COINBASE_MATURITY)\n//         return false;\n\n//       return true;\n//     }\n\n//     if (this.depth === -1)\n//       return true;\n\n//     const depth = coin.getDepth(this.height);\n\n//     if (depth < this.depth)\n//       return false;\n\n//     return true;\n//   }\n\n//   /**\n//    * Get the current fee based on a size.\n//    * @param {Number} size\n//    * @returns {Amount}\n//    */\n\n//   getFee(size) {\n//     // This is mostly here for testing.\n//     // i.e. A fee rounded to the nearest\n//     // kb is easier to predict ahead of time.\n//     if (this.round) {\n//       const fee = policy.getRoundFee(size, this.rate);\n//       return Math.min(fee, CoinSelector.MAX_FEE);\n//     }\n\n//     const fee = policy.getMinFee(size, this.rate);\n//     return Math.min(fee, CoinSelector.MAX_FEE);\n//   }\n\n//   /**\n//    * Fund the transaction with more\n//    * coins if the `output value + fee`\n//    * total was updated.\n//    */\n\n//   fund() {\n//     // Ensure all preferred inputs first.\n//     if (this.inputs.size > 0) {\n//       const coins = [];\n\n//       for (let i = 0; i < this.inputs.size; i++)\n//         coins.push(null);\n\n//       for (const coin of this.coins) {\n//         const {hash, index} = coin;\n//         const key = Outpoint.toKey(hash, index);\n//         const i = this.inputs.get(key);\n\n//         if (i != null) {\n//           coins[i] = coin;\n//           this.inputs.delete(key);\n//         }\n//       }\n\n//       if (this.inputs.size > 0)\n//         throw new Error('Could not resolve preferred inputs.');\n\n//       for (const coin of coins) {\n//         this.tx.addCoin(coin);\n//         this.chosen.push(coin);\n//       }\n//     }\n\n//     while (this.index < this.coins.length) {\n//       const coin = this.coins[this.index++];\n\n//       if (!this.isSpendable(coin))\n//         continue;\n\n//       this.tx.addCoin(coin);\n//       this.chosen.push(coin);\n\n//       if (this.selection === 'all')\n//         continue;\n\n//       if (this.isFull())\n//         break;\n//     }\n//   }\n\n//   /**\n//    * Initiate selection from `coins`.\n//    * @param {Coin[]} coins\n//    * @returns {CoinSelector}\n//    */\n\n//   async select(coins) {\n//     this.init(coins);\n\n//     if (this.hardFee !== -1) {\n//       this.selectHard();\n//     } else {\n//       // This is potentially asynchronous:\n//       // it may invoke the size estimator\n//       // required for redeem scripts (we\n//       // may be calling out to a wallet\n//       // or something similar).\n//       await this.selectEstimate();\n//     }\n\n//     if (!this.isFull()) {\n//       // Still failing to get enough funds.\n//       throw new FundingError(\n//         'Not enough funds.',\n//         this.tx.getInputValue(),\n//         this.total());\n//     }\n\n//     // How much money is left after filling outputs.\n//     this.change = this.tx.getInputValue() - this.total();\n\n//     return this;\n//   }\n\n//   /**\n//    * Initialize selection based on size estimate.\n//    */\n\n//   async selectEstimate() {\n//     // Set minimum fee and do\n//     // an initial round of funding.\n//     this.fee = CoinSelector.MIN_FEE;\n//     this.fund();\n\n//     // Add dummy output for change.\n//     const change = new Output();\n\n//     if (this.changeAddress) {\n//       change.script.fromAddress(this.changeAddress);\n//     } else {\n//       // In case we don't have a change address,\n//       // we use a fake p2pkh output to gauge size.\n//       change.script.fromPubkeyhash(Buffer.allocUnsafe(20));\n//     }\n\n//     this.tx.outputs.push(change);\n\n//     // Keep recalculating the fee and funding\n//     // until we reach some sort of equilibrium.\n//     do {\n//       const size = await this.tx.estimateSize(this.estimate);\n\n//       this.fee = this.getFee(size);\n\n//       if (this.maxFee > 0 && this.fee > this.maxFee)\n//         throw new FundingError('Fee is too high.');\n\n//       // Failed to get enough funds, add more coins.\n//       if (!this.isFull())\n//         this.fund();\n//     } while (!this.isFull() && this.index < this.coins.length);\n//   }\n\n//   /**\n//    * Initiate selection based on a hard fee.\n//    */\n\n//   selectHard() {\n//     this.fee = Math.min(this.hardFee, CoinSelector.MAX_FEE);\n//     this.fund();\n//   }\n// }\n\n// /**\n//  * Default fee rate\n//  * for coin selection.\n//  * @const {Amount}\n//  * @default\n//  */\n\n// CoinSelector.FEE_RATE = 10000;\n\n// /**\n//  * Minimum fee to start with\n//  * during coin selection.\n//  * @const {Amount}\n//  * @default\n//  */\n\n// CoinSelector.MIN_FEE = 10000;\n\n// /**\n//  * Maximum fee to allow\n//  * after coin selection.\n//  * @const {Amount}\n//  * @default\n//  */\n\n// CoinSelector.MAX_FEE = consensus.COIN / 10;\n\n// /**\n//  * Funding Error\n//  * An error thrown from the coin selector.\n//  * @ignore\n//  * @extends Error\n//  * @property {String} message - Error message.\n//  * @property {Amount} availableFunds\n//  * @property {Amount} requiredFunds\n//  */\n\n// class FundingError extends Error {\n//   /**\n//    * Create a funding error.\n//    * @constructor\n//    * @param {String} msg\n//    * @param {Amount} available\n//    * @param {Amount} required\n//    */\n\n//   constructor(msg, available, required) {\n//     super();\n\n//     this.type = 'FundingError';\n//     this.message = msg;\n//     this.availableFunds = -1;\n//     this.requiredFunds = -1;\n\n//     if (available != null) {\n//       this.message += ` (available=${Amount.btc(available)},`;\n//       this.message += ` required=${Amount.btc(required)})`;\n//       this.availableFunds = available;\n//       this.requiredFunds = required;\n//     }\n\n//     if (Error.captureStackTrace)\n//       Error.captureStackTrace(this, FundingError);\n//   }\n// }\n\n// /*\n//  * Helpers\n//  */\n\n// function sortAge(a, b) {\n//   a = a.height === -1 ? 0x7fffffff : a.height;\n//   b = b.height === -1 ? 0x7fffffff : b.height;\n//   return a - b;\n// }\n\n// function sortRandom(a, b) {\n//   return Math.random() > 0.5 ? 1 : -1;\n// }\n\n// function sortValue(a, b) {\n//   if (a.height === -1 && b.height !== -1)\n//     return 1;\n\n//   if (a.height !== -1 && b.height === -1)\n//     return -1;\n\n//   return b.value - a.value;\n// }\n\n// function sortInputs(a, b) {\n//   return a.compare(b);\n// }\n\n// function sortOutputs(a, b) {\n//   return a.compare(b);\n// }\n\n/*\n * Expose\n */\n\nexports = MTX;\nexports.MTX = MTX;\nexports.Selector = CoinSelector;\nexports.FundingError = FundingError;\n\nmodule.exports = exports;\n"]},"metadata":{},"sourceType":"module"}