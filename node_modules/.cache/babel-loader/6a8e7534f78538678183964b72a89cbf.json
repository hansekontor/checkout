{"ast":null,"code":"/*!\n * rsa.js - RSA for javascript\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on golang/go:\n *   Copyright (c) 2009 The Go Authors. All rights reserved.\n *   https://github.com/golang/go\n *\n * Parts of this software are based on indutny/miller-rabin:\n *   Copyright (c) 2014, Fedor Indutny (MIT License).\n *   https://github.com/indutny/miller-rabin\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/RSA_(cryptosystem)\n *   https://tools.ietf.org/html/rfc3447\n *   https://tools.ietf.org/html/rfc8017\n *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_ossl.c\n *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_sign.c\n *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_oaep.c\n *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_pss.c\n *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_pk1.c\n *   https://github.com/golang/go/blob/master/src/crypto/rsa/rsa.go\n *   https://github.com/golang/go/blob/master/src/crypto/rsa/pkcs1v15.go\n *   https://github.com/golang/go/blob/master/src/crypto/rsa/pss.go\n *   https://github.com/golang/go/blob/master/src/crypto/subtle/constant_time.go\n *   https://github.com/ARMmbed/mbed-crypto/blob/master/library/rsa.c\n *\n * References:\n *\n *   [RFC8017] PKCS #1: RSA Cryptography Specifications Version 2.2\n *     K. Moriarty, B. Kaliski, J. Jonsson, A. Rusch\n *     https://tools.ietf.org/html/rfc8017\n *\n *   [FIPS186] Federal Information Processing Standards Publication 186-4\n *     National Institute of Standards and Technology\n *     https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst BN = require('../bn');\n\nconst rng = require('../random');\n\nconst {\n  randomPrime\n} = require('../internal/primes');\n\nconst base64 = require('../encoding/base64');\n\nconst asn1 = require('../internal/asn1');\n\nconst safe = require('../safe');\n\nconst {\n  safeEqual,\n  safeEqualByte,\n  safeSelect,\n  safeLTE\n} = safe;\n/*\n * Constants\n */\n\nconst DEFAULT_BITS = 2048;\nconst DEFAULT_EXP = 65537;\nconst MIN_BITS = 512;\nconst MAX_BITS = 16384;\nconst MIN_EXP = 3;\nconst MAX_EXP = 2 ** 33 - 1;\nconst MAX_EXP_BITS = 33;\nconst SALT_LENGTH_AUTO = 0;\nconst SALT_LENGTH_HASH = -1;\nconst PREFIX = Buffer.alloc(8, 0x00);\nconst EMPTY = Buffer.alloc(0);\n/**\n * PKCS1v1.5+ASN.1 DigestInfo prefixes.\n * @see [RFC8017] Page 45, Section 9.2.\n * @see [RFC8017] Page 63, Section B.1.\n * @const {Object}\n */\n\nconst digestInfo = {\n  __proto__: null,\n  BLAKE2B160: Buffer.from('3027300f060b2b060104018d3a0c02010505000414', 'hex'),\n  BLAKE2B256: Buffer.from('3033300f060b2b060104018d3a0c02010805000420', 'hex'),\n  BLAKE2B384: Buffer.from('3043300f060b2b060104018d3a0c02010c05000430', 'hex'),\n  BLAKE2B512: Buffer.from('3053300f060b2b060104018d3a0c02011005000440', 'hex'),\n  BLAKE2S128: Buffer.from('3023300f060b2b060104018d3a0c02020405000410', 'hex'),\n  BLAKE2S160: Buffer.from('3027300f060b2b060104018d3a0c02020505000414', 'hex'),\n  BLAKE2S224: Buffer.from('302f300f060b2b060104018d3a0c0202070500041c', 'hex'),\n  BLAKE2S256: Buffer.from('3033300f060b2b060104018d3a0c02020805000420', 'hex'),\n  GOST94: Buffer.from('302e300a06062a850302021405000420', 'hex'),\n  HASH160: Buffer.from([20]),\n  HASH256: Buffer.from([32]),\n  KECCAK224: Buffer.from([28]),\n  KECCAK256: Buffer.from([32]),\n  KECCAK384: Buffer.from([48]),\n  KECCAK512: Buffer.from([64]),\n  MD2: Buffer.from('3020300c06082a864886f70d020205000410', 'hex'),\n  MD4: Buffer.from('3020300c06082a864886f70d020405000410', 'hex'),\n  MD5: Buffer.from('3020300c06082a864886f70d020505000410', 'hex'),\n  MD5SHA1: Buffer.from([36]),\n  RIPEMD160: Buffer.from('3022300a060628cf0603003105000414', 'hex'),\n  SHA1: Buffer.from('3021300906052b0e03021a05000414', 'hex'),\n  SHA224: Buffer.from('302d300d06096086480165030402040500041c', 'hex'),\n  SHA256: Buffer.from('3031300d060960864801650304020105000420', 'hex'),\n  SHA384: Buffer.from('3041300d060960864801650304020205000430', 'hex'),\n  SHA512: Buffer.from('3051300d060960864801650304020305000440', 'hex'),\n  SHA3_224: Buffer.from('302d300d06096086480165030402070500041c', 'hex'),\n  SHA3_256: Buffer.from('3031300d060960864801650304020805000420', 'hex'),\n  SHA3_384: Buffer.from('3041300d060960864801650304020905000430', 'hex'),\n  SHA3_512: Buffer.from('3051300d060960864801650304020a05000440', 'hex'),\n  SHAKE128: Buffer.from('3021300d060960864801650304020b05000410', 'hex'),\n  SHAKE256: Buffer.from('3031300d060960864801650304020c05000420', 'hex'),\n  WHIRLPOOL: Buffer.from('304e300a060628cf0603003705000440', 'hex')\n};\n/**\n * RSAPublicKey\n */\n\nclass RSAPublicKey {\n  constructor() {\n    this.n = new BN(0);\n    this.e = new BN(0);\n  }\n\n  bits() {\n    return this.n.bitLength();\n  }\n\n  size() {\n    return this.n.byteLength();\n  }\n\n  isSane() {\n    return this.n.sign() > 0 && this.e.sign() > 0 && this.n.bitLength() <= MAX_BITS && this.e.bitLength() <= MAX_EXP_BITS;\n  }\n\n  verify() {\n    // Sanity checks.\n    if (!this.isSane()) return false; // n >= 2^511 and n mod 2 != 0\n\n    if (this.n.bitLength() < MIN_BITS || !this.n.isOdd()) return false; // e >= 3 and e mod 2 != 0\n\n    if (this.e.cmpn(MIN_EXP) < 0 || !this.e.isOdd()) return false;\n    return true;\n  }\n\n  encrypt(msg) {\n    // [RFC8017] Page 13, Section 5.1.1.\n    //           Page 16, Section 5.2.2.\n    assert(Buffer.isBuffer(msg));\n    const {\n      n,\n      e\n    } = this;\n    const m = BN.decode(msg);\n    if (m.cmp(n) >= 0) throw new Error('Invalid RSA message size.'); // c = m^e mod n\n\n    const c = m.powm(e, n);\n    return c.encode('be', n.byteLength());\n  }\n\n  encode() {\n    const size = asn1.sizeInt(this.n) + asn1.sizeInt(this.e);\n    const out = Buffer.alloc(asn1.sizeSeq(size));\n    let pos = 0;\n    pos = asn1.writeSeq(out, pos, size);\n    pos = asn1.writeInt(out, pos, this.n);\n    pos = asn1.writeInt(out, pos, this.e);\n    assert(pos === out.length);\n    return out;\n  }\n\n  decode(data) {\n    let pos = 0;\n    pos = asn1.readSeq(data, pos);\n    [this.n, pos] = asn1.readInt(data, pos);\n    [this.e, pos] = asn1.readInt(data, pos);\n    if (pos !== data.length) throw new Error('Trailing bytes.');\n    return this;\n  }\n\n  static decode(data) {\n    return new RSAPublicKey().decode(data);\n  }\n\n}\n/**\n * RSAPrivateKey\n */\n\n\nclass RSAPrivateKey extends RSAPublicKey {\n  constructor() {\n    super();\n    this.d = new BN(0);\n    this.p = new BN(0);\n    this.q = new BN(0);\n    this.dp = new BN(0);\n    this.dq = new BN(0);\n    this.qi = new BN(0);\n  }\n\n  isSane() {\n    return this.n.sign() > 0 && this.e.sign() > 0 && this.d.sign() > 0 && this.p.sign() > 0 && this.q.sign() > 0 && this.dp.sign() > 0 && this.dq.sign() > 0 && this.qi.sign() > 0 && this.n.bitLength() <= MAX_BITS && this.e.bitLength() <= MAX_EXP_BITS && this.d.bitLength() <= MAX_BITS && this.p.bitLength() <= MAX_BITS && this.q.bitLength() <= MAX_BITS && this.dp.bitLength() <= MAX_BITS && this.dq.bitLength() <= MAX_BITS && this.qi.bitLength() <= MAX_BITS;\n  }\n\n  verify() {\n    // Sanity checks.\n    if (!this.isSane()) return false; // n >= 2^511 and n mod 2 != 0\n\n    if (this.n.bitLength() < MIN_BITS || !this.n.isOdd()) return false; // e >= 3 and e mod 2 != 0\n\n    if (this.e.cmpn(MIN_EXP) < 0 || !this.e.isOdd()) return false; // p >= 3 and p mod 2 != 0\n\n    if (this.p.cmpn(3) < 0 || !this.p.isOdd()) return false; // q >= 3 and q mod 2 != 0\n\n    if (this.q.cmpn(3) < 0 || !this.q.isOdd()) return false; // phi = (p - 1) * (q - 1)\n\n    const pm1 = this.p.subn(1);\n    const qm1 = this.q.subn(1);\n    const phi = pm1.mul(qm1); // d >= 2 and d < phi\n\n    if (this.d.cmpn(2) < 0 || this.d.cmp(phi) >= 0) return false; // dp != 0 and dp < p - 1\n\n    if (this.dp.sign() === 0 || this.dp.cmp(pm1) >= 0) return false; // dq != 0 and dq < q - 1\n\n    if (this.dq.sign() === 0 || this.dq.cmp(qm1) >= 0) return false; // qi <= 2 and qi < p\n\n    if (this.qi.cmpn(2) < 0 || this.qi.cmp(this.p) >= 0) return false; // p != q\n\n    if (this.p.cmp(this.q) === 0) return false; // n == p * q\n\n    if (this.p.mul(this.q).cmp(this.n) !== 0) return false; // lam = lcm(p - 1, q - 1)\n\n    const lam = phi.div(pm1.gcd(qm1)); // e * d mod lam\n\n    if (this.e.mul(this.d).imod(lam).cmpn(1) !== 0) return false; // dp == d mod (p - 1)\n\n    if (this.d.mod(pm1).cmp(this.dp) !== 0) return false; // dq == d mod (q - 1)\n\n    if (this.d.mod(qm1).cmp(this.dq) !== 0) return false; // q * qi mod p == 1\n\n    if (this.q.mul(this.qi).imod(this.p).cmpn(1) !== 0) return false;\n    return true;\n  }\n\n  decrypt(msg) {\n    // [RFC8017] Page 13, Section 5.1.2.\n    //           Page 15, Section 5.2.1.\n    assert(Buffer.isBuffer(msg));\n    const {\n      n,\n      e,\n      p,\n      q,\n      dp,\n      dq,\n      qi\n    } = this; // Decode message.\n\n    const c = BN.decode(msg); // Validate params.\n\n    if (c.cmp(n) >= 0) throw new Error('Invalid RSA message size.'); // Generate blinding factor.\n\n    let b, bi;\n\n    for (;;) {\n      // s = random integer in [1,n-1]\n      const s = BN.random(rng, 1, n); // bi = s^-1 mod n\n\n      try {\n        bi = s.invert(n);\n      } catch (e) {\n        continue;\n      } // b = s^e mod n\n\n\n      b = s.powm(e, n);\n      break;\n    } // Blind.\n\n\n    c.imul(b).imod(n); // Leverage Chinese Remainder Theorem.\n    //\n    // Computation:\n    //\n    //   mp = c^(d mod p-1) mod p\n    //   mq = c^(d mod q-1) mod q\n    //   md = (mp - mq) / q mod p\n    //   m = (md * q + mq) mod n\n\n    const mp = c.powm(dp, p, true);\n    const mq = c.powm(dq, q, true);\n    const md = mp.sub(mq).mul(qi).imod(p);\n    const m = md.mul(q).iadd(mq).imod(n);\n    if (m.powm(e, n).cmp(c) !== 0) throw new Error('Invalid RSA private key.'); // Unblind.\n\n    m.imul(bi).imod(n);\n    return m.encode('be', n.byteLength());\n  }\n\n  generate(bits, exponent) {\n    // [RFC8017] Page 9, Section 3.2.\n    // [FIPS186] Page 51, Appendix B.3.1\n    //           Page 55, Appendix B.3.3\n    //\n    // There are two methods for choosing `d`.\n    // Implementations differ on whether they\n    // use Euler's totient or the Carmichael\n    // function.\n    //\n    // The best explanation of Euler's phi vs.\n    // Carmichael's lambda I've seen comes from\n    // the crypto stackexchange[1].\n    //\n    // Note that both functions are _equivalent_\n    // when used with RSA, however, Carmichael's\n    // may lend itself to some perf benefits.\n    //\n    // [1] https://crypto.stackexchange.com/a/29595\n    assert(bits >>> 0 === bits);\n    assert(Number.isSafeInteger(exponent) && exponent >= 0);\n    assert(bits >= 64);\n    assert(exponent >= 3 && (exponent & 1) !== 0);\n    const e = new BN(exponent);\n\n    for (;;) {\n      const p = randomPrime((bits >>> 1) + (bits & 1));\n      const q = randomPrime(bits >>> 1);\n      if (p.cmp(q) === 0) continue;\n      if (p.cmp(q) < 0) p.swap(q);\n      if (p.sub(q).bitLength() <= (bits >>> 1) - 99) continue;\n      const n = p.mul(q);\n      if (n.bitLength() !== bits) continue; // Euler's totient: (p - 1) * (q - 1).\n\n      const pm1 = p.subn(1);\n      const qm1 = q.subn(1);\n      const phi = pm1.mul(qm1);\n      if (e.gcd(phi).cmpn(1) !== 0) continue; // Carmichael's function: lcm(p - 1, q - 1).\n\n      const lam = phi.div(pm1.gcd(qm1));\n      const d = e.invert(lam);\n      if (d.bitLength() <= bits + 1 >>> 1) continue;\n      const dp = d.mod(pm1);\n      const dq = d.mod(qm1);\n      const qi = q.invert(p);\n      this.n = n;\n      this.e = e;\n      this.d = d;\n      this.p = p;\n      this.q = q;\n      this.dp = dp;\n      this.dq = dq;\n      this.qi = qi;\n      return this;\n    }\n  }\n\n  async _generateSubtle(bits, exponent) {\n    assert(bits >>> 0 === bits);\n    assert(Number.isSafeInteger(exponent) && exponent >= 0);\n    assert(bits >= 64);\n    assert(exponent >= 3 && (exponent & 1) !== 0);\n    const crypto = global.crypto || global.msCrypto;\n    if (!crypto) throw new Error('Crypto API not available.');\n    const {\n      subtle\n    } = crypto;\n    if (!subtle || !subtle.generateKey || !subtle.exportKey) throw new Error('Subtle API not available.');\n    const e = new BN(exponent);\n    const algo = {\n      name: 'RSASSA-PKCS1-v1_5',\n      modulusLength: bits,\n      publicExponent: new Uint8Array(e.toArray('be', 8)),\n      hash: {\n        name: 'SHA-256'\n      }\n    };\n    const ck = await subtle.generateKey(algo, true, ['sign']);\n    const jwk = await subtle.exportKey('jwk', ck.privateKey);\n    const p = BN.decode(base64.decodeURL(jwk.p));\n    const q = BN.decode(base64.decodeURL(jwk.q));\n    return this.fromPQE(p, q, e);\n  }\n\n  async generateAsync(bits, exponent) {\n    try {\n      return await this._generateSubtle(bits, exponent);\n    } catch (e) {\n      return this.generate(bits, exponent);\n    }\n  }\n\n  fromPQE(p, q, e) {\n    assert(p instanceof BN);\n    assert(q instanceof BN);\n    assert(e instanceof BN);\n    if (p.cmp(q) < 0) [p, q] = [q, p];\n    if (p.cmp(q) === 0) throw new Error('Invalid RSA private key.');\n    if (p.cmpn(3) < 0 || p.bitLength() > MAX_BITS) throw new Error('Invalid RSA private key.');\n    if (q.cmpn(3) < 0 || q.bitLength() > MAX_BITS) throw new Error('Invalid RSA private key.');\n    if (e.cmpn(MIN_EXP) < 0 || e.bitLength() > MAX_EXP_BITS) throw new Error('Invalid RSA private key.');\n    if (!p.isOdd() || !q.isOdd() || !e.isOdd()) throw new Error('Invalid RSA private key.');\n    const n = p.mul(q);\n    assert(n.isOdd());\n    if (n.bitLength() < MIN_BITS || n.bitLength() > MAX_BITS) throw new Error('Invalid RSA private key.');\n    const pm1 = p.subn(1);\n    const qm1 = q.subn(1);\n    const lam = pm1.lcm(qm1);\n    const d = e.invert(lam);\n    const dp = d.mod(pm1);\n    const dq = d.mod(qm1);\n    const qi = q.invert(p);\n    this.n = n;\n    this.e = e;\n    this.d = d;\n    this.p = p;\n    this.q = q;\n    this.dp = dp;\n    this.dq = dq;\n    this.qi = qi;\n    return this;\n  }\n\n  fromPQD(p, q, d) {\n    assert(p instanceof BN);\n    assert(q instanceof BN);\n    assert(d instanceof BN);\n    if (p.cmpn(3) < 0 || p.bitLength() > MAX_BITS) throw new Error('Invalid RSA private key.');\n    if (q.cmpn(3) < 0 || q.bitLength() > MAX_BITS) throw new Error('Invalid RSA private key.');\n    if (!p.isOdd() || !q.isOdd()) throw new Error('Invalid RSA private key.');\n    const pm1 = p.subn(1);\n    const qm1 = q.subn(1);\n    const phi = pm1.mul(qm1);\n    if (d.cmpn(2) < 0 || d.cmp(phi) >= 0) throw new Error('Invalid RSA private key.');\n    const lam = phi.div(pm1.gcd(qm1));\n    const e = d.invert(lam);\n    return this.fromPQE(p, q, e);\n  }\n\n  fromNED(n, e, d) {\n    // Factor an RSA modulus given (n, e, d).\n    //\n    // This is basically the same logic as the\n    // Miller-Rabin primality test[1][2].\n    //\n    // [1] https://crypto.stackexchange.com/questions/11509\n    // [2] https://crypto.stackexchange.com/questions/22374\n    assert(n instanceof BN);\n    assert(e instanceof BN);\n    assert(d instanceof BN);\n    if (n.sign() < 0) throw new Error('Invalid RSA private key.');\n    if (n.bitLength() < MIN_BITS || n.bitLength() > MAX_BITS) throw new Error('Invalid RSA private key.');\n    if (e.cmpn(MIN_EXP) < 0 || e.bitLength() > MAX_EXP_BITS) throw new Error('Invalid RSA private key.');\n    if (d.cmpn(2) < 0 || d.bitLength() > MAX_BITS) throw new Error('Invalid RSA private key.');\n    if (!n.isOdd() || !e.isOdd()) throw new Error('Invalid RSA private key.');\n    const f = e.mul(d).isubn(1);\n    const nm1 = n.subn(1);\n    const s = f.zeroBits();\n    const g = f.ushrn(s);\n\n    for (let i = 0; i < 64; i++) {\n      const a = BN.random(rng, 2, nm1);\n      let b = a.powm(g, n);\n      if (b.cmpn(1) === 0 || b.cmp(nm1) === 0) continue;\n\n      for (let j = 1; j < s; j++) {\n        const c = b.sqr().imod(n);\n\n        if (c.cmpn(1) === 0) {\n          const p = n.gcd(b.subn(1));\n          const q = n.gcd(b.addn(1));\n          return this.fromPQE(p, q, e);\n        }\n\n        if (c.cmp(nm1) === 0) break;\n        b = c;\n      }\n    }\n\n    throw new Error('Invalid RSA private key.');\n  }\n\n  toPublic() {\n    const pub = new RSAPublicKey();\n    pub.n = this.n;\n    pub.e = this.e;\n    return pub;\n  }\n\n  encode() {\n    let size = 0;\n    size += asn1.sizeVersion(0);\n    size += asn1.sizeInt(this.n);\n    size += asn1.sizeInt(this.e);\n    size += asn1.sizeInt(this.d);\n    size += asn1.sizeInt(this.p);\n    size += asn1.sizeInt(this.q);\n    size += asn1.sizeInt(this.dp);\n    size += asn1.sizeInt(this.dq);\n    size += asn1.sizeInt(this.qi);\n    const out = Buffer.alloc(asn1.sizeSeq(size));\n    let pos = 0;\n    pos = asn1.writeSeq(out, pos, size);\n    pos = asn1.writeVersion(out, pos, 0);\n    pos = asn1.writeInt(out, pos, this.n);\n    pos = asn1.writeInt(out, pos, this.e);\n    pos = asn1.writeInt(out, pos, this.d);\n    pos = asn1.writeInt(out, pos, this.p);\n    pos = asn1.writeInt(out, pos, this.q);\n    pos = asn1.writeInt(out, pos, this.dp);\n    pos = asn1.writeInt(out, pos, this.dq);\n    pos = asn1.writeInt(out, pos, this.qi);\n    assert(pos === out.length);\n    return out;\n  }\n\n  decode(data) {\n    let pos = 0;\n    pos = asn1.readSeq(data, pos);\n    pos = asn1.readVersion(data, pos, 0);\n    [this.n, pos] = asn1.readInt(data, pos);\n    [this.e, pos] = asn1.readInt(data, pos);\n    [this.d, pos] = asn1.readInt(data, pos);\n    [this.p, pos] = asn1.readInt(data, pos);\n    [this.q, pos] = asn1.readInt(data, pos);\n    [this.dp, pos] = asn1.readInt(data, pos);\n    [this.dq, pos] = asn1.readInt(data, pos);\n    [this.qi, pos] = asn1.readInt(data, pos);\n    if (pos !== data.length) throw new Error('Trailing bytes.');\n    return this;\n  }\n\n  static generate(bits, exponent) {\n    return new RSAPrivateKey().generate(bits, exponent);\n  }\n\n  static async generateAsync(bits, exponent) {\n    return new RSAPrivateKey().generateAsync(bits, exponent);\n  }\n\n  static fromPQE(p, q, e) {\n    return new RSAPrivateKey().fromPQE(p, q, e);\n  }\n\n  static fromPQD(p, q, d) {\n    return new RSAPrivateKey().fromPQD(p, q, d);\n  }\n\n  static fromNED(n, e, d) {\n    return new RSAPrivateKey().fromNED(n, e, d);\n  }\n\n  static decode(data) {\n    return new RSAPrivateKey().decode(data);\n  }\n\n}\n/**\n * Generate a private key.\n * @param {Number} [bits=2048]\n * @param {Number} [exponent=65537]\n * @returns {Buffer} Private key.\n */\n\n\nfunction privateKeyGenerate(bits, exponent) {\n  if (bits == null) bits = DEFAULT_BITS;\n  if (exponent == null) exponent = DEFAULT_EXP;\n  assert(bits >>> 0 === bits);\n  assert(Number.isSafeInteger(exponent) && exponent >= 0);\n  if (bits < MIN_BITS || bits > MAX_BITS) throw new RangeError(`\"bits\" ranges from ${MIN_BITS} to ${MAX_BITS}.`);\n  if (exponent < MIN_EXP || exponent > MAX_EXP) throw new RangeError(`\"exponent\" ranges from ${MIN_EXP} to ${MAX_EXP}.`);\n  if (exponent === 1 || (exponent & 1) === 0) throw new RangeError('\"exponent\" must be odd.');\n  const key = RSAPrivateKey.generate(bits, exponent);\n  return key.encode();\n}\n/**\n * Generate a private key.\n * @param {Number} [bits=2048]\n * @param {Number} [exponent=65537]\n * @returns {Buffer} Private key.\n */\n\n\nasync function privateKeyGenerateAsync(bits, exponent) {\n  if (bits == null) bits = DEFAULT_BITS;\n  if (exponent == null) exponent = DEFAULT_EXP;\n  assert(bits >>> 0 === bits);\n  assert(Number.isSafeInteger(exponent) && exponent >= 0);\n  if (bits < MIN_BITS || bits > MAX_BITS) throw new RangeError(`\"bits\" ranges from ${MIN_BITS} to ${MAX_BITS}.`);\n  if (exponent < MIN_EXP || exponent > MAX_EXP) throw new RangeError(`\"exponent\" ranges from ${MIN_EXP} to ${MAX_EXP}.`);\n  if (exponent === 1 || (exponent & 1) === 0) throw new RangeError('\"exponent\" must be odd.');\n  const key = await RSAPrivateKey.generateAsync(bits, exponent);\n  return key.encode();\n}\n/**\n * Get a private key's modulus size in bits.\n * @param {Buffer} key\n * @returns {Number}\n */\n\n\nfunction privateKeyBits(key) {\n  const k = RSAPrivateKey.decode(key);\n  if (!k.verify()) throw new Error('Invalid RSA private key.');\n  return k.bits();\n}\n/**\n * Verify a private key.\n * @param {Buffer} key\n * @returns {Boolean}\n */\n\n\nfunction privateKeyVerify(key) {\n  // [RFC8017] Page 9, Section 3.2.\n  assert(Buffer.isBuffer(key));\n  let k;\n\n  try {\n    k = RSAPrivateKey.decode(key);\n  } catch (e) {\n    return false;\n  }\n\n  return k.verify();\n}\n/**\n * Import a private key from an object.\n * @param {Object} json\n * @returns {Buffer}\n */\n\n\nfunction privateKeyImport(json) {\n  // [RFC8017] Page 55, Section A.1.2.\n  assert(json && typeof json === 'object');\n  let k = new RSAPrivateKey();\n  if (json.n != null) k.n = BN.decode(json.n);\n  if (json.e != null) k.e = BN.decode(json.e);\n  if (json.d != null) k.d = BN.decode(json.d);\n  if (json.p != null) k.p = BN.decode(json.p);\n  if (json.q != null) k.q = BN.decode(json.q);\n  if (json.dp != null) k.dp = BN.decode(json.dp);\n  if (json.dq != null) k.dq = BN.decode(json.dq);\n  if (json.qi != null) k.qi = BN.decode(json.qi);\n\n  if (!k.verify()) {\n    if (!k.p.isZero() && !k.q.isZero()) {\n      if (!k.e.isZero()) k = RSAPrivateKey.fromPQE(k.p, k.q, k.e);else k = RSAPrivateKey.fromPQD(k.p, k.q, k.d);\n    } else {\n      k = RSAPrivateKey.fromNED(k.n, k.e, k.d);\n    }\n  }\n\n  return k.encode();\n}\n/**\n * Export a private key to an object.\n * @param {Buffer} key\n * @returns {Object}\n */\n\n\nfunction privateKeyExport(key) {\n  // [RFC8017] Page 55, Section A.1.2.\n  const k = RSAPrivateKey.decode(key);\n  if (!k.verify()) throw new Error('Invalid RSA private key.');\n  return {\n    n: k.n.encode(),\n    e: k.e.encode(),\n    d: k.d.encode(),\n    p: k.p.encode(),\n    q: k.q.encode(),\n    dp: k.dp.encode(),\n    dq: k.dq.encode(),\n    qi: k.qi.encode()\n  };\n}\n/**\n * Create a public key from a private key.\n * @param {Buffer} key\n * @returns {Buffer}\n */\n\n\nfunction publicKeyCreate(key) {\n  const k = RSAPrivateKey.decode(key);\n  if (!k.verify()) throw new Error('Invalid RSA private key.');\n  const p = k.toPublic();\n  return p.encode();\n}\n/**\n * Get a public key's modulus size in bits.\n * @param {Buffer} key\n * @returns {Number}\n */\n\n\nfunction publicKeyBits(key) {\n  const k = RSAPublicKey.decode(key);\n  if (!k.verify()) throw new Error('Invalid RSA public key.');\n  return k.bits();\n}\n/**\n * Verify a public key.\n * @param {Buffer} key\n * @returns {Boolean}\n */\n\n\nfunction publicKeyVerify(key) {\n  // [RFC8017] Page 8, Section 3.1.\n  assert(Buffer.isBuffer(key));\n  let k;\n\n  try {\n    k = RSAPublicKey.decode(key);\n  } catch (e) {\n    return false;\n  }\n\n  return k.verify();\n}\n/**\n * Import a public key from an object.\n * @param {Object} json\n * @returns {Buffer}\n */\n\n\nfunction publicKeyImport(json) {\n  // [RFC8017] Page 54, Section A.1.1.\n  assert(json && typeof json === 'object');\n  const k = new RSAPublicKey();\n  if (json.n != null) k.n = BN.decode(json.n);\n  if (json.e != null) k.e = BN.decode(json.e);\n  if (!k.verify()) throw new Error('Invalid RSA public key.');\n  return k.encode();\n}\n/**\n * Export a public key to an object.\n * @param {Buffer} key\n * @returns {Object}\n */\n\n\nfunction publicKeyExport(key) {\n  // [RFC8017] Page 54, Section A.1.1.\n  const k = RSAPublicKey.decode(key);\n  if (!k.verify()) throw new Error('Invalid RSA public key.');\n  return {\n    n: k.n.encode(),\n    e: k.e.encode()\n  };\n}\n/**\n * Sign a message (PKCS1v1.5).\n * @param {Object|String|null} hash\n * @param {Buffer} msg\n * @param {Buffer} key - Private key.\n * @returns {Buffer} PKCS#1v1.5-formatted signature.\n */\n\n\nfunction sign(hash, msg, key) {\n  // [RFC8017] Page 36, Section 8.2.1.\n  //           Page 45, Section 9.2.\n  if (hash && typeof hash.id === 'string') hash = hash.id;\n  assert(hash == null || typeof hash === 'string');\n  assert(Buffer.isBuffer(msg));\n  const [prefix, hlen] = getDigestInfo(hash, msg);\n  if (!prefix) throw new Error('Unknown RSA hash function.');\n  if (msg.length !== hlen) throw new Error('Invalid RSA message size.');\n  const k = RSAPrivateKey.decode(key);\n  if (!k.verify()) throw new Error('Invalid RSA private key.');\n  const tlen = prefix.length + hlen;\n  const klen = k.size();\n  if (klen < tlen + 11) throw new Error('Invalid RSA message size.'); // EM = 0x00 || 0x01 || PS || 0x00 || T\n\n  const em = Buffer.allocUnsafe(klen);\n  em[0] = 0x00;\n  em[1] = 0x01;\n\n  for (let i = 2; i < klen - tlen - 1; i++) em[i] = 0xff;\n\n  em[klen - tlen - 1] = 0x00;\n  prefix.copy(em, klen - tlen);\n  msg.copy(em, klen - hlen);\n  return k.decrypt(em);\n}\n/**\n * Verify a signature (PKCS1v1.5).\n * @param {Object|String|null} hash\n * @param {Buffer} msg\n * @param {Buffer} sig - PKCS#1v1.5-formatted.\n * @param {Buffer} key\n * @returns {Boolean}\n */\n\n\nfunction verify(hash, msg, sig, key) {\n  if (hash && typeof hash.id === 'string') hash = hash.id;\n  assert(hash == null || typeof hash === 'string');\n  assert(Buffer.isBuffer(msg));\n  assert(Buffer.isBuffer(sig));\n  assert(Buffer.isBuffer(key));\n\n  try {\n    return _verify(hash, msg, sig, key);\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * Verify a signature (PKCS1v1.5).\n * @private\n * @param {String} hash\n * @param {Buffer} msg\n * @param {Buffer} sig - PKCS#1v1.5-formatted.\n * @param {Buffer} key\n * @returns {Boolean}\n */\n\n\nfunction _verify(hash, msg, sig, key) {\n  // [RFC8017] Page 37, Section 8.2.2.\n  //           Page 45, Section 9.2.\n  const [prefix, hlen] = getDigestInfo(hash, msg);\n  if (!prefix) return false;\n  if (msg.length !== hlen) return false;\n  const k = RSAPublicKey.decode(key);\n  if (!k.verify()) return false;\n  const klen = k.size();\n  if (sig.length !== klen) return false;\n  const tlen = prefix.length + hlen;\n  if (klen < tlen + 11) return false;\n  const em = k.encrypt(sig); // EM = 0x00 || 0x01 || PS || 0x00 || T\n\n  let ok = 1;\n  ok &= safeEqualByte(em[0], 0x00);\n  ok &= safeEqualByte(em[1], 0x01);\n\n  for (let i = 2; i < klen - tlen - 1; i++) ok &= safeEqualByte(em[i], 0xff);\n\n  ok &= safeEqualByte(em[klen - tlen - 1], 0x00);\n  ok &= safeEqual(em.slice(klen - tlen, klen - hlen), prefix);\n  ok &= safeEqual(em.slice(klen - hlen, klen), msg);\n  return ok === 1;\n}\n/**\n * Encrypt a message with public key (PKCS1v1.5).\n * @param {Buffer} msg\n * @param {Buffer} key\n * @returns {Buffer}\n */\n\n\nfunction encrypt(msg, key) {\n  // [RFC8017] Page 28, Section 7.2.1.\n  assert(Buffer.isBuffer(msg));\n  const k = RSAPublicKey.decode(key);\n  if (!k.verify()) throw new Error('Invalid RSA public key.');\n  const klen = k.size();\n  if (msg.length > klen - 11) throw new Error('Invalid RSA message size.'); // EM = 0x00 || 0x02 || PS || 0x00 || M\n\n  const em = Buffer.allocUnsafe(klen);\n  const mlen = msg.length;\n  const plen = klen - mlen - 3;\n  em[0] = 0x00;\n  em[1] = 0x02;\n  rng.randomFill(em, 2, plen);\n\n  for (let i = 2; i < 2 + plen; i++) {\n    while (em[i] === 0x00) rng.randomFill(em, i, 1);\n  }\n\n  em[klen - mlen - 1] = 0x00;\n  msg.copy(em, klen - mlen);\n  return k.encrypt(em);\n}\n/**\n * Decrypt a message with private key (PKCS1v1.5).\n * @param {Buffer} msg\n * @param {Buffer} key\n * @returns {Buffer}\n */\n\n\nfunction decrypt(msg, key) {\n  // [RFC8017] Page 29, Section 7.2.2.\n  assert(Buffer.isBuffer(msg));\n  const k = RSAPrivateKey.decode(key);\n  if (!k.verify()) throw new Error('Invalid RSA private key.');\n  const klen = k.size();\n  if (klen < 11) throw new Error('Invalid RSA private key.');\n  if (msg.length !== klen) throw new Error('Invalid RSA message size.'); // EM = 0x00 || 0x02 || PS || 0x00 || M\n\n  const em = k.decrypt(msg);\n  const zero = safeEqualByte(em[0], 0x00);\n  const two = safeEqualByte(em[1], 0x02);\n  let index = 0;\n  let looking = 1;\n\n  for (let i = 2; i < em.length; i++) {\n    const equals0 = safeEqualByte(em[i], 0x00);\n    index = safeSelect(index, i, looking & equals0);\n    looking = safeSelect(looking, 0, equals0);\n  }\n\n  const validPS = safeLTE(2 + 8, index);\n  const valid = zero & two & (looking ^ 1) & validPS;\n  const offset = safeSelect(0, index + 1, valid);\n  if (valid === 0) throw new Error('Invalid RSA ciphertext.');\n  return em.slice(offset);\n}\n/**\n * Sign a message (PSS).\n * @param {Object} hash\n * @param {Buffer} msg\n * @param {Buffer} key - Private key.\n * @param {Number} [saltLen=SALT_LENGTH_HASH]\n * @returns {Buffer} PSS-formatted signature.\n */\n\n\nfunction signPSS(hash, msg, key, saltLen) {\n  // [RFC8017] Page 33, Section 8.1.1.\n  if (saltLen == null) saltLen = SALT_LENGTH_HASH;\n  assert(hash && typeof hash.id === 'string');\n  assert(Buffer.isBuffer(msg));\n  assert((saltLen | 0) === saltLen);\n  if (msg.length !== hash.size) throw new Error('Invalid RSA message size.');\n  const k = RSAPrivateKey.decode(key);\n  if (!k.verify()) throw new Error('Invalid RSA private key.');\n  const bits = k.bits();\n  const klen = bits + 7 >>> 3;\n  const emlen = bits + 6 >>> 3;\n  if (saltLen === SALT_LENGTH_AUTO) saltLen = emlen - 2 - hash.size;else if (saltLen === SALT_LENGTH_HASH) saltLen = hash.size;\n  if (saltLen < 0 || saltLen > klen) throw new Error('Invalid PSS salt length.');\n  const salt = rng.randomBytes(saltLen);\n  const em = pssEncode(hash, msg, bits - 1, salt); // Note that `em` may be one byte less\n  // than the modulus size in the case\n  // of (bits - 1) mod 8 == 0.\n\n  return k.decrypt(em);\n}\n/**\n * Verify a signature (PSS).\n * @param {Object} hash\n * @param {Buffer} msg\n * @param {Buffer} sig - PSS-formatted.\n * @param {Buffer} key\n * @param {Number} [saltLen=SALT_LENGTH_HASH]\n * @returns {Boolean}\n */\n\n\nfunction verifyPSS(hash, msg, sig, key, saltLen) {\n  if (saltLen == null) saltLen = SALT_LENGTH_HASH;\n  assert(hash && typeof hash.id === 'string');\n  assert(Buffer.isBuffer(msg));\n  assert(Buffer.isBuffer(sig));\n  assert(Buffer.isBuffer(key));\n  assert((saltLen | 0) === saltLen);\n\n  try {\n    return _verifyPSS(hash, msg, sig, key, saltLen);\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * Verify a signature (PSS).\n * @private\n * @param {Object} hash\n * @param {Buffer} msg\n * @param {Buffer} sig - PSS-formatted.\n * @param {Buffer} key\n * @param {Number} saltLen\n * @returns {Boolean}\n */\n\n\nfunction _verifyPSS(hash, msg, sig, key, saltLen) {\n  // [RFC8017] Page 34, Section 8.1.2.\n  if (msg.length !== hash.size) return false;\n  const k = RSAPublicKey.decode(key);\n  if (!k.verify()) return false;\n  const bits = k.bits();\n  const klen = bits + 7 >>> 3;\n  if (sig.length !== klen) return false;\n  if (saltLen === SALT_LENGTH_AUTO) saltLen = 0; // Handled in pssVerify.\n  else if (saltLen === SALT_LENGTH_HASH) saltLen = hash.size;\n  if (saltLen < 0 || saltLen > klen) return false;\n  let em = k.encrypt(sig); // Edge case: the encoding crossed a\n  // a byte boundary. Our encryption\n  // function pads to the modulus size\n  // by default, meaning there's one\n  // extra zero byte prepended.\n\n  if ((bits - 1 & 7) === 0) {\n    if (em[0] !== 0x00) return false;\n    em = em.slice(1);\n  }\n\n  return pssVerify(hash, msg, em, bits - 1, saltLen);\n}\n/**\n * Encrypt a message with public key (OAEP).\n * @param {Object} hash\n * @param {Buffer} msg\n * @param {Buffer} key\n * @param {Buffer?} label\n * @returns {Buffer}\n */\n\n\nfunction encryptOAEP(hash, msg, key, label) {\n  // [RFC8017] Page 22, Section 7.1.1.\n  if (label == null) label = EMPTY;\n  assert(hash && typeof hash.id === 'string');\n  assert(Buffer.isBuffer(msg));\n  assert(Buffer.isBuffer(label));\n  const k = RSAPublicKey.decode(key);\n  if (!k.verify()) throw new Error('Invalid RSA public key.');\n  const klen = k.size();\n  const mlen = msg.length;\n  const hlen = hash.size;\n  if (mlen > klen - 2 * hlen - 2) throw new Error('Invalid RSA message size.'); // EM = 0x00 || (seed) || (Hash(L) || PS || 0x01 || M)\n\n  const em = Buffer.allocUnsafe(klen);\n  const lhash = hash.digest(label);\n  const seed = em.slice(1, 1 + hlen);\n  const db = em.slice(1 + hlen);\n  const dlen = db.length;\n  em[0] = 0x00;\n  rng.randomFill(seed, 0, seed.length);\n  lhash.copy(db, 0);\n  db.fill(0x00, hlen, dlen - mlen - 1);\n  db[dlen - mlen - 1] = 0x01;\n  msg.copy(db, dlen - mlen);\n  mgf1xor(hash, db, seed);\n  mgf1xor(hash, seed, db);\n  return k.encrypt(em);\n}\n/**\n * Decrypt a message with private key (OAEP).\n * @param {Object} hash\n * @param {Buffer} msg\n * @param {Buffer} key\n * @param {Buffer?} label\n * @returns {Buffer}\n */\n\n\nfunction decryptOAEP(hash, msg, key, label) {\n  // [RFC8017] Page 25, Section 7.1.2.\n  if (label == null) label = EMPTY;\n  assert(hash && typeof hash.id === 'string');\n  assert(Buffer.isBuffer(msg));\n  assert(Buffer.isBuffer(label));\n  const k = RSAPrivateKey.decode(key);\n  if (!k.verify()) throw new Error('Invalid RSA private key.');\n  const klen = k.size();\n  const mlen = msg.length;\n  const hlen = hash.size;\n  if (klen < hlen * 2 + 2) throw new Error('Invalid RSA private key size.');\n  if (mlen !== klen) throw new Error('Invalid RSA message size.'); // EM = 0x00 || (seed) || (Hash(L) || PS || 0x01 || M)\n\n  const em = k.decrypt(msg);\n  const expect = hash.digest(label);\n  const zero = safeEqualByte(em[0], 0x00);\n  const seed = em.slice(1, hlen + 1);\n  const db = em.slice(hlen + 1);\n  mgf1xor(hash, seed, db);\n  mgf1xor(hash, db, seed);\n  const lhash = db.slice(0, hlen);\n  const lvalid = safeEqual(lhash, expect);\n  const rest = db.slice(hlen);\n  let looking = 1;\n  let index = 0;\n  let invalid = 0;\n\n  for (let i = 0; i < rest.length; i++) {\n    const equals0 = safeEqualByte(rest[i], 0x00);\n    const equals1 = safeEqualByte(rest[i], 0x01);\n    index = safeSelect(index, i, looking & equals1);\n    looking = safeSelect(looking, 0, equals1);\n    invalid = safeSelect(invalid, 1, looking & (equals0 ^ 1));\n  }\n\n  const valid = zero & lvalid & (invalid ^ 1) & (looking ^ 1);\n  if (valid === 0) throw new Error('Invalid RSA ciphertext.');\n  return rest.slice(index + 1);\n}\n/**\n * \"Veil\" an RSA ciphertext to hide the key size.\n * @param {Buffer} msg\n * @param {Number} bits\n * @param {Buffer} key\n * @returns {Buffer}\n */\n\n\nfunction veil(msg, bits, key) {\n  assert(Buffer.isBuffer(msg));\n  assert(bits >>> 0 === bits);\n  const k = RSAPublicKey.decode(key);\n  if (!k.verify()) throw new Error('Invalid RSA public key.');\n  if (msg.length !== k.size()) throw new Error('Invalid RSA ciphertext.');\n  if (bits < k.bits()) throw new Error('Cannot make ciphertext smaller.');\n  const bytes = bits + 7 >>> 3;\n  const c = BN.decode(msg);\n  if (c.cmp(k.n) >= 0) throw new Error('Invalid RSA ciphertext.');\n  const vmax = BN.shift(1, bits);\n  const rmax = vmax.sub(c).iadd(k.n).isubn(1).div(k.n);\n  assert(rmax.sign() > 0);\n  let v = vmax;\n\n  while (v.cmp(vmax) >= 0) {\n    const r = BN.random(rng, 0, rmax);\n    v = c.add(r.mul(k.n));\n  }\n\n  assert(v.mod(k.n).cmp(c) === 0);\n  assert(v.bitLength() <= bits);\n  return v.encode('be', bytes);\n}\n/**\n * \"Unveil\" a veiled RSA ciphertext.\n * @param {Buffer} msg\n * @param {Number} bits\n * @param {Buffer} key\n * @returns {Buffer}\n */\n\n\nfunction unveil(msg, bits, key) {\n  assert(Buffer.isBuffer(msg));\n  assert(bits >>> 0 === bits);\n  const k = RSAPublicKey.decode(key);\n  if (!k.verify()) throw new Error('Invalid RSA public key.');\n  const klen = k.size();\n  if (msg.length < klen) throw new Error('Invalid RSA ciphertext.');\n  const v = BN.decode(msg);\n  if (bits !== 0 && v.bitLength() > bits) throw new Error('Invalid RSA ciphertext.');\n  const c = v.imod(k.n);\n  return c.encode('be', klen);\n}\n/*\n * Digest Info\n */\n\n\nfunction getDigestInfo(name, msg) {\n  // [RFC8017] Page 63, Section B.1.\n  assert(name == null || typeof name === 'string');\n  assert(Buffer.isBuffer(msg));\n  if (name == null) return [EMPTY, msg.length];\n  const prefix = digestInfo[name];\n  if (prefix == null) return [null, 0];\n  if (prefix.length === 1) return [EMPTY, prefix[0]];\n  return [prefix, prefix[prefix.length - 1]];\n}\n/*\n * MGF1\n */\n\n\nfunction mgf1xor(hash, out, seed) {\n  // [RFC8017] Page 67, Section B.2.1.\n  assert(hash && typeof hash.id === 'string');\n  assert(Buffer.isBuffer(out));\n  assert(Buffer.isBuffer(seed));\n  const ctr = Buffer.alloc(4, 0x00);\n  let i = 0;\n\n  while (i < out.length) {\n    const digest = hash.multi(seed, ctr);\n    let j = 0;\n\n    while (i < out.length && j < digest.length) out[i++] ^= digest[j++];\n\n    for (j = 3; j >= 0; j--) {\n      ctr[j] += 1;\n      if (ctr[j] !== 0x00) break;\n    }\n  }\n}\n/*\n * PSS\n */\n\n\nfunction pssEncode(hash, msg, embits, salt) {\n  // [RFC8017] Page 42, Section 9.1.1.\n  assert(hash && typeof hash.id === 'string');\n  assert(Buffer.isBuffer(msg));\n  assert(embits >>> 0 === embits);\n  assert(Buffer.isBuffer(salt));\n  const hlen = hash.size;\n  const slen = salt.length;\n  const emlen = embits + 7 >>> 3;\n  if (msg.length !== hlen) throw new Error('Invalid RSA message size.');\n  if (emlen < hlen + slen + 2) throw new Error('Message too long.'); // EM = (PS || 0x01 || salt) || H || 0xbc\n\n  const em = Buffer.allocUnsafe(emlen);\n  const db = em.slice(0, emlen - hlen - 1);\n  const h = em.slice(emlen - hlen - 1, emlen - 1);\n  const h0 = hash.multi(PREFIX, msg, salt);\n  const mask = 0xff >>> 8 * emlen - embits;\n  db.fill(0x00, 0, emlen - slen - hlen - 2);\n  db[emlen - slen - hlen - 2] = 0x01;\n  salt.copy(db, emlen - slen - hlen - 1);\n  h0.copy(h, 0);\n  em[emlen - 1] = 0xbc;\n  mgf1xor(hash, db, h);\n  db[0] &= mask;\n  return em;\n}\n\nfunction pssVerify(hash, msg, em, embits, slen) {\n  // [RFC8017] Page 44, Section 9.1.2.\n  assert(hash && typeof hash.id === 'string');\n  assert(Buffer.isBuffer(msg));\n  assert(Buffer.isBuffer(em));\n  assert(embits >>> 0 === embits);\n  assert(slen >>> 0 === slen);\n  const hlen = hash.size;\n  const emlen = embits + 7 >>> 3;\n  if (msg.length !== hlen) return false;\n  if (emlen < hlen + slen + 2) return false;\n  if (em[emlen - 1] !== 0xbc) return false; // EM = (PS || 0x01 || salt) || H || 0xbc\n\n  const db = em.slice(0, emlen - hlen - 1);\n  const h = em.slice(emlen - hlen - 1, emlen - 1);\n  const mask = 0xff >>> 8 * emlen - embits;\n  if (em[0] & ~mask) return false;\n  mgf1xor(hash, db, h);\n  db[0] &= mask;\n\n  if (slen === 0) {\n    // Auto\n    slen = -1;\n\n    for (let i = 0; i < db.length; i++) {\n      if (db[i] === 0x00) continue;\n\n      if (db[i] === 0x01) {\n        slen = db.length - (i + 1);\n        break;\n      }\n\n      return false;\n    }\n\n    if (slen === -1) return false;\n  } else {\n    const len = db.length - slen - 1;\n\n    for (let i = 0; i < len; i++) {\n      if (db[i] !== 0x00) return false;\n    }\n\n    if (db[len] !== 0x01) return false;\n  }\n\n  const salt = db.slice(db.length - slen);\n  const h0 = hash.multi(PREFIX, msg, salt);\n  return h0.equals(h);\n}\n/*\n * Expose\n */\n\n\nexports.native = 0;\nexports.SALT_LENGTH_AUTO = SALT_LENGTH_AUTO;\nexports.SALT_LENGTH_HASH = SALT_LENGTH_HASH;\nexports.privateKeyGenerate = privateKeyGenerate;\nexports.privateKeyGenerateAsync = privateKeyGenerateAsync;\nexports.privateKeyBits = privateKeyBits;\nexports.privateKeyVerify = privateKeyVerify;\nexports.privateKeyImport = privateKeyImport;\nexports.privateKeyExport = privateKeyExport;\nexports.publicKeyCreate = publicKeyCreate;\nexports.publicKeyBits = publicKeyBits;\nexports.publicKeyVerify = publicKeyVerify;\nexports.publicKeyImport = publicKeyImport;\nexports.publicKeyExport = publicKeyExport;\nexports.sign = sign;\nexports.verify = verify;\nexports.encrypt = encrypt;\nexports.decrypt = decrypt;\nexports.signPSS = signPSS;\nexports.verifyPSS = verifyPSS;\nexports.encryptOAEP = encryptOAEP;\nexports.decryptOAEP = decryptOAEP;\nexports.veil = veil;\nexports.unveil = unveil;","map":null,"metadata":{},"sourceType":"script"}