'use strict';

const assert = require('bsert');
const BN = require('../lib/bn');
const RNG = require('./util/rng');

const P192 = BN._prime('p192').p;
const P224 = BN._prime('p224').p;
const K256 = BN._prime('k256').p;
const P25519 = BN._prime('p25519').p;

const dhGroups = {
  p16: {
    prime: ''
      + 'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd1'
      + '29024e088a67cc74020bbea63b139b22514a08798e3404dd'
      + 'ef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245'
      + 'e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7ed'
      + 'ee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3d'
      + 'c2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f'
      + '83655d23dca3ad961c62f356208552bb9ed529077096966d'
      + '670c354e4abc9804f1746c08ca18217c32905e462e36ce3b'
      + 'e39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9'
      + 'de2bcbf6955817183995497cea956ae515d2261898fa0510'
      + '15728e5a8aaac42dad33170d04507a33a85521abdf1cba64'
      + 'ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7'
      + 'abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6b'
      + 'f12ffa06d98a0864d87602733ec86a64521f2b18177b200c'
      + 'bbe117577a615d6c770988c0bad946e208e24fa074e5ab31'
      + '43db5bfce0fd108e4b82d120a92108011a723c12a787e6d7'
      + '88719a10bdba5b2699c327186af4e23c1a946834b6150bda'
      + '2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6'
      + '287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed'
      + '1f612970cee2d7afb81bdd762170481cd0069127d5b05aa9'
      + '93b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199'
      + 'ffffffffffffffff',
    priv: ''
      + '6d5923e6449122cbbcc1b96093e0b7e4fd3e469f58daddae'
      + '53b49b20664f4132675df9ce98ae0cfdcac0f4181ccb643b'
      + '625f98104dcf6f7d8e81961e2cab4b5014895260cb977c7d'
      + '2f981f8532fb5da60b3676dfe57f293f05d525866053ac7e'
      + '65abfd19241146e92e64f309a97ef3b529af4d6189fa416c'
      + '9e1a816c3bdf88e5edf48fbd8233ef9038bb46faa95122c0'
      + '5a426be72039639cd2d53d37254b3d258960dcb33c255ede'
      + '20e9d7b4b123c8b4f4b986f53cdd510d042166f7dd7dca98'
      + '7c39ab36381ba30a5fdd027eb6128d2ef8e5802a2194d422'
      + 'b05fe6e1cb4817789b923d8636c1ec4b7601c90da3ddc178'
      + '52f59217ae070d87f2e75cbfb6ff92430ad26a71c8373452'
      + 'ae1cc5c93350e2d7b87e0acfeba401aaf518580937bf0b6c'
      + '341f8c49165a47e49ce50853989d07171c00f43dcddddf72'
      + '94fb9c3f4e1124e98ef656b797ef48974ddcd43a21fa06d0'
      + '565ae8ce494747ce9e0ea0166e76eb45279e5c6471db7df8'
      + 'cc88764be29666de9c545e72da36da2f7a352fb17bdeb982'
      + 'a6dc0193ec4bf00b2e533efd6cd4d46e6fb237b775615576'
      + 'dd6c7c7bbc087a25e6909d1ebc6e5b38e5c8472c0fc429c6'
      + 'f17da1838cbcd9bbef57c5b5522fd6053e62ba21fe97c826'
      + 'd3889d0cc17e5fa00b54d8d9f0f46fb523698af965950f4b'
      + '941369e180f0aece3870d9335f2301db251595d173902cad'
      + '394eaa6ffef8be6c',
    pub: ''
      + 'd53703b7340bc89bfc47176d351e5cf86d5a18d9662eca3c'
      + '9759c83b6ccda8859649a5866524d77f79e501db923416ca'
      + '2636243836d3e6df752defc0fb19cc386e3ae48ad647753f'
      + 'bf415e2612f8a9fd01efe7aca249589590c7e6a0332630bb'
      + '29c5b3501265d720213790556f0f1d114a9e2071be3620bd'
      + '4ee1e8bb96689ac9e226f0a4203025f0267adc273a43582b'
      + '00b70b490343529eaec4dcff140773cd6654658517f51193'
      + '13f21f0a8e04fe7d7b21ffeca85ff8f87c42bb8d9cb13a72'
      + 'c00e9c6e9dfcedda0777af951cc8ccab90d35e915e707d8e'
      + '4c2aca219547dd78e9a1a0730accdc9ad0b854e51edd1e91'
      + '4756760bab156ca6e3cb9c625cf0870def34e9ac2e552800'
      + 'd6ce506d43dbbc75acfa0c8d8fb12daa3c783fb726f187d5'
      + '58131779239c912d389d0511e0f3a81969d12aeee670e48f'
      + 'ba41f7ed9f10705543689c2506b976a8ffabed45e33795b0'
      + '1df4f6b993a33d1deab1316a67419afa31fbb6fdd252ee8c'
      + '7c7d1d016c44e3fcf6b41898d7f206aa33760b505e4eff2e'
      + 'c624bc7fe636b1d59e45d6f904fc391419f13d1f0cdb5b6c'
      + '2378b09434159917dde709f8a6b5dc30994d056e3f964371'
      + '11587ac7af0a442b8367a7bd940f752ddabf31cf01171e24'
      + 'd78df136e9681cd974ce4f858a5fb6efd3234a91857bb52d'
      + '9e7b414a8bc66db4b5a73bbeccfb6eb764b4f0cbf0375136'
      + 'b024b04e698d54a5'
  },
  p17: {
    prime: ''
      + 'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd1'
      + '29024e088a67cc74020bbea63b139b22514a08798e3404dd'
      + 'ef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245'
      + 'e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7ed'
      + 'ee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3d'
      + 'c2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f'
      + '83655d23dca3ad961c62f356208552bb9ed529077096966d'
      + '670c354e4abc9804f1746c08ca18217c32905e462e36ce3b'
      + 'e39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9'
      + 'de2bcbf6955817183995497cea956ae515d2261898fa0510'
      + '15728e5a8aaac42dad33170d04507a33a85521abdf1cba64'
      + 'ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7'
      + 'abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6b'
      + 'f12ffa06d98a0864d87602733ec86a64521f2b18177b200c'
      + 'bbe117577a615d6c770988c0bad946e208e24fa074e5ab31'
      + '43db5bfce0fd108e4b82d120a92108011a723c12a787e6d7'
      + '88719a10bdba5b2699c327186af4e23c1a946834b6150bda'
      + '2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6'
      + '287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed'
      + '1f612970cee2d7afb81bdd762170481cd0069127d5b05aa9'
      + '93b4ea988d8fddc186ffb7dc90a6c08f4df435c934028492'
      + '36c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bd'
      + 'f8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831'
      + '179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1b'
      + 'db7f1447e6cc254b332051512bd7af426fb8f401378cd2bf'
      + '5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6'
      + 'd55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f3'
      + '23a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aa'
      + 'cc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be328'
      + '06a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55c'
      + 'da56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee'
      + '12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff',
    priv: ''
      + '6017f2bc23e1caff5b0a8b4e1fc72422b5204415787801dc'
      + '025762b8dbb98ab57603aaaa27c4e6bdf742b4a1726b9375'
      + 'a8ca3cf07771779589831d8bd18ddeb79c43e7e77d433950'
      + 'e652e49df35b11fa09644874d71d62fdaffb580816c2c88c'
      + '2c4a2eefd4a660360316741b05a15a2e37f236692ad3c463'
      + 'fff559938fc6b77176e84e1bb47fb41af691c5eb7bb81bd8'
      + 'c918f52625a1128f754b08f5a1403b84667231c4dfe07ed4'
      + '326234c113931ce606037e960f35a2dfdec38a5f057884d3'
      + '0af8fab3be39c1eeb390205fd65982191fc21d5aa30ddf51'
      + 'a8e1c58c0c19fc4b4a7380ea9e836aaf671c90c29bc4bcc7'
      + '813811aa436a7a9005de9b507957c56a9caa1351b6efc620'
      + '7225a18f6e97f830fb6a8c4f03b82f4611e67ab9497b9271'
      + 'd6ac252793cc3e5538990dbd894d2dbc2d152801937d9f74'
      + 'da4b741b50b4d40e4c75e2ac163f7b397fd555648b249f97'
      + 'ffe58ffb6d096aa84534c4c5729cff137759bd34e80db4ab'
      + '47e2b9c52064e7f0bf677f72ac9e5d0c6606943683f9d12f'
      + '180cf065a5cb8ec3179a874f358847a907f8471d15f1e728'
      + '7023249d6d13c82da52628654438f47b8b5cdf4761fbf6ad'
      + '9219eceac657dbd06cf2ab776ad4c968f81c3d039367f0a4'
      + 'd77c7ec4435c27b6c147071665100063b5666e06eb2fb2cc'
      + '3159ba34bc98ca346342195f6f1fb053ddc3bc1873564d40'
      + '1c6738cdf764d6e1ff25ca5926f80102ea6593c17170966b'
      + 'b5d7352dd7fb821230237ea3ebed1f920feaadbd21be295a'
      + '69f2083deae9c5cdf5f4830eb04b7c1f80cc61c17232d79f'
      + '7ecc2cc462a7965f804001c89982734e5abba2d31df1b012'
      + '152c6b226dff34510b54be8c2cd68d795def66c57a3abfb6'
      + '896f1d139e633417f8c694764974d268f46ece3a8d6616ea'
      + 'a592144be48ee1e0a1595d3e5edfede5b27cec6c48ceb2ff'
      + 'b42cb44275851b0ebf87dfc9aa2d0cb0805e9454b051dfe8'
      + 'a29fadd82491a4b4c23f2d06ba45483ab59976da1433c9ce'
      + '500164b957a04cf62dd67595319b512fc4b998424d1164dd'
      + 'bbe5d1a0f7257cbb04ec9b5ed92079a1502d98725023ecb2',
    pub: ''
      + '3bf836229c7dd874fe37c1790d201e82ed8e192ed61571ca'
      + '7285264974eb2a0171f3747b2fc23969a916cbd21e14f7e2'
      + 'f0d72dcd2247affba926f9e7bb99944cb5609aed85e71b89'
      + 'e89d2651550cb5bd8281bd3144066af78f194032aa777739'
      + 'cccb7862a1af401f99f7e5c693f25ddce2dedd9686633820'
      + 'd28d0f5ed0c6b5a094f5fe6170b8e2cbc9dff118398baee6'
      + 'e895a6301cb6e881b3cae749a5bdf5c56fc897ff68bc73f2'
      + '4811bb108b882872bade1f147d886a415cda2b93dd90190c'
      + 'be5c2dd53fe78add5960e97f58ff2506afe437f4cf4c912a'
      + '397c1a2139ac6207d3ab76e6b7ffd23bb6866dd7f87a9ae5'
      + '578789084ff2d06ea0d30156d7a10496e8ebe094f5703539'
      + '730f5fdbebc066de417be82c99c7da59953071f49da7878d'
      + 'a588775ff2a7f0084de390f009f372af75cdeba292b08ea8'
      + '4bd13a87e1ca678f9ad148145f7cef3620d69a891be46fbb'
      + 'cad858e2401ec0fd72abdea2f643e6d0197b7646fbb83220'
      + '0f4cf7a7f6a7559f9fb0d0f1680822af9dbd8dec4cd1b5e1'
      + '7bc799e902d9fe746ddf41da3b7020350d3600347398999a'
      + 'baf75d53e03ad2ee17de8a2032f1008c6c2e6618b62f225b'
      + 'a2f350179445debe68500fcbb6cae970a9920e321b468b74'
      + '5fb524fb88abbcacdca121d737c44d30724227a99745c209'
      + 'b970d1ff93bbc9f28b01b4e714d6c9cbd9ea032d4e964d8e'
      + '8fff01db095160c20b7646d9fcd314c4bc11bcc232aeccc0'
      + 'fbedccbc786951025597522eef283e3f56b44561a0765783'
      + '420128638c257e54b972a76e4261892d81222b3e2039c61a'
      + 'ab8408fcaac3d634f848ab3ee65ea1bd13c6cd75d2e78060'
      + 'e13cf67fbef8de66d2049e26c0541c679fff3e6afc290efe'
      + '875c213df9678e4a7ec484bc87dae5f0a1c26d7583e38941'
      + 'b7c68b004d4df8b004b666f9448aac1cc3ea21461f41ea5d'
      + 'd0f7a9e6161cfe0f58bcfd304bdc11d78c2e9d542e86c0b5'
      + '6985cc83f693f686eaac17411a8247bf62f5ccc7782349b5'
      + 'cc1f20e312fa2acc0197154d1bfee507e8db77e8f2732f2d'
      + '641440ccf248e8643b2bd1e1f9e8239356ab91098fcb431d',
    q: ''
      + 'a899c59999bf877d96442d284359783bdc64b5f878b688fe'
      + '51407f0526e616553ad0aaaac4d5bed3046f10a1faaf42bb'
      + '2342dc4b7908eea0c46e4c4576897675c2bfdc4467870d3d'
      + 'cd90adaed4359237a4bc6924bfb99aa6bf5f5ede15b574ea'
      + 'e977eac096f3c67d09bda574c6306c6123fa89d2f086b8dc'
      + 'ff92bc570c18d83fe6c810ccfd22ce4c749ef5e6ead3fffe'
      + 'c63d95e0e3fde1df9db6a35fa1d107058f37e41957769199'
      + 'd945dd7a373622c65f0af3fd9eb1ddc5c764bbfaf7a3dc37'
      + '2548e683b970dac4aa4b9869080d2376c9adecebb84e172c'
      + '09aeeb25fb8df23e60033260c4f8aac6b8b98ab894b1fb84'
      + 'ebb83c0fb2081c3f3eee07f44e24d8fabf76f19ed167b0d7'
      + 'ff971565aa4efa3625fce5a43ceeaa3eebb3ce88a00f597f'
      + '048c69292b38dba2103ecdd5ec4ccfe3b2d87fa6202f334b'
      + 'c1cab83b608dfc875b650b69f2c7e23c0b2b4adf149a6100'
      + 'db1b6dbad4679ecb1ea95eafaba3bd00db11c2134f5a8686'
      + '358b8b2ab49a1b2e85e1e45caeac5cd4dc0b3b5fffba8871'
      + '1c6baf399edd48dad5e5c313702737a6dbdcede80ca358e5'
      + '1d1c4fe42e8948a084403f61baed38aa9a1a5ce2918e9f33'
      + '100050a430b47bc592995606440272a4994677577a6aaa1b'
      + 'a101045dbec5a4e9566dab5445d1af3ed19519f07ac4e2a8'
      + 'bd0a84b01978f203a9125a0be020f71fab56c2c9e344d4f4'
      + '12d53d3cd8eb74ca5122002e931e3cb0bd4b7492436be17a'
      + 'd7ebe27148671f59432c36d8c56eb762655711cfc8471f70'
      + '83a8b7283bcb3b1b1d47d37c23d030288cfcef05fbdb4e16'
      + '652ee03ee7b77056a808cd700bc3d9ef826eca9a59be959c'
      + '947c865d6b372a1ca2d503d7df6d7611b12111665438475a'
      + '1c64145849b3da8c2d343410df892d958db232617f9896f1'
      + 'de95b8b5a47132be80dd65298c7f2047858409bf762dbc05'
      + 'a62ca392ac40cfb8201a0607a2cae07d99a307625f2b2d04'
      + 'fe83fbd3ab53602263410f143b73d5b46fc761882e78c782'
      + 'd2c36e716a770a7aefaf7f76cea872db7bffefdbc4c2f9e0'
      + '39c19adac915e7a63dcb8c8c78c113f29a3e0bc10e100ce0',
    qs: ''
      + '6f0a2fb763eaeb8eb324d564f03d4a55fdcd709e5f1b65e9'
      + '5702b0141182f9f945d71bc3e64a7dfdae7482a7dd5a4e58'
      + 'bc38f78de2013f2c468a621f08536969d2c8d011bb3bc259'
      + '2124692c91140a5472cad224acdacdeae5751dadfdf068b8'
      + '77bfa7374694c6a7be159fc3d24ff9eeeecaf62580427ad8'
      + '622d48c51a1c4b1701d768c79d8c819776e096d2694107a2'
      + 'f3ec0c32224795b59d32894834039dacb369280afb221bc0'
      + '90570a93cf409889b818bb30cccee98b2aa26dbba0f28499'
      + '08e1a3cd43fa1f1fb71049e5c77c3724d74dc351d9989057'
      + '37bbda3805bd6b1293da8774410fb66e3194e18cdb304dd9'
      + 'a0b59b583dcbc9fc045ac9d56aea5cfc9f8a0b95da1e11b7'
      + '574d1f976e45fe12294997fac66ca0b83fc056183549e850'
      + 'a11413cc4abbe39a211e8c8cbf82f2a23266b3c10ab9e286'
      + '07a1b6088909cddff856e1eb6b2cde8bdac53fa939827736'
      + 'ca1b892f6c95899613442bd02dbdb747f02487718e2d3f22'
      + 'f73734d29767ed8d0e346d0c4098b6fdcb4df7d0c4d29603'
      + '5bffe80d6c65ae0a1b814150d349096baaf950f2caf298d2'
      + 'b292a1d48cf82b10734fe8cedfa16914076dfe3e9b51337b'
      + 'ed28ea1e6824bb717b641ca0e526e175d3e5ed7892aebab0'
      + 'f207562cc938a821e2956107c09b6ce4049adddcd0b7505d'
      + '49ae6c69a20122461102d465d93dc03db026be54c303613a'
      + 'b8e5ce3fd4f65d0b6162ff740a0bf5469ffd442d8c509cd2'
      + '3b40dab90f6776ca17fc0678774bd6eee1fa85ababa52ec1'
      + 'a15031eb677c6c488661dddd8b83d6031fe294489ded5f08'
      + '8ad1689a14baeae7e688afa3033899c81f58de39b392ca94'
      + 'af6f15a46f19fa95c06f9493c8b96a9be25e78b9ea35013b'
      + 'caa76de6303939299d07426a88a334278fc3d0d9fa71373e'
      + 'be51d3c1076ab93a11d3d0d703366ff8cde4c11261d488e5'
      + '60a2bdf3bfe2476032294800d6a4a39d306e65c6d7d8d66e'
      + '5ec63eee94531e83a9bddc458a2b508285c0ee10b7bd94da'
      + '2815a0c5bd5b2e15cbe66355e42f5af8955cdfc0b3a4996d'
      + '288db1f4b32b15643b18193e378cb7491f3c3951cdd044b1'
      + 'a519571bffac2da986f5f1d506c66530a55f70751e24fa8e'
      + 'd83ac2347f4069fb561a5565e78c6f0207da24e889a93a96'
      + '65f717d9fe8a2938a09ab5f81be7ccecf466c0397fc15a57'
      + '469939793f302739765773c256a3ca55d0548afd117a7cae'
      + '98ca7e0d749a130c7b743d376848e255f8fdbe4cb4480b63'
      + 'cd2c015d1020cf095d175f3ca9dcdfbaf1b2a6e6468eee4c'
      + 'c750f2132a77f376bd9782b9d0ff4da98621b898e251a263'
      + '4301ba2214a8c430b2f7a79dbbfd6d7ff6e9b0c137b025ff'
      + '587c0bf912f0b19d4fff96b1ecd2ca990c89b386055c60f2'
      + '3b94214bd55096f17a7b2c0fa12b333235101cd6f28a128c'
      + '782e8a72671adadebbd073ded30bd7f09fb693565dcf0bf3'
      + '090c21d13e5b0989dd8956f18f17f4f69449a13549c9d80a'
      + '77e5e61b5aeeee9528634100e7bc390672f0ded1ca53555b'
      + 'abddbcf700b9da6192255bddf50a76b709fbed251dce4c7e'
      + '1ca36b85d1e97c1bc9d38c887a5adf140f9eeef674c31422'
      + 'e65f63cae719f8c1324e42fa5fd8500899ef5aa3f9856aa7'
      + 'ce10c85600a040343204f36bfeab8cfa6e9deb8a2edd2a8e'
      + '018d00c7c9fa3a251ad0f57183c37e6377797653f382ec7a'
      + '2b0145e16d3c856bc3634b46d90d7198aff12aff88a30e34'
      + 'e2bfaf62705f3382576a9d3eeb0829fca2387b5b654af46e'
      + '5cf6316fb57d59e5ea6c369061ac64d99671b0e516529dd5'
      + 'd9c48ea0503e55fee090d36c5ea8b5954f6fcc0060794e1c'
      + 'b7bc24aa1e5c0142fd4ce6e8fd5aa92a7bf84317ea9e1642'
      + 'b6995bac6705adf93cbce72433ed0871139970d640f67b78'
      + 'e63a7a6d849db2567df69ac7d79f8c62664ac221df228289'
      + 'd0a4f9ebd9acb4f87d49da64e51a619fd3f3baccbd9feb12'
      + '5abe0cc2c8d17ed1d8546da2b6c641f4d3020a5f9b9f26ac'
      + '16546c2d61385505612275ea344c2bbf1ce890023738f715'
      + '5e9eba6a071678c8ebd009c328c3eb643679de86e69a9fa5'
      + '67a9e146030ff03d546310a0a568c5ba0070e0da22f2cef8'
      + '54714b04d399bbc8fd261f9e8efcd0e83bdbc3f5cfb2d024'
      + '3e398478cc598e000124eb8858f9df8f52946c2a1ca5c400'
  }
};

// https://en.wikipedia.org/wiki/Legendre_symbol#Table_of_values
const legendre = [
  [1, 3, 1],
  [1, 5, 1],
  [1, 7, 1],
  [1, 11, 1],
  [1, 13, 1],
  [1, 17, 1],
  [1, 19, 1],
  [1, 23, 1],
  [1, 29, 1],
  [1, 31, 1],
  [1, 37, 1],
  [1, 41, 1],
  [1, 43, 1],
  [1, 47, 1],
  [1, 53, 1],
  [1, 59, 1],
  [1, 61, 1],
  [1, 67, 1],
  [1, 71, 1],
  [1, 73, 1],
  [1, 79, 1],
  [1, 83, 1],
  [1, 89, 1],
  [1, 97, 1],
  [1, 101, 1],
  [1, 103, 1],
  [1, 107, 1],
  [1, 109, 1],
  [1, 113, 1],
  [1, 127, 1],
  [2, 3, -1],
  [2, 5, -1],
  [2, 7, 1],
  [2, 11, -1],
  [2, 13, -1],
  [2, 17, 1],
  [2, 19, -1],
  [2, 23, 1],
  [2, 29, -1],
  [2, 31, 1],
  [2, 37, -1],
  [2, 41, 1],
  [2, 43, -1],
  [2, 47, 1],
  [2, 53, -1],
  [2, 59, -1],
  [2, 61, -1],
  [2, 67, -1],
  [2, 71, 1],
  [2, 73, 1],
  [2, 79, 1],
  [2, 83, -1],
  [2, 89, 1],
  [2, 97, 1],
  [2, 101, -1],
  [2, 103, 1],
  [2, 107, -1],
  [2, 109, -1],
  [2, 113, 1],
  [2, 127, 1],
  [3, 3, 0],
  [3, 5, -1],
  [3, 7, -1],
  [3, 11, 1],
  [3, 13, 1],
  [3, 17, -1],
  [3, 19, -1],
  [3, 23, 1],
  [3, 29, -1],
  [3, 31, -1],
  [3, 37, 1],
  [3, 41, -1],
  [3, 43, -1],
  [3, 47, 1],
  [3, 53, -1],
  [3, 59, 1],
  [3, 61, 1],
  [3, 67, -1],
  [3, 71, 1],
  [3, 73, 1],
  [3, 79, -1],
  [3, 83, 1],
  [3, 89, -1],
  [3, 97, 1],
  [3, 101, -1],
  [3, 103, -1],
  [3, 107, 1],
  [3, 109, 1],
  [3, 113, -1],
  [3, 127, -1],
  [4, 3, 1],
  [4, 5, 1],
  [4, 7, 1],
  [4, 11, 1],
  [4, 13, 1],
  [4, 17, 1],
  [4, 19, 1],
  [4, 23, 1],
  [4, 29, 1],
  [4, 31, 1],
  [4, 37, 1],
  [4, 41, 1],
  [4, 43, 1],
  [4, 47, 1],
  [4, 53, 1],
  [4, 59, 1],
  [4, 61, 1],
  [4, 67, 1],
  [4, 71, 1],
  [4, 73, 1],
  [4, 79, 1],
  [4, 83, 1],
  [4, 89, 1],
  [4, 97, 1],
  [4, 101, 1],
  [4, 103, 1],
  [4, 107, 1],
  [4, 109, 1],
  [4, 113, 1],
  [4, 127, 1],
  [5, 3, -1],
  [5, 5, 0],
  [5, 7, -1],
  [5, 11, 1],
  [5, 13, -1],
  [5, 17, -1],
  [5, 19, 1],
  [5, 23, -1],
  [5, 29, 1],
  [5, 31, 1],
  [5, 37, -1],
  [5, 41, 1],
  [5, 43, -1],
  [5, 47, -1],
  [5, 53, -1],
  [5, 59, 1],
  [5, 61, 1],
  [5, 67, -1],
  [5, 71, 1],
  [5, 73, -1],
  [5, 79, 1],
  [5, 83, -1],
  [5, 89, 1],
  [5, 97, -1],
  [5, 101, 1],
  [5, 103, -1],
  [5, 107, -1],
  [5, 109, 1],
  [5, 113, -1],
  [5, 127, -1],
  [6, 3, 0],
  [6, 5, 1],
  [6, 7, -1],
  [6, 11, -1],
  [6, 13, -1],
  [6, 17, -1],
  [6, 19, 1],
  [6, 23, 1],
  [6, 29, 1],
  [6, 31, -1],
  [6, 37, -1],
  [6, 41, -1],
  [6, 43, 1],
  [6, 47, 1],
  [6, 53, 1],
  [6, 59, -1],
  [6, 61, -1],
  [6, 67, 1],
  [6, 71, 1],
  [6, 73, 1],
  [6, 79, -1],
  [6, 83, -1],
  [6, 89, -1],
  [6, 97, 1],
  [6, 101, 1],
  [6, 103, -1],
  [6, 107, -1],
  [6, 109, -1],
  [6, 113, -1],
  [6, 127, -1],
  [7, 3, 1],
  [7, 5, -1],
  [7, 7, 0],
  [7, 11, -1],
  [7, 13, -1],
  [7, 17, -1],
  [7, 19, 1],
  [7, 23, -1],
  [7, 29, 1],
  [7, 31, 1],
  [7, 37, 1],
  [7, 41, -1],
  [7, 43, -1],
  [7, 47, 1],
  [7, 53, 1],
  [7, 59, 1],
  [7, 61, -1],
  [7, 67, -1],
  [7, 71, -1],
  [7, 73, -1],
  [7, 79, -1],
  [7, 83, 1],
  [7, 89, -1],
  [7, 97, -1],
  [7, 101, -1],
  [7, 103, 1],
  [7, 107, -1],
  [7, 109, 1],
  [7, 113, 1],
  [7, 127, -1],
  [8, 3, -1],
  [8, 5, -1],
  [8, 7, 1],
  [8, 11, -1],
  [8, 13, -1],
  [8, 17, 1],
  [8, 19, -1],
  [8, 23, 1],
  [8, 29, -1],
  [8, 31, 1],
  [8, 37, -1],
  [8, 41, 1],
  [8, 43, -1],
  [8, 47, 1],
  [8, 53, -1],
  [8, 59, -1],
  [8, 61, -1],
  [8, 67, -1],
  [8, 71, 1],
  [8, 73, 1],
  [8, 79, 1],
  [8, 83, -1],
  [8, 89, 1],
  [8, 97, 1],
  [8, 101, -1],
  [8, 103, 1],
  [8, 107, -1],
  [8, 109, -1],
  [8, 113, 1],
  [8, 127, 1],
  [9, 3, 0],
  [9, 5, 1],
  [9, 7, 1],
  [9, 11, 1],
  [9, 13, 1],
  [9, 17, 1],
  [9, 19, 1],
  [9, 23, 1],
  [9, 29, 1],
  [9, 31, 1],
  [9, 37, 1],
  [9, 41, 1],
  [9, 43, 1],
  [9, 47, 1],
  [9, 53, 1],
  [9, 59, 1],
  [9, 61, 1],
  [9, 67, 1],
  [9, 71, 1],
  [9, 73, 1],
  [9, 79, 1],
  [9, 83, 1],
  [9, 89, 1],
  [9, 97, 1],
  [9, 101, 1],
  [9, 103, 1],
  [9, 107, 1],
  [9, 109, 1],
  [9, 113, 1],
  [9, 127, 1],
  [10, 3, 1],
  [10, 5, 0],
  [10, 7, -1],
  [10, 11, -1],
  [10, 13, 1],
  [10, 17, -1],
  [10, 19, -1],
  [10, 23, -1],
  [10, 29, -1],
  [10, 31, 1],
  [10, 37, 1],
  [10, 41, 1],
  [10, 43, 1],
  [10, 47, -1],
  [10, 53, 1],
  [10, 59, -1],
  [10, 61, -1],
  [10, 67, 1],
  [10, 71, 1],
  [10, 73, -1],
  [10, 79, 1],
  [10, 83, 1],
  [10, 89, 1],
  [10, 97, -1],
  [10, 101, -1],
  [10, 103, -1],
  [10, 107, 1],
  [10, 109, -1],
  [10, 113, -1],
  [10, 127, -1],
  [11, 3, -1],
  [11, 5, 1],
  [11, 7, 1],
  [11, 11, 0],
  [11, 13, -1],
  [11, 17, -1],
  [11, 19, 1],
  [11, 23, -1],
  [11, 29, -1],
  [11, 31, -1],
  [11, 37, 1],
  [11, 41, -1],
  [11, 43, 1],
  [11, 47, -1],
  [11, 53, 1],
  [11, 59, -1],
  [11, 61, -1],
  [11, 67, -1],
  [11, 71, -1],
  [11, 73, -1],
  [11, 79, 1],
  [11, 83, 1],
  [11, 89, 1],
  [11, 97, 1],
  [11, 101, -1],
  [11, 103, -1],
  [11, 107, 1],
  [11, 109, -1],
  [11, 113, 1],
  [11, 127, 1],
  [12, 3, 0],
  [12, 5, -1],
  [12, 7, -1],
  [12, 11, 1],
  [12, 13, 1],
  [12, 17, -1],
  [12, 19, -1],
  [12, 23, 1],
  [12, 29, -1],
  [12, 31, -1],
  [12, 37, 1],
  [12, 41, -1],
  [12, 43, -1],
  [12, 47, 1],
  [12, 53, -1],
  [12, 59, 1],
  [12, 61, 1],
  [12, 67, -1],
  [12, 71, 1],
  [12, 73, 1],
  [12, 79, -1],
  [12, 83, 1],
  [12, 89, -1],
  [12, 97, 1],
  [12, 101, -1],
  [12, 103, -1],
  [12, 107, 1],
  [12, 109, 1],
  [12, 113, -1],
  [12, 127, -1],
  [13, 3, 1],
  [13, 5, -1],
  [13, 7, -1],
  [13, 11, -1],
  [13, 13, 0],
  [13, 17, 1],
  [13, 19, -1],
  [13, 23, 1],
  [13, 29, 1],
  [13, 31, -1],
  [13, 37, -1],
  [13, 41, -1],
  [13, 43, 1],
  [13, 47, -1],
  [13, 53, 1],
  [13, 59, -1],
  [13, 61, 1],
  [13, 67, -1],
  [13, 71, -1],
  [13, 73, -1],
  [13, 79, 1],
  [13, 83, -1],
  [13, 89, -1],
  [13, 97, -1],
  [13, 101, 1],
  [13, 103, 1],
  [13, 107, 1],
  [13, 109, -1],
  [13, 113, 1],
  [13, 127, 1],
  [14, 3, -1],
  [14, 5, 1],
  [14, 7, 0],
  [14, 11, 1],
  [14, 13, 1],
  [14, 17, -1],
  [14, 19, -1],
  [14, 23, -1],
  [14, 29, -1],
  [14, 31, 1],
  [14, 37, -1],
  [14, 41, -1],
  [14, 43, 1],
  [14, 47, 1],
  [14, 53, -1],
  [14, 59, -1],
  [14, 61, 1],
  [14, 67, 1],
  [14, 71, -1],
  [14, 73, -1],
  [14, 79, -1],
  [14, 83, -1],
  [14, 89, -1],
  [14, 97, -1],
  [14, 101, 1],
  [14, 103, 1],
  [14, 107, 1],
  [14, 109, -1],
  [14, 113, 1],
  [14, 127, -1],
  [15, 3, 0],
  [15, 5, 0],
  [15, 7, 1],
  [15, 11, 1],
  [15, 13, -1],
  [15, 17, 1],
  [15, 19, -1],
  [15, 23, -1],
  [15, 29, -1],
  [15, 31, -1],
  [15, 37, -1],
  [15, 41, -1],
  [15, 43, 1],
  [15, 47, -1],
  [15, 53, 1],
  [15, 59, 1],
  [15, 61, 1],
  [15, 67, 1],
  [15, 71, 1],
  [15, 73, -1],
  [15, 79, -1],
  [15, 83, -1],
  [15, 89, -1],
  [15, 97, -1],
  [15, 101, -1],
  [15, 103, 1],
  [15, 107, -1],
  [15, 109, 1],
  [15, 113, 1],
  [15, 127, 1],
  [16, 3, 1],
  [16, 5, 1],
  [16, 7, 1],
  [16, 11, 1],
  [16, 13, 1],
  [16, 17, 1],
  [16, 19, 1],
  [16, 23, 1],
  [16, 29, 1],
  [16, 31, 1],
  [16, 37, 1],
  [16, 41, 1],
  [16, 43, 1],
  [16, 47, 1],
  [16, 53, 1],
  [16, 59, 1],
  [16, 61, 1],
  [16, 67, 1],
  [16, 71, 1],
  [16, 73, 1],
  [16, 79, 1],
  [16, 83, 1],
  [16, 89, 1],
  [16, 97, 1],
  [16, 101, 1],
  [16, 103, 1],
  [16, 107, 1],
  [16, 109, 1],
  [16, 113, 1],
  [16, 127, 1],
  [17, 3, -1],
  [17, 5, -1],
  [17, 7, -1],
  [17, 11, -1],
  [17, 13, 1],
  [17, 17, 0],
  [17, 19, 1],
  [17, 23, -1],
  [17, 29, -1],
  [17, 31, -1],
  [17, 37, -1],
  [17, 41, -1],
  [17, 43, 1],
  [17, 47, 1],
  [17, 53, 1],
  [17, 59, 1],
  [17, 61, -1],
  [17, 67, 1],
  [17, 71, -1],
  [17, 73, -1],
  [17, 79, -1],
  [17, 83, 1],
  [17, 89, 1],
  [17, 97, -1],
  [17, 101, 1],
  [17, 103, 1],
  [17, 107, -1],
  [17, 109, -1],
  [17, 113, -1],
  [17, 127, 1],
  [18, 3, 0],
  [18, 5, -1],
  [18, 7, 1],
  [18, 11, -1],
  [18, 13, -1],
  [18, 17, 1],
  [18, 19, -1],
  [18, 23, 1],
  [18, 29, -1],
  [18, 31, 1],
  [18, 37, -1],
  [18, 41, 1],
  [18, 43, -1],
  [18, 47, 1],
  [18, 53, -1],
  [18, 59, -1],
  [18, 61, -1],
  [18, 67, -1],
  [18, 71, 1],
  [18, 73, 1],
  [18, 79, 1],
  [18, 83, -1],
  [18, 89, 1],
  [18, 97, 1],
  [18, 101, -1],
  [18, 103, 1],
  [18, 107, -1],
  [18, 109, -1],
  [18, 113, 1],
  [18, 127, 1],
  [19, 3, 1],
  [19, 5, 1],
  [19, 7, -1],
  [19, 11, -1],
  [19, 13, -1],
  [19, 17, 1],
  [19, 19, 0],
  [19, 23, -1],
  [19, 29, -1],
  [19, 31, 1],
  [19, 37, -1],
  [19, 41, -1],
  [19, 43, -1],
  [19, 47, -1],
  [19, 53, -1],
  [19, 59, 1],
  [19, 61, 1],
  [19, 67, 1],
  [19, 71, 1],
  [19, 73, 1],
  [19, 79, 1],
  [19, 83, -1],
  [19, 89, -1],
  [19, 97, -1],
  [19, 101, 1],
  [19, 103, 1],
  [19, 107, 1],
  [19, 109, -1],
  [19, 113, -1],
  [19, 127, 1],
  [20, 3, -1],
  [20, 5, 0],
  [20, 7, -1],
  [20, 11, 1],
  [20, 13, -1],
  [20, 17, -1],
  [20, 19, 1],
  [20, 23, -1],
  [20, 29, 1],
  [20, 31, 1],
  [20, 37, -1],
  [20, 41, 1],
  [20, 43, -1],
  [20, 47, -1],
  [20, 53, -1],
  [20, 59, 1],
  [20, 61, 1],
  [20, 67, -1],
  [20, 71, 1],
  [20, 73, -1],
  [20, 79, 1],
  [20, 83, -1],
  [20, 89, 1],
  [20, 97, -1],
  [20, 101, 1],
  [20, 103, -1],
  [20, 107, -1],
  [20, 109, 1],
  [20, 113, -1],
  [20, 127, -1],
  [21, 3, 0],
  [21, 5, 1],
  [21, 7, 0],
  [21, 11, -1],
  [21, 13, -1],
  [21, 17, 1],
  [21, 19, -1],
  [21, 23, -1],
  [21, 29, -1],
  [21, 31, -1],
  [21, 37, 1],
  [21, 41, 1],
  [21, 43, 1],
  [21, 47, 1],
  [21, 53, -1],
  [21, 59, 1],
  [21, 61, -1],
  [21, 67, 1],
  [21, 71, -1],
  [21, 73, -1],
  [21, 79, 1],
  [21, 83, 1],
  [21, 89, 1],
  [21, 97, -1],
  [21, 101, 1],
  [21, 103, -1],
  [21, 107, -1],
  [21, 109, 1],
  [21, 113, -1],
  [21, 127, 1],
  [22, 3, 1],
  [22, 5, -1],
  [22, 7, 1],
  [22, 11, 0],
  [22, 13, 1],
  [22, 17, -1],
  [22, 19, -1],
  [22, 23, -1],
  [22, 29, 1],
  [22, 31, -1],
  [22, 37, -1],
  [22, 41, -1],
  [22, 43, -1],
  [22, 47, -1],
  [22, 53, -1],
  [22, 59, 1],
  [22, 61, 1],
  [22, 67, 1],
  [22, 71, -1],
  [22, 73, -1],
  [22, 79, 1],
  [22, 83, -1],
  [22, 89, 1],
  [22, 97, 1],
  [22, 101, 1],
  [22, 103, -1],
  [22, 107, -1],
  [22, 109, 1],
  [22, 113, 1],
  [22, 127, 1],
  [23, 3, -1],
  [23, 5, -1],
  [23, 7, 1],
  [23, 11, 1],
  [23, 13, 1],
  [23, 17, -1],
  [23, 19, 1],
  [23, 23, 0],
  [23, 29, 1],
  [23, 31, -1],
  [23, 37, -1],
  [23, 41, 1],
  [23, 43, 1],
  [23, 47, -1],
  [23, 53, -1],
  [23, 59, -1],
  [23, 61, -1],
  [23, 67, 1],
  [23, 71, -1],
  [23, 73, 1],
  [23, 79, 1],
  [23, 83, 1],
  [23, 89, -1],
  [23, 97, -1],
  [23, 101, 1],
  [23, 103, 1],
  [23, 107, 1],
  [23, 109, -1],
  [23, 113, -1],
  [23, 127, -1],
  [24, 3, 0],
  [24, 5, 1],
  [24, 7, -1],
  [24, 11, -1],
  [24, 13, -1],
  [24, 17, -1],
  [24, 19, 1],
  [24, 23, 1],
  [24, 29, 1],
  [24, 31, -1],
  [24, 37, -1],
  [24, 41, -1],
  [24, 43, 1],
  [24, 47, 1],
  [24, 53, 1],
  [24, 59, -1],
  [24, 61, -1],
  [24, 67, 1],
  [24, 71, 1],
  [24, 73, 1],
  [24, 79, -1],
  [24, 83, -1],
  [24, 89, -1],
  [24, 97, 1],
  [24, 101, 1],
  [24, 103, -1],
  [24, 107, -1],
  [24, 109, -1],
  [24, 113, -1],
  [24, 127, -1],
  [25, 3, 1],
  [25, 5, 0],
  [25, 7, 1],
  [25, 11, 1],
  [25, 13, 1],
  [25, 17, 1],
  [25, 19, 1],
  [25, 23, 1],
  [25, 29, 1],
  [25, 31, 1],
  [25, 37, 1],
  [25, 41, 1],
  [25, 43, 1],
  [25, 47, 1],
  [25, 53, 1],
  [25, 59, 1],
  [25, 61, 1],
  [25, 67, 1],
  [25, 71, 1],
  [25, 73, 1],
  [25, 79, 1],
  [25, 83, 1],
  [25, 89, 1],
  [25, 97, 1],
  [25, 101, 1],
  [25, 103, 1],
  [25, 107, 1],
  [25, 109, 1],
  [25, 113, 1],
  [25, 127, 1],
  [26, 3, -1],
  [26, 5, 1],
  [26, 7, -1],
  [26, 11, 1],
  [26, 13, 0],
  [26, 17, 1],
  [26, 19, 1],
  [26, 23, 1],
  [26, 29, -1],
  [26, 31, -1],
  [26, 37, 1],
  [26, 41, -1],
  [26, 43, -1],
  [26, 47, -1],
  [26, 53, -1],
  [26, 59, 1],
  [26, 61, -1],
  [26, 67, 1],
  [26, 71, -1],
  [26, 73, -1],
  [26, 79, 1],
  [26, 83, 1],
  [26, 89, -1],
  [26, 97, -1],
  [26, 101, -1],
  [26, 103, 1],
  [26, 107, -1],
  [26, 109, 1],
  [26, 113, 1],
  [26, 127, 1],
  [27, 3, 0],
  [27, 5, -1],
  [27, 7, -1],
  [27, 11, 1],
  [27, 13, 1],
  [27, 17, -1],
  [27, 19, -1],
  [27, 23, 1],
  [27, 29, -1],
  [27, 31, -1],
  [27, 37, 1],
  [27, 41, -1],
  [27, 43, -1],
  [27, 47, 1],
  [27, 53, -1],
  [27, 59, 1],
  [27, 61, 1],
  [27, 67, -1],
  [27, 71, 1],
  [27, 73, 1],
  [27, 79, -1],
  [27, 83, 1],
  [27, 89, -1],
  [27, 97, 1],
  [27, 101, -1],
  [27, 103, -1],
  [27, 107, 1],
  [27, 109, 1],
  [27, 113, -1],
  [27, 127, -1],
  [28, 3, 1],
  [28, 5, -1],
  [28, 7, 0],
  [28, 11, -1],
  [28, 13, -1],
  [28, 17, -1],
  [28, 19, 1],
  [28, 23, -1],
  [28, 29, 1],
  [28, 31, 1],
  [28, 37, 1],
  [28, 41, -1],
  [28, 43, -1],
  [28, 47, 1],
  [28, 53, 1],
  [28, 59, 1],
  [28, 61, -1],
  [28, 67, -1],
  [28, 71, -1],
  [28, 73, -1],
  [28, 79, -1],
  [28, 83, 1],
  [28, 89, -1],
  [28, 97, -1],
  [28, 101, -1],
  [28, 103, 1],
  [28, 107, -1],
  [28, 109, 1],
  [28, 113, 1],
  [28, 127, -1],
  [29, 3, -1],
  [29, 5, 1],
  [29, 7, 1],
  [29, 11, -1],
  [29, 13, 1],
  [29, 17, -1],
  [29, 19, -1],
  [29, 23, 1],
  [29, 29, 0],
  [29, 31, -1],
  [29, 37, -1],
  [29, 41, -1],
  [29, 43, -1],
  [29, 47, -1],
  [29, 53, 1],
  [29, 59, 1],
  [29, 61, -1],
  [29, 67, 1],
  [29, 71, 1],
  [29, 73, -1],
  [29, 79, -1],
  [29, 83, 1],
  [29, 89, -1],
  [29, 97, -1],
  [29, 101, -1],
  [29, 103, 1],
  [29, 107, 1],
  [29, 109, 1],
  [29, 113, -1],
  [29, 127, -1],
  [30, 3, 0],
  [30, 5, 0],
  [30, 7, 1],
  [30, 11, -1],
  [30, 13, 1],
  [30, 17, 1],
  [30, 19, 1],
  [30, 23, -1],
  [30, 29, 1],
  [30, 31, -1],
  [30, 37, 1],
  [30, 41, -1],
  [30, 43, -1],
  [30, 47, -1],
  [30, 53, -1],
  [30, 59, -1],
  [30, 61, -1],
  [30, 67, -1],
  [30, 71, 1],
  [30, 73, -1],
  [30, 79, -1],
  [30, 83, 1],
  [30, 89, -1],
  [30, 97, -1],
  [30, 101, 1],
  [30, 103, 1],
  [30, 107, 1],
  [30, 109, -1],
  [30, 113, 1],
  [30, 127, 1],
  [12345, 331, -1]
];

const jacobi = [
  [0, 1, 1],
  [0, -1, 1],
  [1, 1, 1],
  [1, -1, 1],
  [0, 5, 0],
  [1, 5, 1],
  [2, 5, -1],
  [-2, 5, -1],
  [2, -5, -1],
  [-2, -5, 1],
  [3, 5, -1],
  [5, 5, 0],
  [-5, 5, 0],
  [6, 5, 1],
  [6, -5, 1],
  [-6, 5, 1],
  [-6, -5, -1],
  // https://en.wikipedia.org/wiki/Jacobi_symbol#Table_of_values
  [1, 1, 1],
  [1, 3, 1],
  [1, 5, 1],
  [1, 7, 1],
  [1, 9, 1],
  [1, 11, 1],
  [1, 13, 1],
  [1, 15, 1],
  [1, 17, 1],
  [1, 19, 1],
  [1, 21, 1],
  [1, 23, 1],
  [1, 25, 1],
  [1, 27, 1],
  [1, 29, 1],
  [1, 31, 1],
  [1, 33, 1],
  [1, 35, 1],
  [1, 37, 1],
  [1, 39, 1],
  [1, 41, 1],
  [1, 43, 1],
  [1, 45, 1],
  [1, 47, 1],
  [1, 49, 1],
  [1, 51, 1],
  [1, 53, 1],
  [1, 55, 1],
  [1, 57, 1],
  [1, 59, 1],
  [2, 1, 1],
  [2, 3, -1],
  [2, 5, -1],
  [2, 7, 1],
  [2, 9, 1],
  [2, 11, -1],
  [2, 13, -1],
  [2, 15, 1],
  [2, 17, 1],
  [2, 19, -1],
  [2, 21, -1],
  [2, 23, 1],
  [2, 25, 1],
  [2, 27, -1],
  [2, 29, -1],
  [2, 31, 1],
  [2, 33, 1],
  [2, 35, -1],
  [2, 37, -1],
  [2, 39, 1],
  [2, 41, 1],
  [2, 43, -1],
  [2, 45, -1],
  [2, 47, 1],
  [2, 49, 1],
  [2, 51, -1],
  [2, 53, -1],
  [2, 55, 1],
  [2, 57, 1],
  [2, 59, -1],
  [3, 1, 1],
  [3, 3, 0],
  [3, 5, -1],
  [3, 7, -1],
  [3, 9, 0],
  [3, 11, 1],
  [3, 13, 1],
  [3, 15, 0],
  [3, 17, -1],
  [3, 19, -1],
  [3, 21, 0],
  [3, 23, 1],
  [3, 25, 1],
  [3, 27, 0],
  [3, 29, -1],
  [3, 31, -1],
  [3, 33, 0],
  [3, 35, 1],
  [3, 37, 1],
  [3, 39, 0],
  [3, 41, -1],
  [3, 43, -1],
  [3, 45, 0],
  [3, 47, 1],
  [3, 49, 1],
  [3, 51, 0],
  [3, 53, -1],
  [3, 55, -1],
  [3, 57, 0],
  [3, 59, 1],
  [4, 1, 1],
  [4, 3, 1],
  [4, 5, 1],
  [4, 7, 1],
  [4, 9, 1],
  [4, 11, 1],
  [4, 13, 1],
  [4, 15, 1],
  [4, 17, 1],
  [4, 19, 1],
  [4, 21, 1],
  [4, 23, 1],
  [4, 25, 1],
  [4, 27, 1],
  [4, 29, 1],
  [4, 31, 1],
  [4, 33, 1],
  [4, 35, 1],
  [4, 37, 1],
  [4, 39, 1],
  [4, 41, 1],
  [4, 43, 1],
  [4, 45, 1],
  [4, 47, 1],
  [4, 49, 1],
  [4, 51, 1],
  [4, 53, 1],
  [4, 55, 1],
  [4, 57, 1],
  [4, 59, 1],
  [5, 1, 1],
  [5, 3, -1],
  [5, 5, 0],
  [5, 7, -1],
  [5, 9, 1],
  [5, 11, 1],
  [5, 13, -1],
  [5, 15, 0],
  [5, 17, -1],
  [5, 19, 1],
  [5, 21, 1],
  [5, 23, -1],
  [5, 25, 0],
  [5, 27, -1],
  [5, 29, 1],
  [5, 31, 1],
  [5, 33, -1],
  [5, 35, 0],
  [5, 37, -1],
  [5, 39, 1],
  [5, 41, 1],
  [5, 43, -1],
  [5, 45, 0],
  [5, 47, -1],
  [5, 49, 1],
  [5, 51, 1],
  [5, 53, -1],
  [5, 55, 0],
  [5, 57, -1],
  [5, 59, 1],
  [6, 1, 1],
  [6, 3, 0],
  [6, 5, 1],
  [6, 7, -1],
  [6, 9, 0],
  [6, 11, -1],
  [6, 13, -1],
  [6, 15, 0],
  [6, 17, -1],
  [6, 19, 1],
  [6, 21, 0],
  [6, 23, 1],
  [6, 25, 1],
  [6, 27, 0],
  [6, 29, 1],
  [6, 31, -1],
  [6, 33, 0],
  [6, 35, -1],
  [6, 37, -1],
  [6, 39, 0],
  [6, 41, -1],
  [6, 43, 1],
  [6, 45, 0],
  [6, 47, 1],
  [6, 49, 1],
  [6, 51, 0],
  [6, 53, 1],
  [6, 55, -1],
  [6, 57, 0],
  [6, 59, -1],
  [7, 1, 1],
  [7, 3, 1],
  [7, 5, -1],
  [7, 7, 0],
  [7, 9, 1],
  [7, 11, -1],
  [7, 13, -1],
  [7, 15, -1],
  [7, 17, -1],
  [7, 19, 1],
  [7, 21, 0],
  [7, 23, -1],
  [7, 25, 1],
  [7, 27, 1],
  [7, 29, 1],
  [7, 31, 1],
  [7, 33, -1],
  [7, 35, 0],
  [7, 37, 1],
  [7, 39, -1],
  [7, 41, -1],
  [7, 43, -1],
  [7, 45, -1],
  [7, 47, 1],
  [7, 49, 0],
  [7, 51, -1],
  [7, 53, 1],
  [7, 55, 1],
  [7, 57, 1],
  [7, 59, 1],
  [8, 1, 1],
  [8, 3, -1],
  [8, 5, -1],
  [8, 7, 1],
  [8, 9, 1],
  [8, 11, -1],
  [8, 13, -1],
  [8, 15, 1],
  [8, 17, 1],
  [8, 19, -1],
  [8, 21, -1],
  [8, 23, 1],
  [8, 25, 1],
  [8, 27, -1],
  [8, 29, -1],
  [8, 31, 1],
  [8, 33, 1],
  [8, 35, -1],
  [8, 37, -1],
  [8, 39, 1],
  [8, 41, 1],
  [8, 43, -1],
  [8, 45, -1],
  [8, 47, 1],
  [8, 49, 1],
  [8, 51, -1],
  [8, 53, -1],
  [8, 55, 1],
  [8, 57, 1],
  [8, 59, -1],
  [9, 1, 1],
  [9, 3, 0],
  [9, 5, 1],
  [9, 7, 1],
  [9, 9, 0],
  [9, 11, 1],
  [9, 13, 1],
  [9, 15, 0],
  [9, 17, 1],
  [9, 19, 1],
  [9, 21, 0],
  [9, 23, 1],
  [9, 25, 1],
  [9, 27, 0],
  [9, 29, 1],
  [9, 31, 1],
  [9, 33, 0],
  [9, 35, 1],
  [9, 37, 1],
  [9, 39, 0],
  [9, 41, 1],
  [9, 43, 1],
  [9, 45, 0],
  [9, 47, 1],
  [9, 49, 1],
  [9, 51, 0],
  [9, 53, 1],
  [9, 55, 1],
  [9, 57, 0],
  [9, 59, 1],
  [10, 1, 1],
  [10, 3, 1],
  [10, 5, 0],
  [10, 7, -1],
  [10, 9, 1],
  [10, 11, -1],
  [10, 13, 1],
  [10, 15, 0],
  [10, 17, -1],
  [10, 19, -1],
  [10, 21, -1],
  [10, 23, -1],
  [10, 25, 0],
  [10, 27, 1],
  [10, 29, -1],
  [10, 31, 1],
  [10, 33, -1],
  [10, 35, 0],
  [10, 37, 1],
  [10, 39, 1],
  [10, 41, 1],
  [10, 43, 1],
  [10, 45, 0],
  [10, 47, -1],
  [10, 49, 1],
  [10, 51, -1],
  [10, 53, 1],
  [10, 55, 0],
  [10, 57, -1],
  [10, 59, -1],
  [11, 1, 1],
  [11, 3, -1],
  [11, 5, 1],
  [11, 7, 1],
  [11, 9, 1],
  [11, 11, 0],
  [11, 13, -1],
  [11, 15, -1],
  [11, 17, -1],
  [11, 19, 1],
  [11, 21, -1],
  [11, 23, -1],
  [11, 25, 1],
  [11, 27, -1],
  [11, 29, -1],
  [11, 31, -1],
  [11, 33, 0],
  [11, 35, 1],
  [11, 37, 1],
  [11, 39, 1],
  [11, 41, -1],
  [11, 43, 1],
  [11, 45, 1],
  [11, 47, -1],
  [11, 49, 1],
  [11, 51, 1],
  [11, 53, 1],
  [11, 55, 0],
  [11, 57, -1],
  [11, 59, -1],
  [12, 1, 1],
  [12, 3, 0],
  [12, 5, -1],
  [12, 7, -1],
  [12, 9, 0],
  [12, 11, 1],
  [12, 13, 1],
  [12, 15, 0],
  [12, 17, -1],
  [12, 19, -1],
  [12, 21, 0],
  [12, 23, 1],
  [12, 25, 1],
  [12, 27, 0],
  [12, 29, -1],
  [12, 31, -1],
  [12, 33, 0],
  [12, 35, 1],
  [12, 37, 1],
  [12, 39, 0],
  [12, 41, -1],
  [12, 43, -1],
  [12, 45, 0],
  [12, 47, 1],
  [12, 49, 1],
  [12, 51, 0],
  [12, 53, -1],
  [12, 55, -1],
  [12, 57, 0],
  [12, 59, 1],
  [13, 1, 1],
  [13, 3, 1],
  [13, 5, -1],
  [13, 7, -1],
  [13, 9, 1],
  [13, 11, -1],
  [13, 13, 0],
  [13, 15, -1],
  [13, 17, 1],
  [13, 19, -1],
  [13, 21, -1],
  [13, 23, 1],
  [13, 25, 1],
  [13, 27, 1],
  [13, 29, 1],
  [13, 31, -1],
  [13, 33, -1],
  [13, 35, 1],
  [13, 37, -1],
  [13, 39, 0],
  [13, 41, -1],
  [13, 43, 1],
  [13, 45, -1],
  [13, 47, -1],
  [13, 49, 1],
  [13, 51, 1],
  [13, 53, 1],
  [13, 55, 1],
  [13, 57, -1],
  [13, 59, -1],
  [14, 1, 1],
  [14, 3, -1],
  [14, 5, 1],
  [14, 7, 0],
  [14, 9, 1],
  [14, 11, 1],
  [14, 13, 1],
  [14, 15, -1],
  [14, 17, -1],
  [14, 19, -1],
  [14, 21, 0],
  [14, 23, -1],
  [14, 25, 1],
  [14, 27, -1],
  [14, 29, -1],
  [14, 31, 1],
  [14, 33, -1],
  [14, 35, 0],
  [14, 37, -1],
  [14, 39, -1],
  [14, 41, -1],
  [14, 43, 1],
  [14, 45, 1],
  [14, 47, 1],
  [14, 49, 0],
  [14, 51, 1],
  [14, 53, -1],
  [14, 55, 1],
  [14, 57, 1],
  [14, 59, -1],
  [15, 1, 1],
  [15, 3, 0],
  [15, 5, 0],
  [15, 7, 1],
  [15, 9, 0],
  [15, 11, 1],
  [15, 13, -1],
  [15, 15, 0],
  [15, 17, 1],
  [15, 19, -1],
  [15, 21, 0],
  [15, 23, -1],
  [15, 25, 0],
  [15, 27, 0],
  [15, 29, -1],
  [15, 31, -1],
  [15, 33, 0],
  [15, 35, 0],
  [15, 37, -1],
  [15, 39, 0],
  [15, 41, -1],
  [15, 43, 1],
  [15, 45, 0],
  [15, 47, -1],
  [15, 49, 1],
  [15, 51, 0],
  [15, 53, 1],
  [15, 55, 0],
  [15, 57, 0],
  [15, 59, 1],
  [16, 1, 1],
  [16, 3, 1],
  [16, 5, 1],
  [16, 7, 1],
  [16, 9, 1],
  [16, 11, 1],
  [16, 13, 1],
  [16, 15, 1],
  [16, 17, 1],
  [16, 19, 1],
  [16, 21, 1],
  [16, 23, 1],
  [16, 25, 1],
  [16, 27, 1],
  [16, 29, 1],
  [16, 31, 1],
  [16, 33, 1],
  [16, 35, 1],
  [16, 37, 1],
  [16, 39, 1],
  [16, 41, 1],
  [16, 43, 1],
  [16, 45, 1],
  [16, 47, 1],
  [16, 49, 1],
  [16, 51, 1],
  [16, 53, 1],
  [16, 55, 1],
  [16, 57, 1],
  [16, 59, 1],
  [17, 1, 1],
  [17, 3, -1],
  [17, 5, -1],
  [17, 7, -1],
  [17, 9, 1],
  [17, 11, -1],
  [17, 13, 1],
  [17, 15, 1],
  [17, 17, 0],
  [17, 19, 1],
  [17, 21, 1],
  [17, 23, -1],
  [17, 25, 1],
  [17, 27, -1],
  [17, 29, -1],
  [17, 31, -1],
  [17, 33, 1],
  [17, 35, 1],
  [17, 37, -1],
  [17, 39, -1],
  [17, 41, -1],
  [17, 43, 1],
  [17, 45, -1],
  [17, 47, 1],
  [17, 49, 1],
  [17, 51, 0],
  [17, 53, 1],
  [17, 55, 1],
  [17, 57, -1],
  [17, 59, 1],
  [18, 1, 1],
  [18, 3, 0],
  [18, 5, -1],
  [18, 7, 1],
  [18, 9, 0],
  [18, 11, -1],
  [18, 13, -1],
  [18, 15, 0],
  [18, 17, 1],
  [18, 19, -1],
  [18, 21, 0],
  [18, 23, 1],
  [18, 25, 1],
  [18, 27, 0],
  [18, 29, -1],
  [18, 31, 1],
  [18, 33, 0],
  [18, 35, -1],
  [18, 37, -1],
  [18, 39, 0],
  [18, 41, 1],
  [18, 43, -1],
  [18, 45, 0],
  [18, 47, 1],
  [18, 49, 1],
  [18, 51, 0],
  [18, 53, -1],
  [18, 55, 1],
  [18, 57, 0],
  [18, 59, -1],
  [19, 1, 1],
  [19, 3, 1],
  [19, 5, 1],
  [19, 7, -1],
  [19, 9, 1],
  [19, 11, -1],
  [19, 13, -1],
  [19, 15, 1],
  [19, 17, 1],
  [19, 19, 0],
  [19, 21, -1],
  [19, 23, -1],
  [19, 25, 1],
  [19, 27, 1],
  [19, 29, -1],
  [19, 31, 1],
  [19, 33, -1],
  [19, 35, -1],
  [19, 37, -1],
  [19, 39, -1],
  [19, 41, -1],
  [19, 43, -1],
  [19, 45, 1],
  [19, 47, -1],
  [19, 49, 1],
  [19, 51, 1],
  [19, 53, -1],
  [19, 55, -1],
  [19, 57, 0],
  [19, 59, 1],
  [20, 1, 1],
  [20, 3, -1],
  [20, 5, 0],
  [20, 7, -1],
  [20, 9, 1],
  [20, 11, 1],
  [20, 13, -1],
  [20, 15, 0],
  [20, 17, -1],
  [20, 19, 1],
  [20, 21, 1],
  [20, 23, -1],
  [20, 25, 0],
  [20, 27, -1],
  [20, 29, 1],
  [20, 31, 1],
  [20, 33, -1],
  [20, 35, 0],
  [20, 37, -1],
  [20, 39, 1],
  [20, 41, 1],
  [20, 43, -1],
  [20, 45, 0],
  [20, 47, -1],
  [20, 49, 1],
  [20, 51, 1],
  [20, 53, -1],
  [20, 55, 0],
  [20, 57, -1],
  [20, 59, 1],
  [21, 1, 1],
  [21, 3, 0],
  [21, 5, 1],
  [21, 7, 0],
  [21, 9, 0],
  [21, 11, -1],
  [21, 13, -1],
  [21, 15, 0],
  [21, 17, 1],
  [21, 19, -1],
  [21, 21, 0],
  [21, 23, -1],
  [21, 25, 1],
  [21, 27, 0],
  [21, 29, -1],
  [21, 31, -1],
  [21, 33, 0],
  [21, 35, 0],
  [21, 37, 1],
  [21, 39, 0],
  [21, 41, 1],
  [21, 43, 1],
  [21, 45, 0],
  [21, 47, 1],
  [21, 49, 0],
  [21, 51, 0],
  [21, 53, -1],
  [21, 55, -1],
  [21, 57, 0],
  [21, 59, 1],
  [22, 1, 1],
  [22, 3, 1],
  [22, 5, -1],
  [22, 7, 1],
  [22, 9, 1],
  [22, 11, 0],
  [22, 13, 1],
  [22, 15, -1],
  [22, 17, -1],
  [22, 19, -1],
  [22, 21, 1],
  [22, 23, -1],
  [22, 25, 1],
  [22, 27, 1],
  [22, 29, 1],
  [22, 31, -1],
  [22, 33, 0],
  [22, 35, -1],
  [22, 37, -1],
  [22, 39, 1],
  [22, 41, -1],
  [22, 43, -1],
  [22, 45, -1],
  [22, 47, -1],
  [22, 49, 1],
  [22, 51, -1],
  [22, 53, -1],
  [22, 55, 0],
  [22, 57, -1],
  [22, 59, 1],
  [23, 1, 1],
  [23, 3, -1],
  [23, 5, -1],
  [23, 7, 1],
  [23, 9, 1],
  [23, 11, 1],
  [23, 13, 1],
  [23, 15, 1],
  [23, 17, -1],
  [23, 19, 1],
  [23, 21, -1],
  [23, 23, 0],
  [23, 25, 1],
  [23, 27, -1],
  [23, 29, 1],
  [23, 31, -1],
  [23, 33, -1],
  [23, 35, -1],
  [23, 37, -1],
  [23, 39, -1],
  [23, 41, 1],
  [23, 43, 1],
  [23, 45, -1],
  [23, 47, -1],
  [23, 49, 1],
  [23, 51, 1],
  [23, 53, -1],
  [23, 55, -1],
  [23, 57, -1],
  [23, 59, -1],
  [24, 1, 1],
  [24, 3, 0],
  [24, 5, 1],
  [24, 7, -1],
  [24, 9, 0],
  [24, 11, -1],
  [24, 13, -1],
  [24, 15, 0],
  [24, 17, -1],
  [24, 19, 1],
  [24, 21, 0],
  [24, 23, 1],
  [24, 25, 1],
  [24, 27, 0],
  [24, 29, 1],
  [24, 31, -1],
  [24, 33, 0],
  [24, 35, -1],
  [24, 37, -1],
  [24, 39, 0],
  [24, 41, -1],
  [24, 43, 1],
  [24, 45, 0],
  [24, 47, 1],
  [24, 49, 1],
  [24, 51, 0],
  [24, 53, 1],
  [24, 55, -1],
  [24, 57, 0],
  [24, 59, -1],
  [25, 1, 1],
  [25, 3, 1],
  [25, 5, 0],
  [25, 7, 1],
  [25, 9, 1],
  [25, 11, 1],
  [25, 13, 1],
  [25, 15, 0],
  [25, 17, 1],
  [25, 19, 1],
  [25, 21, 1],
  [25, 23, 1],
  [25, 25, 0],
  [25, 27, 1],
  [25, 29, 1],
  [25, 31, 1],
  [25, 33, 1],
  [25, 35, 0],
  [25, 37, 1],
  [25, 39, 1],
  [25, 41, 1],
  [25, 43, 1],
  [25, 45, 0],
  [25, 47, 1],
  [25, 49, 1],
  [25, 51, 1],
  [25, 53, 1],
  [25, 55, 0],
  [25, 57, 1],
  [25, 59, 1],
  [26, 1, 1],
  [26, 3, -1],
  [26, 5, 1],
  [26, 7, -1],
  [26, 9, 1],
  [26, 11, 1],
  [26, 13, 0],
  [26, 15, -1],
  [26, 17, 1],
  [26, 19, 1],
  [26, 21, 1],
  [26, 23, 1],
  [26, 25, 1],
  [26, 27, -1],
  [26, 29, -1],
  [26, 31, -1],
  [26, 33, -1],
  [26, 35, -1],
  [26, 37, 1],
  [26, 39, 0],
  [26, 41, -1],
  [26, 43, -1],
  [26, 45, 1],
  [26, 47, -1],
  [26, 49, 1],
  [26, 51, -1],
  [26, 53, -1],
  [26, 55, 1],
  [26, 57, -1],
  [26, 59, 1],
  [27, 1, 1],
  [27, 3, 0],
  [27, 5, -1],
  [27, 7, -1],
  [27, 9, 0],
  [27, 11, 1],
  [27, 13, 1],
  [27, 15, 0],
  [27, 17, -1],
  [27, 19, -1],
  [27, 21, 0],
  [27, 23, 1],
  [27, 25, 1],
  [27, 27, 0],
  [27, 29, -1],
  [27, 31, -1],
  [27, 33, 0],
  [27, 35, 1],
  [27, 37, 1],
  [27, 39, 0],
  [27, 41, -1],
  [27, 43, -1],
  [27, 45, 0],
  [27, 47, 1],
  [27, 49, 1],
  [27, 51, 0],
  [27, 53, -1],
  [27, 55, -1],
  [27, 57, 0],
  [27, 59, 1],
  [28, 1, 1],
  [28, 3, 1],
  [28, 5, -1],
  [28, 7, 0],
  [28, 9, 1],
  [28, 11, -1],
  [28, 13, -1],
  [28, 15, -1],
  [28, 17, -1],
  [28, 19, 1],
  [28, 21, 0],
  [28, 23, -1],
  [28, 25, 1],
  [28, 27, 1],
  [28, 29, 1],
  [28, 31, 1],
  [28, 33, -1],
  [28, 35, 0],
  [28, 37, 1],
  [28, 39, -1],
  [28, 41, -1],
  [28, 43, -1],
  [28, 45, -1],
  [28, 47, 1],
  [28, 49, 0],
  [28, 51, -1],
  [28, 53, 1],
  [28, 55, 1],
  [28, 57, 1],
  [28, 59, 1],
  [29, 1, 1],
  [29, 3, -1],
  [29, 5, 1],
  [29, 7, 1],
  [29, 9, 1],
  [29, 11, -1],
  [29, 13, 1],
  [29, 15, -1],
  [29, 17, -1],
  [29, 19, -1],
  [29, 21, -1],
  [29, 23, 1],
  [29, 25, 1],
  [29, 27, -1],
  [29, 29, 0],
  [29, 31, -1],
  [29, 33, 1],
  [29, 35, 1],
  [29, 37, -1],
  [29, 39, -1],
  [29, 41, -1],
  [29, 43, -1],
  [29, 45, 1],
  [29, 47, -1],
  [29, 49, 1],
  [29, 51, 1],
  [29, 53, 1],
  [29, 55, -1],
  [29, 57, 1],
  [29, 59, 1],
  [30, 1, 1],
  [30, 3, 0],
  [30, 5, 0],
  [30, 7, 1],
  [30, 9, 0],
  [30, 11, -1],
  [30, 13, 1],
  [30, 15, 0],
  [30, 17, 1],
  [30, 19, 1],
  [30, 21, 0],
  [30, 23, -1],
  [30, 25, 0],
  [30, 27, 0],
  [30, 29, 1],
  [30, 31, -1],
  [30, 33, 0],
  [30, 35, 0],
  [30, 37, 1],
  [30, 39, 0],
  [30, 41, -1],
  [30, 43, -1],
  [30, 45, 0],
  [30, 47, -1],
  [30, 49, 1],
  [30, 51, 0],
  [30, 53, -1],
  [30, 55, 0],
  [30, 57, 0],
  [30, 59, -1],
  [1001, 9907, -1]
];

// https://en.wikipedia.org/wiki/Kronecker_symbol#Table_of_values
const kronecker = [
  [1, 1, 1],
  [1, 2, 1],
  [1, 3, 1],
  [1, 4, 1],
  [1, 5, 1],
  [1, 6, 1],
  [1, 7, 1],
  [1, 8, 1],
  [1, 9, 1],
  [1, 10, 1],
  [1, 11, 1],
  [1, 12, 1],
  [1, 13, 1],
  [1, 14, 1],
  [1, 15, 1],
  [1, 16, 1],
  [1, 17, 1],
  [1, 18, 1],
  [1, 19, 1],
  [1, 20, 1],
  [1, 21, 1],
  [1, 22, 1],
  [1, 23, 1],
  [1, 24, 1],
  [1, 25, 1],
  [1, 26, 1],
  [1, 27, 1],
  [1, 28, 1],
  [1, 29, 1],
  [1, 30, 1],
  [2, 1, 1],
  [2, 2, 0],
  [2, 3, -1],
  [2, 4, 0],
  [2, 5, -1],
  [2, 6, 0],
  [2, 7, 1],
  [2, 8, 0],
  [2, 9, 1],
  [2, 10, 0],
  [2, 11, -1],
  [2, 12, 0],
  [2, 13, -1],
  [2, 14, 0],
  [2, 15, 1],
  [2, 16, 0],
  [2, 17, 1],
  [2, 18, 0],
  [2, 19, -1],
  [2, 20, 0],
  [2, 21, -1],
  [2, 22, 0],
  [2, 23, 1],
  [2, 24, 0],
  [2, 25, 1],
  [2, 26, 0],
  [2, 27, -1],
  [2, 28, 0],
  [2, 29, -1],
  [2, 30, 0],
  [3, 1, 1],
  [3, 2, -1],
  [3, 3, 0],
  [3, 4, 1],
  [3, 5, -1],
  [3, 6, 0],
  [3, 7, -1],
  [3, 8, -1],
  [3, 9, 0],
  [3, 10, 1],
  [3, 11, 1],
  [3, 12, 0],
  [3, 13, 1],
  [3, 14, 1],
  [3, 15, 0],
  [3, 16, 1],
  [3, 17, -1],
  [3, 18, 0],
  [3, 19, -1],
  [3, 20, -1],
  [3, 21, 0],
  [3, 22, -1],
  [3, 23, 1],
  [3, 24, 0],
  [3, 25, 1],
  [3, 26, -1],
  [3, 27, 0],
  [3, 28, -1],
  [3, 29, -1],
  [3, 30, 0],
  [4, 1, 1],
  [4, 2, 0],
  [4, 3, 1],
  [4, 4, 0],
  [4, 5, 1],
  [4, 6, 0],
  [4, 7, 1],
  [4, 8, 0],
  [4, 9, 1],
  [4, 10, 0],
  [4, 11, 1],
  [4, 12, 0],
  [4, 13, 1],
  [4, 14, 0],
  [4, 15, 1],
  [4, 16, 0],
  [4, 17, 1],
  [4, 18, 0],
  [4, 19, 1],
  [4, 20, 0],
  [4, 21, 1],
  [4, 22, 0],
  [4, 23, 1],
  [4, 24, 0],
  [4, 25, 1],
  [4, 26, 0],
  [4, 27, 1],
  [4, 28, 0],
  [4, 29, 1],
  [4, 30, 0],
  [5, 1, 1],
  [5, 2, -1],
  [5, 3, -1],
  [5, 4, 1],
  [5, 5, 0],
  [5, 6, 1],
  [5, 7, -1],
  [5, 8, -1],
  [5, 9, 1],
  [5, 10, 0],
  [5, 11, 1],
  [5, 12, -1],
  [5, 13, -1],
  [5, 14, 1],
  [5, 15, 0],
  [5, 16, 1],
  [5, 17, -1],
  [5, 18, -1],
  [5, 19, 1],
  [5, 20, 0],
  [5, 21, 1],
  [5, 22, -1],
  [5, 23, -1],
  [5, 24, 1],
  [5, 25, 0],
  [5, 26, 1],
  [5, 27, -1],
  [5, 28, -1],
  [5, 29, 1],
  [5, 30, 0],
  [6, 1, 1],
  [6, 2, 0],
  [6, 3, 0],
  [6, 4, 0],
  [6, 5, 1],
  [6, 6, 0],
  [6, 7, -1],
  [6, 8, 0],
  [6, 9, 0],
  [6, 10, 0],
  [6, 11, -1],
  [6, 12, 0],
  [6, 13, -1],
  [6, 14, 0],
  [6, 15, 0],
  [6, 16, 0],
  [6, 17, -1],
  [6, 18, 0],
  [6, 19, 1],
  [6, 20, 0],
  [6, 21, 0],
  [6, 22, 0],
  [6, 23, 1],
  [6, 24, 0],
  [6, 25, 1],
  [6, 26, 0],
  [6, 27, 0],
  [6, 28, 0],
  [6, 29, 1],
  [6, 30, 0],
  [7, 1, 1],
  [7, 2, 1],
  [7, 3, 1],
  [7, 4, 1],
  [7, 5, -1],
  [7, 6, 1],
  [7, 7, 0],
  [7, 8, 1],
  [7, 9, 1],
  [7, 10, -1],
  [7, 11, -1],
  [7, 12, 1],
  [7, 13, -1],
  [7, 14, 0],
  [7, 15, -1],
  [7, 16, 1],
  [7, 17, -1],
  [7, 18, 1],
  [7, 19, 1],
  [7, 20, -1],
  [7, 21, 0],
  [7, 22, -1],
  [7, 23, -1],
  [7, 24, 1],
  [7, 25, 1],
  [7, 26, -1],
  [7, 27, 1],
  [7, 28, 0],
  [7, 29, 1],
  [7, 30, -1],
  [8, 1, 1],
  [8, 2, 0],
  [8, 3, -1],
  [8, 4, 0],
  [8, 5, -1],
  [8, 6, 0],
  [8, 7, 1],
  [8, 8, 0],
  [8, 9, 1],
  [8, 10, 0],
  [8, 11, -1],
  [8, 12, 0],
  [8, 13, -1],
  [8, 14, 0],
  [8, 15, 1],
  [8, 16, 0],
  [8, 17, 1],
  [8, 18, 0],
  [8, 19, -1],
  [8, 20, 0],
  [8, 21, -1],
  [8, 22, 0],
  [8, 23, 1],
  [8, 24, 0],
  [8, 25, 1],
  [8, 26, 0],
  [8, 27, -1],
  [8, 28, 0],
  [8, 29, -1],
  [8, 30, 0],
  [9, 1, 1],
  [9, 2, 1],
  [9, 3, 0],
  [9, 4, 1],
  [9, 5, 1],
  [9, 6, 0],
  [9, 7, 1],
  [9, 8, 1],
  [9, 9, 0],
  [9, 10, 1],
  [9, 11, 1],
  [9, 12, 0],
  [9, 13, 1],
  [9, 14, 1],
  [9, 15, 0],
  [9, 16, 1],
  [9, 17, 1],
  [9, 18, 0],
  [9, 19, 1],
  [9, 20, 1],
  [9, 21, 0],
  [9, 22, 1],
  [9, 23, 1],
  [9, 24, 0],
  [9, 25, 1],
  [9, 26, 1],
  [9, 27, 0],
  [9, 28, 1],
  [9, 29, 1],
  [9, 30, 0],
  [10, 1, 1],
  [10, 2, 0],
  [10, 3, 1],
  [10, 4, 0],
  [10, 5, 0],
  [10, 6, 0],
  [10, 7, -1],
  [10, 8, 0],
  [10, 9, 1],
  [10, 10, 0],
  [10, 11, -1],
  [10, 12, 0],
  [10, 13, 1],
  [10, 14, 0],
  [10, 15, 0],
  [10, 16, 0],
  [10, 17, -1],
  [10, 18, 0],
  [10, 19, -1],
  [10, 20, 0],
  [10, 21, -1],
  [10, 22, 0],
  [10, 23, -1],
  [10, 24, 0],
  [10, 25, 0],
  [10, 26, 0],
  [10, 27, 1],
  [10, 28, 0],
  [10, 29, -1],
  [10, 30, 0],
  [11, 1, 1],
  [11, 2, -1],
  [11, 3, -1],
  [11, 4, 1],
  [11, 5, 1],
  [11, 6, 1],
  [11, 7, 1],
  [11, 8, -1],
  [11, 9, 1],
  [11, 10, -1],
  [11, 11, 0],
  [11, 12, -1],
  [11, 13, -1],
  [11, 14, -1],
  [11, 15, -1],
  [11, 16, 1],
  [11, 17, -1],
  [11, 18, -1],
  [11, 19, 1],
  [11, 20, 1],
  [11, 21, -1],
  [11, 22, 0],
  [11, 23, -1],
  [11, 24, 1],
  [11, 25, 1],
  [11, 26, 1],
  [11, 27, -1],
  [11, 28, 1],
  [11, 29, -1],
  [11, 30, 1],
  [12, 1, 1],
  [12, 2, 0],
  [12, 3, 0],
  [12, 4, 0],
  [12, 5, -1],
  [12, 6, 0],
  [12, 7, -1],
  [12, 8, 0],
  [12, 9, 0],
  [12, 10, 0],
  [12, 11, 1],
  [12, 12, 0],
  [12, 13, 1],
  [12, 14, 0],
  [12, 15, 0],
  [12, 16, 0],
  [12, 17, -1],
  [12, 18, 0],
  [12, 19, -1],
  [12, 20, 0],
  [12, 21, 0],
  [12, 22, 0],
  [12, 23, 1],
  [12, 24, 0],
  [12, 25, 1],
  [12, 26, 0],
  [12, 27, 0],
  [12, 28, 0],
  [12, 29, -1],
  [12, 30, 0],
  [13, 1, 1],
  [13, 2, -1],
  [13, 3, 1],
  [13, 4, 1],
  [13, 5, -1],
  [13, 6, -1],
  [13, 7, -1],
  [13, 8, -1],
  [13, 9, 1],
  [13, 10, 1],
  [13, 11, -1],
  [13, 12, 1],
  [13, 13, 0],
  [13, 14, 1],
  [13, 15, -1],
  [13, 16, 1],
  [13, 17, 1],
  [13, 18, -1],
  [13, 19, -1],
  [13, 20, -1],
  [13, 21, -1],
  [13, 22, 1],
  [13, 23, 1],
  [13, 24, -1],
  [13, 25, 1],
  [13, 26, 0],
  [13, 27, 1],
  [13, 28, -1],
  [13, 29, 1],
  [13, 30, 1],
  [14, 1, 1],
  [14, 2, 0],
  [14, 3, -1],
  [14, 4, 0],
  [14, 5, 1],
  [14, 6, 0],
  [14, 7, 0],
  [14, 8, 0],
  [14, 9, 1],
  [14, 10, 0],
  [14, 11, 1],
  [14, 12, 0],
  [14, 13, 1],
  [14, 14, 0],
  [14, 15, -1],
  [14, 16, 0],
  [14, 17, -1],
  [14, 18, 0],
  [14, 19, -1],
  [14, 20, 0],
  [14, 21, 0],
  [14, 22, 0],
  [14, 23, -1],
  [14, 24, 0],
  [14, 25, 1],
  [14, 26, 0],
  [14, 27, -1],
  [14, 28, 0],
  [14, 29, -1],
  [14, 30, 0],
  [15, 1, 1],
  [15, 2, 1],
  [15, 3, 0],
  [15, 4, 1],
  [15, 5, 0],
  [15, 6, 0],
  [15, 7, 1],
  [15, 8, 1],
  [15, 9, 0],
  [15, 10, 0],
  [15, 11, 1],
  [15, 12, 0],
  [15, 13, -1],
  [15, 14, 1],
  [15, 15, 0],
  [15, 16, 1],
  [15, 17, 1],
  [15, 18, 0],
  [15, 19, -1],
  [15, 20, 0],
  [15, 21, 0],
  [15, 22, 1],
  [15, 23, -1],
  [15, 24, 0],
  [15, 25, 0],
  [15, 26, -1],
  [15, 27, 0],
  [15, 28, 1],
  [15, 29, -1],
  [15, 30, 0],
  [16, 1, 1],
  [16, 2, 0],
  [16, 3, 1],
  [16, 4, 0],
  [16, 5, 1],
  [16, 6, 0],
  [16, 7, 1],
  [16, 8, 0],
  [16, 9, 1],
  [16, 10, 0],
  [16, 11, 1],
  [16, 12, 0],
  [16, 13, 1],
  [16, 14, 0],
  [16, 15, 1],
  [16, 16, 0],
  [16, 17, 1],
  [16, 18, 0],
  [16, 19, 1],
  [16, 20, 0],
  [16, 21, 1],
  [16, 22, 0],
  [16, 23, 1],
  [16, 24, 0],
  [16, 25, 1],
  [16, 26, 0],
  [16, 27, 1],
  [16, 28, 0],
  [16, 29, 1],
  [16, 30, 0],
  [17, 1, 1],
  [17, 2, 1],
  [17, 3, -1],
  [17, 4, 1],
  [17, 5, -1],
  [17, 6, -1],
  [17, 7, -1],
  [17, 8, 1],
  [17, 9, 1],
  [17, 10, -1],
  [17, 11, -1],
  [17, 12, -1],
  [17, 13, 1],
  [17, 14, -1],
  [17, 15, 1],
  [17, 16, 1],
  [17, 17, 0],
  [17, 18, 1],
  [17, 19, 1],
  [17, 20, -1],
  [17, 21, 1],
  [17, 22, -1],
  [17, 23, -1],
  [17, 24, -1],
  [17, 25, 1],
  [17, 26, 1],
  [17, 27, -1],
  [17, 28, -1],
  [17, 29, -1],
  [17, 30, 1],
  [18, 1, 1],
  [18, 2, 0],
  [18, 3, 0],
  [18, 4, 0],
  [18, 5, -1],
  [18, 6, 0],
  [18, 7, 1],
  [18, 8, 0],
  [18, 9, 0],
  [18, 10, 0],
  [18, 11, -1],
  [18, 12, 0],
  [18, 13, -1],
  [18, 14, 0],
  [18, 15, 0],
  [18, 16, 0],
  [18, 17, 1],
  [18, 18, 0],
  [18, 19, -1],
  [18, 20, 0],
  [18, 21, 0],
  [18, 22, 0],
  [18, 23, 1],
  [18, 24, 0],
  [18, 25, 1],
  [18, 26, 0],
  [18, 27, 0],
  [18, 28, 0],
  [18, 29, -1],
  [18, 30, 0],
  [19, 1, 1],
  [19, 2, -1],
  [19, 3, 1],
  [19, 4, 1],
  [19, 5, 1],
  [19, 6, -1],
  [19, 7, -1],
  [19, 8, -1],
  [19, 9, 1],
  [19, 10, -1],
  [19, 11, -1],
  [19, 12, 1],
  [19, 13, -1],
  [19, 14, 1],
  [19, 15, 1],
  [19, 16, 1],
  [19, 17, 1],
  [19, 18, -1],
  [19, 19, 0],
  [19, 20, 1],
  [19, 21, -1],
  [19, 22, 1],
  [19, 23, -1],
  [19, 24, -1],
  [19, 25, 1],
  [19, 26, 1],
  [19, 27, 1],
  [19, 28, -1],
  [19, 29, -1],
  [19, 30, -1],
  [20, 1, 1],
  [20, 2, 0],
  [20, 3, -1],
  [20, 4, 0],
  [20, 5, 0],
  [20, 6, 0],
  [20, 7, -1],
  [20, 8, 0],
  [20, 9, 1],
  [20, 10, 0],
  [20, 11, 1],
  [20, 12, 0],
  [20, 13, -1],
  [20, 14, 0],
  [20, 15, 0],
  [20, 16, 0],
  [20, 17, -1],
  [20, 18, 0],
  [20, 19, 1],
  [20, 20, 0],
  [20, 21, 1],
  [20, 22, 0],
  [20, 23, -1],
  [20, 24, 0],
  [20, 25, 0],
  [20, 26, 0],
  [20, 27, -1],
  [20, 28, 0],
  [20, 29, 1],
  [20, 30, 0],
  [21, 1, 1],
  [21, 2, -1],
  [21, 3, 0],
  [21, 4, 1],
  [21, 5, 1],
  [21, 6, 0],
  [21, 7, 0],
  [21, 8, -1],
  [21, 9, 0],
  [21, 10, -1],
  [21, 11, -1],
  [21, 12, 0],
  [21, 13, -1],
  [21, 14, 0],
  [21, 15, 0],
  [21, 16, 1],
  [21, 17, 1],
  [21, 18, 0],
  [21, 19, -1],
  [21, 20, 1],
  [21, 21, 0],
  [21, 22, 1],
  [21, 23, -1],
  [21, 24, 0],
  [21, 25, 1],
  [21, 26, 1],
  [21, 27, 0],
  [21, 28, 0],
  [21, 29, -1],
  [21, 30, 0],
  [22, 1, 1],
  [22, 2, 0],
  [22, 3, 1],
  [22, 4, 0],
  [22, 5, -1],
  [22, 6, 0],
  [22, 7, 1],
  [22, 8, 0],
  [22, 9, 1],
  [22, 10, 0],
  [22, 11, 0],
  [22, 12, 0],
  [22, 13, 1],
  [22, 14, 0],
  [22, 15, -1],
  [22, 16, 0],
  [22, 17, -1],
  [22, 18, 0],
  [22, 19, -1],
  [22, 20, 0],
  [22, 21, 1],
  [22, 22, 0],
  [22, 23, -1],
  [22, 24, 0],
  [22, 25, 1],
  [22, 26, 0],
  [22, 27, 1],
  [22, 28, 0],
  [22, 29, 1],
  [22, 30, 0],
  [23, 1, 1],
  [23, 2, 1],
  [23, 3, -1],
  [23, 4, 1],
  [23, 5, -1],
  [23, 6, -1],
  [23, 7, 1],
  [23, 8, 1],
  [23, 9, 1],
  [23, 10, -1],
  [23, 11, 1],
  [23, 12, -1],
  [23, 13, 1],
  [23, 14, 1],
  [23, 15, 1],
  [23, 16, 1],
  [23, 17, -1],
  [23, 18, 1],
  [23, 19, 1],
  [23, 20, -1],
  [23, 21, -1],
  [23, 22, 1],
  [23, 23, 0],
  [23, 24, -1],
  [23, 25, 1],
  [23, 26, 1],
  [23, 27, -1],
  [23, 28, 1],
  [23, 29, 1],
  [23, 30, 1],
  [24, 1, 1],
  [24, 2, 0],
  [24, 3, 0],
  [24, 4, 0],
  [24, 5, 1],
  [24, 6, 0],
  [24, 7, -1],
  [24, 8, 0],
  [24, 9, 0],
  [24, 10, 0],
  [24, 11, -1],
  [24, 12, 0],
  [24, 13, -1],
  [24, 14, 0],
  [24, 15, 0],
  [24, 16, 0],
  [24, 17, -1],
  [24, 18, 0],
  [24, 19, 1],
  [24, 20, 0],
  [24, 21, 0],
  [24, 22, 0],
  [24, 23, 1],
  [24, 24, 0],
  [24, 25, 1],
  [24, 26, 0],
  [24, 27, 0],
  [24, 28, 0],
  [24, 29, 1],
  [24, 30, 0],
  [25, 1, 1],
  [25, 2, 1],
  [25, 3, 1],
  [25, 4, 1],
  [25, 5, 0],
  [25, 6, 1],
  [25, 7, 1],
  [25, 8, 1],
  [25, 9, 1],
  [25, 10, 0],
  [25, 11, 1],
  [25, 12, 1],
  [25, 13, 1],
  [25, 14, 1],
  [25, 15, 0],
  [25, 16, 1],
  [25, 17, 1],
  [25, 18, 1],
  [25, 19, 1],
  [25, 20, 0],
  [25, 21, 1],
  [25, 22, 1],
  [25, 23, 1],
  [25, 24, 1],
  [25, 25, 0],
  [25, 26, 1],
  [25, 27, 1],
  [25, 28, 1],
  [25, 29, 1],
  [25, 30, 0],
  [26, 1, 1],
  [26, 2, 0],
  [26, 3, -1],
  [26, 4, 0],
  [26, 5, 1],
  [26, 6, 0],
  [26, 7, -1],
  [26, 8, 0],
  [26, 9, 1],
  [26, 10, 0],
  [26, 11, 1],
  [26, 12, 0],
  [26, 13, 0],
  [26, 14, 0],
  [26, 15, -1],
  [26, 16, 0],
  [26, 17, 1],
  [26, 18, 0],
  [26, 19, 1],
  [26, 20, 0],
  [26, 21, 1],
  [26, 22, 0],
  [26, 23, 1],
  [26, 24, 0],
  [26, 25, 1],
  [26, 26, 0],
  [26, 27, -1],
  [26, 28, 0],
  [26, 29, -1],
  [26, 30, 0],
  [27, 1, 1],
  [27, 2, -1],
  [27, 3, 0],
  [27, 4, 1],
  [27, 5, -1],
  [27, 6, 0],
  [27, 7, -1],
  [27, 8, -1],
  [27, 9, 0],
  [27, 10, 1],
  [27, 11, 1],
  [27, 12, 0],
  [27, 13, 1],
  [27, 14, 1],
  [27, 15, 0],
  [27, 16, 1],
  [27, 17, -1],
  [27, 18, 0],
  [27, 19, -1],
  [27, 20, -1],
  [27, 21, 0],
  [27, 22, -1],
  [27, 23, 1],
  [27, 24, 0],
  [27, 25, 1],
  [27, 26, -1],
  [27, 27, 0],
  [27, 28, -1],
  [27, 29, -1],
  [27, 30, 0],
  [28, 1, 1],
  [28, 2, 0],
  [28, 3, 1],
  [28, 4, 0],
  [28, 5, -1],
  [28, 6, 0],
  [28, 7, 0],
  [28, 8, 0],
  [28, 9, 1],
  [28, 10, 0],
  [28, 11, -1],
  [28, 12, 0],
  [28, 13, -1],
  [28, 14, 0],
  [28, 15, -1],
  [28, 16, 0],
  [28, 17, -1],
  [28, 18, 0],
  [28, 19, 1],
  [28, 20, 0],
  [28, 21, 0],
  [28, 22, 0],
  [28, 23, -1],
  [28, 24, 0],
  [28, 25, 1],
  [28, 26, 0],
  [28, 27, 1],
  [28, 28, 0],
  [28, 29, 1],
  [28, 30, 0],
  [29, 1, 1],
  [29, 2, -1],
  [29, 3, -1],
  [29, 4, 1],
  [29, 5, 1],
  [29, 6, 1],
  [29, 7, 1],
  [29, 8, -1],
  [29, 9, 1],
  [29, 10, -1],
  [29, 11, -1],
  [29, 12, -1],
  [29, 13, 1],
  [29, 14, -1],
  [29, 15, -1],
  [29, 16, 1],
  [29, 17, -1],
  [29, 18, -1],
  [29, 19, -1],
  [29, 20, 1],
  [29, 21, -1],
  [29, 22, 1],
  [29, 23, 1],
  [29, 24, 1],
  [29, 25, 1],
  [29, 26, -1],
  [29, 27, -1],
  [29, 28, 1],
  [29, 29, 0],
  [29, 30, 1],
  [30, 1, 1],
  [30, 2, 0],
  [30, 3, 0],
  [30, 4, 0],
  [30, 5, 0],
  [30, 6, 0],
  [30, 7, 1],
  [30, 8, 0],
  [30, 9, 0],
  [30, 10, 0],
  [30, 11, -1],
  [30, 12, 0],
  [30, 13, 1],
  [30, 14, 0],
  [30, 15, 0],
  [30, 16, 0],
  [30, 17, 1],
  [30, 18, 0],
  [30, 19, 1],
  [30, 20, 0],
  [30, 21, 0],
  [30, 22, 0],
  [30, 23, -1],
  [30, 24, 0],
  [30, 25, 0],
  [30, 26, 0],
  [30, 27, 0],
  [30, 28, 0],
  [30, 29, 1],
  [30, 30, 0]
];

describe('BN.js', function() {
  const rng = new RNG();

  describe('BN.js/Arithmetic', () => {
    describe('.add()', () => {
      it('should add numbers', () => {
        assert.strictEqual(new BN(14).add(new BN(26)).toString(16), '28');

        const k = new BN(0x1234);

        let r = k;

        for (let i = 0; i < 257; i++)
          r = r.add(k);

        assert.strictEqual(r.toString(16), '125868');
      });

      it('should handle carry properly (in-place)', () => {
        const k = new BN('abcdefabcdefabcdef', 16);
        const r = new BN('deadbeef', 16);

        for (let i = 0; i < 257; i++)
          r.iadd(k);

        assert.strictEqual(r.toString(16), 'ac79bd9b79be7a277bde');
      });

      it('should properly do positive + negative', () => {
        {
          const a = new BN('abcd', 16);
          const b = new BN('-abce', 16);

          assert.strictEqual(a.iadd(b).toString(16), '-1');
        }

        {
          const a = new BN('abcd', 16);
          const b = new BN('-abce', 16);

          assert.strictEqual(a.add(b).toString(16), '-1');
          assert.strictEqual(b.add(a).toString(16), '-1');
        }
      });
    });

    describe('.iaddn()', () => {
      it('should allow a sign change', () => {
        const a = new BN(-100);

        assert.strictEqual(a.negative, 1);

        a.iaddn(200);

        assert.strictEqual(a.negative, 0);
        assert.strictEqual(a.toString(), '100');
      });

      it('should add negative number', () => {
        const a = new BN(-100);

        assert.strictEqual(a.negative, 1);

        a.iaddn(-200);

        assert.strictEqual(a.toString(), '-300');
      });

      it('should allow neg + pos with big number', () => {
        const a = new BN('-1000000000', 10);

        assert.strictEqual(a.negative, 1);

        a.iaddn(200);

        assert.strictEqual(a.toString(), '-999999800');
      });

      it('should carry limb', () => {
        const a = new BN('3ffffff', 16);

        assert.strictEqual(a.iaddn(1).toString(16), '4000000');
      });

      it('should throw error with num eq 0x4000000', () => {
        assert.throws(() => {
          new BN(0).iaddn(0x4000000);
        });
      });

      it('should reset sign if value equal to value in instance', function () {
        const a = new BN(-1);
        assert.strictEqual(a.addn(1).toString(), '0');
      });
    });

    describe('.sub()', () => {
      it('should subtract small numbers', () => {
        assert.strictEqual(new BN(26).sub(new BN(14)).toString(16), 'c');
        assert.strictEqual(new BN(14).sub(new BN(26)).toString(16), '-c');
        assert.strictEqual(new BN(26).sub(new BN(26)).toString(16), '0');
        assert.strictEqual(new BN(-26).sub(new BN(26)).toString(16), '-34');
      });

      const a = new BN(
        '31ff3c61db2db84b9823d320907a573f6ad37c437abe458b1802cda041d6384' +
        'a7d8daef41395491e2',
        16);

      const b = new BN(
        '6f0e4d9f1d6071c183677f601af9305721c91d31b0bbbae8fb790000',
        16);

      const r = new BN(
        '31ff3c61db2db84b9823d3208989726578fd75276287cd9516533a9acfb9a67' +
        '76281f34583ddb91e2',
        16);

      it('should subtract big numbers', () => {
        assert.strictEqual(a.sub(b).cmp(r), 0);
      });

      it('should subtract numbers in place', () => {
        assert.strictEqual(b.clone().isub(a).neg().cmp(r), 0);
      });

      it('should subtract with carry', () => {
        // Carry and copy
        {
          const a = new BN('12345', 16);
          const b = new BN('1000000000000', 16);

          assert.strictEqual(a.isub(b).toString(16), '-fffffffedcbb');
        }

        {
          const a = new BN('12345', 16);
          const b = new BN('1000000000000', 16);

          assert.strictEqual(b.isub(a).toString(16), 'fffffffedcbb');
        }
      });
    });

    describe('.isubn()', () => {
      it('should subtract negative number', () => {
        const r = new BN(
          '7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b', 16);
        assert.strictEqual(r.isubn(-1).toString(16),
          '7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681c');
      });

      it('should work for positive numbers', () => {
        const a = new BN(-100);

        assert.strictEqual(a.negative, 1);

        a.isubn(200);

        assert.strictEqual(a.negative, 1);
        assert.strictEqual(a.toString(), '-300');
      });

      it('should not allow a sign change', () => {
        const a = new BN(-100);

        assert.strictEqual(a.negative, 1);

        a.isubn(-200);

        assert.strictEqual(a.negative, 0);
        assert.strictEqual(a.toString(), '100');
      });

      it('should change sign on small numbers at 0', () => {
        const a = new BN(0).subn(2);
        assert.strictEqual(a.toString(), '-2');
      });

      it('should change sign on small numbers at 1', () => {
        const a = new BN(1).subn(2);
        assert.strictEqual(a.toString(), '-1');
      });

      it('should throw error with num eq 0x4000000', () => {
        assert.throws(() => {
          new BN(0).isubn(0x4000000);
        });
      });
    });

    function testMethod(name, mul) {
      describe(name, () => {
        it('should multiply numbers of different signs', () => {
          const offsets = [
            1, // smallMulTo
            250, // comb10MulTo
            1000, // bigMulTo
            15000 // jumboMulTo
          ];

          for (let i = 0; i < offsets.length; i++) {
            const x = new BN(1).ishln(offsets[i]);

            assert.strictEqual(mul(x, x).isNeg(), false);
            assert.strictEqual(mul(x, x.neg()).isNeg(), true);
            assert.strictEqual(mul(x.neg(), x).isNeg(), true);
            assert.strictEqual(mul(x.neg(), x.neg()).isNeg(), false);
          }
        });

        it('should multiply with carry', () => {
          const n = new BN(0x1001);

          let r = n;

          for (let i = 0; i < 4; i++)
            r = mul(r, n);

          assert.strictEqual(r.toString(16), '100500a00a005001');
        });

        it('should correctly multiply big numbers', () => {
          const n = new BN(
            '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
            16
          );

          assert.strictEqual(
            mul(n, n).toString(16),
            '39e58a8055b6fb264b75ec8c646509784204ac15a8c24e05babc9729ab9' +
            'b055c3a9458e4ce3289560a38e08ba8175a9446ce14e608245ab3a9' +
            '978a8bd8acaa40');

          assert.strictEqual(
            mul(mul(n, n), n).toString(16),
            '1b888e01a06e974017a28a5b4da436169761c9730b7aeedf75fc60f687b' +
            '46e0cf2cb11667f795d5569482640fe5f628939467a01a612b02350' +
            '0d0161e9730279a7561043af6197798e41b7432458463e64fa81158' +
            '907322dc330562697d0d600');
        });

        it('should multiply neg number on 0', () => {
          assert.strictEqual(
            mul(new BN('-100000000000'), new BN('3').quo(new BN('4')))
              .toString(16),
            '0'
          );
        });

        it('should regress mul big numbers', () => {
          const q = new BN(dhGroups.p17.q, 16);
          const qs = new BN(dhGroups.p17.qs, 16);

          assert.strictEqual(mul(q, q).toString(16), qs.toString(16));
        });
      });
    }

    testMethod('.mul()', (x, y) => {
      return BN.prototype.mul.apply(x, [y]);
    });

    describe('.imul()', () => {
      it('should multiply numbers in-place', () => {
        {
          const a = new BN('abcdef01234567890abcd', 16);
          const b = new BN('deadbeefa551edebabba8', 16);
          const c = a.mul(b);

          assert.strictEqual(a.imul(b).toString(16), c.toString(16));
        }

        {
          const a = new BN('abcdef01234567890abcd214a25123f512361e6d236', 16);
          const b = new BN('deadbeefa551edebabba8121234fd21bac0341324dd', 16);
          const c = a.mul(b);

          assert.strictEqual(a.imul(b).toString(16), c.toString(16));
        }
      });

      it('should multiply by 0', () => {
        const a = new BN('abcdef01234567890abcd', 16);
        const b = new BN('0', 16);
        const c = a.mul(b);

        assert.strictEqual(a.imul(b).toString(16), c.toString(16));
      });

      it('should regress mul big numbers in-place', () => {
        const q = new BN(dhGroups.p17.q, 16);
        const qs = new BN(dhGroups.p17.qs, 16);

        assert.strictEqual(q.isqr().toString(16), qs.toString(16));
      });
    });

    describe('.muln()', () => {
      it('should multiply number by small number', () => {
        const a = new BN('abcdef01234567890abcd', 16);
        const b = new BN('dead', 16);
        const c = a.mul(b);

        assert.strictEqual(a.muln(0xdead).toString(16), c.toString(16));
      });

      it('should throw error with num eq 0x4000000', () => {
        assert.throws(() => {
          new BN(0).imuln(0x4000000);
        });
      });

      it('should negate number if number is negative', () => {
        const a = new BN('dead', 16);

        assert.strictEqual(a.clone().imuln(-1).toString(16),
                     a.clone().neg().toString(16));
        assert.strictEqual(a.clone().muln(-1).toString(16),
                     a.clone().neg().toString(16));

        const b = new BN('dead', 16);

        assert.strictEqual(b.clone().imuln(-42).toString(16),
                     b.clone().neg().muln(42).toString(16));
        assert.strictEqual(b.clone().muln(-42).toString(16),
                     b.clone().neg().muln(42).toString(16));
      });
    });

    describe('.pow()', () => {
      it('should raise number to the power', () => {
        const a = new BN('ab', 16);
        const b = new BN('13', 10);

        assert.strictEqual(a.pow(b).toString(16), '15963da06977df51909c9ba5b');
        assert.strictEqual(a.clone().ipow(b).toString(16), '15963da06977df51909c9ba5b');
        assert.strictEqual(a.pown(13).toString(16), '15963da06977df51909c9ba5b');
        assert.strictEqual(a.clone().ipown(13).toString(16), '15963da06977df51909c9ba5b');
      });
    });

    describe('.quo()', () => {
      it('should divide small numbers (<=26 bits)', () => {
        assert.strictEqual(new BN('256').quo(new BN(10)).toString(10),
          '25');
        assert.strictEqual(new BN('-256').quo(new BN(10)).toString(10),
          '-25');
        assert.strictEqual(new BN('256').quo(new BN(-10)).toString(10),
          '-25');
        assert.strictEqual(new BN('-256').quo(new BN(-10)).toString(10),
          '25');

        assert.strictEqual(new BN('10').quo(new BN(256)).toString(10),
          '0');
        assert.strictEqual(new BN('-10').quo(new BN(256)).toString(10),
          '0');
        assert.strictEqual(new BN('10').quo(new BN(-256)).toString(10),
          '0');
        assert.strictEqual(new BN('-10').quo(new BN(-256)).toString(10),
          '0');
      });

      it('should divide large numbers (>53 bits)', () => {
        assert.strictEqual(new BN('1222222225255589').quo(new BN('611111124969028'))
          .toString(10), '1');
        assert.strictEqual(new BN('-1222222225255589').quo(new BN('611111124969028'))
          .toString(10), '-1');
        assert.strictEqual(new BN('1222222225255589').quo(new BN('-611111124969028'))
          .toString(10), '-1');
        assert.strictEqual(new BN('-1222222225255589').quo(new BN('-611111124969028'))
          .toString(10), '1');

        assert.strictEqual(new BN('611111124969028').quo(new BN('1222222225255589'))
          .toString(10), '0');
        assert.strictEqual(new BN('-611111124969028').quo(new BN('1222222225255589'))
          .toString(10), '0');
        assert.strictEqual(new BN('611111124969028').quo(new BN('-1222222225255589'))
          .toString(10), '0');
        assert.strictEqual(new BN('-611111124969028').quo(new BN('-1222222225255589'))
          .toString(10), '0');
      });

      it('should divide numbers', () => {
        assert.strictEqual(new BN('69527932928').quo(new BN('16974594')).toString(16),
          'fff');
        assert.strictEqual(new BN('-69527932928').quo(new BN('16974594')).toString(16),
          '-fff');

        const b = new BN(''
          + '39e58a8055b6fb264b75ec8c646509784204ac15a8c24e05babc9729ab9'
          + 'b055c3a9458e4ce3289560a38e08ba8175a9446ce14e608245ab3a9'
          + '978a8bd8acaa40',
          16);

        const n = new BN(
          '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
          16
        );

        assert.strictEqual(b.quo(n).toString(16), n.toString(16));

        assert.strictEqual(new BN('1').quo(new BN('-5')).toString(10), '0');
      });

      it('should not fail on regression after moving to _wordDiv (1)', () => {
        // Regression after moving to word div
        const p = new BN(
          'fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f',
          16);

        const a = new BN(
          '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
          16);

        const as = a.sqr();

        assert.strictEqual(
          as.quo(p).toString(16),
          '39e58a8055b6fb264b75ec8c646509784204ac15a8c24e05babc9729e58090b9');
      });

      it('should not fail on regression after moving to _wordDiv (2)', () => {
        const p = new BN(
          'ffffffff00000001000000000000000000000000ffffffffffffffffffffffff',
          16);

        const a = new BN(''
          + 'fffffffe00000003fffffffd0000000200000001fffffffe00000002ffffffff'
          + 'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',
          16);

        assert.strictEqual(
          a.quo(p).toString(16),
          'ffffffff00000002000000000000000000000001000000000000000000000001');
      });
    });

    describe('.iquon()', () => {
      it('should divide numbers in-place', () => {
        assert.strictEqual(new BN('10', 16).iquon(3).toString(16), '5');
        assert.strictEqual(new BN('10', 16).iquon(-3).toString(16), '-5');
        assert.strictEqual(new BN('12', 16).iquon(3).toString(16), '6');
        assert.strictEqual(new BN('10000000000000000').iquon(3).toString(10),
          '3333333333333333');

        assert.strictEqual(
          new BN('100000000000000000000000000000').iquon(3).toString(10),
          '33333333333333333333333333333');

        const t = new BN(3);

        assert.strictEqual(
          new BN('12345678901234567890123456', 16).iquon(3).toString(16),
          new BN('12345678901234567890123456', 16).quo(t).toString(16));
      });
    });

    describe('.divRound()', () => {
      it('should divide numbers with rounding', () => {
        assert.strictEqual(new BN(9).divRound(new BN(20)).toString(10),
          '0');
        assert.strictEqual(new BN(10).divRound(new BN(20)).toString(10),
          '1');
        assert.strictEqual(new BN(150).divRound(new BN(20)).toString(10),
          '8');
        assert.strictEqual(new BN(149).divRound(new BN(20)).toString(10),
          '7');
        assert.strictEqual(new BN(149).divRound(new BN(17)).toString(10),
          '9');
        assert.strictEqual(new BN(144).divRound(new BN(17)).toString(10),
          '8');
        assert.strictEqual(new BN(-144).divRound(new BN(17)).toString(10),
          '-8');
      });

      it('should return 1 on exact division', () => {
        assert.strictEqual(new BN(144).divRound(new BN(144)).toString(10), '1');
      });

      it('should divide negative numbers with rounding', () => {
        assert.strictEqual(new BN(-9).divRound(new BN(20)).toString(10),
          '0');
        assert.strictEqual(new BN(-10).divRound(new BN(20)).toString(10),
          '-1');
        assert.strictEqual(new BN(-150).divRound(new BN(20)).toString(10),
          '-8');
        assert.strictEqual(new BN(-149).divRound(new BN(20)).toString(10),
          '-7');
        assert.strictEqual(new BN(-149).divRound(new BN(17)).toString(10),
          '-9');
        assert.strictEqual(new BN(-144).divRound(new BN(17)).toString(10),
          '-8');
        assert.strictEqual(new BN(-144).divRound(new BN(17)).toString(10),
          '-8');

        assert.strictEqual(new BN(9).divRound(new BN(-20)).toString(10),
          '0');
        assert.strictEqual(new BN(10).divRound(new BN(-20)).toString(10),
          '-1');
        assert.strictEqual(new BN(150).divRound(new BN(-20)).toString(10),
          '-8');
        assert.strictEqual(new BN(149).divRound(new BN(-20)).toString(10),
          '-7');
        assert.strictEqual(new BN(149).divRound(new BN(-17)).toString(10),
          '-9');
        assert.strictEqual(new BN(144).divRound(new BN(-17)).toString(10),
          '-8');
        assert.strictEqual(new BN(144).divRound(new BN(-17)).toString(10),
          '-8');

        assert.strictEqual(new BN(-9).divRound(new BN(-20)).toString(10),
          '0');
        assert.strictEqual(new BN(-10).divRound(new BN(-20)).toString(10),
          '1');
        assert.strictEqual(new BN(-150).divRound(new BN(-20)).toString(10),
          '8');
        assert.strictEqual(new BN(-149).divRound(new BN(-20)).toString(10),
          '7');
        assert.strictEqual(new BN(-149).divRound(new BN(-17)).toString(10),
          '9');
        assert.strictEqual(new BN(-144).divRound(new BN(-17)).toString(10),
          '8');
        assert.strictEqual(new BN(-144).divRound(new BN(-17)).toString(10),
          '8');
      });

      it('should return 1 on exact negative divisions', () => {
        assert.strictEqual(new BN(-144).divRound(new BN(144)).toString(10), '-1');
        assert.strictEqual(new BN(144).divRound(new BN(-144)).toString(10), '-1');
        assert.strictEqual(new BN(-144).divRound(new BN(-144)).toString(10), '1');
      });
    });

    describe('.rem()', () => {
      it('should modulo small numbers (<=26 bits)', () => {
        assert.strictEqual(new BN('256').rem(new BN(10)).toString(10),
          '6');
        assert.strictEqual(new BN('-256').rem(new BN(10)).toString(10),
          '-6');
        assert.strictEqual(new BN('256').rem(new BN(-10)).toString(10),
          '6');
        assert.strictEqual(new BN('-256').rem(new BN(-10)).toString(10),
          '-6');

        assert.strictEqual(new BN('10').rem(new BN(256)).toString(10),
          '10');
        assert.strictEqual(new BN('-10').rem(new BN(256)).toString(10),
          '-10');
        assert.strictEqual(new BN('10').rem(new BN(-256)).toString(10),
          '10');
        assert.strictEqual(new BN('-10').rem(new BN(-256)).toString(10),
          '-10');
      });

      it('should modulo large numbers (>53 bits)', () => {
        assert.strictEqual(new BN('1222222225255589').rem(new BN('611111124969028'))
          .toString(10), '611111100286561');
        assert.strictEqual(new BN('-1222222225255589').rem(new BN('611111124969028'))
          .toString(10), '-611111100286561');
        assert.strictEqual(new BN('1222222225255589').rem(new BN('-611111124969028'))
          .toString(10), '611111100286561');
        assert.strictEqual(new BN('-1222222225255589').rem(new BN('-611111124969028'))
          .toString(10), '-611111100286561');

        assert.strictEqual(new BN('611111124969028').rem(new BN('1222222225255589'))
          .toString(10), '611111124969028');
        assert.strictEqual(new BN('-611111124969028').rem(new BN('1222222225255589'))
          .toString(10), '-611111124969028');
        assert.strictEqual(new BN('611111124969028').rem(new BN('-1222222225255589'))
          .toString(10), '611111124969028');
        assert.strictEqual(new BN('-611111124969028').rem(new BN('-1222222225255589'))
          .toString(10), '-611111124969028');
      });

      it('should mod numbers', () => {
        assert.strictEqual(new BN('10').rem(new BN(256)).toString(16),
          'a');
        assert.strictEqual(new BN('69527932928').rem(new BN('16974594')).toString(16),
          '102f302');

        // 178 = 10 * 17 + 8
        assert.strictEqual(new BN(178).quo(new BN(10)).toNumber(), 17);
        assert.strictEqual(new BN(178).rem(new BN(10)).toNumber(), 8);
        assert.strictEqual(new BN(178).mod(new BN(10)).toNumber(), 8);

        // -178 = 10 * (-17) + (-8)
        assert.strictEqual(new BN(-178).quo(new BN(10)).toNumber(), -17);
        assert.strictEqual(new BN(-178).rem(new BN(10)).toNumber(), -8);
        assert.strictEqual(new BN(-178).mod(new BN(10)).toNumber(), 2);

        // 178 = -10 * (-17) + 8
        assert.strictEqual(new BN(178).quo(new BN(-10)).toNumber(), -17);
        assert.strictEqual(new BN(178).rem(new BN(-10)).toNumber(), 8);
        assert.strictEqual(new BN(178).mod(new BN(-10)).toNumber(), 8);

        // -178 = -10 * (17) + (-8)
        assert.strictEqual(new BN(-178).quo(new BN(-10)).toNumber(), 17);
        assert.strictEqual(new BN(-178).rem(new BN(-10)).toNumber(), -8);
        assert.strictEqual(new BN(-178).mod(new BN(-10)).toNumber(), 2);

        // -4 = 1 * (-3) + -1
        assert.strictEqual(new BN(-4).quo(new BN(-3)).toNumber(), 1);
        assert.strictEqual(new BN(-4).rem(new BN(-3)).toNumber(), -1);

        // -4 = -1 * (3) + -1
        assert.strictEqual(new BN(-4).rem(new BN(3)).toNumber(), -1);
        // -4 = 1 * (-3) + (-1 + 3)
        assert.strictEqual(new BN(-4).mod(new BN(-3)).toNumber(), 2);

        const p = new BN(
          'ffffffff00000001000000000000000000000000ffffffffffffffffffffffff',
          16);

        const a = new BN(
          'fffffffe00000003fffffffd0000000200000001fffffffe00000002ffffffff' +
          'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',
          16);

        assert.strictEqual(
          a.rem(p).toString(16),
          '0');
      });

      it('should properly carry the sign inside division', () => {
        const a = new BN('945304eb96065b2a98b57a48a06ae28d285a71b5', 'hex');
        const b = new BN(
          'fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe',
          'hex');

        assert.strictEqual(a.mul(b).rem(a).cmpn(0), 0);
      });
    });

    describe('.remrn()', () => {
      it('should act like .rem() on small numbers', () => {
        assert.strictEqual(new BN('10', 16).remrn(256).toString(16), '10');
        assert.strictEqual(new BN('10', 16).remrn(-256).toString(16), '10');
        assert.strictEqual(new BN('100', 16).remrn(256).toString(16), '0');
        assert.strictEqual(new BN('1001', 16).remrn(256).toString(16), '1');
        assert.strictEqual(new BN('100000000001', 16).remrn(256).toString(16), '1');
        assert.strictEqual(new BN('100000000001', 16).remrn(257).toString(16),
          new BN('100000000001', 16).rem(new BN(257)).toString(16));
        assert.strictEqual(new BN('123456789012', 16).remrn(3).toString(16),
          new BN('123456789012', 16).rem(new BN(3)).toString(16));
      });
    });

    describe('.abs()', () => {
      it('should return absolute value', () => {
        assert.strictEqual(new BN(0x1001).abs().toString(), '4097');
        assert.strictEqual(new BN(-0x1001).abs().toString(), '4097');
        assert.strictEqual(new BN('ffffffff', 16).abs().toString(), '4294967295');
      });
    });

    describe('.invert()', () => {
      it('should invert relatively-prime numbers', () => {
        {
          const p = new BN(257);
          const a = new BN(3);
          const b = a.invert(p);

          assert.strictEqual(a.mul(b).rem(p).toString(16), '1');
        }

        {
          const p192 = new BN(
            'fffffffffffffffffffffffffffffffeffffffffffffffff',
            16);

          const a = new BN('deadbeef', 16);
          const b = a.invert(p192);

          assert.strictEqual(a.mul(b).rem(p192).toString(16), '1');
        }

        // Even base
        {
          const phi = new BN('872d9b030ba368706b68932cf07a0e0c', 16);
          const e = new BN(65537);
          const d = e.invert(phi);

          assert.strictEqual(e.mul(d).rem(phi).toString(16), '1');
        }

        // Even base (take #2)
        {
          const a = new BN('5');
          const b = new BN('6');
          const r = a.invert(b);

          assert.strictEqual(r.mul(a).rem(b).toString(16), '1');
        }
      });
    });

    describe('.fermat()', () => {
      it('should invert relatively-prime numbers', () => {
        {
          const p = new BN(257);
          const a = new BN(3);
          const b = a.fermat(p);

          assert.strictEqual(a.mul(b).rem(p).toString(16), '1');
        }

        {
          const p192 = new BN(
            'fffffffffffffffffffffffffffffffeffffffffffffffff',
            16);

          const a = new BN('deadbeef', 16);
          const b = a.fermat(p192);

          assert.strictEqual(a.mul(b).rem(p192).toString(16), '1');
        }
      });
    });

    describe('.gcd()', () => {
      it('should return GCD', () => {
        assert.strictEqual(new BN(3).gcd(new BN(2)).toString(10), '1');
        assert.strictEqual(new BN(18).gcd(new BN(12)).toString(10), '6');
        assert.strictEqual(new BN(-18).gcd(new BN(12)).toString(10), '6');
        assert.strictEqual(new BN(-18).gcd(new BN(-12)).toString(10), '6');
        assert.strictEqual(new BN(-18).gcd(new BN(0)).toString(10), '18');
        assert.strictEqual(new BN(0).gcd(new BN(-18)).toString(10), '18');
        assert.strictEqual(new BN(2).gcd(new BN(0)).toString(10), '2');
        assert.strictEqual(new BN(0).gcd(new BN(3)).toString(10), '3');
        assert.strictEqual(new BN(0).gcd(new BN(0)).toString(10), '0');
        assert.strictEqual(new BN(32).gcd(new BN(16)).toString(10), '16');
      });
    });

    describe('.egcd()', () => {
      it('should return EGCD', () => {
        assert.strictEqual(new BN(3).egcd(new BN(2))[2].toString(10), '1');
        assert.strictEqual(new BN(18).egcd(new BN(12))[2].toString(10), '6');
        assert.strictEqual(new BN(-18).egcd(new BN(12))[2].toString(10), '6');
        assert.strictEqual(new BN(0).egcd(new BN(12))[2].toString(10), '12');
        assert.strictEqual(new BN(32).egcd(new BN(16))[2].toString(10), '16');
      });

      it('should not allow 0 input', () => {
        assert.throws(() => {
          new BN(1).egcd(0);
        });
      });

      it('should not allow negative input', () => {
        assert.throws(() => {
          new BN(1).egcd(-1);
        });
      });
    });

    describe('BN.max(a, b)', () => {
      it('should return maximum', () => {
        assert.strictEqual(BN.max(new BN(3), new BN(2)).toString(16), '3');
        assert.strictEqual(BN.max(new BN(2), new BN(3)).toString(16), '3');
        assert.strictEqual(BN.max(new BN(2), new BN(2)).toString(16), '2');
        assert.strictEqual(BN.max(new BN(2), new BN(-2)).toString(16), '2');
      });
    });

    describe('BN.min(a, b)', () => {
      it('should return minimum', () => {
        assert.strictEqual(BN.min(new BN(3), new BN(2)).toString(16), '2');
        assert.strictEqual(BN.min(new BN(2), new BN(3)).toString(16), '2');
        assert.strictEqual(BN.min(new BN(2), new BN(2)).toString(16), '2');
        assert.strictEqual(BN.min(new BN(2), new BN(-2)).toString(16), '-2');
      });
    });

    describe('BN.ineg', () => {
      it('shouldn\'t change sign for zero', () => {
        assert.strictEqual(new BN(0).ineg().toString(10), '0');
      });
    });
  });

  describe('BN.js/Binary', () => {
    describe('.shl()', () => {
      it('should shl numbers', () => {
        assert.strictEqual(new BN('69527932928').shln(13).toString(16),
          '2060602000000');
        assert.strictEqual(new BN('69527932928').shln(45).toString(16),
          '206060200000000000000');
        assert.strictEqual(new BN('-69527932928').shln(13).toString(16),
          '-2060602000000');
        assert.strictEqual(new BN('-69527932928').shln(45).toString(16),
          '-206060200000000000000');
      });

      it('should ushl numbers', () => {
        assert.strictEqual(new BN('69527932928').ushln(13).toString(16),
          '2060602000000');
        assert.strictEqual(new BN('69527932928').ushln(45).toString(16),
          '206060200000000000000');
      });
    });

    describe('.shr()', () => {
      it('should shr numbers', () => {
        assert.strictEqual(new BN('69527932928').shrn(13).toString(16),
          '818180');
        assert.strictEqual(new BN('69527932928').shrn(17).toString(16),
          '81818');
        assert.strictEqual(new BN('69527932928').shrn(256).toString(16),
          '0');
        assert.strictEqual(new BN('-69527932928').shrn(13).toString(16),
          '-818181');
        assert.strictEqual(new BN('-69527932928').shrn(17).toString(16),
          '-81819');
        assert.strictEqual(new BN('-69527932928').shrn(256).toString(16),
          '-1');
      });

      it('should ushr numbers', () => {
        assert.strictEqual(new BN('69527932928').ushrn(13).toString(16),
          '818180');
        assert.strictEqual(new BN('69527932928').ushrn(17).toString(16),
          '81818');
        assert.strictEqual(new BN('69527932928').ushrn(256).toString(16),
          '0');
      });
    });

    describe('.imaskn()', () => {
      it('should mask bits in-place', () => {
        assert.strictEqual(new BN(0).imaskn(1).toString(16), '0');
        assert.strictEqual(new BN(3).imaskn(1).toString(16), '1');
        assert.strictEqual(new BN('123456789', 16).imaskn(4).toString(16), '9');
        assert.strictEqual(new BN('123456789', 16).imaskn(16).toString(16), '6789');
        assert.strictEqual(new BN('123456789', 16).imaskn(28).toString(16), '3456789');

        assert.strictEqual(new BN(-3).imaskn(1).toString(16), '1');
        assert.strictEqual(new BN('-123456789', 16).imaskn(4).toString(16), '7');
        assert.strictEqual(new BN('-123456789', 16).imaskn(16).toString(16), '9877');
        assert.strictEqual(new BN('-123456789', 16).imaskn(28).toString(16), 'cba9877');
      });

      it('should not mask when number is bigger than length', () => {
        assert.strictEqual(new BN(0xe3).imaskn(56).toString(16), 'e3');
        assert.strictEqual(new BN(0xe3).imaskn(26).toString(16), 'e3');
        assert.strictEqual(new BN(-0xe3).imaskn(56).toString(16), 'ffffffffffff1d');
        assert.strictEqual(new BN(-0xe3).imaskn(26).toString(16), '3ffff1d');
      });
    });

    describe('.iumaskn()', () => {
      it('should mask bits in-place', () => {
        assert.strictEqual(new BN(0).iumaskn(1).toString(16), '0');
        assert.strictEqual(new BN(3).iumaskn(1).toString(16), '1');
        assert.strictEqual(new BN('123456789', 16).iumaskn(4).toString(16), '9');
        assert.strictEqual(new BN('123456789', 16).iumaskn(16).toString(16), '6789');
        assert.strictEqual(new BN('123456789', 16).iumaskn(28).toString(16), '3456789');

        assert.strictEqual(new BN(-3).iumaskn(1).toString(16), '-1');
        assert.strictEqual(new BN('-123456789', 16).iumaskn(4).toString(16), '-9');
        assert.strictEqual(new BN('-123456789', 16).iumaskn(16).toString(16), '-6789');
        assert.strictEqual(new BN('-123456789', 16).iumaskn(28).toString(16), '-3456789');
      });

      it('should not mask when number is bigger than length', () => {
        assert.strictEqual(new BN(0xe3).iumaskn(56).toString(16), 'e3');
        assert.strictEqual(new BN(0xe3).iumaskn(26).toString(16), 'e3');
        assert.strictEqual(new BN(-0xe3).iumaskn(56).toString(16), '-e3');
        assert.strictEqual(new BN(-0xe3).iumaskn(26).toString(16), '-e3');
      });
    });

    describe('.testn()', () => {
      it('should support test specific bit', () => {
        [
          'ff',
          'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'
        ].forEach((hex) => {
          const bn = new BN(hex, 16);
          const bl = bn.bitLength();

          for (let i = 0; i < bl; i++) {
            assert.strictEqual(bn.testn(i), 1);
            assert.strictEqual(bn.utestn(i), 1);
          }

          // test off the end
          assert.strictEqual(bn.testn(bl), 0);
          assert.strictEqual(bn.utestn(bl), 0);
        });

        const xbits = '01111001010111001001000100011101'
                    + '11010011101100011000111001011101'
                    + '10010100111000000001011000111101'
                    + '01011111001111100100011110000010'
                    + '01011010100111010001010011000100'
                    + '01101001011110100001001111100110'
                    + '001110010111';

        const x = new BN(
          '23478905234580795234378912401239784125643978256123048348957342');

        for (let i = 0; i < x.bitLength(); i++) {
          assert.strictEqual(x.testn(i), xbits.charCodeAt(i) & 1, 'Failed @ bit ' + i);
          assert.strictEqual(x.utestn(i), xbits.charCodeAt(i) & 1, 'Failed @ bit ' + i);
        }
      });

      it('should support test specific bit (negative)', () => {
        const xbits = '01000110101000110110111011100010'
                    + '00101100010011100111000110100010'
                    + '01101011000111111110100111000010'
                    + '10100000110000011011100001111101'
                    + '10100101011000101110101100111011'
                    + '10010110100001011110110000011001'
                    + '110001101000';

        const x = new BN(
          '-23478905234580795234378912401239784125643978256123048348957342');

        for (let i = 0; i < x.bitLength(); i++)
          assert.strictEqual(x.testn(i), xbits.charCodeAt(i) & 1, 'Failed @ bit ' + i);

        const y = new BN(-2);

        for (let i = 2; i < x.bitLength(); i++)
          y.setn(i, xbits.charCodeAt(i) & 1);

        assert.strictEqual(y.toString(2), x.toString(2));
      });

      it('should have short-cuts', () => {
        const x = new BN('abcd', 16);
        assert(!x.testn(128));
        assert(!x.utestn(128));
      });
    });

    describe('.and()', () => {
      it('should and numbers', () => {
        assert.strictEqual(new BN('1010101010101010101010101010101010101010', 2)
          .and(new BN('101010101010101010101010101010101010101', 2))
          .toString(2), '0');
      });

      it('should and numbers of different limb-length', () => {
        assert.strictEqual(
          new BN('abcd0000ffff', 16)
            .and(new BN('abcd', 16)).toString(16),
          'abcd');
        assert.strictEqual(
          new BN('-abcd0000ffff', 16)
            .and(new BN('abcd', 16)).toString(16),
          '1');
        assert.strictEqual(
          new BN('abcd0000ffff', 16)
            .and(new BN('-abcd', 16)).toString(16),
          'abcd00005433');
        assert.strictEqual(
          new BN('-abcd0000ffff', 16)
            .and(new BN('-abcd', 16)).toString(16),
          '-abcd0000ffff');

        assert.strictEqual(
          new BN('abcd0000ffff', 16)
            .andn(0xabcd).toString(16),
          'abcd');
        assert.strictEqual(
          new BN('-abcd0000ffff', 16)
            .andn(0xabcd).toString(16),
          '1');
        assert.strictEqual(
          new BN('abcd0000ffff', 16)
            .andn(-0xabcd).toString(16),
          'abcd00005433');
        assert.strictEqual(
          new BN('-abcd0000ffff', 16)
            .andn(-0xabcd).toString(16),
          '-abcd0000ffff');

        assert.strictEqual(
          new BN('abcd0000ffff', 16)
            .andrn(0xabcd).toString(16),
          'abcd');
        assert.strictEqual(
          new BN('-abcd0000ffff', 16)
            .andrn(0xabcd).toString(16),
          '1');
        assert.strictEqual(
          new BN('0bcdfff', 16)
            .andrn(-0xabcd).toString(16),
          'bc5433');
        assert.strictEqual(
          new BN('-0bcdfff', 16)
            .andrn(-0xabcd).toString(16),
          '-bcffff');

        assert.throws(() => {
          BN.shift(1, 26).andrn(-1);
        }, RangeError);
      });
    });

    describe('.iand()', () => {
      it('should iand numbers', () => {
        assert.strictEqual(new BN('1010101010101010101010101010101010101010', 2)
          .iand(new BN('101010101010101010101010101010101010101', 2))
          .toString(2), '0');
        assert.strictEqual(new BN('1000000000000000000000000000000000000001', 2)
          .iand(new BN('1', 2))
          .toString(2), '1');
        assert.strictEqual(new BN('1', 2)
          .iand(new BN('1000000000000000000000000000000000000001', 2))
          .toString(2), '1');
      });
    });

    describe('.or()', () => {
      it('should or numbers', () => {
        assert.strictEqual(new BN('1010101010101010101010101010101010101010', 2)
          .or(new BN('101010101010101010101010101010101010101', 2))
          .toString(2), '1111111111111111111111111111111111111111');
      });

      it('should or numbers of different limb-length', () => {
        assert.strictEqual(new BN('abcd00000000', 16)
          .or(new BN('abcd', 16))
          .toString(16), 'abcd0000abcd');
        assert.strictEqual(new BN('-abcd00000000', 16)
          .or(new BN('abcd', 16))
          .toString(16), '-abccffff5433');
        assert.strictEqual(new BN('abcd00000000', 16)
          .or(new BN('-abcd', 16))
          .toString(16), '-abcd');
        assert.strictEqual(new BN('-abcd00000000', 16)
          .or(new BN('-abcd', 16))
          .toString(16), '-abcd');

        assert.strictEqual(new BN('abcd00000000', 16)
          .orn(0xabcd)
          .toString(16), 'abcd0000abcd');
        assert.strictEqual(new BN('-abcd00000000', 16)
          .orn(0xabcd)
          .toString(16), '-abccffff5433');
        assert.strictEqual(new BN('abcd00000000', 16)
          .orn(-0xabcd)
          .toString(16), '-abcd');
        assert.strictEqual(new BN('-abcd00000000', 16)
          .orn(-0xabcd)
          .toString(16), '-abcd');
      });
    });

    describe('.ior()', () => {
      it('should ior numbers', () => {
        assert.strictEqual(new BN('1010101010101010101010101010101010101010', 2)
          .ior(new BN('101010101010101010101010101010101010101', 2))
          .toString(2), '1111111111111111111111111111111111111111');
        assert.strictEqual(new BN('1000000000000000000000000000000000000000', 2)
          .ior(new BN('1', 2))
          .toString(2), '1000000000000000000000000000000000000001');
        assert.strictEqual(new BN('1', 2)
          .ior(new BN('1000000000000000000000000000000000000000', 2))
          .toString(2), '1000000000000000000000000000000000000001');
      });
    });

    describe('.xor()', () => {
      it('should xor numbers', () => {
        assert.strictEqual(new BN('11001100110011001100110011001100', 2)
          .xor(new BN('1100110011001100110011001100110', 2))
          .toString(2), '10101010101010101010101010101010');
      });
    });

    describe('.ixor()', () => {
      it('should ixor numbers', () => {
        assert.strictEqual(new BN('11001100110011001100110011001100', 2)
          .ixor(new BN('1100110011001100110011001100110', 2))
          .toString(2), '10101010101010101010101010101010');
        assert.strictEqual(new BN('11001100110011001100110011001100', 2)
          .ixor(new BN('1', 2))
          .toString(2), '11001100110011001100110011001101');
        assert.strictEqual(new BN('1', 2)
          .ixor(new BN('11001100110011001100110011001100', 2))
          .toString(2), '11001100110011001100110011001101');
      });

      it('should and numbers of different limb-length', () => {
        assert.strictEqual(
          new BN('abcd0000ffff', 16)
            .xor(new BN('abcd', 16)).toString(16),
          'abcd00005432');
        assert.strictEqual(
          new BN('-abcd0000ffff', 16)
            .xor(new BN('abcd', 16)).toString(16),
          '-abcd00005434');
        assert.strictEqual(
          new BN('abcd0000ffff', 16)
            .xor(new BN('-abcd', 16)).toString(16),
          '-abcd00005434');
        assert.strictEqual(
          new BN('-abcd0000ffff', 16)
            .xor(new BN('-abcd', 16)).toString(16),
          'abcd00005432');

        assert.strictEqual(
          new BN('abcd0000ffff', 16)
            .xorn(0xabcd).toString(16),
          'abcd00005432');
        assert.strictEqual(
          new BN('-abcd0000ffff', 16)
            .xorn(0xabcd).toString(16),
          '-abcd00005434');
        assert.strictEqual(
          new BN('abcd0000ffff', 16)
            .xorn(-0xabcd).toString(16),
          '-abcd00005434');
        assert.strictEqual(
          new BN('-abcd0000ffff', 16)
            .xorn(-0xabcd).toString(16),
          'abcd00005432');
      });
    });

    describe('.setn()', () => {
      it('should allow single bits to be set', () => {
        assert.strictEqual(new BN(0).setn(2, true).toString(2), '100');
        assert.strictEqual(new BN(0).setn(27, true).toString(2),
          '1000000000000000000000000000');
        assert.strictEqual(new BN(0).setn(63, true).toString(16),
          new BN(1).iushln(63).toString(16));
        assert.strictEqual(new BN('1000000000000000000000000001', 2).setn(27, false)
          .toString(2), '1');
        assert.strictEqual(new BN('101', 2).setn(2, false).toString(2), '1');

        assert.strictEqual(new BN('-1000000000000000000000000001', 2).setn(27, false)
          .toString(2), '-1000000000000000000000000001');
        assert.strictEqual(new BN('-101', 2).setn(2, false).toString(2), '-101');
      });
    });

    describe('.usetn()', () => {
      it('should allow single bits to be set', () => {
        assert.strictEqual(new BN(0).usetn(2, true).toString(2), '100');
        assert.strictEqual(new BN(0).usetn(27, true).toString(2),
          '1000000000000000000000000000');
        assert.strictEqual(new BN(0).usetn(63, true).toString(16),
          new BN(1).iushln(63).toString(16));
        assert.strictEqual(new BN('1000000000000000000000000001', 2).usetn(27, false)
          .toString(2), '1');
        assert.strictEqual(new BN('101', 2).usetn(2, false).toString(2), '1');

        assert.strictEqual(new BN('-1000000000000000000000000001', 2).usetn(27, false)
          .toString(2), '-1');
        assert.strictEqual(new BN('-101', 2).usetn(2, false).toString(2), '-1');
      });
    });

    describe('.not()', () => {
      it('should allow bitwise negation', () => {
        assert.strictEqual(new BN('111000111', 2).not().toString(2),
          '-111001000');
        assert.strictEqual(new BN('-000111000', 2).not().toString(2),
          '110111');
        assert.strictEqual(new BN('111000111', 2).inot().toString(2),
          '-111001000');
        assert.strictEqual(new BN('-000111000', 2).inot().toString(2),
          '110111');
      });
    });

    describe('.notn()', () => {
      it('should allow bitwise negation', () => {
        assert.strictEqual(new BN('111000111', 2).notn(9).toString(2),
          '111000');
        assert.strictEqual(new BN('000111000', 2).notn(9).toString(2),
          '111000111');
        assert.strictEqual(new BN('111000111', 2).notn(9).toString(2),
          '111000');
        assert.strictEqual(new BN('000111000', 2).notn(9).toString(2),
          '111000111');
        assert.strictEqual(new BN('111000111', 2).notn(32).toString(2),
          '11111111111111111111111000111000');
        assert.strictEqual(new BN('000111000', 2).notn(32).toString(2),
          '11111111111111111111111111000111');
        assert.strictEqual(new BN('111000111', 2).notn(68).toString(2),
          '11111111111111111111111111111111' +
          '111111111111111111111111111000111000');
        assert.strictEqual(new BN('000111000', 2).notn(68).toString(2),
          '11111111111111111111111111111111' +
          '111111111111111111111111111111000111');
      });
    });
  });

  describe('BN.js/Constructor', () => {
    describe('with Smi input', () => {
      it('should accept one limb number', () => {
        assert.strictEqual(new BN(12345).toString(16), '3039');
      });

      it('should accept two-limb number', () => {
        assert.strictEqual(new BN(0x4123456).toString(16), '4123456');
      });

      it('should accept 52 bits of precision', () => {
        const num = Math.pow(2, 52);
        assert.strictEqual(new BN(num, 10).toString(10), num.toString(10));
      });

      it('should accept max safe integer', () => {
        const num = Math.pow(2, 53) - 1;
        assert.strictEqual(new BN(num, 10).toString(10), num.toString(10));
      });

      it('should not accept an unsafe integer', () => {
        const num = Math.pow(2, 53);

        assert.throws(() => {
          return new BN(num, 10);
        });
      });

      it('should accept two-limb LE number', () => {
        assert.strictEqual(new BN(0x4123456, null, 'le').toString(16), '56341204');
      });
    });

    describe('with String input', () => {
      it('should accept base-16', () => {
        assert.strictEqual(new BN('1A6B765D8CDF', 16).toString(16), '1a6b765d8cdf');
        assert.strictEqual(new BN('1A6B765D8CDF', 16).toString(), '29048849665247');
      });

      it('should accept base-hex', () => {
        assert.strictEqual(new BN('FF', 'hex').toString(), '255');
      });

      it('should accept base-16 with spaces', () => {
        const num = 'a89c e5af8724 c0a23e0e 0ff77500';
        assert.strictEqual(new BN(num, 16).toString(16), num.replace(/ /g, ''));
      });

      it('should accept long base-16', () => {
        const num = '123456789abcdef123456789abcdef123456789abcdef';
        assert.strictEqual(new BN(num, 16).toString(16), num);
      });

      it('should accept positive base-10', () => {
        assert.strictEqual(new BN('10654321').toString(), '10654321');
        assert.strictEqual(new BN('29048849665247').toString(16), '1a6b765d8cdf');
      });

      it('should accept negative base-10', () => {
        assert.strictEqual(new BN('-29048849665247').toString(16), '-1a6b765d8cdf');
      });

      it('should accept long base-10', () => {
        const num = '10000000000000000';
        assert.strictEqual(new BN(num).toString(10), num);
      });

      it('should accept base-2', () => {
        const base2 = '11111111111111111111111111111111111111111111111111111';
        assert.strictEqual(new BN(base2, 2).toString(2), base2);
      });

      it('should accept base-36', () => {
        const base36 = 'zzZzzzZzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz';
        assert.strictEqual(new BN(base36, 36).toString(36), base36.toLowerCase());
      });

      it('should not overflow limbs during base-10', () => {
        const num = '65820182292848241686198767302293' +
          '20890292528855852623664389292032';
        const n = new BN(num);
        assert(!n.words || n.words[0] < 0x4000000);
      });

      it('should accept base-16 LE integer', () => {
        assert.strictEqual(new BN('1A6B765D8CDF', 16, 'le').toString(16),
          'df8c5d766b1a');
      });

      it('should not accept wrong characters for base', () => {
        assert.throws(() => {
          return new BN('01FF');
        });
      });

      it('should not accept decimal', () => {
        assert.throws(() => {
          const res = new BN('10.00', 10);
          res;
        });

        assert.throws(() => {
          const res = new BN('16.00', 16);
          res;
        });
      });

      it('should not accept non-hex characters', () => {
        [
          '0000000z',
          '000000gg',
          '0000gg00',
          'fffggfff',
          '/0000000',
          '0-000000', // if -, is first, that is OK
          'ff.fffff',
          'hexadecimal'
        ].forEach((str) => {
          assert.throws(() => {
            const res = new BN(str, 16);
            res;
          });
        });
      });

      it.skip('should not ignore zeroes on LE string', () => {
        assert.strictEqual(new BN('0010', 'hex', 'le').toNumber(), 256);
      });
    });

    describe('with Array input', () => {
      it('should not fail on empty array', () => {
        assert.strictEqual(new BN([]).toString(16), '0');
      });

      it('should import/export big endian', () => {
        assert.strictEqual(new BN([1, 2, 3]).toString(16), '10203');
        assert.strictEqual(new BN([1, 2, 3, 4]).toString(16), '1020304');
        assert.strictEqual(new BN([1, 2, 3, 4, 5]).toString(16), '102030405');
        assert.strictEqual(new BN([1, 2, 3, 4, 5, 6, 7, 8]).toString(16),
          '102030405060708');
        assert.strictEqual(new BN([1, 2, 3, 4]).toArray().join(','), '1,2,3,4');
        assert.strictEqual(new BN([1, 2, 3, 4, 5, 6, 7, 8]).toArray().join(','),
          '1,2,3,4,5,6,7,8');
      });

      it('should import little endian', () => {
        assert.strictEqual(new BN([1, 2, 3], 10, 'le').toString(16), '30201');
        assert.strictEqual(new BN([1, 2, 3, 4], 10, 'le').toString(16), '4030201');
        assert.strictEqual(new BN([1, 2, 3, 4, 5], 10, 'le').toString(16),
          '504030201');
        assert.strictEqual(new BN([1, 2, 3, 4, 5, 6, 7, 8], 'le').toString(16),
          '807060504030201');
        assert.strictEqual(new BN([1, 2, 3, 4]).toArray('le').join(','), '4,3,2,1');
        assert.strictEqual(new BN([1, 2, 3, 4, 5, 6, 7, 8]).toArray('le').join(','),
          '8,7,6,5,4,3,2,1');
      });

      it('should import big endian with implicit base', () => {
        assert.strictEqual(new BN([1, 2, 3, 4, 5], 'le').toString(16), '504030201');
      });
    });

    // the Array code is able to handle Buffer
    describe('with Buffer input', () => {
      it('should not fail on empty Buffer', () => {
        assert.strictEqual(new BN(Buffer.alloc(0)).toString(16), '0');
      });

      it('should import/export big endian', () => {
        assert.strictEqual(new BN(Buffer.from('010203', 'hex')).toString(16), '10203');
      });

      it('should import little endian', () => {
        assert.strictEqual(new BN(Buffer.from('010203', 'hex'), 'le').toString(16), '30201');
      });
    });

    describe('with BN input', () => {
      it('should clone BN', () => {
        const num = new BN(12345);
        assert.strictEqual(new BN(num).toString(10), '12345');
      });
    });
  });

  describe('BN.js/Reduction context', () => {
    function testMethod(name, fn) {
      describe(name + ' method', () => {
        it('should support add, iadd, sub, isub operations', () => {
          const p = new BN(257);
          const m = fn(p);
          const a = new BN(123).toRed(m);
          const b = new BN(231).toRed(m);

          assert.strictEqual(a.redAdd(b).fromRed().toString(10), '97');
          assert.strictEqual(a.redSub(b).fromRed().toString(10), '149');
          assert.strictEqual(b.redSub(a).fromRed().toString(10), '108');

          assert.strictEqual(a.clone().redIAdd(b).fromRed().toString(10), '97');
          assert.strictEqual(a.clone().redISub(b).fromRed().toString(10), '149');
          assert.strictEqual(b.clone().redISub(a).fromRed().toString(10), '108');
        });

        it('should support pow and mul operations', () => {
          const p192 = new BN(
            'fffffffffffffffffffffffffffffffeffffffffffffffff',
            16);

          const m = fn(p192);
          const a = new BN(123);
          const b = new BN(231);
          const c = a.toRed(m).redMul(b.toRed(m)).fromRed();

          assert(c.cmp(a.mul(b).rem(p192)) === 0);

          assert.strictEqual(a.toRed(m).redPow(new BN(0)).fromRed()
            .cmp(new BN(1)), 0);
          assert.strictEqual(a.toRed(m).redPow(new BN(3)).fromRed()
            .cmp(a.sqr().mul(a)), 0);
          assert.strictEqual(a.toRed(m).redPow(new BN(4)).fromRed()
            .cmp(a.sqr().sqr()), 0);
          assert.strictEqual(a.toRed(m).redPow(new BN(8)).fromRed()
            .cmp(a.sqr().sqr().sqr()), 0);
          assert.strictEqual(a.toRed(m).redPow(new BN(9)).fromRed()
            .cmp(a.sqr().sqr().sqr().mul(a)), 0);
          assert.strictEqual(a.toRed(m).redPow(new BN(17)).fromRed()
            .cmp(a.sqr().sqr().sqr().sqr().mul(a)), 0);
          assert.strictEqual(
            a.toRed(m).redPow(new BN('deadbeefabbadead', 16)).fromRed()
              .toString(16),
            '3aa0e7e304e320b68ef61592bcb00341866d6fa66e11a4d6');
        });

        it('should sqrtm numbers', () => {
          {
            const p = new BN(263);
            const m = fn(p);
            const q = new BN(11).toRed(m);

            assert.strictEqual(q.redSqrt().redSqr().cmp(q), 0);
            assert.strictEqual(q.redSqrt().redSqr().cmp(q), 0);
          }

          {
            const p = new BN('fffffffffffffffffffffffffffffffeffffffffffffffff', 16);
            const m = fn(p);
            const q = new BN(13).toRed(m);

            assert.strictEqual(q.redSqrt().redSqr().cmp(q), 0);
            assert.strictEqual(q.redSqrt().redSqr().cmp(q), 0);
          }

          // Tonelli-shanks
          {
            const p = new BN(13);
            const m = fn(p);
            const q = new BN(10).toRed(m);

            assert.strictEqual(q.redSqrt().fromRed().toString(10), '7');
          }
        });

        it('should invert numbers', () => {
          const p = new BN(257);
          const m = fn(p);
          const a = new BN(3).toRed(m);
          const b = a.redInvert();

          assert.strictEqual(a.redMul(b).fromRed().toString(16), '1');
        });

        it('should invert numbers (regression)', () => {
          const p = new BN(
            'ffffffff00000001000000000000000000000000ffffffffffffffffffffffff',
            16);

          const a = new BN(
            'e1d969b8192fbac73ea5b7921896d6a2263d4d4077bb8e5055361d1f7f8163f3',
            16);

          const m = fn(p);

          assert.strictEqual(a.toRed(m).redInvert().fromRed().negative, 0);
        });

        it('should imul numbers', () => {
          const p = new BN(
            'fffffffffffffffffffffffffffffffeffffffffffffffff',
            16);

          const m = fn(p);
          const a = new BN('deadbeefabbadead', 16);
          const b = new BN('abbadeadbeefdead', 16);
          const c = a.mul(b).rem(p);

          assert.strictEqual(a.toRed(m).redIMul(b.toRed(m)).fromRed().toString(16),
            c.toString(16));
        });

        it('should pow(base, 0) == 1', () => {
          const base = new BN(256).toRed(BN.red('k256'));
          const exponent = new BN(0);
          const result = base.redPow(exponent);

          assert.strictEqual(result.toString(), '1');
        });

        it('should shl numbers', () => {
          const base = new BN(256).toRed(BN.red('k256'));
          const result = base.redShln(1);

          assert.strictEqual(result.toString(), '512');
        });

        it('should reduce when converting to red', () => {
          const p = new BN(257);
          const m = fn(p);
          const a = new BN(5).toRed(m);

          assert.doesNotThrow(() => {
            const b = a.redISub(new BN(512).toRed(m));
            b.redISub(new BN(512).toRed(m));
          });
        });

        it('redNeg and zero value', () => {
          const a = new BN(0).toRed(BN.red('k256')).redNeg();
          assert.strictEqual(a.isZero(), true);
        });

        it('should not allow modulus <= 1', () => {
          assert.throws(() => {
            BN.red(new BN(0));
          });

          assert.doesNotThrow(() => {
            BN.red(new BN(1));
          });

          assert.doesNotThrow(() => {
            BN.red(new BN(2));
          });
        });
      });
    }

    testMethod('Plain', BN.red);
    testMethod('Montgomery', BN.mont);

    describe('Pseudo-Mersenne Primes', () => {
      it('should reduce numbers mod k256', () => {
        const p = BN._prime('k256');

        if (!p.ireduce)
          this.skip();

        assert.strictEqual(p.ireduce(new BN(0xdead)).toString(16), 'dead');
        assert.strictEqual(p.ireduce(new BN('deadbeef', 16)).toString(16), 'deadbeef');

        {
          const num = new BN('fedcba9876543210fedcba9876543210dead'
                           + 'fedcba9876543210fedcba9876543210dead', 16);

          const exp = num.rem(p.p);

          assert.strictEqual(p.ireduce(num).toString(16), exp.toString(16));
        }

        {
          const regr = new BN('f7e46df64c1815962bf7bc9c56128798'
                            + '3f4fcef9cb1979573163b477eab93959'
                            + '335dfb29ef07a4d835d22aa3b6797760'
                            + '70a8b8f59ba73d56d01a79af9', 16);

          const exp = regr.rem(p.p);

          assert.strictEqual(p.ireduce(regr).toString(16), exp.toString(16));
        }
      });

      it('should not fail to invert number mod k256', () => {
        const num = new BN('6c150c4aa9a8cf1934485d40674d4a7cd494675537bda36d49405c5d2c6f496f', 16);
        const regr2 = num.toRed(BN.red('k256'));

        assert.strictEqual(regr2.redInvert().redMul(regr2).fromRed().cmpn(1), 0);
      });

      it('should correctly square the number', () => {
        const p = K256;
        const red = BN.red('k256');

        const n = new BN('9cd8cb48c3281596139f147c1364a3ed'
                       + 'e88d3f310fdb0eb98c924e599ca1b3c9', 16);
        const expected = n.sqr().rem(p);
        const actual = n.toRed(red).redSqr().fromRed();

        assert.strictEqual(actual.toString(16), expected.toString(16));
      });

      it('redISqr should return right result', () => {
        const n = new BN('30f28939', 16);
        const actual = n.toRed(BN.red('k256')).redISqr().fromRed();
        assert.strictEqual(actual.toString(16), '95bd93d19520eb1');
      });
    });

    it('should avoid 4.1.0 regresion', () => {
      const bits2int = (obits, q) => {
        const bits = new BN(obits);
        const shift = (obits.length << 3) - q.bitLength();

        if (shift > 0)
          bits.ishrn(shift);

        return bits;
      };

      const t = Buffer.from(''
        + 'aff1651e4cd6036d57aa8b2a05ccf1a9d5a40166340ecbbdc55'
        + 'be10b568aa0aa3d05ce9a2fcec9df8ed018e29683c6051cb83e'
        + '46ce31ba4edb045356a8d0d80b',
        'hex');

      const g = new BN(''
        + '5c7ff6b06f8f143fe8288433493e4769c4d988ace5be25a0e24809670'
        + '716c613d7b0cee6932f8faa7c44d2cb24523da53fbe4f6ec3595892d1'
        + 'aa58c4328a06c46a15662e7eaa703a1decf8bbb2d05dbe2eb956c142a'
        + '338661d10461c0d135472085057f3494309ffa73c611f78b32adbb574'
        + '0c361c9f35be90997db2014e2ef5aa61782f52abeb8bd6432c4dd097b'
        + 'c5423b285dafb60dc364e8161f4a2a35aca3a10b1c4d203cc76a470a3'
        + '3afdcbdd92959859abd8b56e1725252d78eac66e71ba9ae3f1dd24871'
        + '99874393cd4d832186800654760e1e34c09e4d155179f9ec0dc4473f9'
        + '96bdce6eed1cabed8b6f116f7ad9cf505df0f998e34ab27514b0ffe7',
        16);

      const p = new BN(''
        + '9db6fb5951b66bb6fe1e140f1d2ce5502374161fd6538df1648218642'
        + 'f0b5c48c8f7a41aadfa187324b87674fa1822b00f1ecf8136943d7c55'
        + '757264e5a1a44ffe012e9936e00c1d3e9310b01c7d179805d3058b2a9'
        + 'f4bb6f9716bfe6117c6b5b3cc4d9be341104ad4a80ad6c94e005f4b99'
        + '3e14f091eb51743bf33050c38de235567e1b34c3d6a5c0ceaa1a0f368'
        + '213c3d19843d0b4b09dcb9fc72d39c8de41f1bf14d4bb4563ca283716'
        + '21cad3324b6a2d392145bebfac748805236f5ca2fe92b871cd8f9c36d'
        + '3292b5509ca8caa77a2adfc7bfd77dda6f71125a7456fea153e433256'
        + 'a2261c6a06ed3693797e7995fad5aabbcfbe3eda2741e375404ae25b',
        16);

      const q = new BN(''
        + 'f2c3119374ce76c9356990b465374a17f23f9ed35089bd969f61c6dde'
        + '9998c1f', 16);

      const k = bits2int(t, q);
      const expectedR = ''
        + '89ec4bb1400eccff8e7d9aa515cd1de7803f2daff09693ee7fd1353e'
        + '90a68307';

      const r = g.toRed(BN.mont(p)).redPow(k).fromRed().rem(q);

      assert.strictEqual(r.toString(16), expectedR);
    });

    it('K256.split for 512 bits number should return equal numbers', () => {
      const prime = BN._prime('k256');

      if (!prime.split)
        this.skip();

      const input = new BN(1).iushln(512).subn(1);
      assert.strictEqual(input.bitLength(), 512);

      const output = new BN(0);
      prime.split(input, output);

      assert.strictEqual(input.cmp(output), 0);
    });

    it('imod should change host object', () => {
      const red = BN.red(new BN(13));
      const a = new BN(2).toRed(red);
      const b = new BN(7).toRed(red);
      const c = a.redIMul(b);
      assert.strictEqual(a.toNumber(), 1);
      assert.strictEqual(c.toNumber(), 1);
    });
  });

  describe('BN.js/Utils', () => {
    describe('.toString()', () => {
      describe('binary padding', () => {
        it('should have a length of 256', () => {
          const a = new BN(0);

          assert.strictEqual(a.toString(2, 256).length, 256);
        });
      });

      describe('hex padding', () => {
        it('should have length of 8 from leading 15', () => {
          const a = new BN('ffb9602', 16);

          assert.strictEqual(a.toString('hex', 2).length, 8);
        });

        it('should have length of 8 from leading zero', () => {
          const a = new BN('fb9604', 16);

          assert.strictEqual(a.toString('hex', 8).length, 8);
        });

        it('should have length of 8 from leading zeros', () => {
          const a = new BN(0);

          assert.strictEqual(a.toString('hex', 8).length, 8);
        });

        it('should have length of 64 from leading 15', () => {
          const a = new BN(
            'ffb96ff654e61130ba8422f0debca77a0ea74ae5ea8bca9b54ab64aabf01003',
            16);

          assert.strictEqual(a.toString('hex', 2).length, 64);
        });

        it('should have length of 64 from leading zero', () => {
          const a = new BN(
            'fb96ff654e61130ba8422f0debca77a0ea74ae5ea8bca9b54ab64aabf01003',
            16);

          assert.strictEqual(a.toString('hex', 64).length, 64);
        });
      });
    });

    describe('.isNeg()', () => {
      it('should return true for negative numbers', () => {
        assert.strictEqual(new BN(-1).isNeg(), true);
        assert.strictEqual(new BN(1).isNeg(), false);
        assert.strictEqual(new BN(0).isNeg(), false);
        assert.strictEqual(new BN('-0', 10).isNeg(), false);
      });
    });

    describe('.isPos()', () => {
      it('should return true for positive numbers', () => {
        assert.strictEqual(new BN(-1).isPos(), false);
        assert.strictEqual(new BN(1).isPos(), true);
        assert.strictEqual(new BN(0).isPos(), true);
        assert.strictEqual(new BN('-0', 10).isPos(), true);
      });
    });

    describe('.isOdd()', () => {
      it('should return true for odd numbers', () => {
        assert.strictEqual(new BN(0).isOdd(), false);
        assert.strictEqual(new BN(1).isOdd(), true);
        assert.strictEqual(new BN(2).isOdd(), false);
        assert.strictEqual(new BN('-0', 10).isOdd(), false);
        assert.strictEqual(new BN('-1', 10).isOdd(), true);
        assert.strictEqual(new BN('-2', 10).isOdd(), false);
      });
    });

    describe('.isEven()', () => {
      it('should return true for even numbers', () => {
        assert.strictEqual(new BN(0).isEven(), true);
        assert.strictEqual(new BN(1).isEven(), false);
        assert.strictEqual(new BN(2).isEven(), true);
        assert.strictEqual(new BN('-0', 10).isEven(), true);
        assert.strictEqual(new BN('-1', 10).isEven(), false);
        assert.strictEqual(new BN('-2', 10).isEven(), true);
      });
    });

    describe('.isZero()', () => {
      it('should return true for zero', () => {
        assert.strictEqual(new BN(0).isZero(), true);
        assert.strictEqual(new BN(1).isZero(), false);
        assert.strictEqual(new BN(0xffffffff).isZero(), false);
      });
    });

    describe('.bitLength()', () => {
      it('should return proper bitLength', () => {
        assert.strictEqual(new BN(0).bitLength(), 0);
        assert.strictEqual(new BN(0x1).bitLength(), 1);
        assert.strictEqual(new BN(0x2).bitLength(), 2);
        assert.strictEqual(new BN(0x3).bitLength(), 2);
        assert.strictEqual(new BN(0x4).bitLength(), 3);
        assert.strictEqual(new BN(0x8).bitLength(), 4);
        assert.strictEqual(new BN(0x10).bitLength(), 5);
        assert.strictEqual(new BN(0x100).bitLength(), 9);
        assert.strictEqual(new BN(0x123456).bitLength(), 21);
        assert.strictEqual(new BN('123456789', 16).bitLength(), 33);
        assert.strictEqual(new BN('8023456789', 16).bitLength(), 40);
      });
    });

    describe('.byteLength()', () => {
      it('should return proper byteLength', () => {
        assert.strictEqual(new BN(0).byteLength(), 0);
        assert.strictEqual(new BN(0x1).byteLength(), 1);
        assert.strictEqual(new BN(0x2).byteLength(), 1);
        assert.strictEqual(new BN(0x3).byteLength(), 1);
        assert.strictEqual(new BN(0x4).byteLength(), 1);
        assert.strictEqual(new BN(0x8).byteLength(), 1);
        assert.strictEqual(new BN(0x10).byteLength(), 1);
        assert.strictEqual(new BN(0x100).byteLength(), 2);
        assert.strictEqual(new BN(0x123456).byteLength(), 3);
        assert.strictEqual(new BN('123456789', 16).byteLength(), 5);
        assert.strictEqual(new BN('8023456789', 16).byteLength(), 5);
      });
    });

    describe('.toArray()', () => {
      it('should return [0] for `0`', () => {
        const n = new BN(0);
        assert.deepEqual(n.toArray('be'), [0]);
        assert.deepEqual(n.toArray('le'), [0]);
      });

      it('should zero pad to desired lengths', () => {
        const n = new BN(0x123456);
        assert.deepEqual(n.toArray('be', 5), [0x00, 0x00, 0x12, 0x34, 0x56]);
        assert.deepEqual(n.toArray('le', 5), [0x56, 0x34, 0x12, 0x00, 0x00]);
      });

      it('should throw when naturally larger than desired length', () => {
        const n = new BN(0x123456);
        assert.throws(() => {
          n.toArray('be', 2);
        });
      });
    });

    describe('.toBuffer', () => {
      it('should return proper Buffer', () => {
        const n = new BN(0x123456);
        assert.deepEqual(n.toBuffer('be', 5).toString('hex'), '0000123456');
        assert.deepEqual(n.toBuffer('le', 5).toString('hex'), '5634120000');
      });
    });

    describe('.toNumber()', () => {
      it('should return proper Number if below the limit', () => {
        assert.deepEqual(new BN(0x123456).toNumber(), 0x123456);
        assert.deepEqual(new BN(0x3ffffff).toNumber(), 0x3ffffff);
        assert.deepEqual(new BN(0x4000000).toNumber(), 0x4000000);
        assert.deepEqual(new BN(0x10000000000000).toNumber(), 0x10000000000000);
        assert.deepEqual(new BN(0x10040004004000).toNumber(), 0x10040004004000);
        assert.deepEqual(new BN(-0x123456).toNumber(), -0x123456);
        assert.deepEqual(new BN(-0x3ffffff).toNumber(), -0x3ffffff);
        assert.deepEqual(new BN(-0x4000000).toNumber(), -0x4000000);
        assert.deepEqual(new BN(-0x10000000000000).toNumber(), -0x10000000000000);
        assert.deepEqual(new BN(-0x10040004004000).toNumber(), -0x10040004004000);
      });

      it('should throw when number exceeds 53 bits', () => {
        const n = new BN(1).iushln(54);
        assert.throws(() => {
          n.toNumber();
        });
      });
    });

    describe('.zeroBits()', () => {
      it('should return proper zeroBits', () => {
        assert.strictEqual(new BN(0).zeroBits(), 0);
        assert.strictEqual(new BN(0x1).zeroBits(), 0);
        assert.strictEqual(new BN(0x2).zeroBits(), 1);
        assert.strictEqual(new BN(0x3).zeroBits(), 0);
        assert.strictEqual(new BN(0x4).zeroBits(), 2);
        assert.strictEqual(new BN(0x8).zeroBits(), 3);
        assert.strictEqual(new BN(0x10).zeroBits(), 4);
        assert.strictEqual(new BN(0x100).zeroBits(), 8);
        assert.strictEqual(new BN(0x1000000).zeroBits(), 24);
        assert.strictEqual(new BN(0x123456).zeroBits(), 1);

        assert.strictEqual(new BN(-0x1).zeroBits(), 0);
        assert.strictEqual(new BN(-0x2).zeroBits(), 1);
        assert.strictEqual(new BN(-0x3).zeroBits(), 0);
        assert.strictEqual(new BN(-0x4).zeroBits(), 2);
        assert.strictEqual(new BN(-0x8).zeroBits(), 3);
        assert.strictEqual(new BN(-0x10).zeroBits(), 4);
        assert.strictEqual(new BN(-0x100).zeroBits(), 8);
        assert.strictEqual(new BN(-0x1000000).zeroBits(), 24);
        assert.strictEqual(new BN(-0x123456).zeroBits(), 1);
      });
    });

    describe('.toJSON', () => {
      it('should return hex string', () => {
        assert.strictEqual(new BN(0x123).toJSON(), '0123');
      });

      it('should be padded to multiple of 2 bytes for interop', () => {
        assert.strictEqual(new BN(0x1).toJSON(), '01');
      });
    });

    describe('.cmpn', () => {
      it('should return -1, 0, 1 correctly', () => {
        assert.strictEqual(new BN(42).cmpn(42), 0);
        assert.strictEqual(new BN(42).cmpn(43), -1);
        assert.strictEqual(new BN(42).cmpn(41), 1);
        assert.strictEqual(new BN(0x3fffffe).cmpn(0x3fffffe), 0);
        assert.strictEqual(new BN(0x3fffffe).cmpn(0x3ffffff), -1);
        assert.strictEqual(new BN(0x3fffffe).cmpn(0x3fffffd), 1);
        assert.throws(() => {
          new BN(0x3fffffe).cmpn(0x4000000);
        });
        assert.strictEqual(new BN(42).cmpn(-42), 1);
        assert.strictEqual(new BN(-42).cmpn(42), -1);
        assert.strictEqual(new BN(-42).cmpn(-42), 0);
        assert.strictEqual(1 / new BN(-42).cmpn(-42), Infinity);
      });
    });

    describe('.cmp', () => {
      it('should return -1, 0, 1 correctly', () => {
        assert.strictEqual(new BN(42).cmp(new BN(42)), 0);
        assert.strictEqual(new BN(42).cmp(new BN(43)), -1);
        assert.strictEqual(new BN(42).cmp(new BN(41)), 1);
        assert.strictEqual(new BN(0x3fffffe).cmp(new BN(0x3fffffe)), 0);
        assert.strictEqual(new BN(0x3fffffe).cmp(new BN(0x3ffffff)), -1);
        assert.strictEqual(new BN(0x3fffffe).cmp(new BN(0x3fffffd)), 1);
        assert.strictEqual(new BN(0x3fffffe).cmp(new BN(0x4000000)), -1);
        assert.strictEqual(new BN(42).cmp(new BN(-42)), 1);
        assert.strictEqual(new BN(-42).cmp(new BN(42)), -1);
        assert.strictEqual(new BN(-42).cmp(new BN(-42)), 0);
        assert.strictEqual(1 / new BN(-42).cmp(new BN(-42)), Infinity);
      });
    });

    describe('.sign', () => {
      it('should return -1, 0, 1 correctly', () => {
        assert.strictEqual(new BN(0).sign(), 0);
        assert.strictEqual(new BN(-1).sign(), -1);
        assert.strictEqual(new BN(1).sign(), 1);
        assert.strictEqual(new BN(-0x3fffffe).sign(), -1);
        assert.strictEqual(new BN(0x3fffffe).sign(), 1);
        assert.strictEqual(new BN(-0x43fffffe).sign(), -1);
        assert.strictEqual(new BN(0x43fffffe).sign(), 1);
        assert.strictEqual(new BN(-42).sign(), -1);
        assert.strictEqual(new BN(42).sign(), 1);
        assert.strictEqual(1 / new BN(0).sign(), Infinity);
      });
    });

    describe('comparison shorthands', () => {
      it('.gtn greater than', () => {
        assert.strictEqual(new BN(3).gtn(2), true);
        assert.strictEqual(new BN(3).gtn(3), false);
        assert.strictEqual(new BN(3).gtn(4), false);
      });

      it('.gt greater than', () => {
        assert.strictEqual(new BN(3).gt(new BN(2)), true);
        assert.strictEqual(new BN(3).gt(new BN(3)), false);
        assert.strictEqual(new BN(3).gt(new BN(4)), false);
      });

      it('.gten greater than or equal', () => {
        assert.strictEqual(new BN(3).gten(3), true);
        assert.strictEqual(new BN(3).gten(2), true);
        assert.strictEqual(new BN(3).gten(4), false);
      });

      it('.gte greater than or equal', () => {
        assert.strictEqual(new BN(3).gte(new BN(3)), true);
        assert.strictEqual(new BN(3).gte(new BN(2)), true);
        assert.strictEqual(new BN(3).gte(new BN(4)), false);
      });

      it('.ltn less than', () => {
        assert.strictEqual(new BN(2).ltn(3), true);
        assert.strictEqual(new BN(2).ltn(2), false);
        assert.strictEqual(new BN(2).ltn(1), false);
      });

      it('.lt less than', () => {
        assert.strictEqual(new BN(2).lt(new BN(3)), true);
        assert.strictEqual(new BN(2).lt(new BN(2)), false);
        assert.strictEqual(new BN(2).lt(new BN(1)), false);
      });

      it('.lten less than or equal', () => {
        assert.strictEqual(new BN(3).lten(3), true);
        assert.strictEqual(new BN(3).lten(2), false);
        assert.strictEqual(new BN(3).lten(4), true);
      });

      it('.lte less than or equal', () => {
        assert.strictEqual(new BN(3).lte(new BN(3)), true);
        assert.strictEqual(new BN(3).lte(new BN(2)), false);
        assert.strictEqual(new BN(3).lte(new BN(4)), true);
      });

      it('.eqn equal', () => {
        assert.strictEqual(new BN(3).eqn(3), true);
        assert.strictEqual(new BN(3).eqn(2), false);
        assert.strictEqual(new BN(3).eqn(4), false);
      });

      it('.eq equal', () => {
        assert.strictEqual(new BN(3).eq(new BN(3)), true);
        assert.strictEqual(new BN(3).eq(new BN(2)), false);
        assert.strictEqual(new BN(3).eq(new BN(4)), false);
      });
    });

    describe('.fromTwos', () => {
      it('should convert from two\'s complement to negative number', () => {
        assert.strictEqual(new BN('00000000', 16).fromTwos(32).toNumber(), 0);
        assert.strictEqual(new BN('00000001', 16).fromTwos(32).toNumber(), 1);
        assert.strictEqual(new BN('7fffffff', 16).fromTwos(32).toNumber(), 2147483647);
        assert.strictEqual(new BN('80000000', 16).fromTwos(32).toNumber(), -2147483648);
        assert.strictEqual(new BN('f0000000', 16).fromTwos(32).toNumber(), -268435456);
        assert.strictEqual(new BN('f1234567', 16).fromTwos(32).toNumber(), -249346713);
        assert.strictEqual(new BN('ffffffff', 16).fromTwos(32).toNumber(), -1);
        assert.strictEqual(new BN('fffffffe', 16).fromTwos(32).toNumber(), -2);
        assert.strictEqual(new BN('fffffffffffffffffffffffffffffffe', 16)
          .fromTwos(128).toNumber(), -2);
        assert.strictEqual(new BN('ffffffffffffffffffffffffffffffff' +
          'fffffffffffffffffffffffffffffffe', 16).fromTwos(256).toNumber(), -2);
        assert.strictEqual(new BN('ffffffffffffffffffffffffffffffff' +
          'ffffffffffffffffffffffffffffffff', 16).fromTwos(256).toNumber(), -1);
        assert.strictEqual(new BN('7fffffffffffffffffffffffffffffff' +
          'ffffffffffffffffffffffffffffffff', 16).fromTwos(256).toString(10),
          new BN('5789604461865809771178549250434395392663499' +
            '2332820282019728792003956564819967', 10).toString(10));
        assert.strictEqual(new BN('80000000000000000000000000000000' +
          '00000000000000000000000000000000', 16).fromTwos(256).toString(10),
          new BN('-578960446186580977117854925043439539266349' +
            '92332820282019728792003956564819968', 10).toString(10));
      });
    });

    describe('.toTwos', () => {
      it('should convert from negative number to two\'s complement', () => {
        assert.strictEqual(new BN(0).toTwos(32).toString(16), '0');
        assert.strictEqual(new BN(1).toTwos(32).toString(16), '1');
        assert.strictEqual(new BN(2147483647).toTwos(32).toString(16), '7fffffff');
        assert.strictEqual(new BN('-2147483648', 10).toTwos(32).toString(16), '80000000');
        assert.strictEqual(new BN('-268435456', 10).toTwos(32).toString(16), 'f0000000');
        assert.strictEqual(new BN('-249346713', 10).toTwos(32).toString(16), 'f1234567');
        assert.strictEqual(new BN('-1', 10).toTwos(32).toString(16), 'ffffffff');
        assert.strictEqual(new BN('-2', 10).toTwos(32).toString(16), 'fffffffe');
        assert.strictEqual(new BN('-2', 10).toTwos(128).toString(16),
          'fffffffffffffffffffffffffffffffe');
        assert.strictEqual(new BN('-2', 10).toTwos(256).toString(16),
          'fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe');
        assert.strictEqual(new BN('-1', 10).toTwos(256).toString(16),
          'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
        assert.strictEqual(new BN('5789604461865809771178549250434395392663' +
          '4992332820282019728792003956564819967', 10).toTwos(256).toString(16),
          '7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
        assert.strictEqual(new BN('-578960446186580977117854925043439539266' +
          '34992332820282019728792003956564819968', 10).toTwos(256).toString(16),
          '8000000000000000000000000000000000000000000000000000000000000000');
      });
    });

    describe('.isBN', () => {
      it('should return true for BN', () => {
        assert.strictEqual(BN.isBN(new BN()), true);
      });

      it('should return false for everything else', () => {
        assert.strictEqual(BN.isBN(1), false);
        assert.strictEqual(BN.isBN([]), false);
        assert.strictEqual(BN.isBN({}), false);
      });
    });

    describe('.swap()', () => {
      it('should swap two bignums in-place', () => {
        const a = new BN(100);
        const b = new BN(-200);

        a.swap(b);

        assert.strictEqual(a.toString(10), '-200');
        assert.strictEqual(b.toString(10), '100');
      });
    });

    describe('.csign()', () => {
      it('should get sign in constant time', () => {
        assert.strictEqual(new BN(0).csign(), 0);
        assert.strictEqual(new BN(-1).csign(), -1);
        assert.strictEqual(new BN(1).csign(), 1);
        assert.strictEqual(new BN(-0x3fffffe).csign(), -1);
        assert.strictEqual(new BN(0x3fffffe).csign(), 1);
        assert.strictEqual(new BN(-0x43fffffe).csign(), -1);
        assert.strictEqual(new BN(0x43fffffe).csign(), 1);
        assert.strictEqual(new BN(-42).csign(), -1);
        assert.strictEqual(new BN(42).csign(), 1);
        assert.strictEqual(1 / new BN(0).csign(), Infinity);
      });
    });

    describe('.czero()', () => {
      it('should return true for zero', () => {
        assert.strictEqual(new BN(0).czero(), 1);
        assert.strictEqual(new BN(1).czero(), 0);
        assert.strictEqual(new BN(0xffffffff).czero(), 0);
        assert.strictEqual(new BN(-1).czero(), 0);
        assert.strictEqual(new BN(-0xffffffff).czero(), 0);
        assert.strictEqual(new BN(1e9).czero(), 0);
        assert.strictEqual(new BN(-1e9).czero(), 0);
      });
    });

    describe('.cneg()', () => {
      it('should return true for negative numbers', () => {
        assert.strictEqual(new BN(-1).cneg(), 1);
        assert.strictEqual(new BN(1).cneg(), 0);
        assert.strictEqual(new BN(0).cneg(), 0);
        assert.strictEqual(new BN('-0', 10).cneg(), 0);
      });
    });

    describe('.cpos()', () => {
      it('should return true for positive numbers', () => {
        assert.strictEqual(new BN(-1).cpos(), 0);
        assert.strictEqual(new BN(1).cpos(), 1);
        assert.strictEqual(new BN(0).cpos(), 1);
        assert.strictEqual(new BN('-0', 10).cpos(), 1);
      });
    });

    describe('.ceq()', () => {
      it('should return 0, 1 correctly', () => {
        assert.strictEqual(new BN(42).ceq(new BN(42)), 1);
        assert.strictEqual(new BN(42).ceq(new BN(43)), 0);
        assert.strictEqual(new BN(42).ceq(new BN(41)), 0);
        assert.strictEqual(new BN(0x3fffffe).ceq(new BN(0x3fffffe)), 1);
        assert.strictEqual(new BN(0x3fffffe).ceq(new BN(0x3ffffff)), 0);
        assert.strictEqual(new BN(0x3fffffe).ceq(new BN(0x3fffffd)), 0);
        assert.strictEqual(new BN(0x3fffffe).ceq(new BN(0x4000000)), 0);
        assert.strictEqual(new BN(42).ceq(new BN(-42)), 0);
        assert.strictEqual(new BN(-42).ceq(new BN(42)), 0);
        assert.strictEqual(new BN(-42).ceq(new BN(-42)), 1);
        assert.strictEqual(new BN(1e9).ceq(new BN(1e9 - 1)), 0);
        assert.strictEqual(new BN(1e9).ceq(new BN(1e9)), 1);
        assert.strictEqual(new BN(-1e9).ceq(new BN(1e9)), 0);
        assert.strictEqual(new BN(1e9).ceq(new BN(-1e9)), 0);
      });
    });

    describe('.ceqn()', () => {
      it('should return 0, 1 correctly', () => {
        assert.strictEqual(new BN(42).ceqn(42), 1);
        assert.strictEqual(new BN(42).ceqn(43), 0);
        assert.strictEqual(new BN(42).ceqn(41), 0);
        assert.strictEqual(new BN(0x3fffffe).ceqn(0x3fffffe), 1);
        assert.strictEqual(new BN(0x3fffffe).ceqn(0x3ffffff), 0);
        assert.strictEqual(new BN(0x3fffffe).ceqn(0x3fffffd), 0);
        assert.strictEqual(new BN(42).ceqn(-42), 0);
        assert.strictEqual(new BN(-42).ceqn(42), 0);
        assert.strictEqual(new BN(-42).ceqn(-42), 1);
        assert.strictEqual(new BN(-1e9).ceqn(1e6), 0);
        assert.strictEqual(new BN(1e9).ceqn(-1e6), 0);
      });
    });

    describe('.cswap()', () => {
      it('should swap two bignums in-place', () => {
        const a = new BN(100);
        const b = new BN(-200);

        a.cswap(b, 0);

        assert.strictEqual(a.toString(10), '100');
        assert.strictEqual(b.toString(10), '-200');

        a.cswap(b, 1);

        assert.strictEqual(a.toString(10), '-200');
        assert.strictEqual(b.toString(10), '100');

        a.cswap(b, 0);

        assert.strictEqual(a.toString(10), '-200');
        assert.strictEqual(b.toString(10), '100');

        a.cswap(b, 1);

        assert.strictEqual(a.toString(10), '100');
        assert.strictEqual(b.toString(10), '-200');
      });
    });

    describe('.cinject()', () => {
      it('should conditionally inject', () => {
        const a = new BN(100);
        const b = new BN(-200);

        a.cinject(b, 0);

        assert.strictEqual(a.toString(10), '100');
        assert.strictEqual(b.toString(10), '-200');

        a.cinject(b, 1);

        assert.strictEqual(a.toString(10), '-200');
        assert.strictEqual(b.toString(10), '-200');
      });
    });

    describe('.cset()', () => {
      it('should conditionally set', () => {
        const a = new BN(100);

        a.cset(-200, 0);

        assert.strictEqual(a.toString(10), '100');

        a.cset(-200, 1);

        assert.strictEqual(a.toString(10), '-200');
      });
    });
  });

  describe('BN-NG', () => {
    const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;

    it('should compute legendre symbols', () => {
      for (const [x, y, z] of legendre) {
        const xx = new BN(x);
        const yy = new BN(y);

        assert.strictEqual(xx.legendre(yy), z, `(${x}, ${y}, ${z})`);

        {
          const red = BN.red(yy);
          const xr = xx.toRed(red);

          assert.strictEqual(xr.redLegendre(), z, `(${x}, ${y}, ${z})`);
        }

        {
          const red = BN.mont(yy);
          const xr = xx.toRed(red);

          assert.strictEqual(xr.redLegendre(), z, `(${x}, ${y}, ${z})`);
        }
      }
    });

    it('should compute jacobi symbols', () => {
      for (const [x, y, z] of [...legendre, ...jacobi]) {
        const xx = new BN(x);
        const yy = new BN(y);

        assert.strictEqual(xx.jacobi(yy), z, `(${x}, ${y}, ${z})`);

        if (!yy.isNeg()) {
          const red = BN.red(yy);
          const xr = xx.toRed(red);
          assert.strictEqual(xr.redJacobi(), z, `(${x}, ${y}, ${z})`);
        }
      }
    });

    it('should compute kronecker symbols', () => {
      for (const [x, y, z] of [...legendre, ...jacobi, ...kronecker]) {
        const xx = new BN(x);
        const yy = new BN(y);

        assert.strictEqual(xx.kronecker(yy), z, `(${x}, ${y}, ${z})`);

        if (!yy.isNeg() && xx.cmp(yy) < 0) {
          const red = BN.red(yy);
          const xr = xx.toRed(red);
          assert.strictEqual(xr.redKronecker(), z, `(${x}, ${y}, ${z})`);
        }
      }
    });

    it('should compute legendre symbol', () => {
      const p = P25519;
      const n = P192;
      assert.strictEqual(n.legendre(p), -1);
      assert.strictEqual(n.addn(1).legendre(p), 1);
      assert.strictEqual(p.legendre(p), 0);
    });

    it('should compute jacobi symbol', () => {
      const p = P25519;
      const n = P192;
      assert.strictEqual(n.jacobi(p), -1);
      assert.strictEqual(n.addn(1).jacobi(p), 1);
      assert.strictEqual(p.jacobi(p), 0);
    });

    it('should compute kronecker symbol', () => {
      const p = P25519;
      const n = P192;
      assert.strictEqual(n.kronecker(p), -1);
      assert.strictEqual(n.addn(1).kronecker(p), 1);
      assert.strictEqual(p.kronecker(p), 0);
    });

    it('should get random int', () => {
      const p = P192;

      let saw = false;

      for (let i = 0; i < 100; i++) {
        const r = BN.random(rng, 0, p);

        assert(!r.isNeg());
        assert(r.cmp(p) < 0);

        if (r.bitLength() > (p.bitLength() >>> 1))
          saw = true;
      }

      assert(saw);
    });

    it('should get random bits', () => {
      let saw = false;

      for (let i = 0; i < 100; i++) {
        const r = BN.randomBits(rng, 256);

        assert(!r.isNeg());
        assert(r.bitLength() <= 256);

        if (r.bitLength() > (256 >>> 1))
          saw = true;
      }

      assert(saw);
    });

    it('should toNumber and fromNumber', () => {
      assert.strictEqual(BN.fromNumber(1234567890).toNumber(), 1234567890);
      assert.strictEqual(BN.fromNumber(-1234567890).toNumber(), -1234567890);
      assert.strictEqual(BN.fromNumber(0x1234567890).toNumber(), 0x1234567890);
      assert.strictEqual(BN.fromNumber(-0x1234567890).toNumber(), -0x1234567890);

      assert.throws(() => BN.fromNumber(-MAX_SAFE_INTEGER - 1).toNumber());
      assert.throws(() => BN.fromNumber(MAX_SAFE_INTEGER + 1).toNumber());
      assert.doesNotThrow(() => BN.fromNumber(-MAX_SAFE_INTEGER).toNumber());
      assert.doesNotThrow(() => BN.fromNumber(MAX_SAFE_INTEGER).toNumber());
    });

    it('should toDouble and toDouble', () => {
      assert.strictEqual(BN.fromDouble(1234567890).toDouble(), 1234567890);
      assert.strictEqual(BN.fromDouble(-1234567890).toDouble(), -1234567890);
      assert.strictEqual(BN.fromDouble(0x1234567890).toDouble(), 0x1234567890);
      assert.strictEqual(BN.fromDouble(-0x1234567890).toDouble(), -0x1234567890);

      assert.strictEqual(BN.fromDouble(1e100).toString(), '10000000000000000159'
                                                        + '02891109759918046836'
                                                        + '08085639452813897813'
                                                        + '27557747838772170381'
                                                        + '06081346998585681510'
                                                        + '4');

      if (BN.native !== 2)
        assert.strictEqual(BN.pow(10, 100).toDouble(), 1e100);

      assert.strictEqual(BN.fromDouble(1.1).toString(), '1');
      assert.strictEqual(BN.fromDouble(-1.1).toString(), '-1');
      assert.strictEqual(BN.fromDouble(0.1).toString(), '0');
      assert.strictEqual(BN.fromDouble(-0.1).toString(), '0');

      assert.doesNotThrow(() => BN.fromDouble(-MAX_SAFE_INTEGER - 1).toDouble());
      assert.doesNotThrow(() => BN.fromDouble(MAX_SAFE_INTEGER + 1).toDouble());
    });

    it('should toString and fromString', () => {
      assert.strictEqual(BN.fromString('1234567890', 10).toString(), '1234567890');
      assert.strictEqual(BN.fromString('-1234567890', 10).toString(), '-1234567890');
      assert.strictEqual(BN.fromString('1234567890', 16).toString(16), '1234567890');
      assert.strictEqual(BN.fromString('-1234567890', 16).toString(16), '-1234567890');

      assert.strictEqual(BN.fromString('abcdef1234', 16).toString(16), 'abcdef1234');
      assert.strictEqual(BN.fromString('-abcdef1234', 16).toString(16), '-abcdef1234');

      assert.strictEqual(BN.fromString('123456789', 10).toString(10, 2), '0123456789');
      assert.strictEqual(BN.fromString('-123456789', 10).toString(10, 2), '-0123456789');
      assert.strictEqual(BN.fromString('123456789', 16).toString(16, 2), '0123456789');
      assert.strictEqual(BN.fromString('-123456789', 16).toString(16, 2), '-0123456789');
    });

    it('should toJSON and fromJSON', () => {
      assert.strictEqual(BN.fromJSON('1234567890').toJSON(), '1234567890');
      assert.strictEqual(BN.fromJSON('-1234567890').toJSON(), '-1234567890');
      assert.strictEqual(BN.fromJSON('0123456789').toJSON(), '0123456789');
      assert.strictEqual(BN.fromJSON('-0123456789').toJSON(), '-0123456789');
    });

    it('should toBuffer and fromBuffer', () => {
      assert.strictEqual(BN.fromBuffer(new BN(0x1234567890).toBuffer()).toNumber(), 0x1234567890);
    });

    if (typeof BigInt === 'function') {
      it('should toBigInt and fromBigInt', () => {
        assert.strictEqual(new BN(0x1234567890).toBigInt(), BigInt(0x1234567890));
        assert.strictEqual(new BN(-0x1234567890).toBigInt(), BigInt(-0x1234567890));
        assert(BN.fromBigInt(BigInt(0x1234567890)).eq(new BN(0x1234567890)));
        assert(BN.fromBigInt(-BigInt(0x1234567890)).eq(new BN(-0x1234567890)));
      });
    }

    it('should count bits and zero bits', () => {
      assert.strictEqual(new BN(0x010001).zeroBits(), 0);
      assert.strictEqual(new BN(0x010001).bitLength(), 17);
      assert.strictEqual(new BN(-0x010001).zeroBits(), 0);
      assert.strictEqual(new BN(-0x010001).bitLength(), 17);
      assert.strictEqual(new BN(0x20000).zeroBits(), 17);
      assert.strictEqual(new BN(0x20000).bitLength(), 18);
      assert.strictEqual(new BN(-0x20000).zeroBits(), 17);
      assert.strictEqual(new BN(-0x20000).bitLength(), 18);
    });

    it('should compute sqrt', () => {
      assert.strictEqual(new BN(1024).sqrt().toNumber(), 32);
      assert.strictEqual(new BN(1025).sqrt().toNumber(), 32);
    });

    it('should compute root', () => {
      assert.strictEqual(new BN(1860867).root(3).toNumber(), 123);
      assert.strictEqual(new BN(1860868).root(3).toNumber(), 123);
      assert.strictEqual(new BN(1879080904).root(3).toNumber(), 1234);
      assert.strictEqual(new BN(1879080905).root(3).toNumber(), 1234);
    });

    it('should compute divmod', () => {
      const [q, r] = new BN(-3).quorem(new BN(2));
      assert.strictEqual(q.toNumber(), -1);
      assert.strictEqual(r.toNumber(), -1);
    });

    it('should compute quotient', () => {
      assert.strictEqual(new BN(3).quo(new BN(-2)).toNumber(), -1);
      assert.strictEqual(new BN(-3).quo(new BN(2)).toNumber(), -1);
      assert.strictEqual(new BN(-3).quo(new BN(-2)).toNumber(), 1);
      assert.strictEqual(new BN(4).quo(new BN(-2)).toNumber(), -2);
      assert.strictEqual(new BN(-4).quo(new BN(2)).toNumber(), -2);
      assert.strictEqual(new BN(-4).quo(new BN(-2)).toNumber(), 2);
    });

    it('should compute larger quotient', () => {
      assert.strictEqual(new BN(3e8).quo(new BN(-2e8)).toNumber(), -1);
      assert.strictEqual(new BN(-3e8).quo(new BN(2e8)).toNumber(), -1);
      assert.strictEqual(new BN(-3e8).quo(new BN(-2e8)).toNumber(), 1);
      assert.strictEqual(new BN(4e8).quo(new BN(-2e8)).toNumber(), -2);
      assert.strictEqual(new BN(-4e8).quo(new BN(2e8)).toNumber(), -2);
      assert.strictEqual(new BN(-4e8).quo(new BN(-2e8)).toNumber(), 2);
    });

    it('should compute quotient n', () => {
      assert.strictEqual(new BN(3).quon(-2).toNumber(), -1);
      assert.strictEqual(new BN(-3).quon(2).toNumber(), -1);
      assert.strictEqual(new BN(-3).quon(-2).toNumber(), 1);
      assert.strictEqual(new BN(4).quon(-2).toNumber(), -2);
      assert.strictEqual(new BN(-4).quon(2).toNumber(), -2);
      assert.strictEqual(new BN(-4).quon(-2).toNumber(), 2);
    });

    it('should compute remainder', () => {
      assert.strictEqual(new BN(3).rem(new BN(-2)).toNumber(), 1);
      assert.strictEqual(new BN(-3).rem(new BN(2)).toNumber(), -1);
      assert.strictEqual(new BN(-3).rem(new BN(-2)).toNumber(), -1);
      assert.strictEqual(new BN(4).rem(new BN(-2)).toNumber(), 0);
      assert.strictEqual(new BN(-4).rem(new BN(2)).toNumber(), 0);
      assert.strictEqual(new BN(-4).rem(new BN(-2)).toNumber(), 0);
    });

    it('should compute remainder', () => {
      assert.strictEqual(new BN(3e8).rem(new BN(-2e8)).toNumber(), 1e8);
      assert.strictEqual(new BN(-3e8).rem(new BN(2e8)).toNumber(), -1e8);
      assert.strictEqual(new BN(-3e8).rem(new BN(-2e8)).toNumber(), -1e8);
      assert.strictEqual(new BN(4e8).rem(new BN(-2e8)).toNumber(), 0);
      assert.strictEqual(new BN(-4e8).rem(new BN(2e8)).toNumber(), 0);
      assert.strictEqual(new BN(-4e8).rem(new BN(-2e8)).toNumber(), 0);
    });

    it('should compute remainder n', () => {
      assert.strictEqual(new BN(3).remn(-2).toNumber(), 1);
      assert.strictEqual(new BN(-3).remn(2).toNumber(), -1);
      assert.strictEqual(new BN(-3).remn(-2).toNumber(), -1);
      assert.strictEqual(new BN(4).remn(-2).toNumber(), 0);
      assert.strictEqual(new BN(-4).remn(2).toNumber(), 0);
      assert.strictEqual(new BN(-4).remn(-2).toNumber(), 0);
    });

    it('should compute remainder rn', () => {
      assert.strictEqual(new BN(3).remrn(-2), 1);
      assert.strictEqual(new BN(-3).remrn(2), -1);
      assert.strictEqual(new BN(-3).remrn(-2), -1);
      assert.strictEqual(new BN(4).remrn(-2), 0);
      assert.strictEqual(new BN(-4).remrn(2), 0);
      assert.strictEqual(new BN(-4).remrn(-2), 0);
    });

    it('should compute euclidean divmod', () => {
      const [q, r] = new BN(-3).divmod(new BN(2));
      assert.strictEqual(q.toNumber(), -2);
      assert.strictEqual(r.toNumber(), 1);
    });

    it('should compute euclidean division', () => {
      assert.strictEqual(new BN(3).div(new BN(-2)).toNumber(), -1);
      assert.strictEqual(new BN(-3).div(new BN(2)).toNumber(), -2);
      assert.strictEqual(new BN(-3).div(new BN(-2)).toNumber(), 2);
      assert.strictEqual(new BN(4).div(new BN(-2)).toNumber(), -2);
      assert.strictEqual(new BN(-4).div(new BN(2)).toNumber(), -2);
      assert.strictEqual(new BN(-4).div(new BN(-2)).toNumber(), 2);
    });

    it('should compute larger euclidean division', () => {
      assert.strictEqual(new BN(3e8).div(new BN(-2e8)).toNumber(), -1);
      assert.strictEqual(new BN(-3e8).div(new BN(2e8)).toNumber(), -2);
      assert.strictEqual(new BN(-3e8).div(new BN(-2e8)).toNumber(), 2);
      assert.strictEqual(new BN(4e8).div(new BN(-2e8)).toNumber(), -2);
      assert.strictEqual(new BN(-4e8).div(new BN(2e8)).toNumber(), -2);
      assert.strictEqual(new BN(-4e8).div(new BN(-2e8)).toNumber(), 2);
    });

    it('should compute euclidean division n', () => {
      assert.strictEqual(new BN(3).divn(-2).toNumber(), -1);
      assert.strictEqual(new BN(-3).divn(2).toNumber(), -2);
      assert.strictEqual(new BN(-3).divn(-2).toNumber(), 2);
      assert.strictEqual(new BN(4).divn(-2).toNumber(), -2);
      assert.strictEqual(new BN(-4).divn(2).toNumber(), -2);
      assert.strictEqual(new BN(-4).divn(-2).toNumber(), 2);
    });

    it('should compute euclidean modulo', () => {
      assert.strictEqual(new BN(3).mod(new BN(-2)).toNumber(), 1);
      assert.strictEqual(new BN(-3).mod(new BN(2)).toNumber(), 1);
      assert.strictEqual(new BN(-3).mod(new BN(-2)).toNumber(), 1);
      assert.strictEqual(new BN(4).mod(new BN(-2)).toNumber(), 0);
      assert.strictEqual(new BN(-4).mod(new BN(2)).toNumber(), 0);
      assert.strictEqual(new BN(-4).mod(new BN(-2)).toNumber(), 0);
    });

    it('should compute euclidean modulo', () => {
      assert.strictEqual(new BN(3e8).mod(new BN(-2e8)).toNumber(), 1e8);
      assert.strictEqual(new BN(-3e8).mod(new BN(2e8)).toNumber(), 1e8);
      assert.strictEqual(new BN(-3e8).mod(new BN(-2e8)).toNumber(), 1e8);
      assert.strictEqual(new BN(4e8).mod(new BN(-2e8)).toNumber(), 0);
      assert.strictEqual(new BN(-4e8).mod(new BN(2e8)).toNumber(), 0);
      assert.strictEqual(new BN(-4e8).mod(new BN(-2e8)).toNumber(), 0);
    });

    it('should compute euclidean modulo n', () => {
      assert.strictEqual(new BN(3).modn(-2).toNumber(), 1);
      assert.strictEqual(new BN(-3).modn(2).toNumber(), 1);
      assert.strictEqual(new BN(-3).modn(-2).toNumber(), 1);
      assert.strictEqual(new BN(4).modn(-2).toNumber(), 0);
      assert.strictEqual(new BN(-4).modn(2).toNumber(), 0);
      assert.strictEqual(new BN(-4).modn(-2).toNumber(), 0);
    });

    it('should compute euclidean modulo rn', () => {
      assert.strictEqual(new BN(3).modrn(-2), 1);
      assert.strictEqual(new BN(-3).modrn(2), 1);
      assert.strictEqual(new BN(-3).modrn(-2), 1);
      assert.strictEqual(new BN(4).modrn(-2), 0);
      assert.strictEqual(new BN(-4).modrn(2), 0);
      assert.strictEqual(new BN(-4).modrn(-2), 0);
    });

    it('should compute uand', () => {
      assert.strictEqual(new BN(3).uand(new BN(-1)).toNumber(), 1);
      assert.strictEqual(new BN(-3).uand(new BN(1)).toNumber(), -1);
      assert.strictEqual(new BN(-3).uand(new BN(-1)).toNumber(), -1);
      assert.strictEqual(new BN(4).uand(new BN(-1)).toNumber(), 0);
      assert.strictEqual(new BN(-4).uand(new BN(1)).toNumber(), 0);
      assert.strictEqual(new BN(-4).uand(new BN(-1)).toNumber(), 0);
    });

    it('should compute uandn', () => {
      assert.strictEqual(new BN(3).uandn(-1).toNumber(), 1);
      assert.strictEqual(new BN(-3).uandn(1).toNumber(), -1);
      assert.strictEqual(new BN(-3).uandn(-1).toNumber(), -1);
      assert.strictEqual(new BN(4).uandn(-1).toNumber(), 0);
      assert.strictEqual(new BN(-4).uandn(1).toNumber(), 0);
      assert.strictEqual(new BN(-4).uandn(-1).toNumber(), 0);
    });

    it('should compute uandrn', () => {
      assert.strictEqual(new BN(3).uandrn(-1), 1);
      assert.strictEqual(new BN(-3).uandrn(1), -1);
      assert.strictEqual(new BN(-3).uandrn(-1), -1);
      assert.strictEqual(new BN(4).uandrn(-1), 0);
      assert.strictEqual(new BN(-4).uandrn(1), 0);
      assert.strictEqual(new BN(-4).uandrn(-1), 0);
    });

    it('should compute andln', () => {
      assert.strictEqual(new BN(3).andln(-1), 3);
      assert.strictEqual(new BN(-3).andln(1), 1);
      assert.strictEqual(new BN(-3).andln(-1), 3);
      assert.strictEqual(new BN(4).andln(-1), 4);
      assert.strictEqual(new BN(-4).andln(1), 0);
      assert.strictEqual(new BN(-4).andln(-1), 4);
      assert.strictEqual(new BN(0x7fffffff).andln(-1), 0x3ffffff);
    });

    it('should compute powm', () => {
      const x = new BN('49d695e8e09850acf3ced130d55cf4cc', 16);
      const y = new BN('1abc952', 16);
      const m = new BN('b06577896432d8cf7af1c491cad11be9b584316d0045187f40c8ae8d57724725', 16);
      const r = new BN('3f4cbb5b31c94b98dc5234de233af07319e93088192a9c87e3f0da9b213c779b', 16);

      assert.strictEqual(x.powm(y, m).toString(), r.toString());
      assert.strictEqual(
        x.toRed(BN.red(m)).redPow(y).fromRed().toString(),
        r.toString());

      assert.strictEqual(x.clone().ipowm(y, m).toString(), r.toString());
      assert.strictEqual(
        x.toRed(BN.red(m)).redIPow(y).fromRed().toString(),
        r.toString());

      assert.strictEqual(x.powmn(y.toNumber(), m).toString(), r.toString());
      assert.strictEqual(
        x.toRed(BN.red(m)).redPown(y.toNumber()).fromRed().toString(),
        r.toString());

      assert.strictEqual(x.clone().ipowmn(y.toNumber(), m).toString(), r.toString());
      assert.strictEqual(
        x.toRed(BN.red(m)).redIPown(y.toNumber()).fromRed().toString(),
        r.toString());
    });

    it('should compute pown/powm', () => {
      const x = new BN('49d695e8e09850acf3ced130d55cf4cc', 16);
      const red = BN.red('p192');
      const r = x.toRed(red);

      assert.strictEqual(x.pown(0).toString(), '1');
      assert.strictEqual(x.pown(1).toString(), x.toString());
      assert.strictEqual(x.pown(2).toString(), x.sqr().toString());
      assert.strictEqual(x.pown(3).toString(),
                         x.sqr().mul(x).toString());
      assert.strictEqual(x.pown(4).toString(),
                         x.sqr().sqr().toString());
      assert.strictEqual(x.pown(5).toString(),
                         x.sqr().sqr().mul(x).toString());

      assert.strictEqual(x.pow(new BN(0)).toString(), '1');
      assert.strictEqual(x.pow(new BN(1)).toString(), x.toString());
      assert.strictEqual(x.pow(new BN(2)).toString(), x.sqr().toString());
      assert.strictEqual(x.pow(new BN(3)).toString(),
                         x.sqr().mul(x).toString());
      assert.strictEqual(x.pow(new BN(4)).toString(),
                         x.sqr().sqr().toString());
      assert.strictEqual(x.pow(new BN(5)).toString(),
                         x.sqr().sqr().mul(x).toString());

      assert.strictEqual(r.redPown(0).toString(), '1');
      assert.strictEqual(r.redPown(1).toString(), r.toString());
      assert.strictEqual(r.redPown(2).toString(), r.redSqr().toString());
      assert.strictEqual(r.redPown(3).toString(),
                         r.redSqr().redMul(r).toString());
      assert.strictEqual(r.redPown(4).toString(),
                         r.redSqr().redSqr().toString());
      assert.strictEqual(r.redPown(5).toString(),
                         r.redSqr().redSqr().redMul(r).toString());

      assert.strictEqual(r.redPow(new BN(0)).toString(), '1');
      assert.strictEqual(r.redPow(new BN(1)).toString(), r.toString());
      assert.strictEqual(r.redPow(new BN(2)).toString(), r.redSqr().toString());
      assert.strictEqual(r.redPow(new BN(3)).toString(),
                         r.redSqr().redMul(r).toString());
      assert.strictEqual(r.redPow(new BN(4)).toString(),
                         r.redSqr().redSqr().toString());
      assert.strictEqual(r.redPow(new BN(5)).toString(),
                         r.redSqr().redSqr().redMul(r).toString());
    });

    it('should throw on powm with negative exponent', () => {
      const x = new BN('49d695e8e09850acf3ced130d55cf4cc', 16);
      const y = new BN('-1abc952', 16);
      const m = new BN('b06577896432d8cf7af1c491cad11be9b584316d0045187f40c8ae8d57724725', 16);

      assert.throws(() => x.powm(y, m).toString());
      assert.throws(() => x.toRed(BN.red(m)).redPow(y).fromRed());
    });

    it('should compute powm with negative exponent', () => {
      const x = new BN('49d695e8e09850acf3ced130d55cf4cc', 16);
      const y = new BN('-1abc952', 16);
      const m = P192;
      const r = new BN('c512e27cb7074356c472e2be772566a307bd2a8fd9469886', 16);

      assert.strictEqual(x.powm(y, m).toString(), r.toString());
      assert.strictEqual(
        x.toRed(BN.red(m)).redPow(y).fromRed().toString(),
        r.toString());
    });

    it('should compute large powm', () => {
      const x = P224;
      const y = new BN('1abc952', 16);
      const m = P192;
      const r = new BN('65ddeefb718fff7600b3200f3e73f94434d2f5838a7b83ab', 16);

      assert.strictEqual(x.powm(y, m).toString(), r.toString());
    });

    it('should compute powm (ladder)', () => {
      const x = new BN('49d695e8e09850acf3ced130d55cf4cc', 16);
      const y = new BN('1abc952', 16);
      const m = new BN('b06577896432d8cf7af1c491cad11be9b584316d0045187f40c8ae8d57724725', 16);
      const r = new BN('3f4cbb5b31c94b98dc5234de233af07319e93088192a9c87e3f0da9b213c779b', 16);

      assert.strictEqual(x.powm(y, m, 0, 1).toString(), r.toString());
      assert.strictEqual(
        x.toRed(BN.red(m)).redPow(y, 1).fromRed().toString(),
        r.toString());

      assert.strictEqual(x.powm(y, m, 1, 1).toString(), r.toString());
      assert.strictEqual(
        x.toRed(BN.mont(m)).redPow(y, 1).fromRed().toString(),
        r.toString());
    });

    it('should compute powm with negative exponent (ladder)', () => {
      const x = new BN('49d695e8e09850acf3ced130d55cf4cc', 16);
      const y = new BN('-1abc952', 16);
      const m = P192;
      const r = new BN('c512e27cb7074356c472e2be772566a307bd2a8fd9469886', 16);

      assert.strictEqual(x.powm(y, m, 0, 1).toString(), r.toString());
      assert.strictEqual(
        x.toRed(BN.red(m)).redPow(y, 1).fromRed().toString(),
        r.toString());

      assert.strictEqual(x.powm(y, m, 1, 1).toString(), r.toString());
      assert.strictEqual(
        x.toRed(BN.mont(m)).redPow(y, 1).fromRed().toString(),
        r.toString());
    });

    it('should compute large powm (ladder)', () => {
      const x = P224;
      const y = new BN('1abc952', 16);
      const m = P192;
      const r = new BN('65ddeefb718fff7600b3200f3e73f94434d2f5838a7b83ab', 16);

      assert.strictEqual(x.powm(y, m, 0, 1).toString(), r.toString());
      assert.strictEqual(x.powm(y, m, 1, 1).toString(), r.toString());
    });

    it('should compute inverse', () => {
      const y = P192;
      const x = BN.random(rng, 0, y);
      const inv = x.invert(y);
      const inv2 = x.toRed(BN.red(y)).redInvert().fromRed();
      const inv3 = x.toRed(BN.mont(y)).redInvert().fromRed();

      assert.strictEqual(x.mul(inv).subn(1).mod(y).toString(), '0');
      assert.strictEqual(inv.toString(), x.invert(y).toString());
      assert.strictEqual(inv2.toString(), inv.toString());
      assert.strictEqual(inv3.toString(), inv.toString());
    });

    it('should compute large inverse', () => {
      const x = P224;
      const y = P192;
      const r = new BN('ffffffff00000000ffffffff0000000000000000', 16);
      const inv = x.invert(y);
      const inv2 = x.toRed(BN.red(y)).redInvert().fromRed();
      const inv3 = x.toRed(BN.mont(y)).redInvert().fromRed();

      assert.strictEqual(inv.toString(), r.toString());
      assert.strictEqual(inv2.toString(), inv.toString());
      assert.strictEqual(inv3.toString(), inv.toString());
    });

    it('should compute fermat inverse', () => {
      const y = P192;
      const x = BN.random(rng, 0, y);
      const inv = x.fermat(y);
      const inv2 = x.toRed(BN.red(y)).redFermat().fromRed();
      const inv3 = x.toRed(BN.mont(y)).redFermat().fromRed();

      assert.strictEqual(x.mul(inv).subn(1).mod(y).toString(), '0');
      assert.strictEqual(inv.toString(), x.invert(y).toString());
      assert.strictEqual(inv2.toString(), inv.toString());
      assert.strictEqual(inv3.toString(), inv.toString());
    });

    it('should compute large fermat inverse', () => {
      const x = P224;
      const y = P192;
      const r = new BN('ffffffff00000000ffffffff0000000000000000', 16);
      const inv = x.fermat(y);
      const inv2 = x.toRed(BN.red(y)).redFermat().fromRed();
      const inv3 = x.toRed(BN.mont(y)).redFermat().fromRed();

      assert.strictEqual(inv.toString(), r.toString());
      assert.strictEqual(inv2.toString(), inv.toString());
      assert.strictEqual(inv3.toString(), inv.toString());
    });

    it('should compute invertp', () => {
      if (!BN.prototype._invertp)
        this.skip();

      const p = P192;
      const r = BN.random(rng, 0, p);
      const rInv = r._invertp(p);

      assert.strictEqual(r.mul(rInv).subn(1).mod(p).toString(), '0');
      assert.strictEqual(rInv.toString(), r._invertp(p).toString());
    });

    it('should compute gcd and egcd', () => {
      const r1 = BN.randomBits(rng, 256);
      const r2 = BN.randomBits(rng, 256);
      const gcd_ = r1.gcd(r2);
      const [,, gcd] = r1.egcd(r2);

      assert.strictEqual(gcd_.toString(), gcd.toString());
    });

    it('should compute egcd', () => {
      const r1 = BN.randomBits(rng, 256);
      const r2 = BN.randomBits(rng, 256);
      const g = r1.gcd(r2);
      const [a1, b1, g1] = r1.egcd(r2);

      const r1d = r1.quo(g1);
      const r2d = r2.quo(g1);
      const [a2, b2, g2] = r1d.egcd(r2d);

      assert.strictEqual(g.toString(), g1.toString());
      assert.strictEqual(g1.toString(), r1.mul(a1).add(r2.mul(b1)).toString());
      assert.strictEqual(g2.toString(), '1');
      assert.strictEqual(r1d.mul(a2).add(r2d.mul(b2)).subn(1).toString(), '0');
    });

    it('should compute large egcd', () => {
      const x = P224;
      const y = P192;
      const [s, t, g] = x.egcd(y);
      const rs = new BN('ffffffff00000000ffffffff0000000000000000', 16);
      const rt = new BN('-ffffffff00000000ffffffff000000000000000000000001', 16);
      const rg = new BN('01', 16);

      assert.strictEqual(s.toString(16), rs.toString(16));
      assert.strictEqual(t.toString(16), rt.toString(16));
      assert.strictEqual(g.toString(16), rg.toString(16));
    });

    it('should throw on invert with no inverse', () => {
      const z = new BN(0);
      const x = new BN('49d695e8e09850acf3ced130d55cf4cc', 16);
      const m = new BN('b06577896432d8cf7af1c491cad11be9b584316d0045187f40c8ae8d57724725', 16);
      const red = BN.red(m);

      assert.throws(() => x.invert(m));
      assert.throws(() => x.neg().invert(m));
      assert.throws(() => x.toRed(red).redInvert());
      assert.throws(() => x.neg().toRed(red).redInvert());

      assert.throws(() => z.invert(m));
      assert.throws(() => z.toRed(red).redInvert());
    });

    it('should throw on fermat with no inverse', () => {
      const z = new BN(0);
      const m = new BN('b06577896432d8cf7af1c491cad11be9b584316d0045187f40c8ae8d57724725', 16);
      const red = BN.red(m);

      assert.throws(() => z.fermat(m));
      assert.throws(() => z.toRed(red).redFermat());
    });

    it('should compute sqrt', () => {
      const r = BN.randomBits(rng, 256);
      const R = r.sqrt();

      assert(R.sqr().lte(r));
      assert(r.lt(R.addn(1).sqr()));

      const r2 = r.sqr();
      const R2 = r2.sqrt();

      assert(R2.eq(r));
    });

    it('should compute sqrtrem', () => {
      const n = BN.randomBits(rng, 256);
      const [x, r] = n.sqrtrem();
      const v = x.sqr().add(r);

      assert(v.eq(n));
    });

    it('should compute root', () => {
      const r = BN.randomBits(rng, 256);
      const R = r.root(3);

      assert(R.pown(3).lte(r));
      assert(r.lt(R.addn(1).pown(3)));

      const r2 = r.pown(3);
      const R2 = r2.root(3);

      assert(R2.eq(r));
    });

    it('should compute rootrem (1)', () => {
      const n = BN.randomBits(rng, 256);
      const [x, r] = n.rootrem(3);
      const v = x.pown(3).add(r);

      assert(v.eq(n));
      assert(x.pown(3).root(3).eq(x));
      assert(x.pown(3).rootrem(3)[0].eq(x));
      assert(x.pown(3).rootrem(3)[1].isZero());
    });

    it('should compute rootrem (2)', () => {
      const n = new BN(-134123);
      const [x, r] = n.rootrem(3);

      assert(x.eqn(-51));
      assert(r.eqn(-1472));
    });

    it('should compute rootrem (3)', () => {
      const [x1, r1] = new BN(0).rootrem(2);
      const [x2, r2] = new BN(1).rootrem(2);
      const [x3, r3] = new BN(0).sqrtrem();
      const [x4, r4] = new BN(1).sqrtrem();

      assert(x1.isZero());
      assert(r1.isZero());
      assert(x2.eqn(1));
      assert(r2.isZero());

      assert(x3.isZero());
      assert(r3.isZero());
      assert(x4.eqn(1));
      assert(r4.isZero());

      assert(new BN(0).root(2).eq(x1));
      assert(new BN(1).root(2).eq(x2));
      assert(new BN(0).sqrt().eq(x1));
      assert(new BN(1).sqrt().eq(x2));

      assert(new BN(0).isPower(2));
      assert(new BN(1).isPower(2));
      assert(!new BN(2).isPower(2));
      assert(new BN(0).isSquare());
      assert(new BN(1).isSquare());
      assert(!new BN(2).isSquare());
    });

    it('should compute sqrtm (p192, p mod 4 == 3)', () => {
      const p = P192;
      const r = BN.random(rng, 0, p);
      const R = r.sqr().mod(p);
      const s = R.sqrtm(p);

      assert(p.andln(3) === 3);

      assert.strictEqual(s.sqr().mod(p).toString(), R.toString());
    });

    it('should compute sqrtm (p192, zero)', () => {
      const p = P192;
      const s1 = p.sqrtm(p);
      const s2 = p.muln(2).sqrtm(p);

      assert(p.andln(3) === 3);

      assert.strictEqual(s1.toString(), '0');
      assert.strictEqual(s2.toString(), '0');
    });

    it('should compute sqrtm (p25519, p mod 8 == 5)', () => {
      const p = P25519;
      const r = BN.random(rng, 0, p);
      const R = r.sqr().mod(p);
      const s = R.sqrtm(p);

      assert(p.andln(7) === 5);

      assert.strictEqual(s.sqr().mod(p).toString(), R.toString());
    });

    it('should calculate sqrt (p = 5 mod 8)', () => {
      const primes = [];
      const squares = [];

      for (let i = 0; i < 10; i++) {
        let p;

        for (;;) {
          p = BN.randomBits(rng, 128);

          if (p.andln(7) !== 5)
            continue;

          if (p.isPrime(rng, 20))
            break;
        }

        primes.push(p);
      }

      for (let i = 0; i < 10; i++) {
        const p = primes[i];
        const items = [];

        for (let j = 0; j < 10; j++) {
          const x = BN.random(rng, 1, p);

          items.push(x.sqr().imod(p));
        }

        squares.push(items);
      }

      for (let i = 0; i < 10; i++) {
        const p = primes[i];
        const items = squares[i];
        const red = BN.red(p);

        assert(red.sm1 == null);

        for (let j = 0; j < 10; j++) {
          const x = items[j].toRed(red);
          const r = x.redSqrt();

          assert(r.redSqr().eq(x));
        }

        red.precompute();

        assert(red.sm1 != null);

        for (let j = 0; j < 10; j++) {
          const x = items[j].toRed(red);
          const r = x.redSqrt();

          assert(r.redSqr().eq(x));
        }
      }
    });

    it('should test squareness', () => {
      const mods = [
        P192, // legendre
        P192.subn(2), // jacobi
        P192.subn(1) // kronecker
      ];

      for (const p of mods) {
        const red = BN.red(p === P192 ? 'p192' : p);
        const zero = new BN(0).toRed(red);
        const qnr = BN.random(rng, 1, p).toRed(red);

        while (qnr.redKronecker() !== -1)
          qnr.redIAddn(1);

        const qr = qnr.redSqr();

        assert(zero.redKronecker() === 0);
        assert(qnr.redKronecker() === -1);
        assert(qr.redKronecker() === 1);

        assert.strictEqual(zero.redIsSquare(), true);
        assert.strictEqual(qnr.redIsSquare(), false);
        assert.strictEqual(qr.redIsSquare(), true);
      }
    });

    it('should compute sqrtm (p25519, zero)', () => {
      const p = P25519;
      const s1 = p.sqrtm(p);
      const s2 = p.muln(2).sqrtm(p);

      assert(p.andln(7) === 5);

      assert.strictEqual(s1.toString(), '0');
      assert.strictEqual(s2.toString(), '0');
    });

    it('should compute sqrtm (p224, tonelli-shanks)', () => {
      const p = P224;
      const r = BN.random(rng, 0, p);
      const R = r.sqr().mod(p);
      const s = R.sqrtm(p);

      assert(p.andln(3) !== 3 && p.andln(7) !== 5);

      assert.strictEqual(s.sqr().mod(p).toString(), R.toString());
    });

    it('should compute sqrtm (224, zero)', () => {
      const p = P224;
      const s1 = p.sqrtm(p);
      const s2 = p.muln(2).sqrtm(p);

      assert(p.andln(3) !== 3 && p.andln(7) !== 5);

      assert.strictEqual(s1.toString(), '0');
      assert.strictEqual(s2.toString(), '0');
    });

    it('should compute sqrtpq', () => {
      const p = P192;
      const q = P224;
      const n = p.mul(q);
      const r = BN.random(rng, 0, n);
      const R = r.sqr().mod(n);
      const s = R.sqrtpq(p, q);

      assert.strictEqual(s.sqr().mod(n).toString(), R.toString());
    });

    it('should compute negative gcd', () => {
      const p = P192;
      const r = BN.random(rng, 0, p);
      const g1 = r.neg().gcd(p);
      const g2 = r.gcd(p);

      assert.strictEqual(g1.toString(), g2.toString());
    });

    it('should compute lcm (1)', () => {
      const n = new BN('e99696a9507ceafdb46582adc8d66b4106bbd7f7856c3b0d', 16);
      const k = new BN('3b0f7fcc204c2790a9d11d8b19e2a8125b7ab803ac4bdedb', 16);
      const m = new BN('35e3d927cfaedef82e7f5b0c5bf04a3d7110e8dc28b656e79b9ccbcbd460d6ca2a8be2efabaa7fe2590b3dfc079aca1f', 16);
      const l = n.lcm(k);
      const e = n.mul(k).div(n.gcd(k));

      assert.strictEqual(l.toString(), m.toString());
      assert.strictEqual(e.toString(), m.toString());
    });

    it('should compute lcm (2)', () => {
      for (let i = 0; i < 20; i++) {
        const n = BN.randomBits(rng, 256);
        const k = BN.randomBits(rng, 256);
        const l = n.lcm(k);
        const e = n.mul(k).div(n.gcd(k));

        assert.strictEqual(l.toString(), e.toString());
      }
    });

    it('should compute egcd', () => {
      const p = P192;
      const n = new BN('e99696a9507ceafdb46582adc8d66b4106bbd7f7856c3b0d', 16);
      const a1 = new BN('-3b0f7fcc204c2790a9d11d8b19e2a8125b7ab803ac4bdedb', 16);
      const b1 = new BN('35e3d927cfaedef82e7f5b0c5bf04a3da6f4c203f86535e0', 16);
      const g1 = new BN(1);
      const [a, b, g] = n.egcd(p);

      assert.strictEqual(a.toString(), a1.toString());
      assert.strictEqual(b.toString(), b1.toString());
      assert.strictEqual(g.toString(), g1.toString());
      assert.strictEqual(a.mod(p).toString(), n.invert(p).toString());
    });

    it('should compute large egcd', () => {
      const p = P192;
      const n = new BN('fffffffffe99696a9507ceafdb46582adc8d66b4106bbd7f7856c3b0d', 16);
      const a1 = new BN('-2845995b1f610cf0bfd19fca0159c7a065b50cb81d122812', 16);
      const b1 = new BN('2845995b1f28a3ec01323af78e75fed7749bbda8419c7721b153fd115', 16);
      const g1 = new BN(1);
      const [a, b, g] = n.egcd(p);

      assert(n.bitLength() > p.bitLength());

      assert.strictEqual(a.toString(), a1.toString());
      assert.strictEqual(b.toString(), b1.toString());
      assert.strictEqual(g.toString(), g1.toString());
      assert.strictEqual(a.mod(p).toString(), n.invert(p).toString());
    });

    it('should compute negative egcd', () => {
      const p = P192;
      const n = new BN('-e99696a9507ceafdb46582adc8d66b4106bbd7f7856c3b0d', 16);
      const a1 = new BN('3b0f7fcc204c2790a9d11d8b19e2a8125b7ab803ac4bdedb', 16);
      const b1 = new BN('35e3d927cfaedef82e7f5b0c5bf04a3da6f4c203f86535e0', 16);
      const g1 = new BN(1);
      const [a, b, g] = n.egcd(p);

      assert.strictEqual(a.toString(), a1.toString());
      assert.strictEqual(b.toString(), b1.toString());
      assert.strictEqual(g.toString(), g1.toString());
      assert.strictEqual(a.mod(p).toString(), n.invert(p).toString());
    });

    it('should compute negative egcd', () => {
      const p = P192;
      const n = new BN('e99696a9507ceafdb46582adc8d66b4106bbd7f7856c3b0d', 16);
      const a1 = new BN('-3b0f7fcc204c2790a9d11d8b19e2a8125b7ab803ac4bdedb', 16);
      const b1 = new BN('-35e3d927cfaedef82e7f5b0c5bf04a3da6f4c203f86535e0', 16);
      const g1 = new BN(1);
      const [a, b, g] = n.egcd(p.neg());

      assert.strictEqual(a.toString(), a1.toString());
      assert.strictEqual(b.toString(), b1.toString());
      assert.strictEqual(g.toString(), g1.toString());
    });

    it('should compute invert', () => {
      const p = P192;
      const n = new BN('e99696a9507ceafdb46582adc8d66b4106bbd7f7856c3b0d', 16);
      const a1 = new BN('c4f08033dfb3d86f562ee274e61d57eca48547fc53b42124', 16);
      const a = n.invert(p);

      assert.strictEqual(a.toString(), a1.toString());
    });

    it('should compute large invert', () => {
      const p = P192;
      const n = new BN('fffffffffe99696a9507ceafdb46582adc8d66b4106bbd7f7856c3b0d', 16);
      const a1 = new BN('d7ba66a4e09ef30f402e6035fea6385e9a4af347e2edd7ed', 16);
      const a = n.invert(p);
      const b = n.mod(p).invert(p);

      assert(n.bitLength() > p.bitLength());

      assert.strictEqual(a.toString(), a1.toString());
      assert.strictEqual(b.toString(), a1.toString());
    });

    it('should compute negative invert', () => {
      const p = P192;
      const n = new BN('-e99696a9507ceafdb46582adc8d66b4106bbd7f7856c3b0d', 16);
      const a1 = new BN('3b0f7fcc204c2790a9d11d8b19e2a8125b7ab803ac4bdedb', 16);
      const a = n.invert(p);
      const b = n.mod(p).invert(p);

      assert.strictEqual(a.toString(), a1.toString());
      assert.strictEqual(b.toString(), a1.toString());
    });

    it('should compute powm (negative)', () => {
      const x = new BN('-49d695e8e09850acf3ced130d55cf4cc', 16);
      const y = new BN('1abc952', 16);
      const m = new BN('b06577896432d8cf7af1c491cad11be9b584316d0045187f40c8ae8d57724725', 16);
      const r = new BN('3f4cbb5b31c94b98dc5234de233af07319e93088192a9c87e3f0da9b213c779b', 16);

      assert.strictEqual(x.powm(y, m).toString(), r.toString());
      assert.strictEqual(
        x.toRed(BN.red(m)).redPow(y).fromRed().toString(),
        r.toString());
    });

    it('should throw on powm with negative exponent (negative)', () => {
      const x = new BN('-49d695e8e09850acf3ced130d55cf4cc', 16);
      const y = new BN('-1abc952', 16);
      const m = new BN('b06577896432d8cf7af1c491cad11be9b584316d0045187f40c8ae8d57724725', 16);

      assert.throws(() => x.powm(y, m));
      assert.throws(() => x.toRed(BN.red(m)).redPow(y).fromRed());
    });

    it('should compute powm with negative exponent (negative)', () => {
      const x = new BN('-49d695e8e09850acf3ced130d55cf4cc', 16);
      const y = new BN('-1abc952', 16);
      const m = P192;
      const r = new BN('c512e27cb7074356c472e2be772566a307bd2a8fd9469886', 16);

      assert.strictEqual(x.powm(y, m).toString(), r.toString());
      assert.strictEqual(
        x.toRed(BN.red(m)).redPow(y).fromRed().toString(),
        r.toString());
    });

    it('should compute inverse (negative)', () => {
      const p = P192;
      const r = BN.random(rng, 0, p);
      const i1 = r.neg().invert(p);
      const i2 = r.neg().mod(p).invert(p);

      assert.strictEqual(i1.toString(), i2.toString());
    });

    it('should compute fermat inverse (negative)', () => {
      const p = P192;
      const r = BN.random(rng, 0, p);
      const i1 = r.neg().fermat(p);
      const i2 = r.neg().mod(p).fermat(p);

      assert.strictEqual(i1.toString(), i2.toString());
    });

    it('should compute sqrtm (negative)', () => {
      const p = P192;
      const r = BN.random(rng, 0, p).ineg();
      const R = r.sqr().mod(p);
      const s = R.sqrtm(p);

      assert.strictEqual(s.sqr().mod(p).toString(), R.toString());
    });

    it('should compute sqrtpq (negative)', () => {
      const p = P192;
      const q = P224;
      const n = p.mul(q);
      const r = BN.random(rng, 0, n).ineg();
      const R = r.sqr().mod(n);
      const s = R.sqrtpq(p, q);

      assert.strictEqual(s.sqr().mod(n).toString(), R.toString());
    });

    it('should negate', () => {
      const p = P192;
      const r = BN.random(rng, 1, p);

      assert.strictEqual(r.neg().imod(p).toString(), p.sub(r).toString());
    });

    it('should test perfect squares', () => {
      assert(new BN(0).isSquare());
      assert(new BN(1).isSquare());
      assert(!new BN(2).isSquare());
      assert(!new BN(3).isSquare());
      assert(new BN(4).isSquare());
      assert(!new BN(5).isSquare());
      assert(!new BN(6).isSquare());
      assert(!new BN(7).isSquare());
      assert(new BN(1024).isSquare());
      assert(!new BN(1025).isSquare());
    });

    it('should test perfect powers', () => {
      assert(new BN(0).isPower(3));
      assert(new BN(1).isPower(3));
      assert(!new BN(2).isPower(3));
      assert(!new BN(3).isPower(3));
      assert(!new BN(26).isPower(3));
      assert(new BN(27).isPower(3));
      assert(new BN(-27).isPower(3));
      assert(!new BN(28).isPower(3));
      assert(!new BN(5).isPower(3));
      assert(!new BN(6).isPower(3));
      assert(!new BN(7).isPower(3));
      assert(!new BN(63).isPower(3));
      assert(new BN(64).isPower(3));
      assert(!new BN(65).isPower(3));
      assert(!new BN(124).isPower(3));
      assert(new BN(125).isPower(3));
      assert(!new BN(126).isPower(3));
      assert(!new BN(215).isPower(3));
      assert(new BN(216).isPower(3));
      assert(!new BN(217).isPower(3));
    });

    it('should allow negative numbers for reduction context', () => {
      const p = P192;
      const red = BN.red(p);
      const n = BN.random(rng, p.neg(), 0);

      assert(n.isNeg());

      const r = n.toRed(red);

      assert(!r.isNeg());

      assert(r.fromRed().eq(n.mod(p)));
    });

    it('should allow negative numbers for montgomery context', () => {
      const p = P192;
      const red = BN.mont(p);
      const n = BN.random(rng, p.neg(), 0);

      assert(n.isNeg());

      const r = n.toRed(red);

      assert(!r.isNeg());

      assert(r.fromRed().eq(n.mod(p)));
    });

    it('should do division on finite field (1)', () => {
      const red = BN.red('p192');
      const n = BN.random(rng, 1, red.m).toRed(red);
      const d = BN.random(rng, 2, red.m).toRed(red);
      const expect = n.redMul(d.redInvert());
      const r0 = n.redDiv(d);

      assert(!n.eq(r0));

      const r1 = n.redIDiv(d);

      assert(r0.eq(expect));
      assert(r1.eq(expect));
      assert(r1.eq(expect));
      assert(n.eq(r1));
    });

    it('should do division on finite field (2)', () => {
      const red = BN.red('p192');
      const n = BN.random(rng, 1, red.m).toRed(red);
      const d = BN.randomBits(rng, 26).toNumber();
      const expect = n.redMul(new BN(d).toRed(red).redInvert());
      const r0 = n.redDivn(d);

      assert(!n.eq(r0));

      const r1 = n.redIDivn(d);

      assert(r0.eq(expect));
      assert(r1.eq(expect));
      assert(r1.eq(expect));
      assert(n.eq(r1));
    });

    for (const red of [BN.red('p192'), BN.red(P192), BN.mont(P192)]) {
      it('should test red helpers', () => {
        const r0 = new BN(0).toRed(red);
        const r1 = new BN(1).toRed(red);
        const r2 = new BN(2).toRed(red);
        const r3 = new BN(3).toRed(red);
        const r4 = new BN(4).toRed(red);
        const r5 = new BN(5).toRed(red);
        const r6 = new BN(6).toRed(red);
        const r7 = new BN(7).toRed(red);
        const r8 = new BN(8).toRed(red);
        const r9 = new BN(9).toRed(red);
        const r10 = new BN(10).toRed(red);
        const r11 = new BN(11).toRed(red);
        const r12 = new BN(12).toRed(red);
        const r13 = new BN(13).toRed(red);
        const r14 = new BN(14).toRed(red);
        const r15 = new BN(15).toRed(red);
        const r16 = new BN(16).toRed(red);
        const r17 = new BN(17).toRed(red);
        const r18 = new BN(18).toRed(red);
        const raaaa = new BN(0xaaaa).toRed(red);
        const rp = new BN(P192.ushrn(1)).toRed(red);
        const n = BN.random(rng, P192.ushrn(1), P192).toRed(red);

        assert.strictEqual(n.redAddn(0).toString(), n.redAdd(r0).toString());
        assert.strictEqual(n.redAddn(1).toString(), n.redAdd(r1).toString());
        assert.strictEqual(n.redAddn(2).toString(), n.redAdd(r2).toString());
        assert.strictEqual(n.redAddn(3).toString(), n.redAdd(r3).toString());

        assert.strictEqual(n.redAddn(-1).toString(), n.redAdd(r1.redNeg()).toString());
        assert.strictEqual(n.redAddn(-2).toString(), n.redAdd(r2.redNeg()).toString());
        assert.strictEqual(n.redAddn(-3).toString(), n.redAdd(r3.redNeg()).toString());

        assert.strictEqual(n.redSubn(0).toString(), n.redSub(r0).toString());
        assert.strictEqual(n.redSubn(1).toString(), n.redSub(r1).toString());
        assert.strictEqual(n.redSubn(2).toString(), n.redSub(r2).toString());
        assert.strictEqual(n.redSubn(3).toString(), n.redSub(r3).toString());

        assert.strictEqual(n.redSubn(-1).toString(), n.redSub(r1.redNeg()).toString());
        assert.strictEqual(n.redSubn(-2).toString(), n.redSub(r2.redNeg()).toString());
        assert.strictEqual(n.redSubn(-3).toString(), n.redSub(r3.redNeg()).toString());

        assert.strictEqual(n.redMuln(0).toString(), n.redMul(r0).toString());
        assert.strictEqual(n.redMuln(1).toString(), n.redMul(r1).toString());
        assert.strictEqual(n.redMuln(2).toString(), n.redMul(r2).toString());
        assert.strictEqual(n.redMuln(3).toString(), n.redMul(r3).toString());
        assert.strictEqual(n.redMuln(4).toString(), n.redMul(r4).toString());
        assert.strictEqual(n.redMuln(5).toString(), n.redMul(r5).toString());
        assert.strictEqual(n.redMuln(6).toString(), n.redMul(r6).toString());
        assert.strictEqual(n.redMuln(7).toString(), n.redMul(r7).toString());
        assert.strictEqual(n.redMuln(8).toString(), n.redMul(r8).toString());
        assert.strictEqual(n.redMuln(9).toString(), n.redMul(r9).toString());
        assert.strictEqual(n.redMuln(10).toString(), n.redMul(r10).toString());
        assert.strictEqual(n.redMuln(11).toString(), n.redMul(r11).toString());
        assert.strictEqual(n.redMuln(12).toString(), n.redMul(r12).toString());
        assert.strictEqual(n.redMuln(13).toString(), n.redMul(r13).toString());
        assert.strictEqual(n.redMuln(14).toString(), n.redMul(r14).toString());
        assert.strictEqual(n.redMuln(15).toString(), n.redMul(r15).toString());
        assert.strictEqual(n.redMuln(16).toString(), n.redMul(r16).toString());
        assert.strictEqual(n.redMuln(17).toString(), n.redMul(r17).toString());
        assert.strictEqual(n.redMuln(18).toString(), n.redMul(r18).toString());
        assert.strictEqual(n.redMuln(0xaaaa).toString(), n.redMul(raaaa).toString());

        assert.strictEqual(n.redMuln(-1).toString(), n.redMul(r1.redNeg()).toString());
        assert.strictEqual(n.redMuln(-2).toString(), n.redMul(r2.redNeg()).toString());
        assert.strictEqual(n.redMuln(-3).toString(), n.redMul(r3.redNeg()).toString());
        assert.strictEqual(n.redMuln(-4).toString(), n.redMul(r4.redNeg()).toString());
        assert.strictEqual(n.redMuln(-5).toString(), n.redMul(r5.redNeg()).toString());
        assert.strictEqual(n.redMuln(-6).toString(), n.redMul(r6.redNeg()).toString());
        assert.strictEqual(n.redMuln(-7).toString(), n.redMul(r7.redNeg()).toString());
        assert.strictEqual(n.redMuln(-8).toString(), n.redMul(r8.redNeg()).toString());
        assert.strictEqual(n.redMuln(-9).toString(), n.redMul(r9.redNeg()).toString());
        assert.strictEqual(n.redMuln(-10).toString(), n.redMul(r10.redNeg()).toString());
        assert.strictEqual(n.redMuln(-11).toString(), n.redMul(r11.redNeg()).toString());
        assert.strictEqual(n.redMuln(-12).toString(), n.redMul(r12.redNeg()).toString());
        assert.strictEqual(n.redMuln(-13).toString(), n.redMul(r13.redNeg()).toString());
        assert.strictEqual(n.redMuln(-14).toString(), n.redMul(r14.redNeg()).toString());
        assert.strictEqual(n.redMuln(-15).toString(), n.redMul(r15.redNeg()).toString());
        assert.strictEqual(n.redMuln(-16).toString(), n.redMul(r16.redNeg()).toString());
        assert.strictEqual(n.redMuln(-17).toString(), n.redMul(r17.redNeg()).toString());
        assert.strictEqual(n.redMuln(-18).toString(), n.redMul(r18.redNeg()).toString());
        assert.strictEqual(n.redMuln(-0xaaaa).toString(), n.redMul(raaaa.redNeg()).toString());

        assert.strictEqual(n.redShl(new BN(0)).toString(), n.redMuln(1).toString());
        assert.strictEqual(n.redShl(new BN(1)).toString(), n.redMuln(2).toString());
        assert.strictEqual(n.redShl(new BN(2)).toString(), n.redMuln(4).toString());
        assert.strictEqual(n.redShl(new BN(3)).toString(), n.redMuln(8).toString());

        assert.strictEqual(n.redShln(0).toString(), n.redMuln(1).toString());
        assert.strictEqual(n.redShln(1).toString(), n.redMuln(2).toString());
        assert.strictEqual(n.redShln(2).toString(), n.redMuln(4).toString());
        assert.strictEqual(n.redShln(3).toString(), n.redMuln(8).toString());
        assert.strictEqual(n.redShln(4).toString(), n.redMuln(16).toString());
        assert.strictEqual(n.redShln(5).toString(), n.redMuln(32).toString());
        assert.strictEqual(n.redShln(6).toString(), n.redMuln(64).toString());

        assert.strictEqual(n.redIsOdd(), n.fromRed().isOdd());
        assert.strictEqual(n.redIsEven(), n.fromRed().isEven());

        assert.strictEqual(r1.redEq(r1.redNeg()), false);
        assert.strictEqual(r2.redEq(r2.redNeg()), false);
        assert.strictEqual(r3.redEq(r3.redNeg()), false);

        assert.strictEqual(r0.redEq(r3), false);
        assert.strictEqual(r1.redEq(r2), false);
        assert.strictEqual(r2.redEq(r1), false);
        assert.strictEqual(r3.redEq(r0), false);

        assert.strictEqual(r0.redEqn(0), true);
        assert.strictEqual(r1.redEqn(1), true);
        assert.strictEqual(r2.redEqn(2), true);
        assert.strictEqual(r3.redEqn(3), true);

        assert.strictEqual(r1.redEqn(-1), false);
        assert.strictEqual(r2.redEqn(-2), false);
        assert.strictEqual(r3.redEqn(-3), false);

        assert.strictEqual(r0.redEqn(3), false);
        assert.strictEqual(r1.redEqn(2), false);
        assert.strictEqual(r2.redEqn(1), false);
        assert.strictEqual(r3.redEqn(0), false);

        assert.strictEqual(r1.redNeg().redEqn(-1), true);
        assert.strictEqual(r2.redNeg().redEqn(-2), true);

        assert.strictEqual(r1.redEqn(-1), false);
        assert.strictEqual(r1.redNeg().redEqn(-1), true);
        assert.strictEqual(r1.redNeg().redEqn(-2), false);
        assert.strictEqual(r1.redNeg().redAddn(1).redEqn(0), true);
        assert.strictEqual(r1.redNeg().redAddn(1).sign(), 0);

        assert.strictEqual(r1.redIsLow(), true);
        assert.strictEqual(r1.redIsHigh(), false);
        assert.strictEqual(r1.redNeg().redIsLow(), false);
        assert.strictEqual(r1.redNeg().redIsHigh(), true);

        assert.strictEqual(rp.redIsLow(), true);
        assert.strictEqual(rp.redIsHigh(), false);
        assert.strictEqual(rp.redNeg().redIsLow(), false);
        assert.strictEqual(rp.redNeg().redIsHigh(), true);

        assert.strictEqual(rp.redAddn(1).redIsLow(), false);
        assert.strictEqual(rp.redAddn(1).redIsHigh(), true);
      });
    }

    for (const red of [BN.red(new BN(17)), BN.mont(new BN(17))]) {
      it('should test red helpers (small field)', () => {
        const r0 = new BN(0).toRed(red);
        const r1 = new BN(1).toRed(red);
        const r2 = new BN(2).toRed(red);
        const r3 = new BN(3).toRed(red);

        const mod = (x, m) => {
          let r = x % m;

          if (r < 0)
            r += m;

          return r;
        };

        const bn = x => new BN(x).toRed(red);
        const mul = (x, y) => bn(x).redMuln(y).fromRed().toNumber();
        const shl = (x, y) => bn(x).redShln(y).fromRed().toNumber();
        const add = (x, y) => bn(x).redAddn(y).fromRed().toNumber();
        const sub = (x, y) => bn(x).redSubn(y).fromRed().toNumber();

        assert(mod(11 * -137, 17) === mod(11 * mod(-137, 17), 17));
        assert(mod(11 * 137, 17) === mod(11 * mod(137, 17), 17));
        assert(mod(11 + 137, 17) === mod(11 + mod(137, 17), 17));
        assert(mod(11 - 137, 17) === mod(11 - mod(137, 17), 17));

        assert.strictEqual(mul(11, -137), mod(11 * -137, 17));
        assert.strictEqual(mul(11, 137), mod(11 * 137, 17));
        assert.strictEqual(shl(11, 3), mod(11 << 3, 17));
        assert.strictEqual(shl(11, 16), mod(11 << 16, 17));
        assert.strictEqual(add(11, 137), mod(11 + 137, 17));
        assert.strictEqual(sub(11, 137), mod(11 - 137, 17));

        assert.strictEqual(r1.redEq(r1.redNeg()), false);
        assert.strictEqual(r2.redEq(r2.redNeg()), false);
        assert.strictEqual(r3.redEq(r3.redNeg()), false);

        assert.strictEqual(r0.redEq(r3), false);
        assert.strictEqual(r1.redEq(r2), false);
        assert.strictEqual(r2.redEq(r1), false);
        assert.strictEqual(r3.redEq(r0), false);

        assert.strictEqual(r0.redEqn(0), true);
        assert.strictEqual(r1.redEqn(1), true);
        assert.strictEqual(r2.redEqn(2), true);
        assert.strictEqual(r3.redEqn(3), true);

        assert.strictEqual(r1.redEqn(-1), false);
        assert.strictEqual(r2.redEqn(-2), false);
        assert.strictEqual(r3.redEqn(-3), false);

        assert.strictEqual(r0.redEqn(3), false);
        assert.strictEqual(r1.redEqn(2), false);
        assert.strictEqual(r2.redEqn(1), false);
        assert.strictEqual(r3.redEqn(0), false);

        assert.strictEqual(r1.redNeg().redEqn(-1), true);
        assert.strictEqual(r2.redNeg().redEqn(-2), true);

        assert.strictEqual(r1.redEqn(-1), false);
        assert.strictEqual(r1.redNeg().redEqn(-1), true);
        assert.strictEqual(r1.redNeg().redEqn(-2), false);
        assert.strictEqual(r1.redNeg().redAddn(1).redEqn(0), true);
        assert.strictEqual(r1.redNeg().redAddn(1).sign(), 0);

        assert.strictEqual(r1.redIsLow(), true);
        assert.strictEqual(r1.redIsHigh(), false);
        assert.strictEqual(r1.redNeg().redIsLow(), false);
        assert.strictEqual(r1.redNeg().redIsHigh(), true);
      });
    }

    it('should read and serialize aligned data', () => {
      const p = P192;
      const p1 = p.ushrn(8);
      const p7 = p.maskn(7 * 8);
      const be = Buffer.alloc(p.byteLength(), 0x00);
      const le = Buffer.alloc(p.byteLength(), 0x00);

      assert((be.byteOffset & 7) === 0);
      assert((be.byteLength & 7) === 0);
      assert((le.byteOffset & 7) === 0);
      assert((le.byteLength & 7) === 0);

      p.toBuffer('be').copy(be);
      p.toBuffer('le').copy(le);

      assert(BN.fromBuffer(be, 'be').eq(p));
      assert(BN.fromBuffer(le, 'le').eq(p));
      assert(BN.fromArrayLike(be, 'be').eq(p));
      assert(BN.fromArrayLike(le, 'le').eq(p));
      assert(new BN(be, 'be').eq(p));
      assert(new BN(le, 'le').eq(p));

      assert(BN.fromBuffer(be.slice(0, -1), 'be').eq(p1));
      assert(BN.fromBuffer(le.slice(1), 'le').eq(p1));
      assert(BN.fromArrayLike(be.slice(0, -1), 'be').eq(p1));
      assert(BN.fromArrayLike(le.slice(1), 'le').eq(p1));
      assert(new BN(be.slice(0, -1), 'be').eq(p1));
      assert(new BN(le.slice(1), 'le').eq(p1));

      assert(BN.fromBuffer(be.slice(-7), 'be').eq(p7));
      assert(BN.fromBuffer(le.slice(0, 7), 'le').eq(p7));
      assert(BN.fromArrayLike(be.slice(-7), 'be').eq(p7));
      assert(BN.fromArrayLike(le.slice(0, 7), 'le').eq(p7));
      assert(new BN(be.slice(-7), 'be').eq(p7));
      assert(new BN(le.slice(0, 7), 'le').eq(p7));

      const beu = new Uint8Array(be.buffer, be.byteOffset, be.length);
      const leu = new Uint8Array(le.buffer, le.byteOffset, le.length);
      const l = be.length;

      assert(BN.fromArrayLike(beu, 'be').eq(p));
      assert(BN.fromArrayLike(leu, 'le').eq(p));
      assert(new BN(beu, 'be').eq(p));
      assert(new BN(leu, 'le').eq(p));

      assert(BN.fromArrayLike(beu.subarray(0, l - 1), 'be').eq(p1));
      assert(BN.fromArrayLike(leu.subarray(1), 'le').eq(p1));
      assert(new BN(beu.subarray(0, l - 1), 'be').eq(p1));
      assert(new BN(leu.subarray(1), 'le').eq(p1));

      assert(BN.fromArrayLike(beu.subarray(l - 7), 'be').eq(p7));
      assert(BN.fromArrayLike(leu.subarray(0, 7), 'le').eq(p7));
      assert(new BN(beu.subarray(l - 7), 'be').eq(p7));
      assert(new BN(leu.subarray(0, 7), 'le').eq(p7));

      const bea = Array.from(be);
      const lea = Array.from(le);

      assert(BN.fromArrayLike(bea, 'be').eq(p));
      assert(BN.fromArrayLike(lea, 'le').eq(p));
      assert(new BN(bea, 'be').eq(p));
      assert(new BN(lea, 'le').eq(p));

      assert(BN.fromArrayLike(bea.slice(0, -1), 'be').eq(p1));
      assert(BN.fromArrayLike(lea.slice(1), 'le').eq(p1));
      assert(new BN(bea.slice(0, -1), 'be').eq(p1));
      assert(new BN(lea.slice(1), 'le').eq(p1));

      assert(BN.fromArrayLike(bea.slice(-7), 'be').eq(p7));
      assert(BN.fromArrayLike(lea.slice(0, 7), 'le').eq(p7));
      assert(new BN(bea.slice(-7), 'be').eq(p7));
      assert(new BN(lea.slice(0, 7), 'le').eq(p7));
    });

    it('should read and serialize unaligned data', () => {
      const p = P192;
      const p1 = p.ushrn(8);
      const p7 = p.maskn(7 * 8);
      const be = Buffer.alloc(1 + p.byteLength(), 0x00).slice(1);
      const le = Buffer.alloc(1 + p.byteLength(), 0x00).slice(1);

      assert((be.byteOffset & 7) !== 0);
      assert((be.byteLength & 7) === 0);
      assert((le.byteOffset & 7) !== 0);
      assert((le.byteLength & 7) === 0);

      p.toBuffer('be').copy(be);
      p.toBuffer('le').copy(le);

      assert(BN.fromBuffer(be, 'be').eq(p));
      assert(BN.fromBuffer(le, 'le').eq(p));
      assert(BN.fromArrayLike(be, 'be').eq(p));
      assert(BN.fromArrayLike(le, 'le').eq(p));
      assert(new BN(be, 'be').eq(p));
      assert(new BN(le, 'le').eq(p));

      assert(BN.fromBuffer(be.slice(0, -1), 'be').eq(p1));
      assert(BN.fromBuffer(le.slice(1), 'le').eq(p1));
      assert(BN.fromArrayLike(be.slice(0, -1), 'be').eq(p1));
      assert(BN.fromArrayLike(le.slice(1), 'le').eq(p1));
      assert(new BN(be.slice(0, -1), 'be').eq(p1));
      assert(new BN(le.slice(1), 'le').eq(p1));

      assert(BN.fromBuffer(be.slice(-7), 'be').eq(p7));
      assert(BN.fromBuffer(le.slice(0, 7), 'le').eq(p7));
      assert(BN.fromArrayLike(be.slice(-7), 'be').eq(p7));
      assert(BN.fromArrayLike(le.slice(0, 7), 'le').eq(p7));
      assert(new BN(be.slice(-7), 'be').eq(p7));
      assert(new BN(le.slice(0, 7), 'le').eq(p7));

      const beu = new Uint8Array(be.buffer, be.byteOffset, be.length);
      const leu = new Uint8Array(le.buffer, le.byteOffset, le.length);
      const l = be.length;

      assert(BN.fromArrayLike(beu, 'be').eq(p));
      assert(BN.fromArrayLike(leu, 'le').eq(p));
      assert(new BN(beu, 'be').eq(p));
      assert(new BN(leu, 'le').eq(p));

      assert(BN.fromArrayLike(beu.subarray(0, l - 1), 'be').eq(p1));
      assert(BN.fromArrayLike(leu.subarray(1), 'le').eq(p1));
      assert(new BN(beu.subarray(0, l - 1), 'be').eq(p1));
      assert(new BN(leu.subarray(1), 'le').eq(p1));

      assert(BN.fromArrayLike(beu.subarray(l - 7), 'be').eq(p7));
      assert(BN.fromArrayLike(leu.subarray(0, 7), 'le').eq(p7));
      assert(new BN(beu.subarray(l - 7), 'be').eq(p7));
      assert(new BN(leu.subarray(0, 7), 'le').eq(p7));

      const bea = Array.from(be);
      const lea = Array.from(le);

      assert(BN.fromArrayLike(bea, 'be').eq(p));
      assert(BN.fromArrayLike(lea, 'le').eq(p));
      assert(new BN(bea, 'be').eq(p));
      assert(new BN(lea, 'le').eq(p));

      assert(BN.fromArrayLike(bea.slice(0, -1), 'be').eq(p1));
      assert(BN.fromArrayLike(lea.slice(1), 'le').eq(p1));
      assert(new BN(bea.slice(0, -1), 'be').eq(p1));
      assert(new BN(lea.slice(1), 'le').eq(p1));

      assert(BN.fromArrayLike(bea.slice(-7), 'be').eq(p7));
      assert(BN.fromArrayLike(lea.slice(0, 7), 'le').eq(p7));
      assert(new BN(bea.slice(-7), 'be').eq(p7));
      assert(new BN(lea.slice(0, 7), 'le').eq(p7));
    });

    it('should test encoding', () => {
      for (let i = 1; i <= 2048; i++) {
        const n = BN.randomBits(rng, i);
        const hex = n.toString(16, 2);

        let rev = '';

        for (let i = hex.length - 2; i >= 0; i -= 2)
          rev += hex[i] + hex[i + 1];

        assert(BN.decode(n.encode('be'), 'be').eq(n));
        assert(BN.decode(n.encode('le'), 'le').eq(n));
        assert.strictEqual(n.encode('be').toString('hex'), hex);
        assert.strictEqual(n.encode('le').toString('hex'), rev);
      }
    });

    it('should test words', () => {
      for (let i = 256; i <= 266; i++) {
        const p = BN.randomBits(rng, i);
        const q = new BN();
        const len = p.length;
        const words = [];

        for (let j = 0; j < len; j++)
          words.push(p.word(j));

        for (let j = words.length - 1; j >= 0; j--) {
          q.iushln(26);
          q.iuorn(words[j]);
        }

        assert(p.eq(q));
      }
    });

    it('should do rounded mul+shift', () => {
      // even
      assert.strictEqual(new BN(12).mulShift(new BN(13), 2).toString(), '39');
      assert.strictEqual(new BN(12).mulShift(new BN(-13), 2).toString(), '-39');
      // even
      assert.strictEqual(new BN(13).mulShift(new BN(13), 2).toString(), '42');
      assert.strictEqual(new BN(13).mulShift(new BN(-13), 2).toString(), '-42');
      // odd
      assert.strictEqual(new BN(14).mulShift(new BN(13), 2).toString(), '46');
      assert.strictEqual(new BN(14).mulShift(new BN(-13), 2).toString(), '-46');
    });

    it('should do inverse square root', () => {
      const p192 = BN.red('p192');
      const p224 = BN.red('p224');
      const p25519 = BN.red('p25519');
      const p255192 = BN.red('p25519');

      p25519.precompute();

      for (const red of [p192, p224, p25519, p255192]) {
        const zero = new BN(0).toRed(red);
        const one = new BN(1).toRed(red);
        const pairs = [];

        assert(zero.redDivSqrt(one).eq(zero));

        assert.throws(() => zero.redDivSqrt(zero), {
          message: 'Not invertible.'
        });

        assert.throws(() => one.redDivSqrt(zero), {
          message: 'Not invertible.'
        });

        while (pairs.length < 10) {
          const u = BN.random(rng, 0, red.m).toRed(red);
          const v = BN.random(rng, 1, red.m).toRed(red);
          const uv = u.redMul(v.redInvert());

          if (uv.redJacobi() === -1)
            continue;

          pairs.push([u, v]);
        }

        for (const [u, v] of pairs) {
          const e = u.redMul(v.redInvert()).redSqrt();
          const r = u.redDivSqrt(v);

          if (r.redIsOdd() !== e.redIsOdd())
            r.redINeg();

          assert(r.eq(e));
        }
      }
    });

    it('should test quadratic residuosity', () => {
      const red = BN.red('p25519');
      const qnrs = [];
      const qrs = [];

      while (qnrs.length < 100) {
        const x = BN.random(rng, 1, red.m).toRed(red);

        if (x.redJacobi() === -1)
          qnrs.push(x);
      }

      while (qrs.length < 100) {
        const x = BN.random(rng, 1, red.m).toRed(red);

        if (x.redJacobi() === 1)
          qrs.push(x);
      }

      // QNR * QNR = QR
      // -1 * -1 = 1
      for (let i = 0; i < qnrs.length; i += 2) {
        const x1 = qnrs[i + 0];
        const x2 = qnrs[i + 1];
        const x3 = x1.redMul(x2);

        assert(x3.redJacobi() === 1);
      }

      // QR * QR = QR
      // 1 * 1 = 1
      for (let i = 0; i < qrs.length; i += 2) {
        const x1 = qrs[i + 0];
        const x2 = qrs[i + 1];
        const x3 = x1.redMul(x2);

        assert(x3.redJacobi() === 1);
      }

      // QR * QNR = QNR
      // 1 * -1 = -1
      for (let i = 0; i < qnrs.length; i++) {
        const x1 = qrs[i];
        const x2 = qnrs[i];
        const x3 = x1.redMul(x2);

        assert(x3.redJacobi() === -1);
      }
    });
  });

  describe('BN.js/Slow DH test', () => {
    for (const name of Object.keys(dhGroups)) {
      it(`should match public key for ${name} group`, () => {
        const group = dhGroups[name];

        const base = new BN(2);
        const mont = BN.red(new BN(group.prime, 16));
        const priv = new BN(group.priv, 16);
        const multed = base.toRed(mont).redPow(priv).fromRed();
        const actual = multed.toBuffer();

        assert.strictEqual(actual.toString('hex'), group.pub);
      });
    }
  });
});
